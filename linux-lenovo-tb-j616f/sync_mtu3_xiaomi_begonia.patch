diff --git a/drivers/usb/mtu3/Kconfig b/drivers/usb/mtu3/Kconfig
index 521f72f..614adac 100644
--- a/drivers/usb/mtu3/Kconfig
+++ b/drivers/usb/mtu3/Kconfig
@@ -4,7 +4,6 @@ config USB_MTU3
 	tristate "MediaTek USB3 Dual Role controller"
 	depends on EXTCON && (USB || USB_GADGET) && HAS_DMA
 	depends on ARCH_MEDIATEK || COMPILE_TEST || MEDIATEK_SOLUTION
-	depends on EXTCON || !EXTCON
 	select USB_XHCI_MTK if USB_SUPPORT && USB_XHCI_HCD
 	help
 	  Say Y or M here if your system runs on MediaTek SoCs with
diff --git a/drivers/usb/mtu3/Makefile b/drivers/usb/mtu3/Makefile
index ac5d0fc..0081746 100644
--- a/drivers/usb/mtu3/Makefile
+++ b/drivers/usb/mtu3/Makefile
@@ -1,4 +1,3 @@
-# SPDX-License-Identifier: GPL-2.0
 
 ccflags-$(CONFIG_USB_MTU3_DEBUG)	+= -DDEBUG
 
@@ -6,20 +5,12 @@ ifneq ($(CONFIG_USB_MTU3_PLAT_PHONE),)
 ccflags-y += -I$(srctree)/drivers/misc/mediatek/include/
 ccflags-y += -I$(srctree)/drivers/power/supply/mediatek/misc/
 ccflags-y += -I$(srctree)/drivers/misc/mediatek/typec/tcpc/
-ifeq ($(CONFIG_MACH_MT6877),y)
-ccflags-y += -I$(srctree)/drivers/usb/mtu3/mt6877/
-else
 ccflags-y += -I$(srctree)/drivers/usb/mtu3/$(CONFIG_MTK_PLATFORM)/
 endif
-endif
 
 ifneq ($(CONFIG_USB_MTU3_PLAT_PHONE),)
 
-ifeq ($(CONFIG_MACH_MT6877),y)
-obj-y += $(subst ",,mt6877)/
-else
 obj-y += $(subst ",,$(CONFIG_MTK_PLATFORM))/
-endif
 obj-y += mtu3_debugfs_v2.o
 
 obj-$(CONFIG_USB_MTU3)	+= musb_hdrc.o
@@ -40,27 +31,20 @@ endif
 
 else
 
-subdir-ccflags-y += -I$(srctree)/drivers/misc/mediatek/include/mt-plat
-
-ifneq ($(filter y,$(CONFIG_MACH_MT8168)),)
-subdir-ccflags-y += -I$(srctree)/drivers/misc/mediatek/base/power/mt8168/
-endif
-
-
 obj-$(CONFIG_USB_MTU3) += mtu3.o
 
 mtu3-y := mtu3_plat.o
 
 ifneq ($(filter y,$(CONFIG_USB_MTU3_HOST) $(CONFIG_USB_MTU3_DUAL_ROLE)),)
-	mtu3-y	+= mtu3_host.o
+	mtu3-y += mtu3_host.o
 endif
 
 ifneq ($(filter y,$(CONFIG_USB_MTU3_GADGET) $(CONFIG_USB_MTU3_DUAL_ROLE)),)
-	mtu3-y	+= mtu3_core.o mtu3_gadget_ep0.o mtu3_gadget.o mtu3_qmu.o
+	mtu3-y += mtu3_core.o mtu3_gadget_ep0.o mtu3_gadget.o mtu3_qmu.o
 endif
 
 ifneq ($(CONFIG_USB_MTU3_DUAL_ROLE),)
-	mtu3-y	+= mtu3_dr.o
+	mtu3-y += mtu3_dr.o
 endif
 
 endif
diff --git a/drivers/usb/mtu3/mt6771/Makefile b/drivers/usb/mtu3/mt6771/Makefile
deleted file mode 100644
index 8839ae7..0000000
--- a/drivers/usb/mtu3/mt6771/Makefile
+++ /dev/null
@@ -1,16 +0,0 @@
-#
-# Copyright (C) 2017 MediaTek Inc.
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License version 2 as
-# published by the Free Software Foundation.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-# GNU General Public License for more details.
-#
-subdir-ccflags-y += -Werror -I$(srctree)/drivers/usb/mtu3
-subdir-ccflags-y += -I$(srctree)/drivers/misc/mediatek/base/power/include/
-
-obj-y += mtu3_hal.o mtu3_phy_hal.o mtu3_sleep.o mtu3_phy_debugfs.o
diff --git a/drivers/usb/mtu3/mt6771/mtu3_hal.c b/drivers/usb/mtu3/mt6771/mtu3_hal.c
deleted file mode 100644
index d76a21e..0000000
--- a/drivers/usb/mtu3/mt6771/mtu3_hal.c
+++ /dev/null
@@ -1,271 +0,0 @@
-/*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
- */
-
-#include <linux/clk.h>
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-
-
-#include <mtu3.h>
-#include <mtu3_hal.h>
-#include <mtk_spm_resource_req.h>
-#include <mtk_idle.h>
-#include "mtu3_priv.h"
-
-static int dpidle_status = USB_DPIDLE_ALLOWED;
-static DEFINE_SPINLOCK(usb_hal_dpidle_lock);
-static void issue_dpidle_timer(void);
-static void init_usb_audio_idle(void);
-
-static void __iomem *infra_ao_base;
-
-#define DPIDLE_TIMER_INTERVAL_MS 30
-
-int get_ssusb_ext_rscs(struct ssusb_mtk *ssusb)
-{
-	struct device *dev = ssusb->dev;
-	struct ssusb_priv *priv;
-
-	/* all elements are set to ZERO as default value */
-	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	priv->vusb10 = devm_regulator_get(dev, "va09");
-	if (IS_ERR(priv->vusb10)) {
-		dev_info(dev, "failed to get vusb10\n");
-		return PTR_ERR(priv->vusb10);
-	}
-
-	/* private mode setting */
-	ssusb->force_vbus = true;
-	ssusb->u1u2_disable = true;
-	ssusb->u3_loopb_support = true;
-
-
-	ssusb->priv_data = priv;
-
-	init_usb_audio_idle();
-
-	return 0;
-}
-
-static int ssusb_host_clk_on(struct ssusb_mtk *ssusb)
-{
-	return 0;
-}
-
-static int ssusb_host_clk_off(struct ssusb_mtk *ssusb)
-{
-	return 0;
-}
-
-static int ssusb_sysclk_on(struct ssusb_mtk *ssusb)
-{
-	int ret = 0;
-
-	ret = clk_prepare_enable(ssusb->sys_clk);
-	if (ret)
-		dev_info(ssusb->dev, "failed to enable sys_clk\n");
-
-	ret = clk_prepare_enable(ssusb->ref_clk);
-	if (ret)
-		dev_info(ssusb->dev, "failed to enable ref_clk\n");
-
-	return ret;
-}
-
-static void ssusb_sysclk_off(struct ssusb_mtk *ssusb)
-{
-	clk_disable_unprepare(ssusb->sys_clk);
-	clk_disable_unprepare(ssusb->ref_clk);
-}
-
-int ssusb_clk_on(struct ssusb_mtk *ssusb, int host_mode)
-{
-	ssusb_dpidle_request(USB_DPIDLE_FORBIDDEN);
-	if (host_mode) {
-		ssusb_sysclk_on(ssusb);
-		ssusb_host_clk_on(ssusb);
-	} else {
-		ssusb_sysclk_on(ssusb);
-	}
-	return 0;
-}
-
-int ssusb_clk_off(struct ssusb_mtk *ssusb, int host_mode)
-{
-	if (host_mode) {
-		ssusb_host_clk_off(ssusb);
-		ssusb_sysclk_off(ssusb);
-	} else {
-		ssusb_sysclk_off(ssusb);
-	}
-	ssusb_dpidle_request(USB_DPIDLE_ALLOWED);
-	return 0;
-}
-
-int ssusb_ext_pwr_on(struct ssusb_mtk *ssusb, int mode)
-{
-	int ret = 0;
-	struct ssusb_priv *priv;
-
-	priv = ssusb->priv_data;
-	ret = regulator_enable(priv->vusb10);
-	if (ret)
-		dev_info(ssusb->dev, "failed to enable vusb10\n");
-	return ret;
-}
-
-int ssusb_ext_pwr_off(struct ssusb_mtk *ssusb, int mode)
-{
-	int ret = 0;
-	struct ssusb_priv *priv;
-
-	priv = ssusb->priv_data;
-	ret = regulator_disable(priv->vusb10);
-	if (ret)
-		dev_info(ssusb->dev, "failed to disable vusb10\n");
-	return ret;
-}
-
-static void dpidle_timer_wakeup_func(unsigned long data)
-{
-	struct timer_list *timer = (struct timer_list *)data;
-
-	if (dpidle_status == USB_DPIDLE_TIMER)
-		issue_dpidle_timer();
-	kfree(timer);
-}
-
-static void issue_dpidle_timer(void)
-{
-	struct timer_list *timer;
-
-	timer = kzalloc(sizeof(struct timer_list), GFP_ATOMIC);
-	if (!timer)
-		return;
-
-	init_timer(timer);
-	timer->function = dpidle_timer_wakeup_func;
-	timer->data = (unsigned long)timer;
-	timer->expires = jiffies + msecs_to_jiffies(DPIDLE_TIMER_INTERVAL_MS);
-	add_timer(timer);
-}
-
-void ssusb_dpidle_request(int mode)
-{
-	unsigned long flags;
-	static DEFINE_RATELIMIT_STATE(ratelimit, 1 * HZ, 3);
-	static int skip_cnt;
-
-	spin_lock_irqsave(&usb_hal_dpidle_lock, flags);
-
-	/* update dpidle_status */
-	dpidle_status = mode;
-	/*usb_audio_req(false);*/
-
-	switch (mode) {
-
-	case USB_DPIDLE_ALLOWED:
-		spm_resource_req(SPM_RESOURCE_USER_SSUSB, 0);
-		mtu3_printk(K_NOTICE, "DPIDLE_ALLOWED\n");
-		break;
-	case USB_DPIDLE_FORBIDDEN:
-		spm_resource_req(SPM_RESOURCE_USER_SSUSB, SPM_RESOURCE_ALL);
-
-		if (__ratelimit(&ratelimit))
-			mtu3_printk(K_NOTICE,
-				"DPIDLE_FORBIDDEN\n");
-		break;
-	case USB_DPIDLE_SRAM:
-		spm_resource_req(SPM_RESOURCE_USER_SSUSB,
-				SPM_RESOURCE_CK_26M | SPM_RESOURCE_MAINPLL);
-
-		if (__ratelimit(&ratelimit)) {
-			mtu3_printk(K_NOTICE,
-				"DPIDLE_SRAM, skip<%d>\n", skip_cnt);
-			skip_cnt = 0;
-		} else
-			skip_cnt++;
-		break;
-	case USB_DPIDLE_AUDIO:
-		spm_resource_req(SPM_RESOURCE_USER_SSUSB, 0);
-		/*usb_audio_req(true);*/
-
-		if (__ratelimit(&ratelimit)) {
-			mtu3_printk(K_NOTICE,
-				"DPIDLE_AUDIO, skip<%d>\n", skip_cnt);
-			skip_cnt = 0;
-		} else
-			skip_cnt++;
-		break;
-	case USB_DPIDLE_TIMER:
-		spm_resource_req(SPM_RESOURCE_USER_SSUSB, SPM_RESOURCE_CK_26M);
-		mtu3_printk(K_NOTICE, "DPIDLE_TIMER\n");
-		issue_dpidle_timer();
-		break;
-	case USB_DPIDLE_SUSPEND:
-		slp_set_infra_on(true);
-		mtu3_printk(K_NOTICE, "DPIDLE_SUSPEND\n");
-		break;
-	case USB_DPIDLE_RESUME:
-		 slp_set_infra_on(false);
-		mtu3_printk(K_NOTICE, "DPIDLE_RESUME\n");
-		break;
-	default:
-		mtu3_printk(K_WARNIN, "[ERROR] Are you kidding!?!?\n");
-		break;
-	}
-
-	spin_unlock_irqrestore(&usb_hal_dpidle_lock, flags);
-}
-
-static int usbaudio_idle_notify_call(struct notifier_block *nfb,
-				unsigned long id,
-				void *arg)
-{
-	switch (id) {
-	case NOTIFY_DPIDLE_ENTER:
-	case NOTIFY_SOIDLE_ENTER:
-	case NOTIFY_DPIDLE_LEAVE:
-	case NOTIFY_SOIDLE_LEAVE:
-	case NOTIFY_SOIDLE3_ENTER:
-	case NOTIFY_SOIDLE3_LEAVE:
-	default:
-		/* do nothing */
-		break;
-	}
-	return NOTIFY_OK;
-}
-
-static struct notifier_block usbaudio_idle_nfb = {
-	.notifier_call = usbaudio_idle_notify_call,
-};
-
-static void init_usb_audio_idle(void)
-{
-	struct device_node *node;
-
-	node = of_find_compatible_node(NULL, NULL, "mediatek,infracfg_ao");
-	if (node) {
-		infra_ao_base = of_iomap(node, 0);
-		if (infra_ao_base)
-			mtk_idle_notifier_register(&usbaudio_idle_nfb);
-	}
-}
-
-
-
diff --git a/drivers/usb/mtu3/mt6771/mtu3_phy_debugfs.c b/drivers/usb/mtu3/mt6771/mtu3_phy_debugfs.c
deleted file mode 100644
index 016ec9d..0000000
--- a/drivers/usb/mtu3/mt6771/mtu3_phy_debugfs.c
+++ /dev/null
@@ -1,986 +0,0 @@
-/*
- * Copyright (C) 2015 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
-#include <linux/uaccess.h>
-#include <linux/phy/phy.h>
-#include <linux/phy/mediatek/mtk_usb_phy.h>
-
-/* general */
-#define BIT_WIDTH_1		1
-#define MSK_WIDTH_1		0x1
-#define VAL_MAX_WDITH_1	0x1
-#define VAL_0_WIDTH_1		0x0
-#define VAL_1_WIDTH_1		0x1
-#define STRNG_0_WIDTH_1	"0"
-#define STRNG_1_WIDTH_1	"1"
-
-#define BIT_WIDTH_2		2
-#define MSK_WIDTH_2		0x3
-#define VAL_MAX_WDITH_2		0x3
-#define VAL_0_WIDTH_2		0x0
-#define VAL_1_WIDTH_2		0x1
-#define VAL_2_WIDTH_2		0x2
-#define VAL_3_WIDTH_2		0x3
-#define STRNG_0_WIDTH_2	"00"
-#define STRNG_1_WIDTH_2	"01"
-#define STRNG_2_WIDTH_2	"10"
-#define STRNG_3_WIDTH_2	"11"
-
-
-#define BIT_WIDTH_3		3
-#define MSK_WIDTH_3		0x7
-#define VAL_MAX_WDITH_3		0x7
-#define VAL_0_WIDTH_3		0x0
-#define VAL_1_WIDTH_3		0x1
-#define VAL_2_WIDTH_3		0x2
-#define VAL_3_WIDTH_3		0x3
-#define VAL_4_WIDTH_3		0x4
-#define VAL_5_WIDTH_3		0x5
-#define VAL_6_WIDTH_3		0x6
-#define VAL_7_WIDTH_3		0x7
-#define STRNG_0_WIDTH_3	"000"
-#define STRNG_1_WIDTH_3	"001"
-#define STRNG_2_WIDTH_3	"010"
-#define STRNG_3_WIDTH_3	"011"
-#define STRNG_4_WIDTH_3	"100"
-#define STRNG_5_WIDTH_3	"101"
-#define STRNG_6_WIDTH_3	"110"
-#define STRNG_7_WIDTH_3	"111"
-
-#define BIT_WIDTH_4		4
-#define MSK_WIDTH_4		0xf
-#define VAL_MAX_WDITH_4		0xf
-#define VAL_0_WIDTH_4		0x0
-#define VAL_1_WIDTH_4		0x1
-#define VAL_2_WIDTH_4		0x2
-#define VAL_3_WIDTH_4		0x3
-#define VAL_4_WIDTH_4		0x4
-#define VAL_5_WIDTH_4		0x5
-#define VAL_6_WIDTH_4		0x6
-#define VAL_7_WIDTH_4		0x7
-#define VAL_8_WIDTH_4		0x8
-#define VAL_9_WIDTH_4		0x9
-#define VAL_A_WIDTH_4		0xa
-#define VAL_B_WIDTH_4		0xb
-#define VAL_C_WIDTH_4		0xc
-#define VAL_D_WIDTH_4		0xd
-#define VAL_E_WIDTH_4		0xe
-#define VAL_F_WIDTH_4		0xf
-#define STRNG_0_WIDTH_4	"0000"
-#define STRNG_1_WIDTH_4	"0001"
-#define STRNG_2_WIDTH_4	"0010"
-#define STRNG_3_WIDTH_4	"0011"
-#define STRNG_4_WIDTH_4	"0100"
-#define STRNG_5_WIDTH_4	"0101"
-#define STRNG_6_WIDTH_4	"0110"
-#define STRNG_7_WIDTH_4	"0111"
-#define STRNG_8_WIDTH_4	"1000"
-#define STRNG_9_WIDTH_4	"1001"
-#define STRNG_A_WIDTH_4	"1010"
-#define STRNG_B_WIDTH_4	"1011"
-#define STRNG_C_WIDTH_4	"1100"
-#define STRNG_D_WIDTH_4	"1101"
-#define STRNG_E_WIDTH_4	"1110"
-#define STRNG_F_WIDTH_4	"1111"
-
-#define BIT_WIDTH_5		5
-#define MSK_WIDTH_5		0x1f
-#define VAL_MAX_WDITH_5		0x1f
-#define VAL_0_WIDTH_5		0x0
-#define VAL_1_WIDTH_5		0x1
-#define VAL_18_WIDTH_5		0x12
-#define VAL_20_WIDTH_5		0x14
-#define VAL_30_WIDTH_5		0x1e
-#define VAL_31_WIDTH_5		0x1f
-#define STRNG_0_WIDTH_5		"00000"
-#define STRNG_1_WIDTH_5		"00001"
-#define STRNG_18_WIDTH_5	"10010"
-#define STRNG_20_WIDTH_5	"10100"
-#define STRNG_30_WIDTH_5	"11110"
-#define STRNG_31_WIDTH_5	"11111"
-
-/* specific */
-#define FILE_USB_DRIVING_CAPABILITY "USB_DRIVING_CAPABILITY"
-
-#define FILE_RG_USB20_TERM_VREF_SEL "RG_USB20_TERM_VREF_SEL"
-#define MSK_RG_USB20_TERM_VREF_SEL MSK_WIDTH_3
-#define SHFT_RG_USB20_TERM_VREF_SEL 8
-#define OFFSET_RG_USB20_TERM_VREF_SEL 0x4
-
-#define FILE_RG_USB20_HSTX_SRCTRL "RG_USB20_HSTX_SRCTRL"
-#define MSK_RG_USB20_HSTX_SRCTRL MSK_WIDTH_3
-#define SHFT_RG_USB20_HSTX_SRCTRL 12
-#define OFFSET_RG_USB20_HSTX_SRCTRL 0x14
-
-#define FILE_RG_USB20_VRT_VREF_SEL "RG_USB20_VRT_VREF_SEL"
-#define MSK_RG_USB20_VRT_VREF_SEL MSK_WIDTH_3
-#define SHFT_RG_USB20_VRT_VREF_SEL 12
-#define OFFSET_RG_USB20_VRT_VREF_SEL 0x4
-
-#define FILE_RG_USB20_INTR_EN "RG_USB20_INTR_EN"
-#define MSK_RG_USB20_INTR_EN MSK_WIDTH_1
-#define SHFT_RG_USB20_INTR_EN 5
-#define OFFSET_RG_USB20_INTR_EN 0x0
-
-#define FILE_RG_USB20_PHY_REV6 "RG_USB20_PHY_REV6"
-#define MSK_RG_USB20_PHY_REV6 MSK_WIDTH_2
-#define SHFT_RG_USB20_PHY_REV6 30
-#define OFFSET_RG_USB20_PHY_REV6 0x18
-
-#define FILE_RG_USB20_INTR_CAL "RG_USB20_INTR_CAL"
-#define MSK_RG_USB20_INTR_CAL MSK_WIDTH_5
-#define SHFT_RG_USB20_INTR_CAL 19
-#define OFFSET_RG_USB20_INTR_CAL 0x4
-
-#define FILE_RG_USB20_DISCTH "RG_USB20_DISCTH"
-#define MSK_RG_USB20_DISCTH MSK_WIDTH_4
-#define SHFT_RG_USB20_DISCTH 4
-#define OFFSET_RG_USB20_DISCTH 0x18
-
-#define FILE_REG_DEBUG "phy_reg"
-
-static struct proc_dir_entry *usb20_phy_procfs_root;
-static u32 ippc_value, ippc_addr;
-
-static void u3phywrite32(struct phy *phy, int offset, int mask, int value)
-{
-	u32 cur_value;
-	u32 new_value;
-
-	cur_value = usb_mtkphy_io_read(phy, offset);
-	new_value = (cur_value & (~mask)) | value;
-	usb_mtkphy_io_write(phy, new_value, offset);
-}
-
-static void usb20_phy_debugfs_write_width1(struct phy *phy, u8 offset, u8 shift,
-	char *buf)
-{
-	u32 set_val = 0;
-
-	pr_debug("s(%s)\n", buf);
-	if (!strncmp(buf, STRNG_0_WIDTH_1, BIT_WIDTH_1)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_1);
-		set_val = VAL_0_WIDTH_1;
-	} else if (!strncmp(buf, STRNG_1_WIDTH_1, BIT_WIDTH_1)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_1);
-		set_val = VAL_1_WIDTH_1;
-	} else
-		return;
-
-	u3phywrite32(phy, offset, MSK_WIDTH_1 << shift, set_val << shift);
-
-}
-
-static void usb20_phy_debugfs_rev6_write(struct phy *phy, u8 offset, u8 shift,
-	char *buf)
-{
-	u32 set_val = 0xFF;
-
-	pr_debug("s(%s)\n", buf);
-	if (!strncmp(buf, STRNG_0_WIDTH_2, BIT_WIDTH_2)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_2);
-		set_val = VAL_0_WIDTH_2;
-	} else if (!strncmp(buf, STRNG_1_WIDTH_2, BIT_WIDTH_2)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_2);
-		set_val = VAL_1_WIDTH_2;
-	} else if (!strncmp(buf, STRNG_2_WIDTH_2, BIT_WIDTH_2)) {
-		pr_debug("%s case\n", STRNG_2_WIDTH_2);
-		set_val = VAL_2_WIDTH_2;
-	} else if (!strncmp(buf, STRNG_3_WIDTH_2, BIT_WIDTH_2)) {
-		pr_debug("%s case\n", STRNG_3_WIDTH_2);
-		set_val = VAL_3_WIDTH_2;
-	} else
-		return;
-
-	u3phywrite32(phy, offset, MSK_WIDTH_2 << shift, set_val << shift);
-
-}
-
-
-static void usb20_phy_debugfs_write_width3(struct phy *phy, u8 offset, u8 shift,
-	char *buf)
-{
-	u32 set_val = 0;
-
-	pr_debug("s(%s)\n", buf);
-	if (!strncmp(buf, STRNG_0_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_3);
-		set_val = VAL_0_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_1_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_3);
-		set_val = VAL_1_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_2_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_2_WIDTH_3);
-		set_val = VAL_2_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_3_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_3_WIDTH_3);
-		set_val = VAL_3_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_4_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_4_WIDTH_3);
-		set_val = VAL_4_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_5_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_5_WIDTH_3);
-		set_val = VAL_5_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_6_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_6_WIDTH_3);
-		set_val = VAL_6_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_7_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_7_WIDTH_3);
-		set_val = VAL_7_WIDTH_3;
-	} else
-		return;
-
-	u3phywrite32(phy, offset, MSK_WIDTH_3 << shift, set_val << shift);
-
-}
-
-static void usb20_phy_debugfs_write_width4(struct phy *phy, u8 offset, u8 shift,
-	char *buf)
-{
-	u32 set_val = 0;
-
-	pr_debug("s(%s)\n", buf);
-	if (!strncmp(buf, STRNG_0_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_4);
-		set_val = VAL_0_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_1_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_4);
-		set_val = VAL_1_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_2_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_2_WIDTH_4);
-		set_val = VAL_2_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_3_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_3_WIDTH_4);
-		set_val = VAL_3_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_4_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_4_WIDTH_4);
-		set_val = VAL_4_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_5_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_5_WIDTH_4);
-		set_val = VAL_5_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_6_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_6_WIDTH_4);
-		set_val = VAL_6_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_7_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_7_WIDTH_4);
-		set_val = VAL_7_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_8_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_8_WIDTH_4);
-		set_val = VAL_8_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_9_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_9_WIDTH_4);
-		set_val = VAL_9_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_A_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_A_WIDTH_4);
-		set_val = VAL_A_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_B_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_B_WIDTH_4);
-		set_val = VAL_B_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_C_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_C_WIDTH_4);
-		set_val = VAL_C_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_D_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_D_WIDTH_4);
-		set_val = VAL_D_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_E_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_E_WIDTH_4);
-		set_val = VAL_E_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_F_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_F_WIDTH_4);
-		set_val = VAL_F_WIDTH_4;
-	} else
-		return;
-
-	u3phywrite32(phy, offset, MSK_WIDTH_4 << shift, set_val << shift);
-
-}
-
-static void usb20_phy_debugfs_write_width5(struct phy *phy, u8 offset, u8 shift,
-	char *buf)
-{
-	u32 set_val = 0;
-
-	pr_debug("s(%s)\n", buf);
-	if (!strncmp(buf, STRNG_0_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_5);
-		set_val = VAL_0_WIDTH_5;
-	} else if (!strncmp(buf, STRNG_1_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_5);
-		set_val = VAL_1_WIDTH_5;
-	} else if (!strncmp(buf, STRNG_18_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_18_WIDTH_5);
-		set_val = VAL_18_WIDTH_5;
-	} else if (!strncmp(buf, STRNG_20_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_20_WIDTH_5);
-		set_val = VAL_20_WIDTH_5;
-	} else if (!strncmp(buf, STRNG_30_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_30_WIDTH_5);
-		set_val = VAL_30_WIDTH_5;
-	} else if (!strncmp(buf, STRNG_31_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_31_WIDTH_5);
-		set_val = VAL_31_WIDTH_5;
-	} else
-		return;
-
-	u3phywrite32(phy, offset, MSK_WIDTH_5 << shift, set_val << shift);
-
-}
-
-
-static u8 usb20_phy_debugfs_read_val(u32 val, u8 width, char *str)
-{
-	int i, temp;
-
-	temp = val;
-	str[width] = '\0';
-	for (i = (width - 1); i >= 0; i--) {
-		if (val % 2)
-			str[i] = '1';
-		else
-			str[i] = '0';
-		pr_debug("str[%d]:%c\n", i, str[i]);
-		val /= 2;
-	}
-	pr_debug("str(%s)\n", str);
-	return val;
-}
-
-static int usb_driving_capability_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16] = "";
-	u8 combined_val, tmp_val = 0xff;
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_TERM_VREF_SEL));
-	val = val >> SHFT_RG_USB20_TERM_VREF_SEL;
-	val = val & MSK_RG_USB20_TERM_VREF_SEL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_3, str);
-
-	if (!strncmp(str, STRNG_0_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_3);
-		tmp_val = VAL_0_WIDTH_3;
-	} else if (!strncmp(str, STRNG_1_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_3);
-		tmp_val = VAL_1_WIDTH_3;
-	} else if (!strncmp(str, STRNG_2_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_2_WIDTH_3);
-		tmp_val = VAL_2_WIDTH_3;
-	} else if (!strncmp(str, STRNG_3_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_3_WIDTH_3);
-		tmp_val = VAL_3_WIDTH_3;
-	} else if (!strncmp(str, STRNG_4_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_4_WIDTH_3);
-		tmp_val = VAL_4_WIDTH_3;
-	} else if (!strncmp(str, STRNG_5_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_5_WIDTH_3);
-		tmp_val = VAL_5_WIDTH_3;
-	} else if (!strncmp(str, STRNG_6_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_6_WIDTH_3);
-		tmp_val = VAL_6_WIDTH_3;
-	} else if (!strncmp(str, STRNG_7_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_7_WIDTH_3);
-		tmp_val = VAL_7_WIDTH_3;
-	}
-
-	combined_val = tmp_val;
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_VRT_VREF_SEL));
-	val = val >> SHFT_RG_USB20_VRT_VREF_SEL;
-	val = val & MSK_RG_USB20_VRT_VREF_SEL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_3, str);
-
-	if (!strncmp(str, STRNG_0_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_3);
-		tmp_val = VAL_0_WIDTH_3;
-	} else if (!strncmp(str, STRNG_1_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_3);
-		tmp_val = VAL_1_WIDTH_3;
-	} else if (!strncmp(str, STRNG_2_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_2_WIDTH_3);
-		tmp_val = VAL_2_WIDTH_3;
-	} else if (!strncmp(str, STRNG_3_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_3_WIDTH_3);
-		tmp_val = VAL_3_WIDTH_3;
-	} else if (!strncmp(str, STRNG_4_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_4_WIDTH_3);
-		tmp_val = VAL_4_WIDTH_3;
-	} else if (!strncmp(str, STRNG_5_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_5_WIDTH_3);
-		tmp_val = VAL_5_WIDTH_3;
-	} else if (!strncmp(str, STRNG_6_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_6_WIDTH_3);
-		tmp_val = VAL_6_WIDTH_3;
-	} else if (!strncmp(str, STRNG_7_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_7_WIDTH_3);
-		tmp_val = VAL_7_WIDTH_3;
-	}
-
-	pr_debug("combined_val(%d), tmp_val(%d)\n", combined_val, tmp_val);
-	if ((tmp_val == (combined_val - 1)) || (tmp_val == combined_val))
-		combined_val += tmp_val;
-	else
-		combined_val = tmp_val * (VAL_MAX_WDITH_3 + 1) + combined_val;
-
-	pr_debug("combined_val(%d), tmp_val(%d)\n", combined_val, tmp_val);
-
-	seq_printf(s, "%s = %d\n", FILE_USB_DRIVING_CAPABILITY, combined_val);
-	return 0;
-}
-
-static int rg_usb20_term_vref_sel_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16] = "";
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_TERM_VREF_SEL));
-	val = val >> SHFT_RG_USB20_TERM_VREF_SEL;
-	val = val & MSK_RG_USB20_TERM_VREF_SEL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_3, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_TERM_VREF_SEL, str);
-	return 0;
-}
-
-static int rg_usb20_hstx_srctrl_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16] = "";
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_HSTX_SRCTRL));
-	val = val >> SHFT_RG_USB20_HSTX_SRCTRL;
-	val = val & MSK_RG_USB20_HSTX_SRCTRL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_3, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_HSTX_SRCTRL, str);
-	return 0;
-}
-
-static int rg_usb20_vrt_vref_sel_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16] = "";
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_VRT_VREF_SEL));
-	val = val >> SHFT_RG_USB20_VRT_VREF_SEL;
-	val = val & MSK_RG_USB20_VRT_VREF_SEL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_3, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_VRT_VREF_SEL, str);
-	return 0;
-}
-
-static int rg_usb20_intr_en_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16] = "";
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_INTR_EN));
-	val = val >> SHFT_RG_USB20_INTR_EN;
-	val = val & MSK_RG_USB20_INTR_EN;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_1, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_INTR_EN, str);
-	return 0;
-}
-
-static int rg_usb20_rev6_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16] = "";
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_PHY_REV6));
-	val = val >> SHFT_RG_USB20_PHY_REV6;
-	val = val & MSK_RG_USB20_PHY_REV6;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_2, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_PHY_REV6, str);
-	return 0;
-}
-
-static int rg_usb20_intr_cal_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16] = "";
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_INTR_CAL));
-	val = val >> SHFT_RG_USB20_INTR_CAL;
-	val = val & MSK_RG_USB20_INTR_CAL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_5, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_INTR_CAL, str);
-	return 0;
-}
-
-static int rg_usb20_discth_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16] = "";
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_DISCTH));
-	val = val >> SHFT_RG_USB20_DISCTH;
-	val = val & MSK_RG_USB20_DISCTH;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_4, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_DISCTH, str);
-	return 0;
-}
-
-static int phy_rw_show(struct seq_file *s, void *unused)
-{
-	seq_printf(s, "phy[0x%x] = 0x%x\n", ippc_addr, ippc_value);
-
-	return 0;
-}
-
-static int usb_driving_capability_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, usb_driving_capability_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_term_vref_sel_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_term_vref_sel_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_hstx_srctrl_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_hstx_srctrl_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_vrt_vref_sel_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_vrt_vref_sel_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_intr_en_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_intr_en_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_rev6_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_rev6_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_intr_cal_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_intr_cal_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_discth_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_discth_show, PDE_DATA(inode));
-}
-
-static int phy_rw_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, phy_rw_show, PDE_DATA(inode));
-}
-
-void val_to_bstring_width3(u8 val, char *str)
-{
-	switch (val) {
-	case VAL_0_WIDTH_3:
-		memcpy(str, STRNG_0_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_1_WIDTH_3:
-		memcpy(str, STRNG_1_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_2_WIDTH_3:
-		memcpy(str, STRNG_2_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_3_WIDTH_3:
-		memcpy(str, STRNG_3_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_4_WIDTH_3:
-		memcpy(str, STRNG_4_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_5_WIDTH_3:
-		memcpy(str, STRNG_5_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_6_WIDTH_3:
-		memcpy(str, STRNG_6_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_7_WIDTH_3:
-		memcpy(str, STRNG_7_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	}
-
-	pr_debug("val(%d), str(%s)\n", val, str);
-}
-
-static ssize_t usb_driving_capability_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-	u8 val, tmp_val;
-	char str_rg_usb20_term_vref_sel[18], str_rg_usb20_vrt_vref_sel[18];
-
-	memset(buf, 0x00, sizeof(buf));
-	pr_debug("\n");
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-
-	if (kstrtou8(buf, 10, &val) != 0) {
-		pr_debug("kstrtou8, err(%d)\n", kstrtou8(buf, 10, &val));
-		return count;
-	}
-	pr_debug("kstrtol, val(%d)\n", val);
-
-	if (val > VAL_7_WIDTH_3 * 2) {
-		pr_debug("wrong val set(%d), direct return\n", val);
-		return count;
-	}
-	tmp_val = val;
-	val /= 2;
-
-	pr_debug("val(%d), tmp_val(%d)\n", val, tmp_val);
-	val_to_bstring_width3(tmp_val - val, str_rg_usb20_term_vref_sel);
-	val_to_bstring_width3(val, str_rg_usb20_vrt_vref_sel);
-	pr_debug("Config TERM_VREF_SEL %s\n", str_rg_usb20_term_vref_sel);
-	usb20_phy_debugfs_write_width3(phy, OFFSET_RG_USB20_TERM_VREF_SEL,
-		SHFT_RG_USB20_TERM_VREF_SEL, str_rg_usb20_term_vref_sel);
-	pr_debug("Config VRT_VREF_SEL %s\n", str_rg_usb20_vrt_vref_sel);
-	usb20_phy_debugfs_write_width3(phy, OFFSET_RG_USB20_VRT_VREF_SEL,
-		SHFT_RG_USB20_VRT_VREF_SEL, str_rg_usb20_vrt_vref_sel);
-	return count;
-}
-
-static ssize_t rg_usb20_term_vref_sel_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width3(phy, OFFSET_RG_USB20_TERM_VREF_SEL,
-		SHFT_RG_USB20_TERM_VREF_SEL, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_hstx_srctrl_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width3(phy, OFFSET_RG_USB20_HSTX_SRCTRL,
-		SHFT_RG_USB20_HSTX_SRCTRL, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_vrt_vref_sel_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width3(phy, OFFSET_RG_USB20_VRT_VREF_SEL,
-		SHFT_RG_USB20_VRT_VREF_SEL, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_intr_en_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width1(phy, OFFSET_RG_USB20_INTR_EN,
-		SHFT_RG_USB20_INTR_EN, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_rev6_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_rev6_write(phy, OFFSET_RG_USB20_PHY_REV6,
-		SHFT_RG_USB20_PHY_REV6, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_intr_cal_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width5(phy, OFFSET_RG_USB20_INTR_CAL,
-		SHFT_RG_USB20_INTR_CAL, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_discth_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width4(phy, OFFSET_RG_USB20_DISCTH,
-		SHFT_RG_USB20_DISCTH, buf);
-	return count;
-}
-
-static ssize_t phy_rw_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[40];
-
-	memset(buf, 0x00, sizeof(buf));
-
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-
-	if (!strncmp(buf, "w", 1)) {
-		u32 offset;
-		u32 value;
-		u32 shift;
-		u32 mask;
-
-		if (sscanf(buf, "w32 0x%x:%d:0x%x:0x%x",
-			&offset, &shift, &mask, &value) == 4) {
-			if ((offset % 4) != 0) {
-				pr_notice("Must use 32bits alignment address\n");
-				return count;
-			}
-			u3phywrite32(phy, offset,
-				mask << shift, value << shift);
-		} else
-			return -EFAULT;
-	}
-
-	if (!strncmp(buf, "r", 1)) {
-		u32 offset;
-
-		if (sscanf(buf, "r32 0x%x", &offset) == 1) {
-			if ((offset % 4) != 0) {
-				pr_notice("Must use 32bits alignment address\n");
-				return count;
-			}
-			ippc_addr = offset;
-			ippc_value = usb_mtkphy_io_read(phy, ippc_addr);
-		}
-	}
-
-	return count;
-}
-
-
-
-static const struct file_operations usb_driving_capability_fops = {
-	.open = usb_driving_capability_open,
-	.write = usb_driving_capability_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_term_vref_sel_fops = {
-	.open = rg_usb20_term_vref_sel_open,
-	.write = rg_usb20_term_vref_sel_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_hstx_srctrl_fops = {
-	.open = rg_usb20_hstx_srctrl_open,
-	.write = rg_usb20_hstx_srctrl_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_vrt_vref_sel_fops = {
-	.open = rg_usb20_vrt_vref_sel_open,
-	.write = rg_usb20_vrt_vref_sel_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_intr_en_fops = {
-	.open = rg_usb20_intr_en_open,
-	.write = rg_usb20_intr_en_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_rev6_fops = {
-	.open = rg_usb20_rev6_open,
-	.write = rg_usb20_rev6_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_intr_cal_fops = {
-	.open = rg_usb20_intr_cal_open,
-	.write = rg_usb20_intr_cal_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_discth_fops = {
-	.open = rg_usb20_discth_open,
-	.write = rg_usb20_discth_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations phy_rw_fops = {
-	.open = phy_rw_open,
-	.write = phy_rw_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-int mtu3_phy_init_debugfs(struct phy *phy)
-{
-	struct proc_dir_entry *root;
-	struct proc_dir_entry *file;
-	int ret;
-
-	proc_mkdir("mtk_usb", NULL);
-
-	root = proc_mkdir("mtk_usb/usb20_phy", NULL);
-	if (!root) {
-		ret = -ENOMEM;
-		goto err0;
-	}
-
-	file = proc_create_data(FILE_USB_DRIVING_CAPABILITY, 0644,
-				   root, &usb_driving_capability_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_TERM_VREF_SEL, 0644,
-				   root, &rg_usb20_term_vref_sel_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_HSTX_SRCTRL, 0644,
-				   root, &rg_usb20_hstx_srctrl_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_VRT_VREF_SEL, 0644,
-				   root, &rg_usb20_vrt_vref_sel_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_INTR_EN, 0644,
-				   root, &rg_usb20_intr_en_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_PHY_REV6, 0644,
-				   root, &rg_usb20_rev6_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_INTR_CAL, 0644,
-				   root, &rg_usb20_intr_cal_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_DISCTH, 0644,
-				   root, &rg_usb20_discth_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_REG_DEBUG, 0644,
-				   root, &phy_rw_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-
-	usb20_phy_procfs_root = root;
-	return 0;
-
-err1:
-	proc_remove(root);
-
-err0:
-	return ret;
-}
-
-int mtu3_phy_exit_debugfs(void)
-{
-	proc_remove(usb20_phy_procfs_root);
-	return 0;
-}
diff --git a/drivers/usb/mtu3/mt6771/mtu3_phy_hal.c b/drivers/usb/mtu3/mt6771/mtu3_phy_hal.c
deleted file mode 100644
index 09417a7..0000000
--- a/drivers/usb/mtu3/mt6771/mtu3_phy_hal.c
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/phy/phy.h>
-#include <linux/phy/mediatek/mtk_usb_phy.h>
-#include <linux/clk.h>
-
-#include "mtu3.h"
-#include "mtu3_priv.h"
-
-static struct phy *mtk_phy;
-
-#if !defined(CONFIG_USB_MU3D_DRV)
-void Charger_Detect_Init(void)
-{
-	if (mtu3_cable_mode == CABLE_MODE_FORCEON) {
-		pr_info("%s-, SKIP\n", __func__);
-		return;
-	}
-
-	if (mtk_phy)
-		usb_mtkphy_switch_to_bc11(mtk_phy, true);
-}
-
-void Charger_Detect_Release(void)
-{
-	if (mtu3_cable_mode == CABLE_MODE_FORCEON) {
-		pr_info("%s-, SKIP\n", __func__);
-		return;
-	}
-
-	if (mtk_phy)
-		usb_mtkphy_switch_to_bc11(mtk_phy, false);
-}
-#endif
-
-void usb_dpdm_pulldown(bool enable)
-{
-#ifdef CONFIG_MTK_TYPEC_WATER_DETECT
-	if (mtk_phy) {
-		pr_info("%s: pulldown=%d\n", __func__, enable);
-		usb_mtkphy_dpdm_pulldown(mtk_phy, enable);
-	}
-#endif
-}
-
-int ssusb_dual_phy_power_on(struct ssusb_mtk *ssusb, bool host_mode)
-{
-	int ret;
-
-	ret = phy_power_on(ssusb->phys[0]);
-
-	if (host_mode) {
-		if (!ret)
-			usb_mtkphy_host_mode(ssusb->phys[0], true);
-	}
-	return ret;
-}
-
-void ssusb_dual_phy_power_off(struct ssusb_mtk *ssusb, bool host_mode)
-{
-	if (host_mode)
-		usb_mtkphy_host_mode(ssusb->phys[0], false);
-
-	phy_power_off(ssusb->phys[0]);
-}
-
-bool ssusb_u3loop_back_test(struct ssusb_mtk *ssusb)
-{
-	int ret;
-	void __iomem *ibase = ssusb->ippc_base;
-
-	ret = clk_prepare_enable(ssusb->sys_clk);
-	if (ret) {
-		dev_info(ssusb->dev, "failed to enable sys_clk\n");
-		return ret;
-	}
-	mtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL0, SSUSB_IP_SW_RST);
-	mtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL1, SSUSB_IP_HOST_PDN);
-	mtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL2, SSUSB_IP_DEV_PDN);
-	mtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL3, SSUSB_IP_PCIE_PDN);
-	mtu3_clrbits(ibase, SSUSB_U3_CTRL(0),
-		(SSUSB_U3_PORT_DIS | SSUSB_U3_PORT_PDN));
-	mdelay(10);
-
-	if (usb_mtkphy_u3_loop_back_test(ssusb->phys[0]) > 0)
-		ret = true;
-	else
-		ret = false;
-
-	mtu3_setbits(ibase, U3D_SSUSB_IP_PW_CTRL3, SSUSB_IP_PCIE_PDN);
-
-	clk_disable_unprepare(ssusb->sys_clk);
-
-	return ret;
-}
-
-void ssusb_set_phy_mode(int speed)
-{
-	/* do nothing */
-}
-
-void phy_hal_init(struct phy *phy)
-{
-	mtk_phy = phy;
-	mtu3_phy_init_debugfs(mtk_phy);
-}
-
-void phy_hal_exit(struct phy *phy)
-{
-	mtu3_phy_exit_debugfs();
-	mtk_phy = NULL;
-}
-
diff --git a/drivers/usb/mtu3/mt6771/mtu3_priv.h b/drivers/usb/mtu3/mt6771/mtu3_priv.h
deleted file mode 100644
index 25e3a5c..0000000
--- a/drivers/usb/mtu3/mt6771/mtu3_priv.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
- */
-
-
-#ifndef __MTU3_PRIV__
-#define __MTU3_PRIV__
-
-struct ssusb_priv {
-	struct regulator *vusb10;
-};
-
-extern void usb_audio_req(bool on);
-extern int mtu3_phy_init_debugfs(struct phy *phy);
-extern int mtu3_phy_exit_debugfs(void);
-extern void slp_set_infra_on(bool infra_on);
-
-#endif
-
diff --git a/drivers/usb/mtu3/mt6771/mtu3_sleep.c b/drivers/usb/mtu3/mt6771/mtu3_sleep.c
deleted file mode 100644
index bc0dee4..0000000
--- a/drivers/usb/mtu3/mt6771/mtu3_sleep.c
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <linux/of_irq.h>
-
-#include "mtu3.h"
-#include "mtu3_priv.h"
-
-static int ipsleep_irqnum;
-static int ipsleep_init;
-
-static irqreturn_t ipsleep_eint_isr(int irqnum, void *data)
-{
-	disable_irq_nosync(irqnum);
-	pr_info("ipsleep_eint\n");
-	return IRQ_HANDLED;
-}
-
-static int ipsleep_eint_irq_en(struct device *dev)
-{
-	int ret = 0;
-
-	ret = devm_request_irq(dev, ipsleep_irqnum,
-		ipsleep_eint_isr, 0, "usbcd_eint", NULL);
-
-	if (ret != 0) {
-		dev_info(dev, "usbcd irq fail, ret %d, irqnum %d!!!\n",
-			ret, ipsleep_irqnum);
-	} else
-		enable_irq_wake(ipsleep_irqnum);
-
-	return ret;
-}
-
-static int mt_usb_ipsleep_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-	struct device *dev = &pdev->dev;
-	struct device_node *node = dev->of_node;
-
-	ipsleep_irqnum = irq_of_parse_and_map(node, 0);
-	if (ipsleep_irqnum < 0) {
-		dev_info(dev, "get eint fail\n");
-		return -ENODEV;
-	}
-
-	ret = ipsleep_eint_irq_en(dev);
-	if (ret != 0)
-		goto irqfail;
-
-	ipsleep_init = 1;
-
-irqfail:
-	return ret;
-}
-
-static int mt_usb_ipsleep_remove(struct platform_device *pdev)
-{
-	free_irq(ipsleep_irqnum, NULL);
-	return 0;
-}
-
-static const struct of_device_id usb_ipsleep_of_match[] = {
-	{.compatible = "mediatek,usb_ipsleep"},
-	{},
-};
-
-static struct platform_driver usb_ipsleep_driver = {
-	.remove = mt_usb_ipsleep_remove,
-	.probe = mt_usb_ipsleep_probe,
-	.driver = {
-		.name = "usb_ipsleep",
-		.owner = THIS_MODULE,
-		.of_match_table = usb_ipsleep_of_match,
-	},
-};
-
-void ssusb_wakeup_mode_enable(struct ssusb_mtk *ssusb)
-{
-	if (ipsleep_init)
-		enable_irq(ipsleep_irqnum);
-}
-
-void ssusb_wakeup_mode_disable(struct ssusb_mtk *ssusb)
-{
-	if (ipsleep_init)
-		disable_irq(ipsleep_irqnum);
-}
-
-module_platform_driver(usb_ipsleep_driver);
-
diff --git a/drivers/usb/mtu3/mt6785/mtu3_hal.c b/drivers/usb/mtu3/mt6785/mtu3_hal.c
index f2666b0..5475949 100644
--- a/drivers/usb/mtu3/mt6785/mtu3_hal.c
+++ b/drivers/usb/mtu3/mt6785/mtu3_hal.c
@@ -217,16 +217,6 @@ void ssusb_dpidle_request(int mode)
 		mtu3_printk(K_NOTICE, "DPIDLE_TIMER\n");
 		issue_dpidle_timer();
 		break;
-	case USB_DPIDLE_SUSPEND:
-		spm_resource_req(SPM_RESOURCE_USER_SSUSB,
-				SPM_RESOURCE_MAINPLL | SPM_RESOURCE_CK_26M |
-				SPM_RESOURCE_AXI_BUS);
-		mtu3_printk(K_NOTICE, "DPIDLE_SUSPEND\n");
-		break;
-	case USB_DPIDLE_RESUME:
-		spm_resource_req(SPM_RESOURCE_USER_SSUSB, 0);
-		mtu3_printk(K_NOTICE, "DPIDLE_RESUME\n");
-		break;
 	default:
 		mtu3_printk(K_WARNIN, "[ERROR] Are you kidding!?!?\n");
 		break;
diff --git a/drivers/usb/mtu3/mt6785/mtu3_phy_debugfs.c b/drivers/usb/mtu3/mt6785/mtu3_phy_debugfs.c
index e0fd2c2..e66be6c 100644
--- a/drivers/usb/mtu3/mt6785/mtu3_phy_debugfs.c
+++ b/drivers/usb/mtu3/mt6785/mtu3_phy_debugfs.c
@@ -14,7 +14,7 @@
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
-#include <linux/proc_fs.h>
+#include <linux/debugfs.h>
 #include <linux/seq_file.h>
 #include <linux/uaccess.h>
 #include <linux/phy/phy.h>
@@ -92,7 +92,7 @@
 
 #define FILE_REG_DEBUG "phy_reg"
 
-static struct proc_dir_entry *usb20_phy_procfs_root;
+static struct dentry *usb20_phy_debugfs_root;
 static u32 ippc_value, ippc_addr;
 
 static void u3phywrite32(struct phy *phy, int offset, int mask, int value)
@@ -372,37 +372,37 @@ static int phy_rw_show(struct seq_file *s, void *unused)
 
 static int usb_driving_capability_open(struct inode *inode, struct file *file)
 {
-	return single_open(file, usb_driving_capability_show, PDE_DATA(inode));
+	return single_open(file, usb_driving_capability_show, inode->i_private);
 }
 
 static int rg_usb20_term_vref_sel_open(struct inode *inode, struct file *file)
 {
-	return single_open(file, rg_usb20_term_vref_sel_show, PDE_DATA(inode));
+	return single_open(file, rg_usb20_term_vref_sel_show, inode->i_private);
 }
 
 static int rg_usb20_hstx_srctrl_open(struct inode *inode, struct file *file)
 {
-	return single_open(file, rg_usb20_hstx_srctrl_show, PDE_DATA(inode));
+	return single_open(file, rg_usb20_hstx_srctrl_show, inode->i_private);
 }
 
 static int rg_usb20_vrt_vref_sel_open(struct inode *inode, struct file *file)
 {
-	return single_open(file, rg_usb20_vrt_vref_sel_show, PDE_DATA(inode));
+	return single_open(file, rg_usb20_vrt_vref_sel_show, inode->i_private);
 }
 
 static int rg_usb20_intr_en_open(struct inode *inode, struct file *file)
 {
-	return single_open(file, rg_usb20_intr_en_show, PDE_DATA(inode));
+	return single_open(file, rg_usb20_intr_en_show, inode->i_private);
 }
 
 static int rg_usb20_rev6_open(struct inode *inode, struct file *file)
 {
-	return single_open(file, rg_usb20_rev6_show, PDE_DATA(inode));
+	return single_open(file, rg_usb20_rev6_show, inode->i_private);
 }
 
 static int phy_rw_open(struct inode *inode, struct file *file)
 {
-	return single_open(file, phy_rw_show, PDE_DATA(inode));
+	return single_open(file, phy_rw_show, inode->i_private);
 }
 
 void val_to_bstring_width3(u8 val, char *str)
@@ -451,8 +451,8 @@ static ssize_t usb_driving_capability_write(struct file *file,
 	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
 		return -EFAULT;
 
-	if (kstrtou8(buf, 10, &val) != 0) {
-		pr_debug("kstrtou8, err(%d)\n", kstrtou8(buf, 10, &val));
+	if (kstrtol(buf, 10, (long *)&val) != 0) {
+		pr_debug("kstrtol, err(%d)\n", kstrtol(buf, 10, (long *)&val));
 		return count;
 	}
 	pr_debug("kstrtol, val(%d)\n", val);
@@ -661,67 +661,65 @@ static const struct file_operations phy_rw_fops = {
 
 int mtu3_phy_init_debugfs(struct phy *phy)
 {
-	struct proc_dir_entry *root;
-	struct proc_dir_entry *file;
+	struct dentry *root;
+	struct dentry *file;
 	int ret;
 
-	proc_mkdir("mtk_usb", NULL);
-
-	root = proc_mkdir("mtk_usb/usb20_phy", NULL);
+	root = debugfs_create_dir("usb20_phy", NULL);
 	if (!root) {
 		ret = -ENOMEM;
 		goto err0;
 	}
 
-	file = proc_create_data(FILE_USB_DRIVING_CAPABILITY, 0644,
-				   root, &usb_driving_capability_fops, phy);
+	file = debugfs_create_file(FILE_USB_DRIVING_CAPABILITY, 0644,
+				   root, phy, &usb_driving_capability_fops);
 	if (!file) {
 		ret = -ENOMEM;
 		goto err1;
 	}
-	file = proc_create_data(FILE_RG_USB20_TERM_VREF_SEL, 0644,
-				   root, &rg_usb20_term_vref_sel_fops, phy);
+	file = debugfs_create_file(FILE_RG_USB20_TERM_VREF_SEL, 0644,
+				   root, phy, &rg_usb20_term_vref_sel_fops);
 	if (!file) {
 		ret = -ENOMEM;
 		goto err1;
 	}
-	file = proc_create_data(FILE_RG_USB20_HSTX_SRCTRL, 0644,
-				   root, &rg_usb20_hstx_srctrl_fops, phy);
+	file = debugfs_create_file(FILE_RG_USB20_HSTX_SRCTRL, 0644,
+				   root, phy, &rg_usb20_hstx_srctrl_fops);
 	if (!file) {
 		ret = -ENOMEM;
 		goto err1;
 	}
-	file = proc_create_data(FILE_RG_USB20_VRT_VREF_SEL, 0644,
-				   root, &rg_usb20_vrt_vref_sel_fops, phy);
+	file = debugfs_create_file(FILE_RG_USB20_VRT_VREF_SEL, 0644,
+				   root, phy, &rg_usb20_vrt_vref_sel_fops);
 	if (!file) {
 		ret = -ENOMEM;
 		goto err1;
 	}
-	file = proc_create_data(FILE_RG_USB20_INTR_EN, 0644,
-				   root, &rg_usb20_intr_en_fops, phy);
+	file = debugfs_create_file(FILE_RG_USB20_INTR_EN, 0644,
+				   root, phy, &rg_usb20_intr_en_fops);
 	if (!file) {
 		ret = -ENOMEM;
 		goto err1;
 	}
-	file = proc_create_data(FILE_RG_USB20_PHY_REV6, 0644,
-				   root, &rg_usb20_rev6_fops, phy);
+	file = debugfs_create_file(FILE_RG_USB20_PHY_REV6, 0644,
+				   root, phy, &rg_usb20_rev6_fops);
 	if (!file) {
 		ret = -ENOMEM;
 		goto err1;
 	}
 
-	file = proc_create_data(FILE_REG_DEBUG, 0644,
-				   root, &phy_rw_fops, phy);
+	file = debugfs_create_file(FILE_REG_DEBUG, 0644,
+				   root, phy, &phy_rw_fops);
 	if (!file) {
 		ret = -ENOMEM;
 		goto err1;
 	}
 
-	usb20_phy_procfs_root = root;
+	usb20_phy_debugfs_root = root;
 	return 0;
 
 err1:
-	proc_remove(root);
+	debugfs_remove_recursive(root);
 
 err0:
 	return ret;
@@ -729,6 +727,6 @@ err0:
 
 int mtu3_phy_exit_debugfs(void)
 {
-	proc_remove(usb20_phy_procfs_root);
+	debugfs_remove_recursive(usb20_phy_debugfs_root);
 	return 0;
 }
diff --git a/drivers/usb/mtu3/mt6785/mtu3_phy_hal.c b/drivers/usb/mtu3/mt6785/mtu3_phy_hal.c
index 09417a7..1d9a1a6 100644
--- a/drivers/usb/mtu3/mt6785/mtu3_phy_hal.c
+++ b/drivers/usb/mtu3/mt6785/mtu3_phy_hal.c
@@ -107,11 +107,6 @@ bool ssusb_u3loop_back_test(struct ssusb_mtk *ssusb)
 	return ret;
 }
 
-void ssusb_set_phy_mode(int speed)
-{
-	/* do nothing */
-}
-
 void phy_hal_init(struct phy *phy)
 {
 	mtk_phy = phy;
diff --git a/drivers/usb/mtu3/mt6785/mtu3_sleep.c b/drivers/usb/mtu3/mt6785/mtu3_sleep.c
index bc0dee4..19a0da3 100644
--- a/drivers/usb/mtu3/mt6785/mtu3_sleep.c
+++ b/drivers/usb/mtu3/mt6785/mtu3_sleep.c
@@ -90,13 +90,13 @@ static struct platform_driver usb_ipsleep_driver = {
 	},
 };
 
-void ssusb_wakeup_mode_enable(struct ssusb_mtk *ssusb)
+void usb_wakeup_enable(struct ssusb_mtk *ssusb)
 {
 	if (ipsleep_init)
 		enable_irq(ipsleep_irqnum);
 }
 
-void ssusb_wakeup_mode_disable(struct ssusb_mtk *ssusb)
+void usb_wakeup_disable(struct ssusb_mtk *ssusb)
 {
 	if (ipsleep_init)
 		disable_irq(ipsleep_irqnum);
diff --git a/drivers/usb/mtu3/mt6833/Makefile b/drivers/usb/mtu3/mt6833/Makefile
deleted file mode 100644
index 8839ae7..0000000
--- a/drivers/usb/mtu3/mt6833/Makefile
+++ /dev/null
@@ -1,16 +0,0 @@
-#
-# Copyright (C) 2017 MediaTek Inc.
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License version 2 as
-# published by the Free Software Foundation.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-# GNU General Public License for more details.
-#
-subdir-ccflags-y += -Werror -I$(srctree)/drivers/usb/mtu3
-subdir-ccflags-y += -I$(srctree)/drivers/misc/mediatek/base/power/include/
-
-obj-y += mtu3_hal.o mtu3_phy_hal.o mtu3_sleep.o mtu3_phy_debugfs.o
diff --git a/drivers/usb/mtu3/mt6833/mtu3_hal.c b/drivers/usb/mtu3/mt6833/mtu3_hal.c
deleted file mode 100644
index 9dfb8b2..0000000
--- a/drivers/usb/mtu3/mt6833/mtu3_hal.c
+++ /dev/null
@@ -1,145 +0,0 @@
-/*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
- */
-
-#include <linux/clk.h>
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-
-#include <mtu3.h>
-#include <mtu3_hal.h>
-#include <mtk_idle.h>
-#include "mtu3_priv.h"
-
-int get_ssusb_ext_rscs(struct ssusb_mtk *ssusb)
-{
-	struct device *dev = ssusb->dev;
-	struct ssusb_priv *priv;
-
-	/* all elements are set to ZERO as default value */
-	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	priv->vusb10 = devm_regulator_get(dev, "va09");
-	if (IS_ERR(priv->vusb10)) {
-		dev_info(dev, "failed to get vusb10\n");
-		return PTR_ERR(priv->vusb10);
-	}
-
-	/* private mode setting */
-	ssusb->force_vbus = true;
-	ssusb->u1u2_disable = true;
-	ssusb->u3_loopb_support = true;
-
-	ssusb->priv_data = priv;
-	return 0;
-}
-
-static int ssusb_host_clk_on(struct ssusb_mtk *ssusb)
-{
-	return 0;
-}
-
-static int ssusb_host_clk_off(struct ssusb_mtk *ssusb)
-{
-	return 0;
-}
-
-static int ssusb_sysclk_on(struct ssusb_mtk *ssusb)
-{
-	int ret = 0;
-
-	ret = clk_prepare_enable(ssusb->sys_clk);
-	if (ret)
-		dev_info(ssusb->dev, "failed to enable sys_clk\n");
-
-	ret = clk_prepare_enable(ssusb->host_clk);
-	if (ret)
-		dev_info(ssusb->dev, "failed to enable host_clk\n");
-
-	ret = clk_prepare_enable(ssusb->ref_clk);
-	if (ret)
-		dev_info(ssusb->dev, "failed to enable ref_clk\n");
-
-	ret = clk_prepare_enable(ssusb->mcu_clk);
-	if (ret)
-		dev_info(ssusb->dev, "failed to enable mcu_clk\n");
-
-	ret = clk_prepare_enable(ssusb->dma_clk);
-	if (ret)
-		dev_info(ssusb->dev, "failed to enable dma_clk\n");
-
-	return ret;
-}
-
-static void ssusb_sysclk_off(struct ssusb_mtk *ssusb)
-{
-	clk_disable_unprepare(ssusb->dma_clk);
-	clk_disable_unprepare(ssusb->mcu_clk);
-	clk_disable_unprepare(ssusb->ref_clk);
-	clk_disable_unprepare(ssusb->host_clk);
-	clk_disable_unprepare(ssusb->sys_clk);
-}
-
-int ssusb_clk_on(struct ssusb_mtk *ssusb, int host_mode)
-{
-	if (host_mode) {
-		ssusb_sysclk_on(ssusb);
-		ssusb_host_clk_on(ssusb);
-	} else {
-		ssusb_sysclk_on(ssusb);
-	}
-	return 0;
-}
-
-int ssusb_clk_off(struct ssusb_mtk *ssusb, int host_mode)
-{
-	if (host_mode) {
-		ssusb_host_clk_off(ssusb);
-		ssusb_sysclk_off(ssusb);
-	} else {
-		ssusb_sysclk_off(ssusb);
-	}
-	return 0;
-}
-
-int ssusb_ext_pwr_on(struct ssusb_mtk *ssusb, int mode)
-{
-	int ret = 0;
-	struct ssusb_priv *priv;
-
-	priv = ssusb->priv_data;
-	ret = regulator_enable(priv->vusb10);
-	if (ret)
-		dev_info(ssusb->dev, "failed to enable vusb10\n");
-	return ret;
-}
-
-int ssusb_ext_pwr_off(struct ssusb_mtk *ssusb, int mode)
-{
-	int ret = 0;
-	struct ssusb_priv *priv;
-
-	priv = ssusb->priv_data;
-	ret = regulator_disable(priv->vusb10);
-	if (ret)
-		dev_info(ssusb->dev, "failed to disable vusb10\n");
-	return ret;
-}
-
-void ssusb_dpidle_request(int mode)
-{
-	/* not support */
-}
diff --git a/drivers/usb/mtu3/mt6833/mtu3_phy_debugfs.c b/drivers/usb/mtu3/mt6833/mtu3_phy_debugfs.c
deleted file mode 100644
index df42b8f..0000000
--- a/drivers/usb/mtu3/mt6833/mtu3_phy_debugfs.c
+++ /dev/null
@@ -1,986 +0,0 @@
-/*
- * Copyright (C) 2015 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
-#include <linux/uaccess.h>
-#include <linux/phy/phy.h>
-#include <linux/phy/mediatek/mtk_usb_phy.h>
-
-/* general */
-#define BIT_WIDTH_1		1
-#define MSK_WIDTH_1		0x1
-#define VAL_MAX_WDITH_1	0x1
-#define VAL_0_WIDTH_1		0x0
-#define VAL_1_WIDTH_1		0x1
-#define STRNG_0_WIDTH_1	"0"
-#define STRNG_1_WIDTH_1	"1"
-
-#define BIT_WIDTH_2		2
-#define MSK_WIDTH_2		0x3
-#define VAL_MAX_WDITH_2		0x3
-#define VAL_0_WIDTH_2		0x0
-#define VAL_1_WIDTH_2		0x1
-#define VAL_2_WIDTH_2		0x2
-#define VAL_3_WIDTH_2		0x3
-#define STRNG_0_WIDTH_2	"00"
-#define STRNG_1_WIDTH_2	"01"
-#define STRNG_2_WIDTH_2	"10"
-#define STRNG_3_WIDTH_2	"11"
-
-
-#define BIT_WIDTH_3		3
-#define MSK_WIDTH_3		0x7
-#define VAL_MAX_WDITH_3		0x7
-#define VAL_0_WIDTH_3		0x0
-#define VAL_1_WIDTH_3		0x1
-#define VAL_2_WIDTH_3		0x2
-#define VAL_3_WIDTH_3		0x3
-#define VAL_4_WIDTH_3		0x4
-#define VAL_5_WIDTH_3		0x5
-#define VAL_6_WIDTH_3		0x6
-#define VAL_7_WIDTH_3		0x7
-#define STRNG_0_WIDTH_3	"000"
-#define STRNG_1_WIDTH_3	"001"
-#define STRNG_2_WIDTH_3	"010"
-#define STRNG_3_WIDTH_3	"011"
-#define STRNG_4_WIDTH_3	"100"
-#define STRNG_5_WIDTH_3	"101"
-#define STRNG_6_WIDTH_3	"110"
-#define STRNG_7_WIDTH_3	"111"
-
-#define BIT_WIDTH_4		4
-#define MSK_WIDTH_4		0xf
-#define VAL_MAX_WDITH_4		0xf
-#define VAL_0_WIDTH_4		0x0
-#define VAL_1_WIDTH_4		0x1
-#define VAL_2_WIDTH_4		0x2
-#define VAL_3_WIDTH_4		0x3
-#define VAL_4_WIDTH_4		0x4
-#define VAL_5_WIDTH_4		0x5
-#define VAL_6_WIDTH_4		0x6
-#define VAL_7_WIDTH_4		0x7
-#define VAL_8_WIDTH_4		0x8
-#define VAL_9_WIDTH_4		0x9
-#define VAL_A_WIDTH_4		0xa
-#define VAL_B_WIDTH_4		0xb
-#define VAL_C_WIDTH_4		0xc
-#define VAL_D_WIDTH_4		0xd
-#define VAL_E_WIDTH_4		0xe
-#define VAL_F_WIDTH_4		0xf
-#define STRNG_0_WIDTH_4	"0000"
-#define STRNG_1_WIDTH_4	"0001"
-#define STRNG_2_WIDTH_4	"0010"
-#define STRNG_3_WIDTH_4	"0011"
-#define STRNG_4_WIDTH_4	"0100"
-#define STRNG_5_WIDTH_4	"0101"
-#define STRNG_6_WIDTH_4	"0110"
-#define STRNG_7_WIDTH_4	"0111"
-#define STRNG_8_WIDTH_4	"1000"
-#define STRNG_9_WIDTH_4	"1001"
-#define STRNG_A_WIDTH_4	"1010"
-#define STRNG_B_WIDTH_4	"1011"
-#define STRNG_C_WIDTH_4	"1100"
-#define STRNG_D_WIDTH_4	"1101"
-#define STRNG_E_WIDTH_4	"1110"
-#define STRNG_F_WIDTH_4	"1111"
-
-#define BIT_WIDTH_5		5
-#define MSK_WIDTH_5		0x1f
-#define VAL_MAX_WDITH_5		0x1f
-#define VAL_0_WIDTH_5		0x0
-#define VAL_1_WIDTH_5		0x1
-#define VAL_18_WIDTH_5		0x12
-#define VAL_20_WIDTH_5		0x14
-#define VAL_30_WIDTH_5		0x1e
-#define VAL_31_WIDTH_5		0x1f
-#define STRNG_0_WIDTH_5		"00000"
-#define STRNG_1_WIDTH_5		"00001"
-#define STRNG_18_WIDTH_5	"10010"
-#define STRNG_20_WIDTH_5	"10100"
-#define STRNG_30_WIDTH_5	"11110"
-#define STRNG_31_WIDTH_5	"11111"
-
-/* specific */
-#define FILE_USB_DRIVING_CAPABILITY "USB_DRIVING_CAPABILITY"
-
-#define FILE_RG_USB20_TERM_VREF_SEL "RG_USB20_TERM_VREF_SEL"
-#define MSK_RG_USB20_TERM_VREF_SEL MSK_WIDTH_3
-#define SHFT_RG_USB20_TERM_VREF_SEL 8
-#define OFFSET_RG_USB20_TERM_VREF_SEL 0x4
-
-#define FILE_RG_USB20_HSTX_SRCTRL "RG_USB20_HSTX_SRCTRL"
-#define MSK_RG_USB20_HSTX_SRCTRL MSK_WIDTH_3
-#define SHFT_RG_USB20_HSTX_SRCTRL 12
-#define OFFSET_RG_USB20_HSTX_SRCTRL 0x14
-
-#define FILE_RG_USB20_VRT_VREF_SEL "RG_USB20_VRT_VREF_SEL"
-#define MSK_RG_USB20_VRT_VREF_SEL MSK_WIDTH_3
-#define SHFT_RG_USB20_VRT_VREF_SEL 12
-#define OFFSET_RG_USB20_VRT_VREF_SEL 0x4
-
-#define FILE_RG_USB20_INTR_EN "RG_USB20_INTR_EN"
-#define MSK_RG_USB20_INTR_EN MSK_WIDTH_1
-#define SHFT_RG_USB20_INTR_EN 5
-#define OFFSET_RG_USB20_INTR_EN 0x0
-
-#define FILE_RG_USB20_PHY_REV6 "RG_USB20_PHY_REV6"
-#define MSK_RG_USB20_PHY_REV6 MSK_WIDTH_2
-#define SHFT_RG_USB20_PHY_REV6 30
-#define OFFSET_RG_USB20_PHY_REV6 0x18
-
-#define FILE_RG_USB20_INTR_CAL "RG_USB20_INTR_CAL"
-#define MSK_RG_USB20_INTR_CAL MSK_WIDTH_5
-#define SHFT_RG_USB20_INTR_CAL 19
-#define OFFSET_RG_USB20_INTR_CAL 0x4
-
-#define FILE_RG_USB20_DISCTH "RG_USB20_DISCTH"
-#define MSK_RG_USB20_DISCTH MSK_WIDTH_4
-#define SHFT_RG_USB20_DISCTH 4
-#define OFFSET_RG_USB20_DISCTH 0x18
-
-#define FILE_REG_DEBUG "phy_reg"
-
-static struct proc_dir_entry *usb20_phy_procfs_root;
-static u32 ippc_value, ippc_addr;
-
-static void u3phywrite32(struct phy *phy, int offset, int mask, int value)
-{
-	u32 cur_value;
-	u32 new_value;
-
-	cur_value = usb_mtkphy_io_read(phy, offset);
-	new_value = (cur_value & (~mask)) | value;
-	usb_mtkphy_io_write(phy, new_value, offset);
-}
-
-static void usb20_phy_debugfs_write_width1(struct phy *phy, u8 offset, u8 shift,
-	char *buf)
-{
-	u32 set_val = 0;
-
-	pr_debug("s(%s)\n", buf);
-	if (!strncmp(buf, STRNG_0_WIDTH_1, BIT_WIDTH_1)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_1);
-		set_val = VAL_0_WIDTH_1;
-	} else if (!strncmp(buf, STRNG_1_WIDTH_1, BIT_WIDTH_1)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_1);
-		set_val = VAL_1_WIDTH_1;
-	} else
-		return;
-
-	u3phywrite32(phy, offset, MSK_WIDTH_1 << shift, set_val << shift);
-
-}
-
-static void usb20_phy_debugfs_rev6_write(struct phy *phy, u8 offset, u8 shift,
-	char *buf)
-{
-	u32 set_val = 0xFF;
-
-	pr_debug("s(%s)\n", buf);
-	if (!strncmp(buf, STRNG_0_WIDTH_2, BIT_WIDTH_2)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_2);
-		set_val = VAL_0_WIDTH_2;
-	} else if (!strncmp(buf, STRNG_1_WIDTH_2, BIT_WIDTH_2)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_2);
-		set_val = VAL_1_WIDTH_2;
-	} else if (!strncmp(buf, STRNG_2_WIDTH_2, BIT_WIDTH_2)) {
-		pr_debug("%s case\n", STRNG_2_WIDTH_2);
-		set_val = VAL_2_WIDTH_2;
-	} else if (!strncmp(buf, STRNG_3_WIDTH_2, BIT_WIDTH_2)) {
-		pr_debug("%s case\n", STRNG_3_WIDTH_2);
-		set_val = VAL_3_WIDTH_2;
-	} else
-		return;
-
-	u3phywrite32(phy, offset, MSK_WIDTH_2 << shift, set_val << shift);
-
-}
-
-
-static void usb20_phy_debugfs_write_width3(struct phy *phy, u8 offset, u8 shift,
-	char *buf)
-{
-	u32 set_val = 0;
-
-	pr_debug("s(%s)\n", buf);
-	if (!strncmp(buf, STRNG_0_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_3);
-		set_val = VAL_0_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_1_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_3);
-		set_val = VAL_1_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_2_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_2_WIDTH_3);
-		set_val = VAL_2_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_3_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_3_WIDTH_3);
-		set_val = VAL_3_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_4_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_4_WIDTH_3);
-		set_val = VAL_4_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_5_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_5_WIDTH_3);
-		set_val = VAL_5_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_6_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_6_WIDTH_3);
-		set_val = VAL_6_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_7_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_7_WIDTH_3);
-		set_val = VAL_7_WIDTH_3;
-	} else
-		return;
-
-	u3phywrite32(phy, offset, MSK_WIDTH_3 << shift, set_val << shift);
-
-}
-
-static void usb20_phy_debugfs_write_width4(struct phy *phy, u8 offset, u8 shift,
-	char *buf)
-{
-	u32 set_val = 0;
-
-	pr_debug("s(%s)\n", buf);
-	if (!strncmp(buf, STRNG_0_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_4);
-		set_val = VAL_0_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_1_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_4);
-		set_val = VAL_1_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_2_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_2_WIDTH_4);
-		set_val = VAL_2_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_3_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_3_WIDTH_4);
-		set_val = VAL_3_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_4_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_4_WIDTH_4);
-		set_val = VAL_4_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_5_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_5_WIDTH_4);
-		set_val = VAL_5_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_6_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_6_WIDTH_4);
-		set_val = VAL_6_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_7_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_7_WIDTH_4);
-		set_val = VAL_7_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_8_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_8_WIDTH_4);
-		set_val = VAL_8_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_9_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_9_WIDTH_4);
-		set_val = VAL_9_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_A_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_A_WIDTH_4);
-		set_val = VAL_A_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_B_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_B_WIDTH_4);
-		set_val = VAL_B_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_C_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_C_WIDTH_4);
-		set_val = VAL_C_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_D_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_D_WIDTH_4);
-		set_val = VAL_D_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_E_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_E_WIDTH_4);
-		set_val = VAL_E_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_F_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_F_WIDTH_4);
-		set_val = VAL_F_WIDTH_4;
-	} else
-		return;
-
-	u3phywrite32(phy, offset, MSK_WIDTH_4 << shift, set_val << shift);
-
-}
-
-static void usb20_phy_debugfs_write_width5(struct phy *phy, u8 offset, u8 shift,
-	char *buf)
-{
-	u32 set_val = 0;
-
-	pr_debug("s(%s)\n", buf);
-	if (!strncmp(buf, STRNG_0_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_5);
-		set_val = VAL_0_WIDTH_5;
-	} else if (!strncmp(buf, STRNG_1_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_5);
-		set_val = VAL_1_WIDTH_5;
-	} else if (!strncmp(buf, STRNG_18_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_18_WIDTH_5);
-		set_val = VAL_18_WIDTH_5;
-	} else if (!strncmp(buf, STRNG_20_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_20_WIDTH_5);
-		set_val = VAL_20_WIDTH_5;
-	} else if (!strncmp(buf, STRNG_30_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_30_WIDTH_5);
-		set_val = VAL_30_WIDTH_5;
-	} else if (!strncmp(buf, STRNG_31_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_31_WIDTH_5);
-		set_val = VAL_31_WIDTH_5;
-	} else
-		return;
-
-	u3phywrite32(phy, offset, MSK_WIDTH_5 << shift, set_val << shift);
-
-}
-
-
-static u8 usb20_phy_debugfs_read_val(u32 val, u8 width, char *str)
-{
-	int i, temp;
-
-	temp = val;
-	str[width] = '\0';
-	for (i = (width - 1); i >= 0; i--) {
-		if (val % 2)
-			str[i] = '1';
-		else
-			str[i] = '0';
-		pr_debug("str[%d]:%c\n", i, str[i]);
-		val /= 2;
-	}
-	pr_debug("str(%s)\n", str);
-	return val;
-}
-
-static int usb_driving_capability_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-	u8 combined_val, tmp_val = 0xff;
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_TERM_VREF_SEL));
-	val = val >> SHFT_RG_USB20_TERM_VREF_SEL;
-	val = val & MSK_RG_USB20_TERM_VREF_SEL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_3, str);
-
-	if (!strncmp(str, STRNG_0_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_3);
-		tmp_val = VAL_0_WIDTH_3;
-	} else if (!strncmp(str, STRNG_1_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_3);
-		tmp_val = VAL_1_WIDTH_3;
-	} else if (!strncmp(str, STRNG_2_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_2_WIDTH_3);
-		tmp_val = VAL_2_WIDTH_3;
-	} else if (!strncmp(str, STRNG_3_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_3_WIDTH_3);
-		tmp_val = VAL_3_WIDTH_3;
-	} else if (!strncmp(str, STRNG_4_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_4_WIDTH_3);
-		tmp_val = VAL_4_WIDTH_3;
-	} else if (!strncmp(str, STRNG_5_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_5_WIDTH_3);
-		tmp_val = VAL_5_WIDTH_3;
-	} else if (!strncmp(str, STRNG_6_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_6_WIDTH_3);
-		tmp_val = VAL_6_WIDTH_3;
-	} else if (!strncmp(str, STRNG_7_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_7_WIDTH_3);
-		tmp_val = VAL_7_WIDTH_3;
-	}
-
-	combined_val = tmp_val;
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_VRT_VREF_SEL));
-	val = val >> SHFT_RG_USB20_VRT_VREF_SEL;
-	val = val & MSK_RG_USB20_VRT_VREF_SEL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_3, str);
-
-	if (!strncmp(str, STRNG_0_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_3);
-		tmp_val = VAL_0_WIDTH_3;
-	} else if (!strncmp(str, STRNG_1_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_3);
-		tmp_val = VAL_1_WIDTH_3;
-	} else if (!strncmp(str, STRNG_2_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_2_WIDTH_3);
-		tmp_val = VAL_2_WIDTH_3;
-	} else if (!strncmp(str, STRNG_3_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_3_WIDTH_3);
-		tmp_val = VAL_3_WIDTH_3;
-	} else if (!strncmp(str, STRNG_4_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_4_WIDTH_3);
-		tmp_val = VAL_4_WIDTH_3;
-	} else if (!strncmp(str, STRNG_5_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_5_WIDTH_3);
-		tmp_val = VAL_5_WIDTH_3;
-	} else if (!strncmp(str, STRNG_6_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_6_WIDTH_3);
-		tmp_val = VAL_6_WIDTH_3;
-	} else if (!strncmp(str, STRNG_7_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_7_WIDTH_3);
-		tmp_val = VAL_7_WIDTH_3;
-	}
-
-	pr_debug("combined_val(%d), tmp_val(%d)\n", combined_val, tmp_val);
-	if ((tmp_val == (combined_val - 1)) || (tmp_val == combined_val))
-		combined_val += tmp_val;
-	else
-		combined_val = tmp_val * (VAL_MAX_WDITH_3 + 1) + combined_val;
-
-	pr_debug("combined_val(%d), tmp_val(%d)\n", combined_val, tmp_val);
-
-	seq_printf(s, "%s = %d\n", FILE_USB_DRIVING_CAPABILITY, combined_val);
-	return 0;
-}
-
-static int rg_usb20_term_vref_sel_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_TERM_VREF_SEL));
-	val = val >> SHFT_RG_USB20_TERM_VREF_SEL;
-	val = val & MSK_RG_USB20_TERM_VREF_SEL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_3, str);
-
-	seq_printf(s, "%s= %s\n", FILE_RG_USB20_TERM_VREF_SEL, str);
-	return 0;
-}
-
-static int rg_usb20_hstx_srctrl_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_HSTX_SRCTRL));
-	val = val >> SHFT_RG_USB20_HSTX_SRCTRL;
-	val = val & MSK_RG_USB20_HSTX_SRCTRL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_3, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_HSTX_SRCTRL, str);
-	return 0;
-}
-
-static int rg_usb20_vrt_vref_sel_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_VRT_VREF_SEL));
-	val = val >> SHFT_RG_USB20_VRT_VREF_SEL;
-	val = val & MSK_RG_USB20_VRT_VREF_SEL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_3, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_VRT_VREF_SEL, str);
-	return 0;
-}
-
-static int rg_usb20_intr_en_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_INTR_EN));
-	val = val >> SHFT_RG_USB20_INTR_EN;
-	val = val & MSK_RG_USB20_INTR_EN;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_1, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_INTR_EN, str);
-	return 0;
-}
-
-static int rg_usb20_rev6_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_PHY_REV6));
-	val = val >> SHFT_RG_USB20_PHY_REV6;
-	val = val & MSK_RG_USB20_PHY_REV6;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_2, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_PHY_REV6, str);
-	return 0;
-}
-
-static int rg_usb20_intr_cal_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_INTR_CAL));
-	val = val >> SHFT_RG_USB20_INTR_CAL;
-	val = val & MSK_RG_USB20_INTR_CAL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_5, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_INTR_CAL, str);
-	return 0;
-}
-
-static int rg_usb20_discth_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_DISCTH));
-	val = val >> SHFT_RG_USB20_DISCTH;
-	val = val & MSK_RG_USB20_DISCTH;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_4, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_DISCTH, str);
-	return 0;
-}
-
-static int phy_rw_show(struct seq_file *s, void *unused)
-{
-	seq_printf(s, "phy[0x%x] = 0x%x\n", ippc_addr, ippc_value);
-
-	return 0;
-}
-
-static int usb_driving_capability_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, usb_driving_capability_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_term_vref_sel_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_term_vref_sel_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_hstx_srctrl_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_hstx_srctrl_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_vrt_vref_sel_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_vrt_vref_sel_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_intr_en_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_intr_en_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_rev6_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_rev6_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_intr_cal_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_intr_cal_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_discth_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_discth_show, PDE_DATA(inode));
-}
-
-static int phy_rw_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, phy_rw_show, PDE_DATA(inode));
-}
-
-void val_to_bstring_width3(u8 val, char *str)
-{
-	switch (val) {
-	case VAL_0_WIDTH_3:
-		memcpy(str, STRNG_0_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_1_WIDTH_3:
-		memcpy(str, STRNG_1_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_2_WIDTH_3:
-		memcpy(str, STRNG_2_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_3_WIDTH_3:
-		memcpy(str, STRNG_3_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_4_WIDTH_3:
-		memcpy(str, STRNG_4_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_5_WIDTH_3:
-		memcpy(str, STRNG_5_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_6_WIDTH_3:
-		memcpy(str, STRNG_6_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_7_WIDTH_3:
-		memcpy(str, STRNG_7_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	}
-
-	pr_debug("val(%d), str(%s)\n", val, str);
-}
-
-static ssize_t usb_driving_capability_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-	u8 val, tmp_val;
-	char str_rg_usb20_term_vref_sel[18], str_rg_usb20_vrt_vref_sel[18];
-
-	memset(buf, 0x00, sizeof(buf));
-	pr_debug("\n");
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-
-	if (kstrtol(buf, 10, (long *)&val) != 0) {
-		pr_debug("kstrtol, err(%d)\n", kstrtol(buf, 10, (long *)&val));
-		return count;
-	}
-	pr_debug("kstrtol, val(%d)\n", val);
-
-	if (val > VAL_7_WIDTH_3 * 2) {
-		pr_debug("wrong val set(%d), direct return\n", val);
-		return count;
-	}
-	tmp_val = val;
-	val /= 2;
-
-	pr_debug("val(%d), tmp_val(%d)\n", val, tmp_val);
-	val_to_bstring_width3(tmp_val - val, str_rg_usb20_term_vref_sel);
-	val_to_bstring_width3(val, str_rg_usb20_vrt_vref_sel);
-	pr_debug("Config TERM_VREF_SEL %s\n", str_rg_usb20_term_vref_sel);
-	usb20_phy_debugfs_write_width3(phy, OFFSET_RG_USB20_TERM_VREF_SEL,
-		SHFT_RG_USB20_TERM_VREF_SEL, str_rg_usb20_term_vref_sel);
-	pr_debug("Config VRT_VREF_SEL %s\n", str_rg_usb20_vrt_vref_sel);
-	usb20_phy_debugfs_write_width3(phy, OFFSET_RG_USB20_VRT_VREF_SEL,
-		SHFT_RG_USB20_VRT_VREF_SEL, str_rg_usb20_vrt_vref_sel);
-	return count;
-}
-
-static ssize_t rg_usb20_term_vref_sel_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width3(phy, OFFSET_RG_USB20_TERM_VREF_SEL,
-		SHFT_RG_USB20_TERM_VREF_SEL, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_hstx_srctrl_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width3(phy, OFFSET_RG_USB20_HSTX_SRCTRL,
-		SHFT_RG_USB20_HSTX_SRCTRL, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_vrt_vref_sel_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width3(phy, OFFSET_RG_USB20_VRT_VREF_SEL,
-		SHFT_RG_USB20_VRT_VREF_SEL, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_intr_en_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width1(phy, OFFSET_RG_USB20_INTR_EN,
-		SHFT_RG_USB20_INTR_EN, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_rev6_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_rev6_write(phy, OFFSET_RG_USB20_PHY_REV6,
-		SHFT_RG_USB20_PHY_REV6, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_intr_cal_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width5(phy, OFFSET_RG_USB20_INTR_CAL,
-		SHFT_RG_USB20_INTR_CAL, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_discth_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width4(phy, OFFSET_RG_USB20_DISCTH,
-		SHFT_RG_USB20_DISCTH, buf);
-	return count;
-}
-
-static ssize_t phy_rw_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[40];
-
-	memset(buf, 0x00, sizeof(buf));
-
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-
-	if (!strncmp(buf, "w", 1)) {
-		u32 offset;
-		u32 value;
-		u32 shift;
-		u32 mask;
-
-		if (sscanf(buf, "w32 0x%x:%d:0x%x:0x%x",
-			&offset, &shift, &mask, &value) == 4) {
-			if ((offset % 4) != 0) {
-				pr_notice("Must use 32bits alignment address\n");
-				return count;
-			}
-			u3phywrite32(phy, offset,
-				mask << shift, value << shift);
-		} else
-			return -EFAULT;
-	}
-
-	if (!strncmp(buf, "r", 1)) {
-		u32 offset;
-
-		if (sscanf(buf, "r32 0x%x", &offset) == 1) {
-			if ((offset % 4) != 0) {
-				pr_notice("Must use 32bits alignment address\n");
-				return count;
-			}
-			ippc_addr = offset;
-			ippc_value = usb_mtkphy_io_read(phy, ippc_addr);
-		}
-	}
-
-	return count;
-}
-
-
-
-static const struct file_operations usb_driving_capability_fops = {
-	.open = usb_driving_capability_open,
-	.write = usb_driving_capability_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_term_vref_sel_fops = {
-	.open = rg_usb20_term_vref_sel_open,
-	.write = rg_usb20_term_vref_sel_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_hstx_srctrl_fops = {
-	.open = rg_usb20_hstx_srctrl_open,
-	.write = rg_usb20_hstx_srctrl_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_vrt_vref_sel_fops = {
-	.open = rg_usb20_vrt_vref_sel_open,
-	.write = rg_usb20_vrt_vref_sel_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_intr_en_fops = {
-	.open = rg_usb20_intr_en_open,
-	.write = rg_usb20_intr_en_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_rev6_fops = {
-	.open = rg_usb20_rev6_open,
-	.write = rg_usb20_rev6_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_intr_cal_fops = {
-	.open = rg_usb20_intr_cal_open,
-	.write = rg_usb20_intr_cal_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_discth_fops = {
-	.open = rg_usb20_discth_open,
-	.write = rg_usb20_discth_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations phy_rw_fops = {
-	.open = phy_rw_open,
-	.write = phy_rw_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-int mtu3_phy_init_debugfs(struct phy *phy)
-{
-	struct proc_dir_entry *root;
-	struct proc_dir_entry *file;
-	int ret;
-
-	proc_mkdir("mtk_usb", NULL);
-
-	root = proc_mkdir("mtk_usb/usb20_phy", NULL);
-	if (!root) {
-		ret = -ENOMEM;
-		goto err0;
-	}
-
-	file = proc_create_data(FILE_USB_DRIVING_CAPABILITY, 0644,
-				   root, &usb_driving_capability_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_TERM_VREF_SEL, 0644,
-				   root, &rg_usb20_term_vref_sel_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_HSTX_SRCTRL, 0644,
-				   root, &rg_usb20_hstx_srctrl_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_VRT_VREF_SEL, 0644,
-				   root, &rg_usb20_vrt_vref_sel_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_INTR_EN, 0644,
-				   root, &rg_usb20_intr_en_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_PHY_REV6, 0644,
-				   root, &rg_usb20_rev6_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_INTR_CAL, 0644,
-				   root, &rg_usb20_intr_cal_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_DISCTH, 0644,
-				   root, &rg_usb20_discth_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_REG_DEBUG, 0644,
-				   root, &phy_rw_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-
-	usb20_phy_procfs_root = root;
-	return 0;
-
-err1:
-	proc_remove(root);
-
-err0:
-	return ret;
-}
-
-int mtu3_phy_exit_debugfs(void)
-{
-	proc_remove(usb20_phy_procfs_root);
-	return 0;
-}
diff --git a/drivers/usb/mtu3/mt6833/mtu3_phy_hal.c b/drivers/usb/mtu3/mt6833/mtu3_phy_hal.c
deleted file mode 100644
index 1d9a1a6..0000000
--- a/drivers/usb/mtu3/mt6833/mtu3_phy_hal.c
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/phy/phy.h>
-#include <linux/phy/mediatek/mtk_usb_phy.h>
-#include <linux/clk.h>
-
-#include "mtu3.h"
-#include "mtu3_priv.h"
-
-static struct phy *mtk_phy;
-
-#if !defined(CONFIG_USB_MU3D_DRV)
-void Charger_Detect_Init(void)
-{
-	if (mtu3_cable_mode == CABLE_MODE_FORCEON) {
-		pr_info("%s-, SKIP\n", __func__);
-		return;
-	}
-
-	if (mtk_phy)
-		usb_mtkphy_switch_to_bc11(mtk_phy, true);
-}
-
-void Charger_Detect_Release(void)
-{
-	if (mtu3_cable_mode == CABLE_MODE_FORCEON) {
-		pr_info("%s-, SKIP\n", __func__);
-		return;
-	}
-
-	if (mtk_phy)
-		usb_mtkphy_switch_to_bc11(mtk_phy, false);
-}
-#endif
-
-void usb_dpdm_pulldown(bool enable)
-{
-#ifdef CONFIG_MTK_TYPEC_WATER_DETECT
-	if (mtk_phy) {
-		pr_info("%s: pulldown=%d\n", __func__, enable);
-		usb_mtkphy_dpdm_pulldown(mtk_phy, enable);
-	}
-#endif
-}
-
-int ssusb_dual_phy_power_on(struct ssusb_mtk *ssusb, bool host_mode)
-{
-	int ret;
-
-	ret = phy_power_on(ssusb->phys[0]);
-
-	if (host_mode) {
-		if (!ret)
-			usb_mtkphy_host_mode(ssusb->phys[0], true);
-	}
-	return ret;
-}
-
-void ssusb_dual_phy_power_off(struct ssusb_mtk *ssusb, bool host_mode)
-{
-	if (host_mode)
-		usb_mtkphy_host_mode(ssusb->phys[0], false);
-
-	phy_power_off(ssusb->phys[0]);
-}
-
-bool ssusb_u3loop_back_test(struct ssusb_mtk *ssusb)
-{
-	int ret;
-	void __iomem *ibase = ssusb->ippc_base;
-
-	ret = clk_prepare_enable(ssusb->sys_clk);
-	if (ret) {
-		dev_info(ssusb->dev, "failed to enable sys_clk\n");
-		return ret;
-	}
-	mtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL0, SSUSB_IP_SW_RST);
-	mtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL1, SSUSB_IP_HOST_PDN);
-	mtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL2, SSUSB_IP_DEV_PDN);
-	mtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL3, SSUSB_IP_PCIE_PDN);
-	mtu3_clrbits(ibase, SSUSB_U3_CTRL(0),
-		(SSUSB_U3_PORT_DIS | SSUSB_U3_PORT_PDN));
-	mdelay(10);
-
-	if (usb_mtkphy_u3_loop_back_test(ssusb->phys[0]) > 0)
-		ret = true;
-	else
-		ret = false;
-
-	mtu3_setbits(ibase, U3D_SSUSB_IP_PW_CTRL3, SSUSB_IP_PCIE_PDN);
-
-	clk_disable_unprepare(ssusb->sys_clk);
-
-	return ret;
-}
-
-void phy_hal_init(struct phy *phy)
-{
-	mtk_phy = phy;
-	mtu3_phy_init_debugfs(mtk_phy);
-}
-
-void phy_hal_exit(struct phy *phy)
-{
-	mtu3_phy_exit_debugfs();
-	mtk_phy = NULL;
-}
-
diff --git a/drivers/usb/mtu3/mt6833/mtu3_priv.h b/drivers/usb/mtu3/mt6833/mtu3_priv.h
deleted file mode 100644
index 30d2d87..0000000
--- a/drivers/usb/mtu3/mt6833/mtu3_priv.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
- */
-
-
-#ifndef __MTU3_PRIV__
-#define __MTU3_PRIV__
-
-struct ssusb_priv {
-	struct regulator *vusb10;
-};
-
-extern void usb_audio_req(bool on);
-extern int mtu3_phy_init_debugfs(struct phy *phy);
-extern int mtu3_phy_exit_debugfs(void);
-
-#endif
-
diff --git a/drivers/usb/mtu3/mt6833/mtu3_sleep.c b/drivers/usb/mtu3/mt6833/mtu3_sleep.c
deleted file mode 100644
index 19a0da3..0000000
--- a/drivers/usb/mtu3/mt6833/mtu3_sleep.c
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <linux/of_irq.h>
-
-#include "mtu3.h"
-#include "mtu3_priv.h"
-
-static int ipsleep_irqnum;
-static int ipsleep_init;
-
-static irqreturn_t ipsleep_eint_isr(int irqnum, void *data)
-{
-	disable_irq_nosync(irqnum);
-	pr_info("ipsleep_eint\n");
-	return IRQ_HANDLED;
-}
-
-static int ipsleep_eint_irq_en(struct device *dev)
-{
-	int ret = 0;
-
-	ret = devm_request_irq(dev, ipsleep_irqnum,
-		ipsleep_eint_isr, 0, "usbcd_eint", NULL);
-
-	if (ret != 0) {
-		dev_info(dev, "usbcd irq fail, ret %d, irqnum %d!!!\n",
-			ret, ipsleep_irqnum);
-	} else
-		enable_irq_wake(ipsleep_irqnum);
-
-	return ret;
-}
-
-static int mt_usb_ipsleep_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-	struct device *dev = &pdev->dev;
-	struct device_node *node = dev->of_node;
-
-	ipsleep_irqnum = irq_of_parse_and_map(node, 0);
-	if (ipsleep_irqnum < 0) {
-		dev_info(dev, "get eint fail\n");
-		return -ENODEV;
-	}
-
-	ret = ipsleep_eint_irq_en(dev);
-	if (ret != 0)
-		goto irqfail;
-
-	ipsleep_init = 1;
-
-irqfail:
-	return ret;
-}
-
-static int mt_usb_ipsleep_remove(struct platform_device *pdev)
-{
-	free_irq(ipsleep_irqnum, NULL);
-	return 0;
-}
-
-static const struct of_device_id usb_ipsleep_of_match[] = {
-	{.compatible = "mediatek,usb_ipsleep"},
-	{},
-};
-
-static struct platform_driver usb_ipsleep_driver = {
-	.remove = mt_usb_ipsleep_remove,
-	.probe = mt_usb_ipsleep_probe,
-	.driver = {
-		.name = "usb_ipsleep",
-		.owner = THIS_MODULE,
-		.of_match_table = usb_ipsleep_of_match,
-	},
-};
-
-void usb_wakeup_enable(struct ssusb_mtk *ssusb)
-{
-	if (ipsleep_init)
-		enable_irq(ipsleep_irqnum);
-}
-
-void usb_wakeup_disable(struct ssusb_mtk *ssusb)
-{
-	if (ipsleep_init)
-		disable_irq(ipsleep_irqnum);
-}
-
-module_platform_driver(usb_ipsleep_driver);
-
diff --git a/drivers/usb/mtu3/mt6853/Makefile b/drivers/usb/mtu3/mt6853/Makefile
deleted file mode 100644
index 8839ae7..0000000
--- a/drivers/usb/mtu3/mt6853/Makefile
+++ /dev/null
@@ -1,16 +0,0 @@
-#
-# Copyright (C) 2017 MediaTek Inc.
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License version 2 as
-# published by the Free Software Foundation.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-# GNU General Public License for more details.
-#
-subdir-ccflags-y += -Werror -I$(srctree)/drivers/usb/mtu3
-subdir-ccflags-y += -I$(srctree)/drivers/misc/mediatek/base/power/include/
-
-obj-y += mtu3_hal.o mtu3_phy_hal.o mtu3_sleep.o mtu3_phy_debugfs.o
diff --git a/drivers/usb/mtu3/mt6853/mtu3_hal.c b/drivers/usb/mtu3/mt6853/mtu3_hal.c
deleted file mode 100644
index 8bf3900..0000000
--- a/drivers/usb/mtu3/mt6853/mtu3_hal.c
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
- */
-
-#include <linux/clk.h>
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/arm-smccc.h>
-#include <linux/soc/mediatek/mtk_sip_svc.h>
-
-#include <mtu3.h>
-#include <mtu3_hal.h>
-#include <mtk_idle.h>
-#include "mtu3_priv.h"
-
-struct ssusb_mtk *g_ssusb;
-
-struct ssusb_mtk *get_ssusb(void)
-{
-	return g_ssusb;
-}
-
-int get_ssusb_ext_rscs(struct ssusb_mtk *ssusb)
-{
-	struct device *dev = ssusb->dev;
-	struct ssusb_priv *priv;
-
-	/* all elements are set to ZERO as default value */
-	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	priv->vusb10 = devm_regulator_get(dev, "va09");
-	if (IS_ERR(priv->vusb10)) {
-		dev_info(dev, "failed to get vusb10\n");
-		return PTR_ERR(priv->vusb10);
-	}
-
-	/* private mode setting */
-	ssusb->force_vbus = true;
-	ssusb->u1u2_disable = true;
-	ssusb->u3_loopb_support = true;
-
-	ssusb->priv_data = priv;
-	g_ssusb = ssusb;
-	return 0;
-}
-
-static int ssusb_host_clk_on(struct ssusb_mtk *ssusb)
-{
-	return 0;
-}
-
-static int ssusb_host_clk_off(struct ssusb_mtk *ssusb)
-{
-	return 0;
-}
-
-static int ssusb_sysclk_on(struct ssusb_mtk *ssusb)
-{
-	int ret = 0;
-
-	ret = clk_prepare_enable(ssusb->sys_clk);
-	if (ret)
-		dev_info(ssusb->dev, "failed to enable sys_clk\n");
-
-	ret = clk_prepare_enable(ssusb->host_clk);
-	if (ret)
-		dev_info(ssusb->dev, "failed to enable host_clk\n");
-
-	ret = clk_prepare_enable(ssusb->ref_clk);
-	if (ret)
-		dev_info(ssusb->dev, "failed to enable ref_clk\n");
-
-	ssusb_switch_usbpll_div13(ssusb, true);
-
-	ret = clk_prepare_enable(ssusb->mcu_clk);
-	if (ret)
-		dev_info(ssusb->dev, "failed to enable mcu_clk\n");
-
-	ret = clk_prepare_enable(ssusb->dma_clk);
-	if (ret)
-		dev_info(ssusb->dev, "failed to enable dma_clk\n");
-
-	return ret;
-}
-
-static void ssusb_sysclk_off(struct ssusb_mtk *ssusb)
-{
-	clk_disable_unprepare(ssusb->dma_clk);
-	clk_disable_unprepare(ssusb->mcu_clk);
-	clk_disable_unprepare(ssusb->ref_clk);
-
-	ssusb_switch_usbpll_div13(ssusb, false);
-
-	clk_disable_unprepare(ssusb->host_clk);
-	clk_disable_unprepare(ssusb->sys_clk);
-}
-
-int ssusb_clk_on(struct ssusb_mtk *ssusb, int host_mode)
-{
-	if (host_mode) {
-		ssusb_sysclk_on(ssusb);
-		ssusb_host_clk_on(ssusb);
-	} else {
-		ssusb_sysclk_on(ssusb);
-	}
-	return 0;
-}
-
-int ssusb_clk_off(struct ssusb_mtk *ssusb, int host_mode)
-{
-	if (host_mode) {
-		ssusb_host_clk_off(ssusb);
-		ssusb_sysclk_off(ssusb);
-	} else {
-		ssusb_sysclk_off(ssusb);
-	}
-	return 0;
-}
-
-int ssusb_ext_pwr_on(struct ssusb_mtk *ssusb, int mode)
-{
-	int ret = 0;
-	struct ssusb_priv *priv;
-
-	priv = ssusb->priv_data;
-	ret = regulator_enable(priv->vusb10);
-	if (ret)
-		dev_info(ssusb->dev, "failed to enable vusb10\n");
-	return ret;
-}
-
-int ssusb_ext_pwr_off(struct ssusb_mtk *ssusb, int mode)
-{
-	int ret = 0;
-	struct ssusb_priv *priv;
-
-	priv = ssusb->priv_data;
-	ret = regulator_disable(priv->vusb10);
-	if (ret)
-		dev_info(ssusb->dev, "failed to disable vusb10\n");
-	return ret;
-}
-
-void ssusb_dpidle_request(int mode)
-{
-	struct arm_smccc_res res;
-	int op;
-
-	switch (mode) {
-	case USB_DPIDLE_SUSPEND:
-		op = MTK_USB_SMC_INFRA_REQUEST;
-		break;
-	case USB_DPIDLE_RESUME:
-		op = MTK_USB_SMC_INFRA_RELEASE;
-		break;
-	default:
-		return;
-	}
-
-	pr_info("%s operation = %d\n", __func__, op);
-	arm_smccc_smc(MTK_SIP_USB_CONTROL, op, 0, 0, 0, 0, 0, 0, &res);
-}
diff --git a/drivers/usb/mtu3/mt6853/mtu3_phy_debugfs.c b/drivers/usb/mtu3/mt6853/mtu3_phy_debugfs.c
deleted file mode 100644
index f8576ee..0000000
--- a/drivers/usb/mtu3/mt6853/mtu3_phy_debugfs.c
+++ /dev/null
@@ -1,986 +0,0 @@
-/*
- * Copyright (C) 2015 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
-#include <linux/uaccess.h>
-#include <linux/phy/phy.h>
-#include <linux/phy/mediatek/mtk_usb_phy.h>
-
-/* general */
-#define BIT_WIDTH_1		1
-#define MSK_WIDTH_1		0x1
-#define VAL_MAX_WDITH_1	0x1
-#define VAL_0_WIDTH_1		0x0
-#define VAL_1_WIDTH_1		0x1
-#define STRNG_0_WIDTH_1	"0"
-#define STRNG_1_WIDTH_1	"1"
-
-#define BIT_WIDTH_2		2
-#define MSK_WIDTH_2		0x3
-#define VAL_MAX_WDITH_2		0x3
-#define VAL_0_WIDTH_2		0x0
-#define VAL_1_WIDTH_2		0x1
-#define VAL_2_WIDTH_2		0x2
-#define VAL_3_WIDTH_2		0x3
-#define STRNG_0_WIDTH_2	"00"
-#define STRNG_1_WIDTH_2	"01"
-#define STRNG_2_WIDTH_2	"10"
-#define STRNG_3_WIDTH_2	"11"
-
-
-#define BIT_WIDTH_3		3
-#define MSK_WIDTH_3		0x7
-#define VAL_MAX_WDITH_3		0x7
-#define VAL_0_WIDTH_3		0x0
-#define VAL_1_WIDTH_3		0x1
-#define VAL_2_WIDTH_3		0x2
-#define VAL_3_WIDTH_3		0x3
-#define VAL_4_WIDTH_3		0x4
-#define VAL_5_WIDTH_3		0x5
-#define VAL_6_WIDTH_3		0x6
-#define VAL_7_WIDTH_3		0x7
-#define STRNG_0_WIDTH_3	"000"
-#define STRNG_1_WIDTH_3	"001"
-#define STRNG_2_WIDTH_3	"010"
-#define STRNG_3_WIDTH_3	"011"
-#define STRNG_4_WIDTH_3	"100"
-#define STRNG_5_WIDTH_3	"101"
-#define STRNG_6_WIDTH_3	"110"
-#define STRNG_7_WIDTH_3	"111"
-
-#define BIT_WIDTH_4		4
-#define MSK_WIDTH_4		0xf
-#define VAL_MAX_WDITH_4		0xf
-#define VAL_0_WIDTH_4		0x0
-#define VAL_1_WIDTH_4		0x1
-#define VAL_2_WIDTH_4		0x2
-#define VAL_3_WIDTH_4		0x3
-#define VAL_4_WIDTH_4		0x4
-#define VAL_5_WIDTH_4		0x5
-#define VAL_6_WIDTH_4		0x6
-#define VAL_7_WIDTH_4		0x7
-#define VAL_8_WIDTH_4		0x8
-#define VAL_9_WIDTH_4		0x9
-#define VAL_A_WIDTH_4		0xa
-#define VAL_B_WIDTH_4		0xb
-#define VAL_C_WIDTH_4		0xc
-#define VAL_D_WIDTH_4		0xd
-#define VAL_E_WIDTH_4		0xe
-#define VAL_F_WIDTH_4		0xf
-#define STRNG_0_WIDTH_4	"0000"
-#define STRNG_1_WIDTH_4	"0001"
-#define STRNG_2_WIDTH_4	"0010"
-#define STRNG_3_WIDTH_4	"0011"
-#define STRNG_4_WIDTH_4	"0100"
-#define STRNG_5_WIDTH_4	"0101"
-#define STRNG_6_WIDTH_4	"0110"
-#define STRNG_7_WIDTH_4	"0111"
-#define STRNG_8_WIDTH_4	"1000"
-#define STRNG_9_WIDTH_4	"1001"
-#define STRNG_A_WIDTH_4	"1010"
-#define STRNG_B_WIDTH_4	"1011"
-#define STRNG_C_WIDTH_4	"1100"
-#define STRNG_D_WIDTH_4	"1101"
-#define STRNG_E_WIDTH_4	"1110"
-#define STRNG_F_WIDTH_4	"1111"
-
-#define BIT_WIDTH_5		5
-#define MSK_WIDTH_5		0x1f
-#define VAL_MAX_WDITH_5		0x1f
-#define VAL_0_WIDTH_5		0x0
-#define VAL_1_WIDTH_5		0x1
-#define VAL_18_WIDTH_5		0x12
-#define VAL_20_WIDTH_5		0x14
-#define VAL_30_WIDTH_5		0x1e
-#define VAL_31_WIDTH_5		0x1f
-#define STRNG_0_WIDTH_5		"00000"
-#define STRNG_1_WIDTH_5		"00001"
-#define STRNG_18_WIDTH_5	"10010"
-#define STRNG_20_WIDTH_5	"10100"
-#define STRNG_30_WIDTH_5	"11110"
-#define STRNG_31_WIDTH_5	"11111"
-
-/* specific */
-#define FILE_USB_DRIVING_CAPABILITY "USB_DRIVING_CAPABILITY"
-
-#define FILE_RG_USB20_TERM_VREF_SEL "RG_USB20_TERM_VREF_SEL"
-#define MSK_RG_USB20_TERM_VREF_SEL MSK_WIDTH_3
-#define SHFT_RG_USB20_TERM_VREF_SEL 8
-#define OFFSET_RG_USB20_TERM_VREF_SEL 0x4
-
-#define FILE_RG_USB20_HSTX_SRCTRL "RG_USB20_HSTX_SRCTRL"
-#define MSK_RG_USB20_HSTX_SRCTRL MSK_WIDTH_3
-#define SHFT_RG_USB20_HSTX_SRCTRL 12
-#define OFFSET_RG_USB20_HSTX_SRCTRL 0x14
-
-#define FILE_RG_USB20_VRT_VREF_SEL "RG_USB20_VRT_VREF_SEL"
-#define MSK_RG_USB20_VRT_VREF_SEL MSK_WIDTH_3
-#define SHFT_RG_USB20_VRT_VREF_SEL 12
-#define OFFSET_RG_USB20_VRT_VREF_SEL 0x4
-
-#define FILE_RG_USB20_INTR_EN "RG_USB20_INTR_EN"
-#define MSK_RG_USB20_INTR_EN MSK_WIDTH_1
-#define SHFT_RG_USB20_INTR_EN 5
-#define OFFSET_RG_USB20_INTR_EN 0x0
-
-#define FILE_RG_USB20_PHY_REV6 "RG_USB20_PHY_REV6"
-#define MSK_RG_USB20_PHY_REV6 MSK_WIDTH_2
-#define SHFT_RG_USB20_PHY_REV6 30
-#define OFFSET_RG_USB20_PHY_REV6 0x18
-
-#define FILE_RG_USB20_INTR_CAL "RG_USB20_INTR_CAL"
-#define MSK_RG_USB20_INTR_CAL MSK_WIDTH_5
-#define SHFT_RG_USB20_INTR_CAL 19
-#define OFFSET_RG_USB20_INTR_CAL 0x4
-
-#define FILE_RG_USB20_DISCTH "RG_USB20_DISCTH"
-#define MSK_RG_USB20_DISCTH MSK_WIDTH_4
-#define SHFT_RG_USB20_DISCTH 4
-#define OFFSET_RG_USB20_DISCTH 0x18
-
-#define FILE_REG_DEBUG "phy_reg"
-
-static struct proc_dir_entry *usb20_phy_procfs_root;
-static u32 ippc_value, ippc_addr;
-
-void u3phywrite32(struct phy *phy, int offset, int mask, int value)
-{
-	u32 cur_value;
-	u32 new_value;
-
-	cur_value = usb_mtkphy_io_read(phy, offset);
-	new_value = (cur_value & (~mask)) | value;
-	usb_mtkphy_io_write(phy, new_value, offset);
-}
-
-static void usb20_phy_debugfs_write_width1(struct phy *phy, u8 offset, u8 shift,
-	char *buf)
-{
-	u32 set_val = 0;
-
-	pr_debug("s(%s)\n", buf);
-	if (!strncmp(buf, STRNG_0_WIDTH_1, BIT_WIDTH_1)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_1);
-		set_val = VAL_0_WIDTH_1;
-	} else if (!strncmp(buf, STRNG_1_WIDTH_1, BIT_WIDTH_1)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_1);
-		set_val = VAL_1_WIDTH_1;
-	} else
-		return;
-
-	u3phywrite32(phy, offset, MSK_WIDTH_1 << shift, set_val << shift);
-
-}
-
-static void usb20_phy_debugfs_rev6_write(struct phy *phy, u8 offset, u8 shift,
-	char *buf)
-{
-	u32 set_val = 0xFF;
-
-	pr_debug("s(%s)\n", buf);
-	if (!strncmp(buf, STRNG_0_WIDTH_2, BIT_WIDTH_2)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_2);
-		set_val = VAL_0_WIDTH_2;
-	} else if (!strncmp(buf, STRNG_1_WIDTH_2, BIT_WIDTH_2)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_2);
-		set_val = VAL_1_WIDTH_2;
-	} else if (!strncmp(buf, STRNG_2_WIDTH_2, BIT_WIDTH_2)) {
-		pr_debug("%s case\n", STRNG_2_WIDTH_2);
-		set_val = VAL_2_WIDTH_2;
-	} else if (!strncmp(buf, STRNG_3_WIDTH_2, BIT_WIDTH_2)) {
-		pr_debug("%s case\n", STRNG_3_WIDTH_2);
-		set_val = VAL_3_WIDTH_2;
-	} else
-		return;
-
-	u3phywrite32(phy, offset, MSK_WIDTH_2 << shift, set_val << shift);
-
-}
-
-
-static void usb20_phy_debugfs_write_width3(struct phy *phy, u8 offset, u8 shift,
-	char *buf)
-{
-	u32 set_val = 0;
-
-	pr_debug("s(%s)\n", buf);
-	if (!strncmp(buf, STRNG_0_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_3);
-		set_val = VAL_0_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_1_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_3);
-		set_val = VAL_1_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_2_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_2_WIDTH_3);
-		set_val = VAL_2_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_3_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_3_WIDTH_3);
-		set_val = VAL_3_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_4_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_4_WIDTH_3);
-		set_val = VAL_4_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_5_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_5_WIDTH_3);
-		set_val = VAL_5_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_6_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_6_WIDTH_3);
-		set_val = VAL_6_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_7_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_7_WIDTH_3);
-		set_val = VAL_7_WIDTH_3;
-	} else
-		return;
-
-	u3phywrite32(phy, offset, MSK_WIDTH_3 << shift, set_val << shift);
-
-}
-
-static void usb20_phy_debugfs_write_width4(struct phy *phy, u8 offset, u8 shift,
-	char *buf)
-{
-	u32 set_val = 0;
-
-	pr_debug("s(%s)\n", buf);
-	if (!strncmp(buf, STRNG_0_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_4);
-		set_val = VAL_0_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_1_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_4);
-		set_val = VAL_1_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_2_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_2_WIDTH_4);
-		set_val = VAL_2_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_3_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_3_WIDTH_4);
-		set_val = VAL_3_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_4_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_4_WIDTH_4);
-		set_val = VAL_4_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_5_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_5_WIDTH_4);
-		set_val = VAL_5_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_6_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_6_WIDTH_4);
-		set_val = VAL_6_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_7_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_7_WIDTH_4);
-		set_val = VAL_7_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_8_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_8_WIDTH_4);
-		set_val = VAL_8_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_9_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_9_WIDTH_4);
-		set_val = VAL_9_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_A_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_A_WIDTH_4);
-		set_val = VAL_A_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_B_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_B_WIDTH_4);
-		set_val = VAL_B_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_C_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_C_WIDTH_4);
-		set_val = VAL_C_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_D_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_D_WIDTH_4);
-		set_val = VAL_D_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_E_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_E_WIDTH_4);
-		set_val = VAL_E_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_F_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_F_WIDTH_4);
-		set_val = VAL_F_WIDTH_4;
-	} else
-		return;
-
-	u3phywrite32(phy, offset, MSK_WIDTH_4 << shift, set_val << shift);
-
-}
-
-static void usb20_phy_debugfs_write_width5(struct phy *phy, u8 offset, u8 shift,
-	char *buf)
-{
-	u32 set_val = 0;
-
-	pr_debug("s(%s)\n", buf);
-	if (!strncmp(buf, STRNG_0_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_5);
-		set_val = VAL_0_WIDTH_5;
-	} else if (!strncmp(buf, STRNG_1_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_5);
-		set_val = VAL_1_WIDTH_5;
-	} else if (!strncmp(buf, STRNG_18_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_18_WIDTH_5);
-		set_val = VAL_18_WIDTH_5;
-	} else if (!strncmp(buf, STRNG_20_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_20_WIDTH_5);
-		set_val = VAL_20_WIDTH_5;
-	} else if (!strncmp(buf, STRNG_30_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_30_WIDTH_5);
-		set_val = VAL_30_WIDTH_5;
-	} else if (!strncmp(buf, STRNG_31_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_31_WIDTH_5);
-		set_val = VAL_31_WIDTH_5;
-	} else
-		return;
-
-	u3phywrite32(phy, offset, MSK_WIDTH_5 << shift, set_val << shift);
-
-}
-
-
-static u8 usb20_phy_debugfs_read_val(u32 val, u8 width, char *str)
-{
-	int i, temp;
-
-	temp = val;
-	str[width] = '\0';
-	for (i = (width - 1); i >= 0; i--) {
-		if (val % 2)
-			str[i] = '1';
-		else
-			str[i] = '0';
-		pr_debug("str[%d]:%c\n", i, str[i]);
-		val /= 2;
-	}
-	pr_debug("str(%s)\n", str);
-	return val;
-}
-
-static int usb_driving_capability_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-	u8 combined_val, tmp_val = 0xff;
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_TERM_VREF_SEL));
-	val = val >> SHFT_RG_USB20_TERM_VREF_SEL;
-	val = val & MSK_RG_USB20_TERM_VREF_SEL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_3, str);
-
-	if (!strncmp(str, STRNG_0_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_3);
-		tmp_val = VAL_0_WIDTH_3;
-	} else if (!strncmp(str, STRNG_1_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_3);
-		tmp_val = VAL_1_WIDTH_3;
-	} else if (!strncmp(str, STRNG_2_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_2_WIDTH_3);
-		tmp_val = VAL_2_WIDTH_3;
-	} else if (!strncmp(str, STRNG_3_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_3_WIDTH_3);
-		tmp_val = VAL_3_WIDTH_3;
-	} else if (!strncmp(str, STRNG_4_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_4_WIDTH_3);
-		tmp_val = VAL_4_WIDTH_3;
-	} else if (!strncmp(str, STRNG_5_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_5_WIDTH_3);
-		tmp_val = VAL_5_WIDTH_3;
-	} else if (!strncmp(str, STRNG_6_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_6_WIDTH_3);
-		tmp_val = VAL_6_WIDTH_3;
-	} else if (!strncmp(str, STRNG_7_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_7_WIDTH_3);
-		tmp_val = VAL_7_WIDTH_3;
-	}
-
-	combined_val = tmp_val;
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_VRT_VREF_SEL));
-	val = val >> SHFT_RG_USB20_VRT_VREF_SEL;
-	val = val & MSK_RG_USB20_VRT_VREF_SEL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_3, str);
-
-	if (!strncmp(str, STRNG_0_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_3);
-		tmp_val = VAL_0_WIDTH_3;
-	} else if (!strncmp(str, STRNG_1_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_3);
-		tmp_val = VAL_1_WIDTH_3;
-	} else if (!strncmp(str, STRNG_2_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_2_WIDTH_3);
-		tmp_val = VAL_2_WIDTH_3;
-	} else if (!strncmp(str, STRNG_3_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_3_WIDTH_3);
-		tmp_val = VAL_3_WIDTH_3;
-	} else if (!strncmp(str, STRNG_4_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_4_WIDTH_3);
-		tmp_val = VAL_4_WIDTH_3;
-	} else if (!strncmp(str, STRNG_5_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_5_WIDTH_3);
-		tmp_val = VAL_5_WIDTH_3;
-	} else if (!strncmp(str, STRNG_6_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_6_WIDTH_3);
-		tmp_val = VAL_6_WIDTH_3;
-	} else if (!strncmp(str, STRNG_7_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_7_WIDTH_3);
-		tmp_val = VAL_7_WIDTH_3;
-	}
-
-	pr_debug("combined_val(%d), tmp_val(%d)\n", combined_val, tmp_val);
-	if ((tmp_val == (combined_val - 1)) || (tmp_val == combined_val))
-		combined_val += tmp_val;
-	else
-		combined_val = tmp_val * (VAL_MAX_WDITH_3 + 1) + combined_val;
-
-	pr_debug("combined_val(%d), tmp_val(%d)\n", combined_val, tmp_val);
-
-	seq_printf(s, "%s = %d\n", FILE_USB_DRIVING_CAPABILITY, combined_val);
-	return 0;
-}
-
-static int rg_usb20_term_vref_sel_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_TERM_VREF_SEL));
-	val = val >> SHFT_RG_USB20_TERM_VREF_SEL;
-	val = val & MSK_RG_USB20_TERM_VREF_SEL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_3, str);
-
-	seq_printf(s, "%s= %s\n", FILE_RG_USB20_TERM_VREF_SEL, str);
-	return 0;
-}
-
-static int rg_usb20_hstx_srctrl_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_HSTX_SRCTRL));
-	val = val >> SHFT_RG_USB20_HSTX_SRCTRL;
-	val = val & MSK_RG_USB20_HSTX_SRCTRL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_3, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_HSTX_SRCTRL, str);
-	return 0;
-}
-
-static int rg_usb20_vrt_vref_sel_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_VRT_VREF_SEL));
-	val = val >> SHFT_RG_USB20_VRT_VREF_SEL;
-	val = val & MSK_RG_USB20_VRT_VREF_SEL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_3, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_VRT_VREF_SEL, str);
-	return 0;
-}
-
-static int rg_usb20_intr_en_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_INTR_EN));
-	val = val >> SHFT_RG_USB20_INTR_EN;
-	val = val & MSK_RG_USB20_INTR_EN;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_1, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_INTR_EN, str);
-	return 0;
-}
-
-static int rg_usb20_rev6_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_PHY_REV6));
-	val = val >> SHFT_RG_USB20_PHY_REV6;
-	val = val & MSK_RG_USB20_PHY_REV6;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_2, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_PHY_REV6, str);
-	return 0;
-}
-
-static int rg_usb20_intr_cal_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_INTR_CAL));
-	val = val >> SHFT_RG_USB20_INTR_CAL;
-	val = val & MSK_RG_USB20_INTR_CAL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_5, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_INTR_CAL, str);
-	return 0;
-}
-
-static int rg_usb20_discth_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_DISCTH));
-	val = val >> SHFT_RG_USB20_DISCTH;
-	val = val & MSK_RG_USB20_DISCTH;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_4, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_DISCTH, str);
-	return 0;
-}
-
-static int phy_rw_show(struct seq_file *s, void *unused)
-{
-	seq_printf(s, "phy[0x%x] = 0x%x\n", ippc_addr, ippc_value);
-
-	return 0;
-}
-
-static int usb_driving_capability_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, usb_driving_capability_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_term_vref_sel_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_term_vref_sel_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_hstx_srctrl_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_hstx_srctrl_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_vrt_vref_sel_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_vrt_vref_sel_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_intr_en_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_intr_en_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_rev6_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_rev6_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_intr_cal_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_intr_cal_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_discth_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_discth_show, PDE_DATA(inode));
-}
-
-static int phy_rw_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, phy_rw_show, PDE_DATA(inode));
-}
-
-void val_to_bstring_width3(u8 val, char *str)
-{
-	switch (val) {
-	case VAL_0_WIDTH_3:
-		memcpy(str, STRNG_0_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_1_WIDTH_3:
-		memcpy(str, STRNG_1_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_2_WIDTH_3:
-		memcpy(str, STRNG_2_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_3_WIDTH_3:
-		memcpy(str, STRNG_3_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_4_WIDTH_3:
-		memcpy(str, STRNG_4_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_5_WIDTH_3:
-		memcpy(str, STRNG_5_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_6_WIDTH_3:
-		memcpy(str, STRNG_6_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_7_WIDTH_3:
-		memcpy(str, STRNG_7_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	}
-
-	pr_debug("val(%d), str(%s)\n", val, str);
-}
-
-static ssize_t usb_driving_capability_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-	u8 val, tmp_val;
-	char str_rg_usb20_term_vref_sel[18], str_rg_usb20_vrt_vref_sel[18];
-
-	memset(buf, 0x00, sizeof(buf));
-	pr_debug("\n");
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-
-	if (kstrtou8(buf, 10, &val) != 0) {
-		pr_debug("kstrtou8, err(%d)\n", kstrtou8(buf, 10, &val));
-		return count;
-	}
-	pr_debug("kstrtol, val(%d)\n", val);
-
-	if (val > VAL_7_WIDTH_3 * 2) {
-		pr_debug("wrong val set(%d), direct return\n", val);
-		return count;
-	}
-	tmp_val = val;
-	val /= 2;
-
-	pr_debug("val(%d), tmp_val(%d)\n", val, tmp_val);
-	val_to_bstring_width3(tmp_val - val, str_rg_usb20_term_vref_sel);
-	val_to_bstring_width3(val, str_rg_usb20_vrt_vref_sel);
-	pr_debug("Config TERM_VREF_SEL %s\n", str_rg_usb20_term_vref_sel);
-	usb20_phy_debugfs_write_width3(phy, OFFSET_RG_USB20_TERM_VREF_SEL,
-		SHFT_RG_USB20_TERM_VREF_SEL, str_rg_usb20_term_vref_sel);
-	pr_debug("Config VRT_VREF_SEL %s\n", str_rg_usb20_vrt_vref_sel);
-	usb20_phy_debugfs_write_width3(phy, OFFSET_RG_USB20_VRT_VREF_SEL,
-		SHFT_RG_USB20_VRT_VREF_SEL, str_rg_usb20_vrt_vref_sel);
-	return count;
-}
-
-static ssize_t rg_usb20_term_vref_sel_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width3(phy, OFFSET_RG_USB20_TERM_VREF_SEL,
-		SHFT_RG_USB20_TERM_VREF_SEL, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_hstx_srctrl_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width3(phy, OFFSET_RG_USB20_HSTX_SRCTRL,
-		SHFT_RG_USB20_HSTX_SRCTRL, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_vrt_vref_sel_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width3(phy, OFFSET_RG_USB20_VRT_VREF_SEL,
-		SHFT_RG_USB20_VRT_VREF_SEL, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_intr_en_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width1(phy, OFFSET_RG_USB20_INTR_EN,
-		SHFT_RG_USB20_INTR_EN, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_rev6_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_rev6_write(phy, OFFSET_RG_USB20_PHY_REV6,
-		SHFT_RG_USB20_PHY_REV6, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_intr_cal_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width5(phy, OFFSET_RG_USB20_INTR_CAL,
-		SHFT_RG_USB20_INTR_CAL, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_discth_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width4(phy, OFFSET_RG_USB20_DISCTH,
-		SHFT_RG_USB20_DISCTH, buf);
-	return count;
-}
-
-static ssize_t phy_rw_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[40];
-
-	memset(buf, 0x00, sizeof(buf));
-
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-
-	if (!strncmp(buf, "w", 1)) {
-		u32 offset;
-		u32 value;
-		u32 shift;
-		u32 mask;
-
-		if (sscanf(buf, "w32 0x%x:%d:0x%x:0x%x",
-			&offset, &shift, &mask, &value) == 4) {
-			if ((offset % 4) != 0) {
-				pr_notice("Must use 32bits alignment address\n");
-				return count;
-			}
-			u3phywrite32(phy, offset,
-				mask << shift, value << shift);
-		} else
-			return -EFAULT;
-	}
-
-	if (!strncmp(buf, "r", 1)) {
-		u32 offset;
-
-		if (sscanf(buf, "r32 0x%x", &offset) == 1) {
-			if ((offset % 4) != 0) {
-				pr_notice("Must use 32bits alignment address\n");
-				return count;
-			}
-			ippc_addr = offset;
-			ippc_value = usb_mtkphy_io_read(phy, ippc_addr);
-		}
-	}
-
-	return count;
-}
-
-
-
-static const struct file_operations usb_driving_capability_fops = {
-	.open = usb_driving_capability_open,
-	.write = usb_driving_capability_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_term_vref_sel_fops = {
-	.open = rg_usb20_term_vref_sel_open,
-	.write = rg_usb20_term_vref_sel_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_hstx_srctrl_fops = {
-	.open = rg_usb20_hstx_srctrl_open,
-	.write = rg_usb20_hstx_srctrl_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_vrt_vref_sel_fops = {
-	.open = rg_usb20_vrt_vref_sel_open,
-	.write = rg_usb20_vrt_vref_sel_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_intr_en_fops = {
-	.open = rg_usb20_intr_en_open,
-	.write = rg_usb20_intr_en_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_rev6_fops = {
-	.open = rg_usb20_rev6_open,
-	.write = rg_usb20_rev6_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_intr_cal_fops = {
-	.open = rg_usb20_intr_cal_open,
-	.write = rg_usb20_intr_cal_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_discth_fops = {
-	.open = rg_usb20_discth_open,
-	.write = rg_usb20_discth_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations phy_rw_fops = {
-	.open = phy_rw_open,
-	.write = phy_rw_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-int mtu3_phy_init_debugfs(struct phy *phy)
-{
-	struct proc_dir_entry *root;
-	struct proc_dir_entry *file;
-	int ret;
-
-	proc_mkdir("mtk_usb", NULL);
-
-	root = proc_mkdir("mtk_usb/usb20_phy", NULL);
-	if (!root) {
-		ret = -ENOMEM;
-		goto err0;
-	}
-
-	file = proc_create_data(FILE_USB_DRIVING_CAPABILITY, 0644,
-				   root, &usb_driving_capability_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_TERM_VREF_SEL, 0644,
-				   root, &rg_usb20_term_vref_sel_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_HSTX_SRCTRL, 0644,
-				   root, &rg_usb20_hstx_srctrl_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_VRT_VREF_SEL, 0644,
-				   root, &rg_usb20_vrt_vref_sel_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_INTR_EN, 0644,
-				   root, &rg_usb20_intr_en_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_PHY_REV6, 0644,
-				   root, &rg_usb20_rev6_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_INTR_CAL, 0644,
-				   root, &rg_usb20_intr_cal_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_DISCTH, 0644,
-				   root, &rg_usb20_discth_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_REG_DEBUG, 0644,
-				   root, &phy_rw_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-
-	usb20_phy_procfs_root = root;
-	return 0;
-
-err1:
-	proc_remove(root);
-
-err0:
-	return ret;
-}
-
-int mtu3_phy_exit_debugfs(void)
-{
-	proc_remove(usb20_phy_procfs_root);
-	return 0;
-}
diff --git a/drivers/usb/mtu3/mt6853/mtu3_phy_hal.c b/drivers/usb/mtu3/mt6853/mtu3_phy_hal.c
deleted file mode 100644
index e7270f8..0000000
--- a/drivers/usb/mtu3/mt6853/mtu3_phy_hal.c
+++ /dev/null
@@ -1,257 +0,0 @@
-/*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
- */
-
-#include <linux/clk.h>
-#include <linux/iopoll.h>
-#include <linux/mfd/syscon.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/phy/phy.h>
-#include <linux/phy/mediatek/mtk_usb_phy.h>
-#include <linux/pm_qos.h>
-#include <linux/regmap.h>
-
-#include "mtu3.h"
-#include "mtu3_hal.h"
-#include "mtu3_priv.h"
-
-#define USBPHYACR0		(0x0000)
-#define USBPHYACR0_MASK		(0xffffffff)
-#define U2PHYDTM1		(0x006C)
-#define FORCE_LINESTATE_C(x)	(((x) & 0x1) << 14)
-#define RG_LINESTATE_C(x)	(((x) & 0x3) << 6)
-
-#define RG_USBPLL_192M_OPP_EN	(0x304)
-#define RG_USBPLL_DIV13_C(x)	(((x) & 0x1) << 21)
-
-#define USBPLL_FS	(2704000000)
-#define USBPLL_HS	(2496000000)
-#define U2PLL_FS	(0x00466fae)
-#define U2PLL_HS	(0x00463c6e)
-
-#define DIV13_TRY_TIMES 3
-#define VCORE_OPP 0
-
-static struct phy *mtk_phy;
-struct pm_qos_request vcore_pm_qos;
-
-#if !defined(CONFIG_USB_MU3D_DRV)
-void Charger_Detect_Init(void)
-{
-	if (mtu3_cable_mode == CABLE_MODE_FORCEON) {
-		pr_info("%s-, SKIP\n", __func__);
-		return;
-	}
-
-	if (mtk_phy)
-		usb_mtkphy_switch_to_bc11(mtk_phy, true);
-}
-
-void Charger_Detect_Release(void)
-{
-	if (mtu3_cable_mode == CABLE_MODE_FORCEON) {
-		pr_info("%s-, SKIP\n", __func__);
-		return;
-	}
-
-	if (mtk_phy)
-		usb_mtkphy_switch_to_bc11(mtk_phy, false);
-}
-#endif
-
-void usb_dpdm_pulldown(bool enable)
-{
-#ifdef CONFIG_MTK_TYPEC_WATER_DETECT
-	if (mtk_phy) {
-		pr_info("%s: pulldown=%d\n", __func__, enable);
-		usb_mtkphy_dpdm_pulldown(mtk_phy, enable);
-	}
-#endif
-}
-
-void ssusb_switch_usbpll_div13(struct ssusb_mtk *ssusb, bool on)
-{
-	struct regmap *ap_regmap;
-	struct device_node *node = ssusb->dev->of_node;
-	int div13_try = DIV13_TRY_TIMES;
-
-	ap_regmap = syscon_regmap_lookup_by_phandle(node, "apmixed");
-	if (IS_ERR(ap_regmap)) {
-		pr_info("failed to get ap_regmap\n");
-		return;
-	}
-
-	udelay(20);
-
-	if (on) {
-		regmap_update_bits(ap_regmap, RG_USBPLL_192M_OPP_EN,
-				RG_USBPLL_DIV13_C(0x1), RG_USBPLL_DIV13_C(0x1));
-	} else {
-		while (div13_try--) {
-			regmap_update_bits(ap_regmap, RG_USBPLL_192M_OPP_EN,
-				RG_USBPLL_DIV13_C(0x1), RG_USBPLL_DIV13_C(0x0));
-			regmap_update_bits(ap_regmap, RG_USBPLL_192M_OPP_EN,
-				RG_USBPLL_DIV13_C(0x1), RG_USBPLL_DIV13_C(0x1));
-		}
-		regmap_update_bits(ap_regmap, RG_USBPLL_192M_OPP_EN,
-				RG_USBPLL_DIV13_C(0x1), RG_USBPLL_DIV13_C(0x0));
-	}
-
-	udelay(20);
-}
-
-static void ssusb_switch_phy_to_fs(struct ssusb_mtk *ssusb, bool is_fs)
-{
-	struct phy *phy = ssusb->phys[0];
-
-	clk_disable(ssusb->ref_clk);
-
-	ssusb_switch_usbpll_div13(ssusb, false);
-
-	if (is_fs) {
-		clk_set_rate(ssusb->ref_clk, USBPLL_FS);
-		u3phywrite32(phy, USBPHYACR0, USBPHYACR0_MASK, U2PLL_FS);
-	} else {
-		clk_set_rate(ssusb->ref_clk, USBPLL_HS);
-		u3phywrite32(phy, USBPHYACR0, USBPHYACR0_MASK, U2PLL_HS);
-	}
-
-	clk_enable(ssusb->ref_clk);
-
-	ssusb_switch_usbpll_div13(ssusb, true);
-}
-
-int ssusb_dual_phy_power_on(struct ssusb_mtk *ssusb, bool host_mode)
-{
-	int ret;
-
-	if (host_mode) {
-		if (pm_qos_request_active(&vcore_pm_qos)) {
-			pm_qos_update_request(&vcore_pm_qos, VCORE_OPP);
-			pr_info("%s: Vcore QOS update %d\n", __func__,
-								VCORE_OPP);
-		} else {
-			pm_qos_add_request(&vcore_pm_qos, PM_QOS_VCORE_OPP,
-								VCORE_OPP);
-			pr_info("%s: Vcore QOS request\n", __func__);
-		}
-	}
-
-	ret = phy_power_on(ssusb->phys[0]);
-
-	if (host_mode) {
-		if (!ret)
-			usb_mtkphy_host_mode(ssusb->phys[0], true);
-	}
-	return ret;
-}
-
-void ssusb_dual_phy_power_off(struct ssusb_mtk *ssusb, bool host_mode)
-{
-	if (host_mode) {
-		if (pm_qos_request_active(&vcore_pm_qos)) {
-			pm_qos_remove_request(&vcore_pm_qos);
-			pr_info("%s: Vcore QOS remove\n",  __func__);
-		} else
-			pr_info("%s: Vcore QOS remove again\n", __func__);
-		usb_mtkphy_host_mode(ssusb->phys[0], false);
-	}
-
-	phy_power_off(ssusb->phys[0]);
-}
-
-bool ssusb_u3loop_back_test(struct ssusb_mtk *ssusb)
-{
-	int ret;
-	void __iomem *ibase = ssusb->ippc_base;
-
-	ret = clk_prepare_enable(ssusb->sys_clk);
-	if (ret) {
-		dev_info(ssusb->dev, "failed to enable sys_clk\n");
-		return ret;
-	}
-	mtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL0, SSUSB_IP_SW_RST);
-	mtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL1, SSUSB_IP_HOST_PDN);
-	mtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL2, SSUSB_IP_DEV_PDN);
-	mtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL3, SSUSB_IP_PCIE_PDN);
-	mtu3_clrbits(ibase, SSUSB_U3_CTRL(0),
-		(SSUSB_U3_PORT_DIS | SSUSB_U3_PORT_PDN));
-	mdelay(10);
-
-	if (usb_mtkphy_u3_loop_back_test(ssusb->phys[0]) > 0)
-		ret = true;
-	else
-		ret = false;
-
-	mtu3_setbits(ibase, U3D_SSUSB_IP_PW_CTRL3, SSUSB_IP_PCIE_PDN);
-
-	clk_disable_unprepare(ssusb->sys_clk);
-
-	return ret;
-}
-
-void ssusb_set_phy_mode(int speed)
-{
-	struct ssusb_mtk *ssusb;
-	void __iomem *ibase;
-	struct phy *phy;
-	u32 value;
-
-	ssusb = get_ssusb();
-	if (!ssusb || !ssusb->phys[0]) {
-		pr_info("ssusb not ready\n");
-		return;
-	}
-
-	pr_info("%s speed=%d\n", __func__, speed);
-
-	ibase = ssusb->ippc_base;
-	phy = ssusb->phys[0];
-
-	if (speed == DEV_SPEED_INACTIVE) {
-		ssusb_switch_phy_to_fs(ssusb, false);
-		return;
-	}
-
-	u3phywrite32(phy, U2PHYDTM1, RG_LINESTATE_C(0x3),
-			RG_LINESTATE_C(0x1));
-	u3phywrite32(phy, U2PHYDTM1, FORCE_LINESTATE_C(0x1),
-				 FORCE_LINESTATE_C(0x1));
-
-	mtu3_setbits(ibase, U3D_SSUSB_IP_PW_CTRL1, SSUSB_IP_HOST_PDN);
-
-	if (readl_poll_timeout_atomic(ibase + U3D_SSUSB_IP_PW_STS1,
-			value, (value & SSUSB_IP_SLEEP_STS), 100, 100000))
-		pr_info("ip sleep failed\n");
-
-	ssusb_switch_phy_to_fs(ssusb, (speed == DEV_SPEED_FULL));
-
-	u3phywrite32(phy, U2PHYDTM1, FORCE_LINESTATE_C(0x1),
-			FORCE_LINESTATE_C(0x0));
-
-	mtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL1, SSUSB_IP_HOST_PDN);
-	udelay(200);
-}
-
-void phy_hal_init(struct phy *phy)
-{
-	mtk_phy = phy;
-	mtu3_phy_init_debugfs(mtk_phy);
-}
-
-void phy_hal_exit(struct phy *phy)
-{
-	mtu3_phy_exit_debugfs();
-	mtk_phy = NULL;
-}
-
diff --git a/drivers/usb/mtu3/mt6853/mtu3_priv.h b/drivers/usb/mtu3/mt6853/mtu3_priv.h
deleted file mode 100644
index cada7be..0000000
--- a/drivers/usb/mtu3/mt6853/mtu3_priv.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
- */
-
-
-#ifndef __MTU3_PRIV__
-#define __MTU3_PRIV__
-
-struct ssusb_priv {
-	struct regulator *vusb10;
-};
-
-enum MTK_USB_SMC_CALL {
-	MTK_USB_SMC_INFRA_REQUEST = 0,
-	MTK_USB_SMC_INFRA_RELEASE,
-	MTK_USB_SMC_NUM
-};
-
-extern void usb_audio_req(bool on);
-extern int mtu3_phy_init_debugfs(struct phy *phy);
-extern int mtu3_phy_exit_debugfs(void);
-extern void u3phywrite32(struct phy *phy, int offset, int mask, int value);
-extern struct ssusb_mtk *get_ssusb(void);
-extern void ssusb_switch_usbpll_div13(struct ssusb_mtk *ssusb, bool on);
-
-#endif
-
diff --git a/drivers/usb/mtu3/mt6853/mtu3_sleep.c b/drivers/usb/mtu3/mt6853/mtu3_sleep.c
deleted file mode 100644
index bc0dee4..0000000
--- a/drivers/usb/mtu3/mt6853/mtu3_sleep.c
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <linux/of_irq.h>
-
-#include "mtu3.h"
-#include "mtu3_priv.h"
-
-static int ipsleep_irqnum;
-static int ipsleep_init;
-
-static irqreturn_t ipsleep_eint_isr(int irqnum, void *data)
-{
-	disable_irq_nosync(irqnum);
-	pr_info("ipsleep_eint\n");
-	return IRQ_HANDLED;
-}
-
-static int ipsleep_eint_irq_en(struct device *dev)
-{
-	int ret = 0;
-
-	ret = devm_request_irq(dev, ipsleep_irqnum,
-		ipsleep_eint_isr, 0, "usbcd_eint", NULL);
-
-	if (ret != 0) {
-		dev_info(dev, "usbcd irq fail, ret %d, irqnum %d!!!\n",
-			ret, ipsleep_irqnum);
-	} else
-		enable_irq_wake(ipsleep_irqnum);
-
-	return ret;
-}
-
-static int mt_usb_ipsleep_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-	struct device *dev = &pdev->dev;
-	struct device_node *node = dev->of_node;
-
-	ipsleep_irqnum = irq_of_parse_and_map(node, 0);
-	if (ipsleep_irqnum < 0) {
-		dev_info(dev, "get eint fail\n");
-		return -ENODEV;
-	}
-
-	ret = ipsleep_eint_irq_en(dev);
-	if (ret != 0)
-		goto irqfail;
-
-	ipsleep_init = 1;
-
-irqfail:
-	return ret;
-}
-
-static int mt_usb_ipsleep_remove(struct platform_device *pdev)
-{
-	free_irq(ipsleep_irqnum, NULL);
-	return 0;
-}
-
-static const struct of_device_id usb_ipsleep_of_match[] = {
-	{.compatible = "mediatek,usb_ipsleep"},
-	{},
-};
-
-static struct platform_driver usb_ipsleep_driver = {
-	.remove = mt_usb_ipsleep_remove,
-	.probe = mt_usb_ipsleep_probe,
-	.driver = {
-		.name = "usb_ipsleep",
-		.owner = THIS_MODULE,
-		.of_match_table = usb_ipsleep_of_match,
-	},
-};
-
-void ssusb_wakeup_mode_enable(struct ssusb_mtk *ssusb)
-{
-	if (ipsleep_init)
-		enable_irq(ipsleep_irqnum);
-}
-
-void ssusb_wakeup_mode_disable(struct ssusb_mtk *ssusb)
-{
-	if (ipsleep_init)
-		disable_irq(ipsleep_irqnum);
-}
-
-module_platform_driver(usb_ipsleep_driver);
-
diff --git a/drivers/usb/mtu3/mt6885/Makefile b/drivers/usb/mtu3/mt6885/Makefile
deleted file mode 100644
index 8839ae7..0000000
--- a/drivers/usb/mtu3/mt6885/Makefile
+++ /dev/null
@@ -1,16 +0,0 @@
-#
-# Copyright (C) 2017 MediaTek Inc.
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License version 2 as
-# published by the Free Software Foundation.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-# GNU General Public License for more details.
-#
-subdir-ccflags-y += -Werror -I$(srctree)/drivers/usb/mtu3
-subdir-ccflags-y += -I$(srctree)/drivers/misc/mediatek/base/power/include/
-
-obj-y += mtu3_hal.o mtu3_phy_hal.o mtu3_sleep.o mtu3_phy_debugfs.o
diff --git a/drivers/usb/mtu3/mt6885/mtu3_hal.c b/drivers/usb/mtu3/mt6885/mtu3_hal.c
deleted file mode 100644
index 48fb981..0000000
--- a/drivers/usb/mtu3/mt6885/mtu3_hal.c
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
- */
-
-#include <linux/clk.h>
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/arm-smccc.h>
-#include <linux/soc/mediatek/mtk_sip_svc.h>
-
-#include <mtu3.h>
-#include <mtu3_hal.h>
-#include <mtk_idle.h>
-#include "mtu3_priv.h"
-
-int get_ssusb_ext_rscs(struct ssusb_mtk *ssusb)
-{
-	struct device *dev = ssusb->dev;
-	struct ssusb_priv *priv;
-
-	/* all elements are set to ZERO as default value */
-	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv)
-		return -ENOMEM;
-
-	priv->vusb10 = devm_regulator_get(dev, "va09");
-	if (IS_ERR(priv->vusb10)) {
-		dev_info(dev, "failed to get vusb10\n");
-		return PTR_ERR(priv->vusb10);
-	}
-
-	/* private mode setting */
-	ssusb->force_vbus = true;
-	ssusb->u1u2_disable = true;
-	ssusb->u3_loopb_support = true;
-
-	ssusb->priv_data = priv;
-	return 0;
-}
-
-static int ssusb_host_clk_on(struct ssusb_mtk *ssusb)
-{
-	return 0;
-}
-
-static int ssusb_host_clk_off(struct ssusb_mtk *ssusb)
-{
-	return 0;
-}
-
-static int ssusb_sysclk_on(struct ssusb_mtk *ssusb)
-{
-	int ret = 0;
-
-	ret = clk_prepare_enable(ssusb->sys_clk);
-	if (ret)
-		dev_info(ssusb->dev, "failed to enable sys_clk\n");
-
-	ret = clk_prepare_enable(ssusb->ref_clk);
-	if (ret)
-		dev_info(ssusb->dev, "failed to enable ref_clk\n");
-
-	return ret;
-}
-
-static void ssusb_sysclk_off(struct ssusb_mtk *ssusb)
-{
-	clk_disable_unprepare(ssusb->sys_clk);
-	clk_disable_unprepare(ssusb->ref_clk);
-}
-
-int ssusb_clk_on(struct ssusb_mtk *ssusb, int host_mode)
-{
-	if (host_mode) {
-		ssusb_sysclk_on(ssusb);
-		ssusb_host_clk_on(ssusb);
-	} else {
-		ssusb_sysclk_on(ssusb);
-	}
-	return 0;
-}
-
-int ssusb_clk_off(struct ssusb_mtk *ssusb, int host_mode)
-{
-	if (host_mode) {
-		ssusb_host_clk_off(ssusb);
-		ssusb_sysclk_off(ssusb);
-	} else {
-		ssusb_sysclk_off(ssusb);
-	}
-	return 0;
-}
-
-int ssusb_ext_pwr_on(struct ssusb_mtk *ssusb, int mode)
-{
-	int ret = 0;
-	struct ssusb_priv *priv;
-
-	priv = ssusb->priv_data;
-	ret = regulator_enable(priv->vusb10);
-	if (ret)
-		dev_info(ssusb->dev, "failed to enable vusb10\n");
-	return ret;
-}
-
-int ssusb_ext_pwr_off(struct ssusb_mtk *ssusb, int mode)
-{
-	int ret = 0;
-	struct ssusb_priv *priv;
-
-	priv = ssusb->priv_data;
-	ret = regulator_disable(priv->vusb10);
-	if (ret)
-		dev_info(ssusb->dev, "failed to disable vusb10\n");
-	return ret;
-}
-
-void ssusb_dpidle_request(int mode)
-{
-	struct arm_smccc_res res;
-	int op;
-
-	switch (mode) {
-	case USB_DPIDLE_SUSPEND:
-		op = MTK_USB_SMC_INFRA_REQUEST;
-		break;
-	case USB_DPIDLE_RESUME:
-		op = MTK_USB_SMC_INFRA_RELEASE;
-		break;
-	default:
-		return;
-	}
-
-	pr_info("%s operation = %d\n", __func__, op);
-	arm_smccc_smc(MTK_SIP_USB_CONTROL, op, 0, 0, 0, 0, 0, 0, &res);
-}
diff --git a/drivers/usb/mtu3/mt6885/mtu3_phy_debugfs.c b/drivers/usb/mtu3/mt6885/mtu3_phy_debugfs.c
deleted file mode 100644
index cb90fb1..0000000
--- a/drivers/usb/mtu3/mt6885/mtu3_phy_debugfs.c
+++ /dev/null
@@ -1,986 +0,0 @@
-/*
- * Copyright (C) 2015 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
-#include <linux/uaccess.h>
-#include <linux/phy/phy.h>
-#include <linux/phy/mediatek/mtk_usb_phy.h>
-
-/* general */
-#define BIT_WIDTH_1		1
-#define MSK_WIDTH_1		0x1
-#define VAL_MAX_WDITH_1	0x1
-#define VAL_0_WIDTH_1		0x0
-#define VAL_1_WIDTH_1		0x1
-#define STRNG_0_WIDTH_1	"0"
-#define STRNG_1_WIDTH_1	"1"
-
-#define BIT_WIDTH_2		2
-#define MSK_WIDTH_2		0x3
-#define VAL_MAX_WDITH_2		0x3
-#define VAL_0_WIDTH_2		0x0
-#define VAL_1_WIDTH_2		0x1
-#define VAL_2_WIDTH_2		0x2
-#define VAL_3_WIDTH_2		0x3
-#define STRNG_0_WIDTH_2	"00"
-#define STRNG_1_WIDTH_2	"01"
-#define STRNG_2_WIDTH_2	"10"
-#define STRNG_3_WIDTH_2	"11"
-
-
-#define BIT_WIDTH_3		3
-#define MSK_WIDTH_3		0x7
-#define VAL_MAX_WDITH_3		0x7
-#define VAL_0_WIDTH_3		0x0
-#define VAL_1_WIDTH_3		0x1
-#define VAL_2_WIDTH_3		0x2
-#define VAL_3_WIDTH_3		0x3
-#define VAL_4_WIDTH_3		0x4
-#define VAL_5_WIDTH_3		0x5
-#define VAL_6_WIDTH_3		0x6
-#define VAL_7_WIDTH_3		0x7
-#define STRNG_0_WIDTH_3	"000"
-#define STRNG_1_WIDTH_3	"001"
-#define STRNG_2_WIDTH_3	"010"
-#define STRNG_3_WIDTH_3	"011"
-#define STRNG_4_WIDTH_3	"100"
-#define STRNG_5_WIDTH_3	"101"
-#define STRNG_6_WIDTH_3	"110"
-#define STRNG_7_WIDTH_3	"111"
-
-#define BIT_WIDTH_4		4
-#define MSK_WIDTH_4		0xf
-#define VAL_MAX_WDITH_4		0xf
-#define VAL_0_WIDTH_4		0x0
-#define VAL_1_WIDTH_4		0x1
-#define VAL_2_WIDTH_4		0x2
-#define VAL_3_WIDTH_4		0x3
-#define VAL_4_WIDTH_4		0x4
-#define VAL_5_WIDTH_4		0x5
-#define VAL_6_WIDTH_4		0x6
-#define VAL_7_WIDTH_4		0x7
-#define VAL_8_WIDTH_4		0x8
-#define VAL_9_WIDTH_4		0x9
-#define VAL_A_WIDTH_4		0xa
-#define VAL_B_WIDTH_4		0xb
-#define VAL_C_WIDTH_4		0xc
-#define VAL_D_WIDTH_4		0xd
-#define VAL_E_WIDTH_4		0xe
-#define VAL_F_WIDTH_4		0xf
-#define STRNG_0_WIDTH_4	"0000"
-#define STRNG_1_WIDTH_4	"0001"
-#define STRNG_2_WIDTH_4	"0010"
-#define STRNG_3_WIDTH_4	"0011"
-#define STRNG_4_WIDTH_4	"0100"
-#define STRNG_5_WIDTH_4	"0101"
-#define STRNG_6_WIDTH_4	"0110"
-#define STRNG_7_WIDTH_4	"0111"
-#define STRNG_8_WIDTH_4	"1000"
-#define STRNG_9_WIDTH_4	"1001"
-#define STRNG_A_WIDTH_4	"1010"
-#define STRNG_B_WIDTH_4	"1011"
-#define STRNG_C_WIDTH_4	"1100"
-#define STRNG_D_WIDTH_4	"1101"
-#define STRNG_E_WIDTH_4	"1110"
-#define STRNG_F_WIDTH_4	"1111"
-
-#define BIT_WIDTH_5		5
-#define MSK_WIDTH_5		0x1f
-#define VAL_MAX_WDITH_5		0x1f
-#define VAL_0_WIDTH_5		0x0
-#define VAL_1_WIDTH_5		0x1
-#define VAL_18_WIDTH_5		0x12
-#define VAL_20_WIDTH_5		0x14
-#define VAL_30_WIDTH_5		0x1e
-#define VAL_31_WIDTH_5		0x1f
-#define STRNG_0_WIDTH_5		"00000"
-#define STRNG_1_WIDTH_5		"00001"
-#define STRNG_18_WIDTH_5	"10010"
-#define STRNG_20_WIDTH_5	"10100"
-#define STRNG_30_WIDTH_5	"11110"
-#define STRNG_31_WIDTH_5	"11111"
-
-/* specific */
-#define FILE_USB_DRIVING_CAPABILITY "USB_DRIVING_CAPABILITY"
-
-#define FILE_RG_USB20_TERM_VREF_SEL "RG_USB20_TERM_VREF_SEL"
-#define MSK_RG_USB20_TERM_VREF_SEL MSK_WIDTH_3
-#define SHFT_RG_USB20_TERM_VREF_SEL 8
-#define OFFSET_RG_USB20_TERM_VREF_SEL 0x4
-
-#define FILE_RG_USB20_HSTX_SRCTRL "RG_USB20_HSTX_SRCTRL"
-#define MSK_RG_USB20_HSTX_SRCTRL MSK_WIDTH_3
-#define SHFT_RG_USB20_HSTX_SRCTRL 12
-#define OFFSET_RG_USB20_HSTX_SRCTRL 0x14
-
-#define FILE_RG_USB20_VRT_VREF_SEL "RG_USB20_VRT_VREF_SEL"
-#define MSK_RG_USB20_VRT_VREF_SEL MSK_WIDTH_3
-#define SHFT_RG_USB20_VRT_VREF_SEL 12
-#define OFFSET_RG_USB20_VRT_VREF_SEL 0x4
-
-#define FILE_RG_USB20_INTR_EN "RG_USB20_INTR_EN"
-#define MSK_RG_USB20_INTR_EN MSK_WIDTH_1
-#define SHFT_RG_USB20_INTR_EN 5
-#define OFFSET_RG_USB20_INTR_EN 0x0
-
-#define FILE_RG_USB20_PHY_REV6 "RG_USB20_PHY_REV6"
-#define MSK_RG_USB20_PHY_REV6 MSK_WIDTH_2
-#define SHFT_RG_USB20_PHY_REV6 30
-#define OFFSET_RG_USB20_PHY_REV6 0x18
-
-#define FILE_RG_USB20_INTR_CAL "RG_USB20_INTR_CAL"
-#define MSK_RG_USB20_INTR_CAL MSK_WIDTH_5
-#define SHFT_RG_USB20_INTR_CAL 19
-#define OFFSET_RG_USB20_INTR_CAL 0x4
-
-#define FILE_RG_USB20_DISCTH "RG_USB20_DISCTH"
-#define MSK_RG_USB20_DISCTH MSK_WIDTH_4
-#define SHFT_RG_USB20_DISCTH 4
-#define OFFSET_RG_USB20_DISCTH 0x18
-
-#define FILE_REG_DEBUG "phy_reg"
-
-static struct proc_dir_entry *usb20_phy_procfs_root;
-static u32 ippc_value, ippc_addr;
-
-static void u3phywrite32(struct phy *phy, int offset, int mask, int value)
-{
-	u32 cur_value;
-	u32 new_value;
-
-	cur_value = usb_mtkphy_io_read(phy, offset);
-	new_value = (cur_value & (~mask)) | value;
-	usb_mtkphy_io_write(phy, new_value, offset);
-}
-
-static void usb20_phy_debugfs_write_width1(struct phy *phy, u8 offset, u8 shift,
-	char *buf)
-{
-	u32 set_val = 0;
-
-	pr_debug("s(%s)\n", buf);
-	if (!strncmp(buf, STRNG_0_WIDTH_1, BIT_WIDTH_1)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_1);
-		set_val = VAL_0_WIDTH_1;
-	} else if (!strncmp(buf, STRNG_1_WIDTH_1, BIT_WIDTH_1)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_1);
-		set_val = VAL_1_WIDTH_1;
-	} else
-		return;
-
-	u3phywrite32(phy, offset, MSK_WIDTH_1 << shift, set_val << shift);
-
-}
-
-static void usb20_phy_debugfs_rev6_write(struct phy *phy, u8 offset, u8 shift,
-	char *buf)
-{
-	u32 set_val = 0xFF;
-
-	pr_debug("s(%s)\n", buf);
-	if (!strncmp(buf, STRNG_0_WIDTH_2, BIT_WIDTH_2)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_2);
-		set_val = VAL_0_WIDTH_2;
-	} else if (!strncmp(buf, STRNG_1_WIDTH_2, BIT_WIDTH_2)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_2);
-		set_val = VAL_1_WIDTH_2;
-	} else if (!strncmp(buf, STRNG_2_WIDTH_2, BIT_WIDTH_2)) {
-		pr_debug("%s case\n", STRNG_2_WIDTH_2);
-		set_val = VAL_2_WIDTH_2;
-	} else if (!strncmp(buf, STRNG_3_WIDTH_2, BIT_WIDTH_2)) {
-		pr_debug("%s case\n", STRNG_3_WIDTH_2);
-		set_val = VAL_3_WIDTH_2;
-	} else
-		return;
-
-	u3phywrite32(phy, offset, MSK_WIDTH_2 << shift, set_val << shift);
-
-}
-
-
-static void usb20_phy_debugfs_write_width3(struct phy *phy, u8 offset, u8 shift,
-	char *buf)
-{
-	u32 set_val = 0;
-
-	pr_debug("s(%s)\n", buf);
-	if (!strncmp(buf, STRNG_0_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_3);
-		set_val = VAL_0_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_1_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_3);
-		set_val = VAL_1_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_2_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_2_WIDTH_3);
-		set_val = VAL_2_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_3_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_3_WIDTH_3);
-		set_val = VAL_3_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_4_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_4_WIDTH_3);
-		set_val = VAL_4_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_5_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_5_WIDTH_3);
-		set_val = VAL_5_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_6_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_6_WIDTH_3);
-		set_val = VAL_6_WIDTH_3;
-	} else if (!strncmp(buf, STRNG_7_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_7_WIDTH_3);
-		set_val = VAL_7_WIDTH_3;
-	} else
-		return;
-
-	u3phywrite32(phy, offset, MSK_WIDTH_3 << shift, set_val << shift);
-
-}
-
-static void usb20_phy_debugfs_write_width4(struct phy *phy, u8 offset, u8 shift,
-	char *buf)
-{
-	u32 set_val = 0;
-
-	pr_debug("s(%s)\n", buf);
-	if (!strncmp(buf, STRNG_0_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_4);
-		set_val = VAL_0_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_1_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_4);
-		set_val = VAL_1_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_2_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_2_WIDTH_4);
-		set_val = VAL_2_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_3_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_3_WIDTH_4);
-		set_val = VAL_3_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_4_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_4_WIDTH_4);
-		set_val = VAL_4_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_5_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_5_WIDTH_4);
-		set_val = VAL_5_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_6_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_6_WIDTH_4);
-		set_val = VAL_6_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_7_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_7_WIDTH_4);
-		set_val = VAL_7_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_8_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_8_WIDTH_4);
-		set_val = VAL_8_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_9_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_9_WIDTH_4);
-		set_val = VAL_9_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_A_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_A_WIDTH_4);
-		set_val = VAL_A_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_B_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_B_WIDTH_4);
-		set_val = VAL_B_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_C_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_C_WIDTH_4);
-		set_val = VAL_C_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_D_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_D_WIDTH_4);
-		set_val = VAL_D_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_E_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_E_WIDTH_4);
-		set_val = VAL_E_WIDTH_4;
-	} else if (!strncmp(buf, STRNG_F_WIDTH_4, BIT_WIDTH_4)) {
-		pr_debug("%s case\n", STRNG_F_WIDTH_4);
-		set_val = VAL_F_WIDTH_4;
-	} else
-		return;
-
-	u3phywrite32(phy, offset, MSK_WIDTH_4 << shift, set_val << shift);
-
-}
-
-static void usb20_phy_debugfs_write_width5(struct phy *phy, u8 offset, u8 shift,
-	char *buf)
-{
-	u32 set_val = 0;
-
-	pr_debug("s(%s)\n", buf);
-	if (!strncmp(buf, STRNG_0_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_5);
-		set_val = VAL_0_WIDTH_5;
-	} else if (!strncmp(buf, STRNG_1_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_5);
-		set_val = VAL_1_WIDTH_5;
-	} else if (!strncmp(buf, STRNG_18_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_18_WIDTH_5);
-		set_val = VAL_18_WIDTH_5;
-	} else if (!strncmp(buf, STRNG_20_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_20_WIDTH_5);
-		set_val = VAL_20_WIDTH_5;
-	} else if (!strncmp(buf, STRNG_30_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_30_WIDTH_5);
-		set_val = VAL_30_WIDTH_5;
-	} else if (!strncmp(buf, STRNG_31_WIDTH_5, BIT_WIDTH_5)) {
-		pr_debug("%s case\n", STRNG_31_WIDTH_5);
-		set_val = VAL_31_WIDTH_5;
-	} else
-		return;
-
-	u3phywrite32(phy, offset, MSK_WIDTH_5 << shift, set_val << shift);
-
-}
-
-
-static u8 usb20_phy_debugfs_read_val(u32 val, u8 width, char *str)
-{
-	int i, temp;
-
-	temp = val;
-	str[width] = '\0';
-	for (i = (width - 1); i >= 0; i--) {
-		if (val % 2)
-			str[i] = '1';
-		else
-			str[i] = '0';
-		pr_debug("str[%d]:%c\n", i, str[i]);
-		val /= 2;
-	}
-	pr_debug("str(%s)\n", str);
-	return val;
-}
-
-static int usb_driving_capability_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-	u8 combined_val, tmp_val = 0xff;
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_TERM_VREF_SEL));
-	val = val >> SHFT_RG_USB20_TERM_VREF_SEL;
-	val = val & MSK_RG_USB20_TERM_VREF_SEL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_3, str);
-
-	if (!strncmp(str, STRNG_0_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_3);
-		tmp_val = VAL_0_WIDTH_3;
-	} else if (!strncmp(str, STRNG_1_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_3);
-		tmp_val = VAL_1_WIDTH_3;
-	} else if (!strncmp(str, STRNG_2_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_2_WIDTH_3);
-		tmp_val = VAL_2_WIDTH_3;
-	} else if (!strncmp(str, STRNG_3_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_3_WIDTH_3);
-		tmp_val = VAL_3_WIDTH_3;
-	} else if (!strncmp(str, STRNG_4_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_4_WIDTH_3);
-		tmp_val = VAL_4_WIDTH_3;
-	} else if (!strncmp(str, STRNG_5_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_5_WIDTH_3);
-		tmp_val = VAL_5_WIDTH_3;
-	} else if (!strncmp(str, STRNG_6_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_6_WIDTH_3);
-		tmp_val = VAL_6_WIDTH_3;
-	} else if (!strncmp(str, STRNG_7_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_7_WIDTH_3);
-		tmp_val = VAL_7_WIDTH_3;
-	}
-
-	combined_val = tmp_val;
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_VRT_VREF_SEL));
-	val = val >> SHFT_RG_USB20_VRT_VREF_SEL;
-	val = val & MSK_RG_USB20_VRT_VREF_SEL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_3, str);
-
-	if (!strncmp(str, STRNG_0_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_0_WIDTH_3);
-		tmp_val = VAL_0_WIDTH_3;
-	} else if (!strncmp(str, STRNG_1_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_1_WIDTH_3);
-		tmp_val = VAL_1_WIDTH_3;
-	} else if (!strncmp(str, STRNG_2_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_2_WIDTH_3);
-		tmp_val = VAL_2_WIDTH_3;
-	} else if (!strncmp(str, STRNG_3_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_3_WIDTH_3);
-		tmp_val = VAL_3_WIDTH_3;
-	} else if (!strncmp(str, STRNG_4_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_4_WIDTH_3);
-		tmp_val = VAL_4_WIDTH_3;
-	} else if (!strncmp(str, STRNG_5_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_5_WIDTH_3);
-		tmp_val = VAL_5_WIDTH_3;
-	} else if (!strncmp(str, STRNG_6_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_6_WIDTH_3);
-		tmp_val = VAL_6_WIDTH_3;
-	} else if (!strncmp(str, STRNG_7_WIDTH_3, BIT_WIDTH_3)) {
-		pr_debug("%s case\n", STRNG_7_WIDTH_3);
-		tmp_val = VAL_7_WIDTH_3;
-	}
-
-	pr_debug("combined_val(%d), tmp_val(%d)\n", combined_val, tmp_val);
-	if ((tmp_val == (combined_val - 1)) || (tmp_val == combined_val))
-		combined_val += tmp_val;
-	else
-		combined_val = tmp_val * (VAL_MAX_WDITH_3 + 1) + combined_val;
-
-	pr_debug("combined_val(%d), tmp_val(%d)\n", combined_val, tmp_val);
-
-	seq_printf(s, "%s = %d\n", FILE_USB_DRIVING_CAPABILITY, combined_val);
-	return 0;
-}
-
-static int rg_usb20_term_vref_sel_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_TERM_VREF_SEL));
-	val = val >> SHFT_RG_USB20_TERM_VREF_SEL;
-	val = val & MSK_RG_USB20_TERM_VREF_SEL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_3, str);
-
-	seq_printf(s, "%s= %s\n", FILE_RG_USB20_TERM_VREF_SEL, str);
-	return 0;
-}
-
-static int rg_usb20_hstx_srctrl_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_HSTX_SRCTRL));
-	val = val >> SHFT_RG_USB20_HSTX_SRCTRL;
-	val = val & MSK_RG_USB20_HSTX_SRCTRL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_3, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_HSTX_SRCTRL, str);
-	return 0;
-}
-
-static int rg_usb20_vrt_vref_sel_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_VRT_VREF_SEL));
-	val = val >> SHFT_RG_USB20_VRT_VREF_SEL;
-	val = val & MSK_RG_USB20_VRT_VREF_SEL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_3, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_VRT_VREF_SEL, str);
-	return 0;
-}
-
-static int rg_usb20_intr_en_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_INTR_EN));
-	val = val >> SHFT_RG_USB20_INTR_EN;
-	val = val & MSK_RG_USB20_INTR_EN;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_1, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_INTR_EN, str);
-	return 0;
-}
-
-static int rg_usb20_rev6_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_PHY_REV6));
-	val = val >> SHFT_RG_USB20_PHY_REV6;
-	val = val & MSK_RG_USB20_PHY_REV6;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_2, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_PHY_REV6, str);
-	return 0;
-}
-
-static int rg_usb20_intr_cal_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_INTR_CAL));
-	val = val >> SHFT_RG_USB20_INTR_CAL;
-	val = val & MSK_RG_USB20_INTR_CAL;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_5, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_INTR_CAL, str);
-	return 0;
-}
-
-static int rg_usb20_discth_show(struct seq_file *s, void *unused)
-{
-	struct phy *phy = s->private;
-	u32 val;
-	char str[16];
-
-	val = usb_mtkphy_io_read(phy, (OFFSET_RG_USB20_DISCTH));
-	val = val >> SHFT_RG_USB20_DISCTH;
-	val = val & MSK_RG_USB20_DISCTH;
-	val = usb20_phy_debugfs_read_val(val, BIT_WIDTH_4, str);
-
-	seq_printf(s, "%s = %s\n", FILE_RG_USB20_DISCTH, str);
-	return 0;
-}
-
-static int phy_rw_show(struct seq_file *s, void *unused)
-{
-	seq_printf(s, "phy[0x%x] = 0x%x\n", ippc_addr, ippc_value);
-
-	return 0;
-}
-
-static int usb_driving_capability_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, usb_driving_capability_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_term_vref_sel_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_term_vref_sel_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_hstx_srctrl_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_hstx_srctrl_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_vrt_vref_sel_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_vrt_vref_sel_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_intr_en_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_intr_en_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_rev6_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_rev6_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_intr_cal_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_intr_cal_show, PDE_DATA(inode));
-}
-
-static int rg_usb20_discth_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, rg_usb20_discth_show, PDE_DATA(inode));
-}
-
-static int phy_rw_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, phy_rw_show, PDE_DATA(inode));
-}
-
-void val_to_bstring_width3(u8 val, char *str)
-{
-	switch (val) {
-	case VAL_0_WIDTH_3:
-		memcpy(str, STRNG_0_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_1_WIDTH_3:
-		memcpy(str, STRNG_1_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_2_WIDTH_3:
-		memcpy(str, STRNG_2_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_3_WIDTH_3:
-		memcpy(str, STRNG_3_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_4_WIDTH_3:
-		memcpy(str, STRNG_4_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_5_WIDTH_3:
-		memcpy(str, STRNG_5_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_6_WIDTH_3:
-		memcpy(str, STRNG_6_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	case VAL_7_WIDTH_3:
-		memcpy(str, STRNG_7_WIDTH_3, BIT_WIDTH_3 + 1);
-		break;
-	}
-
-	pr_debug("val(%d), str(%s)\n", val, str);
-}
-
-static ssize_t usb_driving_capability_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-	u8 val, tmp_val;
-	char str_rg_usb20_term_vref_sel[18], str_rg_usb20_vrt_vref_sel[18];
-
-	memset(buf, 0x00, sizeof(buf));
-	pr_debug("\n");
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-
-	if (kstrtou8(buf, 10, &val) != 0) {
-		pr_debug("kstrtou8, err(%d)\n", kstrtou8(buf, 10, &val));
-		return count;
-	}
-	pr_debug("kstrtol, val(%d)\n", val);
-
-	if (val > VAL_7_WIDTH_3 * 2) {
-		pr_debug("wrong val set(%d), direct return\n", val);
-		return count;
-	}
-	tmp_val = val;
-	val /= 2;
-
-	pr_debug("val(%d), tmp_val(%d)\n", val, tmp_val);
-	val_to_bstring_width3(tmp_val - val, str_rg_usb20_term_vref_sel);
-	val_to_bstring_width3(val, str_rg_usb20_vrt_vref_sel);
-	pr_debug("Config TERM_VREF_SEL %s\n", str_rg_usb20_term_vref_sel);
-	usb20_phy_debugfs_write_width3(phy, OFFSET_RG_USB20_TERM_VREF_SEL,
-		SHFT_RG_USB20_TERM_VREF_SEL, str_rg_usb20_term_vref_sel);
-	pr_debug("Config VRT_VREF_SEL %s\n", str_rg_usb20_vrt_vref_sel);
-	usb20_phy_debugfs_write_width3(phy, OFFSET_RG_USB20_VRT_VREF_SEL,
-		SHFT_RG_USB20_VRT_VREF_SEL, str_rg_usb20_vrt_vref_sel);
-	return count;
-}
-
-static ssize_t rg_usb20_term_vref_sel_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width3(phy, OFFSET_RG_USB20_TERM_VREF_SEL,
-		SHFT_RG_USB20_TERM_VREF_SEL, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_hstx_srctrl_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width3(phy, OFFSET_RG_USB20_HSTX_SRCTRL,
-		SHFT_RG_USB20_HSTX_SRCTRL, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_vrt_vref_sel_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width3(phy, OFFSET_RG_USB20_VRT_VREF_SEL,
-		SHFT_RG_USB20_VRT_VREF_SEL, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_intr_en_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width1(phy, OFFSET_RG_USB20_INTR_EN,
-		SHFT_RG_USB20_INTR_EN, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_rev6_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_rev6_write(phy, OFFSET_RG_USB20_PHY_REV6,
-		SHFT_RG_USB20_PHY_REV6, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_intr_cal_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width5(phy, OFFSET_RG_USB20_INTR_CAL,
-		SHFT_RG_USB20_INTR_CAL, buf);
-	return count;
-}
-
-static ssize_t rg_usb20_discth_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[18];
-
-	memset(buf, 0x00, sizeof(buf));
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-	usb20_phy_debugfs_write_width4(phy, OFFSET_RG_USB20_DISCTH,
-		SHFT_RG_USB20_DISCTH, buf);
-	return count;
-}
-
-static ssize_t phy_rw_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	struct seq_file *s = file->private_data;
-	struct phy *phy = s->private;
-	char buf[40];
-
-	memset(buf, 0x00, sizeof(buf));
-
-	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-
-	if (!strncmp(buf, "w", 1)) {
-		u32 offset;
-		u32 value;
-		u32 shift;
-		u32 mask;
-
-		if (sscanf(buf, "w32 0x%x:%d:0x%x:0x%x",
-			&offset, &shift, &mask, &value) == 4) {
-			if ((offset % 4) != 0) {
-				pr_notice("Must use 32bits alignment address\n");
-				return count;
-			}
-			u3phywrite32(phy, offset,
-				mask << shift, value << shift);
-		} else
-			return -EFAULT;
-	}
-
-	if (!strncmp(buf, "r", 1)) {
-		u32 offset;
-
-		if (sscanf(buf, "r32 0x%x", &offset) == 1) {
-			if ((offset % 4) != 0) {
-				pr_notice("Must use 32bits alignment address\n");
-				return count;
-			}
-			ippc_addr = offset;
-			ippc_value = usb_mtkphy_io_read(phy, ippc_addr);
-		}
-	}
-
-	return count;
-}
-
-
-
-static const struct file_operations usb_driving_capability_fops = {
-	.open = usb_driving_capability_open,
-	.write = usb_driving_capability_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_term_vref_sel_fops = {
-	.open = rg_usb20_term_vref_sel_open,
-	.write = rg_usb20_term_vref_sel_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_hstx_srctrl_fops = {
-	.open = rg_usb20_hstx_srctrl_open,
-	.write = rg_usb20_hstx_srctrl_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_vrt_vref_sel_fops = {
-	.open = rg_usb20_vrt_vref_sel_open,
-	.write = rg_usb20_vrt_vref_sel_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_intr_en_fops = {
-	.open = rg_usb20_intr_en_open,
-	.write = rg_usb20_intr_en_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_rev6_fops = {
-	.open = rg_usb20_rev6_open,
-	.write = rg_usb20_rev6_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_intr_cal_fops = {
-	.open = rg_usb20_intr_cal_open,
-	.write = rg_usb20_intr_cal_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations rg_usb20_discth_fops = {
-	.open = rg_usb20_discth_open,
-	.write = rg_usb20_discth_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-static const struct file_operations phy_rw_fops = {
-	.open = phy_rw_open,
-	.write = phy_rw_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-int mtu3_phy_init_debugfs(struct phy *phy)
-{
-	struct proc_dir_entry *root;
-	struct proc_dir_entry *file;
-	int ret;
-
-	proc_mkdir("mtk_usb", NULL);
-
-	root = proc_mkdir("mtk_usb/usb20_phy", NULL);
-	if (!root) {
-		ret = -ENOMEM;
-		goto err0;
-	}
-
-	file = proc_create_data(FILE_USB_DRIVING_CAPABILITY, 0644,
-				   root, &usb_driving_capability_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_TERM_VREF_SEL, 0644,
-				   root, &rg_usb20_term_vref_sel_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_HSTX_SRCTRL, 0644,
-				   root, &rg_usb20_hstx_srctrl_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_VRT_VREF_SEL, 0644,
-				   root, &rg_usb20_vrt_vref_sel_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_INTR_EN, 0644,
-				   root, &rg_usb20_intr_en_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_PHY_REV6, 0644,
-				   root, &rg_usb20_rev6_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_INTR_CAL, 0644,
-				   root, &rg_usb20_intr_cal_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_RG_USB20_DISCTH, 0644,
-				   root, &rg_usb20_discth_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-	file = proc_create_data(FILE_REG_DEBUG, 0644,
-				   root, &phy_rw_fops, phy);
-	if (!file) {
-		ret = -ENOMEM;
-		goto err1;
-	}
-
-	usb20_phy_procfs_root = root;
-	return 0;
-
-err1:
-	proc_remove(root);
-
-err0:
-	return ret;
-}
-
-int mtu3_phy_exit_debugfs(void)
-{
-	proc_remove(usb20_phy_procfs_root);
-	return 0;
-}
diff --git a/drivers/usb/mtu3/mt6885/mtu3_phy_hal.c b/drivers/usb/mtu3/mt6885/mtu3_phy_hal.c
deleted file mode 100644
index becbbd2..0000000
--- a/drivers/usb/mtu3/mt6885/mtu3_phy_hal.c
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/phy/phy.h>
-#include <linux/phy/mediatek/mtk_usb_phy.h>
-#include <linux/clk.h>
-#include <linux/pm_qos.h>
-
-#include "mtu3.h"
-#include "mtu3_priv.h"
-
-static struct phy *mtk_phy;
-
-#ifdef CONFIG_MACH_MT6885
-#define VCORE_OPP 1
-static struct pm_qos_request vcore_pm_qos;
-#endif
-
-#if !defined(CONFIG_USB_MU3D_DRV)
-void Charger_Detect_Init(void)
-{
-	if (mtu3_cable_mode == CABLE_MODE_FORCEON) {
-		pr_info("%s-, SKIP\n", __func__);
-		return;
-	}
-
-	if (mtk_phy)
-		usb_mtkphy_switch_to_bc11(mtk_phy, true);
-}
-
-void Charger_Detect_Release(void)
-{
-	if (mtu3_cable_mode == CABLE_MODE_FORCEON) {
-		pr_info("%s-, SKIP\n", __func__);
-		return;
-	}
-
-	if (mtk_phy)
-		usb_mtkphy_switch_to_bc11(mtk_phy, false);
-}
-#endif
-
-void usb_dpdm_pulldown(bool enable)
-{
-#ifdef CONFIG_MTK_TYPEC_WATER_DETECT
-	if (mtk_phy) {
-		pr_info("%s: pulldown=%d\n", __func__, enable);
-		usb_mtkphy_dpdm_pulldown(mtk_phy, enable);
-	}
-#endif
-}
-
-int ssusb_dual_phy_power_on(struct ssusb_mtk *ssusb, bool host_mode)
-{
-	int ret;
-
-#ifdef CONFIG_MACH_MT6885
-	if (host_mode) {
-		if (pm_qos_request_active(&vcore_pm_qos)) {
-			pm_qos_update_request(&vcore_pm_qos, VCORE_OPP);
-			dev_info(ssusb->dev, "%s: Vcore QOS update %d\n", __func__,
-								VCORE_OPP);
-		} else {
-			pm_qos_add_request(&vcore_pm_qos, PM_QOS_VCORE_OPP,
-								VCORE_OPP);
-			dev_info(ssusb->dev, "%s: Vcore QOS request %d\n", __func__,
-								VCORE_OPP);
-		}
-	}
-#endif
-	ret = phy_power_on(ssusb->phys[0]);
-
-	if (host_mode) {
-		if (!ret)
-			usb_mtkphy_host_mode(ssusb->phys[0], true);
-	}
-	return ret;
-}
-
-void ssusb_dual_phy_power_off(struct ssusb_mtk *ssusb, bool host_mode)
-{
-#ifdef CONFIG_MACH_MT6885
-	if (host_mode) {
-		if (pm_qos_request_active(&vcore_pm_qos)) {
-			pm_qos_remove_request(&vcore_pm_qos);
-			dev_info(ssusb->dev, "%s: Vcore QOS remove\n",  __func__);
-		} else
-			dev_info(ssusb->dev, "%s: Vcore QOS remove again\n", __func__);
-
-		usb_mtkphy_host_mode(ssusb->phys[0], false);
-	}
-#endif
-	phy_power_off(ssusb->phys[0]);
-}
-
-bool ssusb_u3loop_back_test(struct ssusb_mtk *ssusb)
-{
-	int ret;
-	void __iomem *ibase = ssusb->ippc_base;
-
-	ret = clk_prepare_enable(ssusb->sys_clk);
-	if (ret) {
-		dev_info(ssusb->dev, "failed to enable sys_clk\n");
-		return ret;
-	}
-	mtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL0, SSUSB_IP_SW_RST);
-	mtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL1, SSUSB_IP_HOST_PDN);
-	mtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL2, SSUSB_IP_DEV_PDN);
-	mtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL3, SSUSB_IP_PCIE_PDN);
-	mtu3_clrbits(ibase, SSUSB_U3_CTRL(0),
-		(SSUSB_U3_PORT_DIS | SSUSB_U3_PORT_PDN));
-	mdelay(10);
-
-	if (usb_mtkphy_u3_loop_back_test(ssusb->phys[0]) > 0)
-		ret = true;
-	else
-		ret = false;
-
-	mtu3_setbits(ibase, U3D_SSUSB_IP_PW_CTRL3, SSUSB_IP_PCIE_PDN);
-
-	clk_disable_unprepare(ssusb->sys_clk);
-
-	return ret;
-}
-
-void ssusb_set_phy_mode(int speed)
-{
-	/* do nothing */
-}
-
-void phy_hal_init(struct phy *phy)
-{
-	mtk_phy = phy;
-	mtu3_phy_init_debugfs(mtk_phy);
-}
-
-void phy_hal_exit(struct phy *phy)
-{
-	mtu3_phy_exit_debugfs();
-	mtk_phy = NULL;
-}
-
diff --git a/drivers/usb/mtu3/mt6885/mtu3_priv.h b/drivers/usb/mtu3/mt6885/mtu3_priv.h
deleted file mode 100644
index 7c087b6..0000000
--- a/drivers/usb/mtu3/mt6885/mtu3_priv.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
- */
-
-
-#ifndef __MTU3_PRIV__
-#define __MTU3_PRIV__
-
-struct ssusb_priv {
-	struct regulator *vusb10;
-};
-
-enum MTK_USB_SMC_CALL {
-	MTK_USB_SMC_INFRA_REQUEST = 0,
-	MTK_USB_SMC_INFRA_RELEASE,
-	MTK_USB_SMC_NUM
-};
-
-extern void usb_audio_req(bool on);
-extern int mtu3_phy_init_debugfs(struct phy *phy);
-extern int mtu3_phy_exit_debugfs(void);
-
-#endif
-
diff --git a/drivers/usb/mtu3/mt6885/mtu3_sleep.c b/drivers/usb/mtu3/mt6885/mtu3_sleep.c
deleted file mode 100644
index bc0dee4..0000000
--- a/drivers/usb/mtu3/mt6885/mtu3_sleep.c
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <linux/of_irq.h>
-
-#include "mtu3.h"
-#include "mtu3_priv.h"
-
-static int ipsleep_irqnum;
-static int ipsleep_init;
-
-static irqreturn_t ipsleep_eint_isr(int irqnum, void *data)
-{
-	disable_irq_nosync(irqnum);
-	pr_info("ipsleep_eint\n");
-	return IRQ_HANDLED;
-}
-
-static int ipsleep_eint_irq_en(struct device *dev)
-{
-	int ret = 0;
-
-	ret = devm_request_irq(dev, ipsleep_irqnum,
-		ipsleep_eint_isr, 0, "usbcd_eint", NULL);
-
-	if (ret != 0) {
-		dev_info(dev, "usbcd irq fail, ret %d, irqnum %d!!!\n",
-			ret, ipsleep_irqnum);
-	} else
-		enable_irq_wake(ipsleep_irqnum);
-
-	return ret;
-}
-
-static int mt_usb_ipsleep_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-	struct device *dev = &pdev->dev;
-	struct device_node *node = dev->of_node;
-
-	ipsleep_irqnum = irq_of_parse_and_map(node, 0);
-	if (ipsleep_irqnum < 0) {
-		dev_info(dev, "get eint fail\n");
-		return -ENODEV;
-	}
-
-	ret = ipsleep_eint_irq_en(dev);
-	if (ret != 0)
-		goto irqfail;
-
-	ipsleep_init = 1;
-
-irqfail:
-	return ret;
-}
-
-static int mt_usb_ipsleep_remove(struct platform_device *pdev)
-{
-	free_irq(ipsleep_irqnum, NULL);
-	return 0;
-}
-
-static const struct of_device_id usb_ipsleep_of_match[] = {
-	{.compatible = "mediatek,usb_ipsleep"},
-	{},
-};
-
-static struct platform_driver usb_ipsleep_driver = {
-	.remove = mt_usb_ipsleep_remove,
-	.probe = mt_usb_ipsleep_probe,
-	.driver = {
-		.name = "usb_ipsleep",
-		.owner = THIS_MODULE,
-		.of_match_table = usb_ipsleep_of_match,
-	},
-};
-
-void ssusb_wakeup_mode_enable(struct ssusb_mtk *ssusb)
-{
-	if (ipsleep_init)
-		enable_irq(ipsleep_irqnum);
-}
-
-void ssusb_wakeup_mode_disable(struct ssusb_mtk *ssusb)
-{
-	if (ipsleep_init)
-		disable_irq(ipsleep_irqnum);
-}
-
-module_platform_driver(usb_ipsleep_driver);
-
diff --git a/drivers/usb/mtu3/mtu3.h b/drivers/usb/mtu3/mtu3.h
index dbce261..447faed 100644
--- a/drivers/usb/mtu3/mtu3.h
+++ b/drivers/usb/mtu3/mtu3.h
@@ -2,6 +2,7 @@
  * mtu3.h - MediaTek USB3 DRD header
  *
  * Copyright (C) 2016 MediaTek Inc.
+ * Copyright (C) 2019 XiaoMi, Inc.
  *
  * Author: Chunfeng Yun <chunfeng.yun@mediatek.com>
  *
@@ -28,7 +29,6 @@
 #include <linux/regulator/consumer.h>
 #include <linux/usb.h>
 #include <linux/usb/ch9.h>
-#include <linux/usb/class-dual-role.h>
 #include <linux/usb/gadget.h>
 #include <linux/usb/otg.h>
 
@@ -82,10 +82,10 @@ struct mtu3_request;
 #define K_DEBUG		7
 
 #ifdef CONFIG_USB_MTU3_PLAT_PHONE
-#define MTU3_U3_IP_SLOT_DEFAULT 2
+#define MTU3_U3_IP_SLOT_DEFAULT 1
 #define MTU3_LTSSM_INTR_EN (U3_RESUME_INTR | U3_LFPS_TMOUT_INTR | \
 		VBUS_FALL_INTR | VBUS_RISE_INTR | \
-		/*RXDET_SUCCESS_INTR |*/ EXIT_U3_INTR | \
+		RXDET_SUCCESS_INTR | EXIT_U3_INTR | \
 		ENTER_U3_INTR | ENTER_U0_INTR | \
 		RECOVERY_INTR | WARM_RST_INTR | \
 		HOT_RST_INTR | LOOPBACK_INTR | \
@@ -124,19 +124,6 @@ extern u32 debug_level;
  */
 #define EP0_RESPONSE_BUF  6
 
-/**
- * MTU3_DR_FORCE_NONE: automatically switch host and periperal mode
- *		by IDPIN signal.
- * MTU3_DR_FORCE_HOST: force to enter host mode and override OTG
- *		IDPIN signal.
- * MTU3_DR_FORCE_DEVICE: force to enter peripheral mode.
- */
-enum mtu3_dr_force_mode {
-	MTU3_DR_FORCE_NONE = 0,
-	MTU3_DR_FORCE_HOST,
-	MTU3_DR_FORCE_DEVICE,
-};
-
 /* device operated link and speed got from DEVICE_CONF register */
 enum mtu3_speed {
 	MTU3_SPEED_INACTIVE = 0,
@@ -163,12 +150,10 @@ enum mtu3_g_ep0_state {
 	MU3D_EP0_STATE_STALL,
 };
 
-enum fpga_phy_version {
-	NO_PHY = 0,
-	A60930,
-	A60979,
-	A60931,
-	A60862,
+enum usb_state_enum {
+	USB_SUSPEND = 0,
+	USB_UNCONFIGURED,
+	USB_CONFIGURED
 };
 
 /**
@@ -272,10 +257,6 @@ struct otg_switch_mtk {
  * @ippc_base: register base address of IP Power and Clock interface (IPPC)
  * @vusb33: usb3.3V shared by device/host IP
  * @sys_clk: system clock of mtu3, shared by device/host IP
- * @ref_clk: reference clock
- * @mcu_clk: mcu_bus_ck clock for AHB bus etc
- * @dma_clk: dma_bus_ck clock for AXI bus etc
- * @host_clk: host_clk clock for host
  * @dr_mode: works in which mode:
  *		host only, device only or dual-role mode
  * @u2_ports: number of usb2.0 host ports
@@ -290,21 +271,14 @@ struct ssusb_mtk {
 	struct mtu3 *u3d;
 	void __iomem *mac_base;
 	void __iomem *ippc_base;
-	void __iomem *xhci_base;
 	struct phy **phys;
 	int num_phys;
 	/* common power & clock */
 	struct regulator *vusb33;
 	struct clk *sys_clk;
 	struct clk *ref_clk;
-	struct clk *mcu_clk;
-	struct clk *dma_clk;
-	struct clk *host_clk;
-	struct clk *xhci_clk;
 	/* otg */
 	struct otg_switch_mtk otg_switch;
-	struct delayed_work clk_ctl_dwork;
-	struct delayed_work otg_detect_dwork;
 	enum usb_dr_mode dr_mode;
 	bool is_host;
 	bool u3ports_disable;
@@ -313,26 +287,13 @@ struct ssusb_mtk {
 	struct dentry *dbgfs_root;
 	/* usb wakeup for host mode */
 	bool wakeup_en;
-	struct regmap *uwk;
-	u32 uwk_reg_base;
-	u32 uwk_vers;
-	/* keep clock and phy always on*/
-	bool keep_ao;
-	/* keep infra power on*/
-	bool infra_on;
 	bool force_vbus;
-	bool noise_still_tr;
 	bool u1u2_disable;
 	bool u3_loopb_support;
 	struct clk *wk_deb_p0;
 	struct clk *wk_deb_p1;
 	struct regmap *pericfg;
-	struct dual_role_phy_instance *drp_inst;
-	enum mtu3_dr_force_mode drp_state;
-	struct charger_device *chg_dev;
 	void *priv_data;
-	enum fpga_phy_version fpga_phy_ver;
-    bool otg_enable;
 };
 
 /**
@@ -453,8 +414,12 @@ static inline struct mtu3_ep *to_mtu3_ep(struct usb_ep *ep)
 
 static inline struct mtu3_request *next_request(struct mtu3_ep *mep)
 {
-	return list_first_entry_or_null(&mep->req_list, struct mtu3_request,
-					list);
+	struct list_head *queue = &mep->req_list;
+
+	if (list_empty(queue))
+		return NULL;
+
+	return list_first_entry(queue, struct mtu3_request, list);
 }
 
 static inline void mtu3_writel(void __iomem *base, u32 offset, u32 data)
@@ -497,7 +462,6 @@ void mtu3_ep0_setup(struct mtu3 *mtu);
 void mtu3_start(struct mtu3 *mtu);
 void mtu3_stop(struct mtu3 *mtu);
 void mtu3_dev_on_off(struct mtu3 *mtu, int is_on);
-void mtu3_nuke_all_ep(struct mtu3 *mtu);
 
 int mtu3_gadget_setup(struct mtu3 *mtu);
 void mtu3_gadget_cleanup(struct mtu3 *mtu);
@@ -508,16 +472,10 @@ void mtu3_gadget_disconnect(struct mtu3 *mtu);
 
 irqreturn_t mtu3_ep0_isr(struct mtu3 *mtu);
 extern const struct usb_ep_ops mtu3_ep0_ops;
-
-#if !IS_ENABLED(CONFIG_USB_MTU3_PLAT_PHONE)
-int ssusb_clks_enable(struct ssusb_mtk *ssusb);
-void ssusb_clks_disable(struct ssusb_mtk *ssusb);
-int ssusb_phy_power_on(struct ssusb_mtk *ssusb);
-void ssusb_phy_power_off(struct ssusb_mtk *ssusb);
-void ssusb_ip_sw_reset(struct ssusb_mtk *ssusb);
-#else
 extern void mtu3_check_ltssm_work(struct work_struct *data);
-extern bool mtu3_hal_is_vbus_exist(void);
+extern void BATTERY_SetUSBState(int usb_state_value);
+extern bool upmu_is_chr_det(void);
+extern u32 upmu_get_rgs_chrdet(void);
 extern void disconnect_check(struct mtu3 *mtu);
 extern bool is_saving_mode(void);
 extern unsigned int mtu3_cable_mode;
@@ -529,6 +487,5 @@ enum cable_mode {
 	CABLE_MODE_FORCEON,
 	CABLE_MODE_MAX
 };
-#endif
 
 #endif
diff --git a/drivers/usb/mtu3/mtu3_core.c b/drivers/usb/mtu3/mtu3_core.c
index d9875b8..3a5bdc6 100644
--- a/drivers/usb/mtu3/mtu3_core.c
+++ b/drivers/usb/mtu3/mtu3_core.c
@@ -25,10 +25,8 @@
 #include <linux/dma-mapping.h>
 
 #include "mtu3.h"
-#include "mtu3_dr.h"
-#ifdef CONFIG_USB_MTU3_PLAT_PHONE
+
 static u32 sts_ltssm;
-#endif
 
 static int ep_fifo_alloc(struct mtu3_ep *mep, u32 seg_size)
 {
@@ -81,19 +79,9 @@ static void ep_fifo_free(struct mtu3_ep *mep)
 static inline void mtu3_ss_func_set(struct mtu3 *mtu, bool enable)
 {
 	/* If usb3_en==0, LTSSM will go to SS.Disable state */
-	if (enable) {
-#ifdef CONFIG_FPGA_EARLY_PORTING
-		/*
-		 * A60931 new DTB has true type-C connector.
-		 * Phy sends vbus_present and starts to swap lane.
-		 * It will take about 120ms to swap lane if needed.
-		 * Device shall wait lane swap and then enable U3 terminator.
-		 */
-		if (mtu->ssusb->fpga_phy_ver == A60931)
-			mdelay(180);
-#endif
+	if (enable)
 		mtu3_setbits(mtu->mac_base, U3D_USB3_CONFIG, USB3_EN);
-	} else
+	else
 		mtu3_clrbits(mtu->mac_base, U3D_USB3_CONFIG, USB3_EN);
 
 	dev_dbg(mtu->dev, "USB3_EN = %d\n", !!enable);
@@ -274,6 +262,46 @@ void mtu3_dev_on_off(struct mtu3 *mtu, int is_on)
 		usb_speed_string(mtu->max_speed), is_on ? "+" : "-");
 }
 
+void mtu3_start(struct mtu3 *mtu)
+{
+	void __iomem *mbase = mtu->mac_base;
+
+	dev_dbg(mtu->dev, "%s devctl 0x%x\n", __func__,
+		mtu3_readl(mbase, U3D_DEVICE_CONTROL));
+
+	mtu3_clrbits(mtu->ippc_base, U3D_SSUSB_IP_PW_CTRL2, SSUSB_IP_DEV_PDN);
+
+	/*
+	 * When disable U2 port, USB2_CSR's register will be reset to
+	 * default value after re-enable it again(HS is enabled by default).
+	 * So if force mac to work as FS, disable HS function.
+	 */
+	if (mtu->max_speed == USB_SPEED_FULL)
+		mtu3_clrbits(mbase, U3D_POWER_MANAGEMENT, HS_ENABLE);
+
+	/* Initialize the default interrupts */
+	mtu3_intr_enable(mtu);
+	mtu->is_active = 1;
+
+	if (mtu->softconnect)
+		mtu3_dev_on_off(mtu, 1);
+}
+
+void mtu3_stop(struct mtu3 *mtu)
+{
+	dev_dbg(mtu->dev, "%s\n", __func__);
+
+	mtu3_intr_disable(mtu);
+	mtu3_intr_status_clear(mtu);
+
+	if (mtu->softconnect)
+		mtu3_dev_on_off(mtu, 0);
+
+	mtu->is_active = 0;
+	mtu3_setbits(mtu->ippc_base, U3D_SSUSB_IP_PW_CTRL2, SSUSB_IP_DEV_PDN);
+	cancel_delayed_work_sync(&mtu->check_ltssm_work);
+}
+
 /* for non-ep0 */
 int mtu3_config_ep(struct mtu3 *mtu, struct mtu3_ep *mep,
 			int interval, int burst, int mult)
@@ -554,10 +582,8 @@ static void mtu3_regs_init(struct mtu3 *mtu)
 	if (mtu->is_u3_ip) {
 		/* disable LGO_U1/U2 by default */
 		mtu3_clrbits(mbase, U3D_LINK_POWER_CONTROL,
+				SW_U1_ACCEPT_ENABLE | SW_U2_ACCEPT_ENABLE |
 				SW_U1_REQUEST_ENABLE | SW_U2_REQUEST_ENABLE);
-		/* enable accept LGO_U1/U2 link command from host */
-		mtu3_setbits(mbase, U3D_LINK_POWER_CONTROL,
-				SW_U1_ACCEPT_ENABLE | SW_U2_ACCEPT_ENABLE);
 		/* device responses to u3_exit from host automatically */
 		mtu3_clrbits(mbase, U3D_LTSSM_CTRL, SOFT_U3_EXIT_EN);
 		/* automatically build U2 link when U3 detect fail */
@@ -628,17 +654,10 @@ static irqreturn_t mtu3_link_isr(struct mtu3 *mtu)
 	mtu->g.ep0->maxpacket = maxpkt;
 	mtu->ep0_state = MU3D_EP0_STATE_SETUP;
 
-	if (udev_speed == USB_SPEED_UNKNOWN) {
+	if (udev_speed == USB_SPEED_UNKNOWN)
 		mtu3_gadget_disconnect(mtu);
-		#if !IS_ENABLED(CONFIG_USB_MTU3_PLAT_PHONE)
-		mtu3_drp_to_none(mtu);
-		#endif
-	} else {
+	else
 		mtu3_ep0_setup(mtu);
-		#if !IS_ENABLED(CONFIG_USB_MTU3_PLAT_PHONE)
-		mtu3_drp_to_device(mtu);
-		#endif
-	}
 
 	if (udev_speed == USB_SPEED_SUPER) {
 		mep = mtu->ep0;
@@ -661,7 +680,6 @@ static irqreturn_t mtu3_u3_ltssm_isr(struct mtu3 *mtu)
 	mtu3_writel(mbase, U3D_LTSSM_INTR, ltssm); /* W1C */
 	dev_dbg(mtu->dev, "=== LTSSM[%x] ===\n", ltssm);
 
-	#ifdef CONFIG_USB_MTU3_PLAT_PHONE
 	if (ltssm & SS_DISABLE_INTR) {
 		/* enable U2 link. after host reset,
 		 *HS/FS EP0 configuration is applied in musb_g_reset
@@ -673,7 +691,6 @@ static irqreturn_t mtu3_u3_ltssm_isr(struct mtu3 *mtu)
 		cancel_delayed_work(&mtu->check_ltssm_work);
 		sts_ltssm = ENTER_U0_INTR;
 	}
-	#endif
 
 	if (ltssm & (HOT_RST_INTR | WARM_RST_INTR))
 		mtu3_gadget_reset(mtu);
@@ -690,7 +707,6 @@ static irqreturn_t mtu3_u3_ltssm_isr(struct mtu3 *mtu)
 	if (ltssm & ENTER_U3_INTR)
 		mtu3_gadget_suspend(mtu);
 
-	#ifdef CONFIG_USB_MTU3_PLAT_PHONE
 	if (ltssm & HOT_RST_INTR) {
 		u32 link_err_cnt;
 		u32 timeout_val;
@@ -752,7 +768,6 @@ static irqreturn_t mtu3_u3_ltssm_isr(struct mtu3 *mtu)
 		schedule_delayed_work(&mtu->check_ltssm_work,
 			msecs_to_jiffies(1000));
 	}
-	#endif
 
 	return IRQ_HANDLED;
 }
@@ -769,9 +784,7 @@ static irqreturn_t mtu3_u2_common_isr(struct mtu3 *mtu)
 
 	if (u2comm & SUSPEND_INTR) {
 		mtu3_gadget_suspend(mtu);
-		#ifdef CONFIG_USB_MTU3_PLAT_PHONE
 		disconnect_check(mtu);
-		#endif
 	}
 
 	if (u2comm & RESUME_INTR)
@@ -795,7 +808,6 @@ static irqreturn_t mtu3_irq(int irq, void *data)
 	level1 = mtu3_readl(mtu->mac_base, U3D_LV1ISR);
 	level1 &= mtu3_readl(mtu->mac_base, U3D_LV1IER);
 
-	#ifdef CONFIG_USB_MTU3_PLAT_PHONE
 	if (unlikely(!mtu->softconnect) && (level1 & MAC2_INTR)) {
 		u32 u2comm;
 
@@ -839,7 +851,6 @@ static irqreturn_t mtu3_irq(int irq, void *data)
 		spin_unlock_irqrestore(&mtu->lock, flags);
 		return IRQ_HANDLED;
 	}
-	#endif
 
 	if (level1 & EP_CTRL_INTR)
 		mtu3_link_isr(mtu);
@@ -882,7 +893,6 @@ static int mtu3_hw_init(struct mtu3 *mtu)
 		return ret;
 	}
 
-	#ifdef CONFIG_USB_MTU3_PLAT_PHONE
 	cap_dev = mtu3_readl(mtu->mac_base, U3D_MISC_CTRL);
 	mtu->is_36bit = !!CAP_36BIT_SUPPORT(cap_dev);
 
@@ -890,7 +900,6 @@ static int mtu3_hw_init(struct mtu3 *mtu)
 
 	if (mtu->is_36bit)
 		dma_set_mask_and_coherent(mtu->dev, DMA_BIT_MASK(36));
-	#endif
 
 	ret = mtu3_mem_alloc(mtu);
 	if (ret)
@@ -907,49 +916,6 @@ static void mtu3_hw_exit(struct mtu3 *mtu)
 	mtu3_mem_free(mtu);
 }
 
-void mtu3_start(struct mtu3 *mtu)
-{
-	void __iomem *mbase = mtu->mac_base;
-
-	dev_dbg(mtu->dev, "%s devctl 0x%x\n", __func__,
-		mtu3_readl(mbase, U3D_DEVICE_CONTROL));
-
-	mtu3_clrbits(mtu->ippc_base, U3D_SSUSB_IP_PW_CTRL2, SSUSB_IP_DEV_PDN);
-
-	/*
-	 * When disable U2 port, USB2_CSR's register will be reset to
-	 * default value after re-enable it again(HS is enabled by default).
-	 * So if force mac to work as FS, disable HS function.
-	 */
-	if (mtu->max_speed == USB_SPEED_FULL)
-		mtu3_clrbits(mbase, U3D_POWER_MANAGEMENT, HS_ENABLE);
-	mtu3_regs_init(mtu);
-	/* Initialize the default interrupts */
-	mtu3_intr_enable(mtu);
-	mtu->is_active = 1;
-
-	if (mtu->softconnect)
-		mtu3_dev_on_off(mtu, 1);
-}
-
-void mtu3_stop(struct mtu3 *mtu)
-{
-	dev_dbg(mtu->dev, "%s\n", __func__);
-
-	mtu3_intr_disable(mtu);
-	mtu3_intr_status_clear(mtu);
-
-	if (mtu->softconnect)
-		mtu3_dev_on_off(mtu, 0);
-
-	mtu->is_active = 0;
-	mtu3_setbits(mtu->ippc_base, U3D_SSUSB_IP_PW_CTRL2, SSUSB_IP_DEV_PDN);
-	#ifdef CONFIG_USB_MTU3_PLAT_PHONE
-	cancel_delayed_work_sync(&mtu->check_ltssm_work);
-	#endif
-
-}
-
 /*-------------------------------------------------------------------------*/
 
 int ssusb_gadget_init(struct ssusb_mtk *ssusb)
@@ -985,11 +951,9 @@ int ssusb_gadget_init(struct ssusb_mtk *ssusb)
 	ssusb->u3d = mtu;
 	mtu->ssusb = ssusb;
 	mtu->max_speed = usb_get_maximum_speed(dev);
-	#ifdef CONFIG_USB_MTU3_PLAT_PHONE
 	mtu3_cable_mode = CABLE_MODE_NORMAL;
 
 	INIT_DELAYED_WORK(&mtu->check_ltssm_work, mtu3_check_ltssm_work);
-	#endif
 
 	/* check the max_speed parameter */
 	switch (mtu->max_speed) {
@@ -1058,7 +1022,6 @@ void ssusb_gadget_exit(struct ssusb_mtk *ssusb)
 	mtu3_hw_exit(mtu);
 }
 
-#ifdef CONFIG_USB_MTU3_PLAT_PHONE
 void mtu3_check_ltssm_work(struct work_struct *data)
 {
 	struct mtu3 *mtu;
@@ -1084,8 +1047,11 @@ void disconnect_check(struct mtu3 *mtu)
 
 	mdelay(50);
 
-	vbus_exist = mtu3_hal_is_vbus_exist();
-
+#ifdef CONFIG_POWER_EXT
+	vbus_exist = upmu_get_rgs_chrdet();
+#else
+	vbus_exist = upmu_is_chr_det();
+#endif
 	pr_info("vbus_exist:<%d>\n", vbus_exist);
 	if (vbus_exist)
 		return;
@@ -1102,4 +1068,3 @@ void disconnect_check(struct mtu3 *mtu)
 	}
 	pr_info("speed <%d>\n", mtu->g.speed);
 }
-#endif
diff --git a/drivers/usb/mtu3/mtu3_debugfs_v2.c b/drivers/usb/mtu3/mtu3_debugfs_v2.c
index 95f8de5..0f46154 100644
--- a/drivers/usb/mtu3/mtu3_debugfs_v2.c
+++ b/drivers/usb/mtu3/mtu3_debugfs_v2.c
@@ -16,35 +16,22 @@
  *
  */
 
-#include <linux/proc_fs.h>
+#include <linux/debugfs.h>
 #include <linux/seq_file.h>
 #include <linux/uaccess.h>
 #include <linux/platform_device.h>
 
 #include "mtu3.h"
 #include "mtu3_hal.h"
-#include "mtu3_dr.h"
 
-#define PROC_DIR_MTK_USB "mtk_usb"
-#define PROC_FILE_SMTERRCOUNT "mtk_usb/smt_err_count"
-#define PROC_FILE_IPPCREG "mtk_usb/ippc_reg"
-#define PROC_FILE_MACREG "mtk_usb/mac_reg"
-#define PROC_FILE_SPEED "mtk_usb/speed"
-
-#define PROC_FILE_NUM 4
-static struct proc_dir_entry *proc_files[PROC_FILE_NUM] = {
-	NULL, NULL, NULL, NULL};
 
 static u32 mac_value, mac_addr;
 static u32 ippc_value, ippc_addr;
 
 static int smt_err_count_get(void *data, u64 *val)
 {
-	struct ssusb_mtk *ssusb = NULL;
+	struct ssusb_mtk *ssusb = data;
 
-	if (IS_ERR_OR_NULL(data))
-		return -EFAULT;
-	ssusb = data;
 	*val = ssusb_u3loop_back_test(ssusb);
 
 	mtu3_printk(K_INFO, "%s %llu\n", __func__, *val);
@@ -63,7 +50,7 @@ static void mac_write32(struct ssusb_mtk *ssusb, int offset,
 	struct platform_device *pdev = to_platform_device(ssusb->dev);
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mac");
-	if (IS_ERR_OR_NULL(res) || offset >= resource_size(res)) {
+	if (offset >= resource_size(res)) {
 		pr_info("%s error range\n", __func__);
 		return;
 	}
@@ -82,7 +69,7 @@ static void ippc_write32(struct ssusb_mtk *ssusb, int offset,
 	struct platform_device *pdev = to_platform_device(ssusb->dev);
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ippc");
-	if (IS_ERR_OR_NULL(res) || offset >= resource_size(res)) {
+	if (offset >= resource_size(res)) {
 		pr_info("%s error range\n", __func__);
 		return;
 	}
@@ -148,7 +135,7 @@ static ssize_t mac_rw_write(struct file *file,
 
 static int mac_rw_open(struct inode *inode, struct file *file)
 {
-	return single_open(file, mac_rw_show, PDE_DATA(inode));
+	return single_open(file, mac_rw_show, inode->i_private);
 }
 
 static const struct file_operations mac_rw_fops = {
@@ -215,7 +202,7 @@ static ssize_t ippc_rw_write(struct file *file,
 
 static int ippc_rw_open(struct inode *inode, struct file *file)
 {
-	return single_open(file, ippc_rw_show, PDE_DATA(inode));
+	return single_open(file, ippc_rw_show, inode->i_private);
 }
 
 static const struct file_operations ippc_rw_fops = {
@@ -226,85 +213,42 @@ static const struct file_operations ippc_rw_fops = {
 	.release = single_release,
 };
 
-static int mtu3_speed_show(struct seq_file *s, void *unused)
-{
-	seq_printf(s, "mtu3_speed = %d\n", mtu3_speed);
-	return 0;
-}
-
-static int mtu3_speed_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, mtu3_speed_show, PDE_DATA(inode));
-}
-
-static ssize_t mtu3_speed_write(struct file *file,
-			const char __user *ubuf, size_t count, loff_t *ppos)
-{
-	char buf[20];
-	int val;
-
-	memset(buf, 0x00, sizeof(buf));
-
-	if (copy_from_user(buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
-
-	if (kstrtouint(buf, 10, &val) == 0  && val >= 0 && val <= 1)
-		mtu3_speed = val;
-	else
-		return -EINVAL;
-
-	return count;
-}
-
-static const struct file_operations mtu3_speed_fops = {
-	.open = mtu3_speed_open,
-	.write = mtu3_speed_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
 
 void ssusb_debugfs_init(struct ssusb_mtk *ssusb)
 {
-	int idx = 0;
+	struct dentry *root;
+	struct dentry *file;
 
-	proc_mkdir(PROC_DIR_MTK_USB, NULL);
+	root = debugfs_create_dir("musb-hdrc", NULL);
+	if (IS_ERR_OR_NULL(root)) {
+		if (!root)
+			dev_dbg(ssusb->dev, "create debugfs root failed\n");
+		return;
+	}
+	ssusb->dbgfs_root = root;
 
 	if (ssusb->u3_loopb_support) {
-		proc_files[idx] = proc_create_data(PROC_FILE_SMTERRCOUNT, 0644, NULL,
-			&smt_err_count, ssusb);
-		if (!proc_files[idx])
+		file = debugfs_create_file("smt_err_count", 0644, root,
+			ssusb, &smt_err_count);
+		if (!file)
 			dev_dbg(ssusb->dev, "file smt_err_count failed\n");
-		idx++;
 	}
 
-	proc_files[idx] = proc_create_data(PROC_FILE_IPPCREG, 0644, NULL,
-		&ippc_rw_fops, ssusb);
-	if (!proc_files[idx])
+	file = debugfs_create_file("ippc_reg", 0644, root,
+		ssusb, &ippc_rw_fops);
+	if (!file)
 		dev_dbg(ssusb->dev, "file ippc_reg failed\n");
-	idx++;
 
-	proc_files[idx] = proc_create_data(PROC_FILE_MACREG, 0644, NULL,
-		&mac_rw_fops, ssusb);
-	if (!proc_files[idx])
+	file = debugfs_create_file("mac_reg", 0644, root,
+		ssusb, &mac_rw_fops);
+	if (!file)
 		dev_dbg(ssusb->dev, "file mac_reg failed\n");
-	idx++;
-
-	proc_files[idx] = proc_create_data(PROC_FILE_SPEED, 0644, NULL,
-		&mtu3_speed_fops, ssusb);
-	if (!proc_files[idx])
-		dev_dbg(ssusb->dev, "file speed failed\n");
-
 }
 
+
 void ssusb_debugfs_exit(struct ssusb_mtk *ssusb)
 {
-	int idx = 0;
-
-	for (; idx < PROC_FILE_NUM ; idx++) {
-		if (proc_files[idx])
-			proc_remove(proc_files[idx]);
-	}
+	debugfs_remove_recursive(ssusb->dbgfs_root);
 }
 
 
diff --git a/drivers/usb/mtu3/mtu3_dr.c b/drivers/usb/mtu3/mtu3_dr.c
index c59aa8d..720ef84 100644
--- a/drivers/usb/mtu3/mtu3_dr.c
+++ b/drivers/usb/mtu3/mtu3_dr.c
@@ -27,9 +27,6 @@
 #include "mtu3.h"
 #include "mtu3_dr.h"
 
-#include <charger_class.h>
-#include <mtk_boot_common.h>
-
 #define USB2_PORT 2
 #define USB3_PORT 3
 
@@ -40,8 +37,6 @@ enum mtu3_vbus_id_state {
 	MTU3_VBUS_VALID,
 };
 
-struct extcon_dev *g_extcon_edev;
-
 static void toggle_opstate(struct ssusb_mtk *ssusb)
 {
 	if (!ssusb->otg_switch.is_u3_drd) {
@@ -108,17 +103,6 @@ static void switch_port_to_host(struct ssusb_mtk *ssusb)
 	toggle_opstate(ssusb);
 }
 
-static void ssusb_dev_sw_reset(struct ssusb_mtk *ssusb)
-{
-	/* reset ssusb dev */
-	mtu3_setbits(ssusb->ippc_base, U3D_SSUSB_DEV_RST_CTRL,
-		SSUSB_DEV_SW_RST);
-	udelay(1);
-	mtu3_clrbits(ssusb->ippc_base, U3D_SSUSB_DEV_RST_CTRL,
-		SSUSB_DEV_SW_RST);
-
-}
-
 static void switch_port_to_device(struct ssusb_mtk *ssusb)
 {
 	u32 check_clk = 0;
@@ -149,57 +133,18 @@ int ssusb_set_vbus(struct otg_switch_mtk *otg_sx, int is_on)
 	dev_dbg(ssusb->dev, "%s: turn %s\n", __func__, is_on ? "on" : "off");
 
 	if (is_on) {
-		#ifdef CONFIG_MTK_CHARGER
-		charger_dev_enable_otg(ssusb->chg_dev, true);
-		#endif
 		ret = regulator_enable(vbus);
 		if (ret) {
 			dev_err(ssusb->dev, "vbus regulator enable failed\n");
 			return ret;
 		}
 	} else {
-		#ifdef CONFIG_MTK_CHARGER
-		charger_dev_enable_otg(ssusb->chg_dev, false);
-		#endif
 		regulator_disable(vbus);
 	}
 
 	return 0;
 }
 
-static void ssusb_set_force_mode(struct ssusb_mtk *ssusb,
-		enum mtu3_dr_force_mode mode)
-{
-	u32 value;
-
-	value = mtu3_readl(ssusb->ippc_base, SSUSB_U2_CTRL(0));
-	switch (mode) {
-	case MTU3_DR_FORCE_DEVICE:
-		value |= SSUSB_U2_PORT_FORCE_IDDIG | SSUSB_U2_PORT_RG_IDDIG;
-		break;
-	case MTU3_DR_FORCE_HOST:
-		value |= SSUSB_U2_PORT_FORCE_IDDIG;
-		value &= ~SSUSB_U2_PORT_RG_IDDIG;
-		break;
-	case MTU3_DR_FORCE_NONE:
-		value &= ~(SSUSB_U2_PORT_FORCE_IDDIG | SSUSB_U2_PORT_RG_IDDIG);
-		break;
-	default:
-		return;
-	}
-	mtu3_writel(ssusb->ippc_base, SSUSB_U2_CTRL(0), value);
-}
-
-static void clk_control_dwork(struct work_struct *work)
-{
-	struct delayed_work *dwork = to_delayed_work(work);
-	struct ssusb_mtk *ssusb =
-		container_of(dwork, struct ssusb_mtk, clk_ctl_dwork);
-
-	ssusb_phy_power_off(ssusb);
-	ssusb_clks_disable(ssusb);
-}
-
 /*
  * switch to host: -> MTU3_VBUS_OFF --> MTU3_ID_GROUND
  * switch to device: -> MTU3_ID_FLOAT --> MTU3_VBUS_VALID
@@ -210,98 +155,32 @@ static void ssusb_set_mailbox(struct otg_switch_mtk *otg_sx,
 	struct ssusb_mtk *ssusb =
 		container_of(otg_sx, struct ssusb_mtk, otg_switch);
 	struct mtu3 *mtu = ssusb->u3d;
-	unsigned long flags;
-	int ret = 0;
-	struct platform_device *pdev = to_platform_device(ssusb->dev);
-	struct device_node *node = pdev->dev.of_node;
 
 	dev_dbg(ssusb->dev, "mailbox state(%d)\n", status);
 
 	switch (status) {
 	case MTU3_ID_GROUND:
-		if (!ssusb->keep_ao) {
-			ret = ssusb_clks_enable(ssusb);
-			if (ret) {
-				dev_err(ssusb->dev, "failed to enable clock\n");
-				break;
-			}
-			ret = ssusb_phy_power_on(ssusb);
-			if (ret) {
-				dev_err(ssusb->dev, "failed to power on phy\n");
-				goto err_power_on;
-			}
-			ssusb_ip_sw_reset(ssusb);
-			ssusb_dev_sw_reset(ssusb);
-			ssusb_set_force_mode(ssusb, MTU3_DR_FORCE_HOST);
-			ret = ssusb_host_init(ssusb, node);
-			if (ret) {
-				dev_info(ssusb->dev, "failed to initialize host\n");
-				goto err_host_init;
-			}
-		} else {
-			ssusb_set_force_mode(ssusb, MTU3_DR_FORCE_HOST);
-			switch_port_to_host(ssusb);
-		}
+		switch_port_to_host(ssusb);
 		ssusb_set_vbus(otg_sx, 1);
 		ssusb->is_host = true;
-		mtu3_drp_to_host(mtu);
 		break;
 	case MTU3_ID_FLOAT:
 		ssusb->is_host = false;
 		ssusb_set_vbus(otg_sx, 0);
 		switch_port_to_device(ssusb);
-		mtu3_drp_to_none(mtu);
-		if (!ssusb->keep_ao) {
-			ssusb_host_exit(ssusb);
-			schedule_delayed_work(&ssusb->clk_ctl_dwork, 2 * HZ);
-			pm_wakeup_event(ssusb->dev, 3000);
-		}
 		break;
 	case MTU3_VBUS_OFF:
 		mtu3_stop(mtu);
 		pm_relax(ssusb->dev);
-		spin_lock_irqsave(&mtu->lock, flags);
-		mtu3_gadget_disconnect(mtu);
-		spin_unlock_irqrestore(&mtu->lock, flags);
-		mtu3_drp_to_none(mtu);
-		if (!ssusb->keep_ao) {
-			ssusb_phy_power_off(ssusb);
-			ssusb_clks_disable(ssusb);
-		}
 		break;
 	case MTU3_VBUS_VALID:
-		if (ssusb->is_host == true)
-			break;
-		if (!ssusb->keep_ao) {
-			ret = ssusb_clks_enable(ssusb);
-			if (ret) {
-				dev_err(ssusb->dev, "failed to enable clock\n");
-				break;
-			}
-			ret = ssusb_phy_power_on(ssusb);
-			if (ret) {
-				dev_err(ssusb->dev, "failed to power on phy\n");
-				goto err_power_on;
-			}
-			ssusb_ip_sw_reset(ssusb);
-			ssusb_dev_sw_reset(ssusb);
-		}
-		ssusb_set_force_mode(ssusb, MTU3_DR_FORCE_DEVICE);
 		/* avoid suspend when works as device */
-		switch_port_to_device(ssusb);
 		pm_stay_awake(ssusb->dev);
 		mtu3_start(mtu);
 		break;
 	default:
 		dev_err(ssusb->dev, "invalid state\n");
 	}
-
-	return;
-
-err_host_init:
-	ssusb_phy_power_off(ssusb);
-err_power_on:
-	ssusb_clks_disable(ssusb);
 }
 
 static int ssusb_id_notifier(struct notifier_block *nb,
@@ -343,30 +222,26 @@ static int ssusb_extcon_register(struct otg_switch_mtk *otg_sx)
 	if (!edev)
 		return 0;
 
-	g_extcon_edev = otg_sx->edev;
-
 	otg_sx->vbus_nb.notifier_call = ssusb_vbus_notifier;
-	ret = devm_extcon_register_notifier(ssusb->dev, edev, EXTCON_USB,
+	ret = extcon_register_notifier(edev, EXTCON_USB,
 					&otg_sx->vbus_nb);
 	if (ret < 0)
 		dev_err(ssusb->dev, "failed to register notifier for USB\n");
 
 	otg_sx->id_nb.notifier_call = ssusb_id_notifier;
-	ret = devm_extcon_register_notifier(ssusb->dev, edev, EXTCON_USB_HOST,
+	ret = extcon_register_notifier(edev, EXTCON_USB_HOST,
 					&otg_sx->id_nb);
 	if (ret < 0)
 		dev_err(ssusb->dev, "failed to register notifier for USB-HOST\n");
 
 	dev_dbg(ssusb->dev, "EXTCON_USB: %d, EXTCON_USB_HOST: %d\n",
-		extcon_get_state(edev, EXTCON_USB),
-		extcon_get_state(edev, EXTCON_USB_HOST));
-
-	ssusb_set_vbus(otg_sx, 0);
+		extcon_get_cable_state_(edev, EXTCON_USB),
+		extcon_get_cable_state_(edev, EXTCON_USB_HOST));
 
 	/* default as host, switch to device mode if needed */
-	if (extcon_get_state(edev, EXTCON_USB_HOST) == true)
-		ssusb_set_mailbox(otg_sx, MTU3_ID_GROUND);
-	if (extcon_get_state(edev, EXTCON_USB) == true)
+	if (extcon_get_cable_state_(edev, EXTCON_USB_HOST) == false)
+		ssusb_set_mailbox(otg_sx, MTU3_ID_FLOAT);
+	if (extcon_get_cable_state_(edev, EXTCON_USB) == true)
 		ssusb_set_mailbox(otg_sx, MTU3_VBUS_VALID);
 
 	return 0;
@@ -471,138 +346,17 @@ static void ssusb_debugfs_exit(struct ssusb_mtk *ssusb)
 	debugfs_remove_recursive(ssusb->dbgfs_root);
 }
 
-#if IS_ENABLED(CONFIG_DUAL_ROLE_USB_INTF)
-static int mtu3_drp_get_prop(struct dual_role_phy_instance *drp_inst,
-		enum dual_role_property prop, unsigned int *val)
-{
-	struct ssusb_mtk *ssusb = dual_role_get_drvdata(drp_inst);
-	enum mtu3_dr_force_mode drp_state;
-	int mode, pr, dr;
-	int ret = 0;
-
-	/*
-	 * devm_dual_role_instance_register() may call this function,
-	 * but haven't save ssusb into drp_inst->drv_data, so skip NULL value
-	 */
-	drp_state = ssusb ? ssusb->drp_state : MTU3_DR_FORCE_NONE;
-
-	switch (drp_state) {
-	case MTU3_DR_FORCE_DEVICE:
-		mode = DUAL_ROLE_PROP_MODE_UFP;
-		pr = DUAL_ROLE_PROP_PR_SNK;
-		dr = DUAL_ROLE_PROP_DR_DEVICE;
-		break;
-	case MTU3_DR_FORCE_HOST:
-		mode = DUAL_ROLE_PROP_MODE_DFP;
-		pr = DUAL_ROLE_PROP_PR_SRC;
-		dr = DUAL_ROLE_PROP_DR_HOST;
-		break;
-	case MTU3_DR_FORCE_NONE:
-		/* fall through */
-	default:
-		mode = DUAL_ROLE_PROP_MODE_NONE;
-		pr = DUAL_ROLE_PROP_PR_NONE;
-		dr = DUAL_ROLE_PROP_DR_NONE;
-		break;
-	}
-
-	switch (prop) {
-	case DUAL_ROLE_PROP_MODE:
-		*val = mode;
-		break;
-	case DUAL_ROLE_PROP_PR:
-		*val = pr;
-		break;
-	case DUAL_ROLE_PROP_DR:
-		*val = dr;
-		break;
-	case DUAL_ROLE_PROP_VCONN_SUPPLY:
-		*val = DUAL_ROLE_PROP_VCONN_SUPPLY_NO;
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
-
-	return ret;
-}
-
-void mtu3_drp_to_none(struct mtu3 *mtu3)
-{
-	struct ssusb_mtk *ssusb = mtu3->ssusb;
-
-	ssusb->drp_state = MTU3_DR_FORCE_NONE;
-	dual_role_instance_changed(ssusb->drp_inst);
-}
-
-void mtu3_drp_to_device(struct mtu3 *mtu3)
-{
-	struct ssusb_mtk *ssusb = mtu3->ssusb;
-
-	ssusb->drp_state = MTU3_DR_FORCE_DEVICE;
-	dual_role_instance_changed(ssusb->drp_inst);
-}
-
-void mtu3_drp_to_host(struct mtu3 *mtu3)
-{
-	struct ssusb_mtk *ssusb = mtu3->ssusb;
-
-	ssusb->drp_state = MTU3_DR_FORCE_HOST;
-	dual_role_instance_changed(ssusb->drp_inst);
-}
-
-static enum dual_role_property mtu3_dr_props[] = {
-	DUAL_ROLE_PROP_MODE,
-	DUAL_ROLE_PROP_PR,
-	DUAL_ROLE_PROP_DR,
-	/* DUAL_ROLE_PROP_VCONN_SUPPLY, */
-};
-
-static const struct dual_role_phy_desc mtu3_drp_desc = {
-	.name = "dual-role-usb20",
-	.supported_modes = DUAL_ROLE_SUPPORTED_MODES_DFP_AND_UFP,
-	.properties = mtu3_dr_props,
-	.num_properties = ARRAY_SIZE(mtu3_dr_props),
-	.get_property = mtu3_drp_get_prop,
-};
-
-/* provide typeC state, in fact it should be provided by typeC driver */
-static int mtu3_drp_init(struct mtu3 *mtu3)
-{
-	struct dual_role_phy_instance *drp_inst;
-
-	drp_inst = devm_dual_role_instance_register(mtu3->dev, &mtu3_drp_desc);
-	if (IS_ERR(drp_inst)) {
-		dev_err(mtu3->dev, "fail to register dual role instance\n");
-		return PTR_ERR(drp_inst);
-	}
-
-	mtu3->ssusb->drp_inst = drp_inst;
-	drp_inst->drv_data = mtu3->ssusb;
-
-	return 0;
-}
-#endif
-
 int ssusb_otg_switch_init(struct ssusb_mtk *ssusb)
 {
 	struct otg_switch_mtk *otg_sx = &ssusb->otg_switch;
 
 	INIT_DELAYED_WORK(&otg_sx->extcon_reg_dwork, extcon_register_dwork);
 
-	#ifdef CONFIG_MTK_CHARGER
-	ssusb->chg_dev = get_charger_by_name("primary_chg");
-	#endif
-	INIT_DELAYED_WORK(&ssusb->clk_ctl_dwork, clk_control_dwork);
-
 	if (otg_sx->manual_drd_enabled)
 		ssusb_debugfs_init(ssusb);
 
 	/* It is enough to delay 1s for waiting for host initialization */
 	schedule_delayed_work(&otg_sx->extcon_reg_dwork, HZ);
-	#if IS_ENABLED(CONFIG_DUAL_ROLE_USB_INTF)
-	mtu3_drp_init(ssusb->u3d);
-	#endif
 
 	return 0;
 }
@@ -623,25 +377,3 @@ void ssusb_otg_switch_exit(struct ssusb_mtk *ssusb)
 	if (otg_sx->manual_drd_enabled)
 		ssusb_debugfs_exit(ssusb);
 }
-
-int ssusb_otg_detect(struct ssusb_mtk *ssusb)
-{
-	struct extcon_dev *edev = g_extcon_edev;
-	struct otg_switch_mtk *otg_sx = &ssusb->otg_switch;
-
-	if (extcon_get_state(edev, EXTCON_USB_HOST) == true)
-		ssusb_set_mailbox(otg_sx, MTU3_ID_GROUND);
-
-	return 0;
-}
-
-bool mt_usb_is_device(void)
-{
-	int host_state = extcon_get_state(g_extcon_edev, EXTCON_USB_HOST);
-
-	if (host_state == 1)
-		return false;
-
-	return true;
-}
-EXPORT_SYMBOL_GPL(mt_usb_is_device);
diff --git a/drivers/usb/mtu3/mtu3_dr.h b/drivers/usb/mtu3/mtu3_dr.h
index 17d7f00..4cafe5d 100644
--- a/drivers/usb/mtu3/mtu3_dr.h
+++ b/drivers/usb/mtu3/mtu3_dr.h
@@ -68,7 +68,6 @@ static inline void ssusb_wakeup_disable(struct ssusb_mtk *ssusb)
 
 #endif
 
-#if IS_ENABLED(CONFIG_USB_MTU3_PLAT_PHONE)
 enum mtu3_vbus_id_state {
 	MTU3_ID_FLOAT = 1,
 	MTU3_ID_GROUND,
@@ -83,8 +82,6 @@ extern u32 upmu_get_rgs_chrdet(void);
 void ssusb_set_mailbox(struct otg_switch_mtk *otg_sx,
 	enum mtu3_vbus_id_state status);
 
-void ssusb_wakeup_set(struct ssusb_mtk *ssusb, bool enable);
-#endif
 
 #if IS_ENABLED(CONFIG_USB_MTU3_GADGET) || IS_ENABLED(CONFIG_USB_MTU3_DUAL_ROLE)
 int ssusb_gadget_init(struct ssusb_mtk *ssusb);
@@ -104,10 +101,6 @@ static inline void ssusb_gadget_exit(struct ssusb_mtk *ssusb)
 int ssusb_otg_switch_init(struct ssusb_mtk *ssusb);
 void ssusb_otg_switch_exit(struct ssusb_mtk *ssusb);
 int ssusb_set_vbus(struct otg_switch_mtk *otg_sx, int is_on);
-#if !IS_ENABLED(CONFIG_USB_MTU3_PLAT_PHONE)
-int ssusb_otg_detect(struct ssusb_mtk *ssusb);
-#endif
-
 #if IS_ENABLED(CONFIG_USB_MTU3_PLAT_PHONE)
 extern u32 mtu3_speed;
 #endif
@@ -127,28 +120,6 @@ static inline int ssusb_set_vbus(struct otg_switch_mtk *otg_sx, int is_on)
 	return 0;
 }
 
-int ssusb_otg_detect(struct ssusb_mtk *ssusb)
-{
-	return 0;
-}
 #endif
 
-#if !IS_ENABLED(CONFIG_USB_MTU3_PLAT_PHONE)
-#if IS_ENABLED(CONFIG_USB_MTU3_DUAL_ROLE)
-#if IS_ENABLED(CONFIG_DUAL_ROLE_USB_INTF)
-void mtu3_drp_to_none(struct mtu3 *mtu3);
-void mtu3_drp_to_device(struct mtu3 *mtu3);
-void mtu3_drp_to_host(struct mtu3 *mtu3);
-#else
-static inline void mtu3_drp_to_none(struct mtu3 *mtu3)
-{}
-
-static inline void mtu3_drp_to_device(struct mtu3 *mtu3)
-{}
-
-static inline void mtu3_drp_to_host(struct mtu3 *mtu3)
-{}
-#endif
-#endif
-#endif
 #endif		/* _MTU3_DR_H_ */
diff --git a/drivers/usb/mtu3/mtu3_dr_v2.c b/drivers/usb/mtu3/mtu3_dr_v2.c
index 4296bc9..4b44fe2 100644
--- a/drivers/usb/mtu3/mtu3_dr_v2.c
+++ b/drivers/usb/mtu3/mtu3_dr_v2.c
@@ -26,18 +26,8 @@
 
 #define USB2_PORT 2
 #define USB3_PORT 3
-extern int32_t nvt_set_charger(uint8_t charger_on_off);
-extern char mtkfb_lcm_name[256];
 
 struct otg_switch_mtk *g_otg_sx;
-static int otg_enable = 1;
-static int __init get_otg_state(char *str)
-{
-    get_option(&str,&otg_enable);
-    printk("otg_state = %d\n",otg_enable);
-    return 1;
-}
-__setup("usb20.otg_enable=",get_otg_state);
 
 enum {
 	DUAL_PROP_HOST = 0,
@@ -66,32 +56,25 @@ static enum charger_type mtu3_hal_get_charger_type(void)
 {
 	enum charger_type chg_type;
 
-#ifdef CONFIG_MTK_CHARGER
 	chg_type = mt_get_charger_type();
-#else
-	chg_type = STANDARD_HOST;
-#endif
 
 	return chg_type;
 }
 
-bool mtu3_hal_is_vbus_exist(void)
+static bool mtu3_hal_is_vbus_exist(void)
 {
 	bool vbus_exist;
 
-#ifdef CONFIG_MTK_CHARGER
 #ifdef CONFIG_POWER_EXT
 	vbus_exist = upmu_get_rgs_chrdet();
 #else
 	vbus_exist = upmu_is_chr_det();
 #endif
-#else
-	vbus_exist = true;
-#endif
 
 	return vbus_exist;
 }
 
+
 bool usb_cable_connected(void)
 {
 	enum charger_type chg_type = CHARGER_UNKNOWN;
@@ -124,17 +107,6 @@ static bool mtu3_mode_check(enum mtu3_vbus_id_state status)
 	case MTU3_VBUS_VALID:
 	case MTU3_CMODE_VBUS_VALID:
 		/*Check charger status*/
-		if (IS_ERR_OR_NULL(mtkfb_lcm_name)) {
-			pr_info("mtkfb_lcm_name null!");
-		} else {
-			if (strcmp(mtkfb_lcm_name,"nt36523w_fhdp_dsi_vdo_boe_p522_drv") == 0) {
-				pr_info("TP info: [Vendor]novatek [IC]nt36523w");
-				pr_info("%s: charger on\n", __func__);
-				nvt_set_charger(1);//charger on
-			} else {
-				pr_info("TP info: [Vendor]himax [IC]hx83102");
-			}
-		}
 #if !defined(CONFIG_USB_MU3D_DRV)
 		if (!usb_cable_connected()) {
 			mtu3_printk(K_CRIT, "cable not connected\n");
@@ -144,17 +116,6 @@ static bool mtu3_mode_check(enum mtu3_vbus_id_state status)
 		break;
 	case MTU3_VBUS_OFF:
 		/*Disconnection case, only need to check force on*/
-		if (IS_ERR_OR_NULL(mtkfb_lcm_name)) {
-			pr_info("mtkfb_lcm_name null!");
-		} else {
-			if (strcmp(mtkfb_lcm_name,"nt36523w_fhdp_dsi_vdo_boe_p522_drv") == 0) {
-				pr_info("TP info: [Vendor]novatek [IC]nt36523w");
-				pr_info("%s: charger off\n", __func__);
-				nvt_set_charger(0);//charger off
-			} else {
-				pr_info("TP info: [Vendor]himax [IC]hx83102");
-			}
-		}
 		if (mtu3_cable_mode == CABLE_MODE_FORCEON)
 			return true;
 		break;
@@ -228,15 +189,13 @@ static void ssusb_ip_sleep(struct ssusb_mtk *ssusb)
 	mtu3_setbits(ibase, U3D_SSUSB_IP_PW_CTRL0, SSUSB_IP_SW_RST);
 }
 
+
 static void switch_port_to_none(struct ssusb_mtk *ssusb)
 {
 	dev_info(ssusb->dev, "%s\n", __func__);
 
-	if (ssusb->is_host) {
-		/* workaround for host handle disconnect follow */
-		mdelay(50);
+	if (ssusb->is_host)
 		xhci_mtk_unregister_plat();
-	}
 
 	ssusb_ip_sleep(ssusb);
 	ssusb_dual_phy_power_off(ssusb, ssusb->is_host);
@@ -248,7 +207,7 @@ static void switch_port_to_none(struct ssusb_mtk *ssusb)
 static void switch_port_to_host(struct ssusb_mtk *ssusb)
 {
 	int retval;
-	u32 temp;
+
 	u32 check_clk = 0;
 
 	dev_info(ssusb->dev, "%s\n", __func__);
@@ -271,11 +230,6 @@ static void switch_port_to_host(struct ssusb_mtk *ssusb)
 		ssusb->is_host = true;
 
 	/* after all clocks are stable */
-	if (ssusb->noise_still_tr) {
-		temp = readl(ssusb->mac_base + U3D_USB_BUS_PERFORMANCE);
-		temp |= NOISE_STILL_TRANSFER;
-		writel(temp, ssusb->mac_base + U3D_USB_BUS_PERFORMANCE);
-	}
 }
 
 static void switch_port_to_device(struct ssusb_mtk *ssusb)
@@ -326,9 +280,8 @@ void ssusb_gadget_disconnect(struct mtu3 *mtu)
 
 static void ssusb_set_mode(struct work_struct *work)
 {
-	struct otg_switch_mtk *__otg_sx = container_of(to_delayed_work(work),
+	struct otg_switch_mtk *otg_sx = container_of(to_delayed_work(work),
 				struct otg_switch_mtk, dr_work);
-	struct otg_switch_mtk *otg_sx = g_otg_sx;
 	struct ssusb_mtk *ssusb =
 		container_of(otg_sx, struct ssusb_mtk, otg_switch);
 	struct mtu3 *mtu = ssusb->u3d;
@@ -336,7 +289,7 @@ static void ssusb_set_mode(struct work_struct *work)
 	unsigned int usb_mode;
 
 	spin_lock_irqsave(&otg_sx->dr_lock, flags);
-	usb_mode = __otg_sx->desire_usb_mode;
+	usb_mode = otg_sx->desire_usb_mode;
 	spin_unlock_irqrestore(&otg_sx->dr_lock, flags);
 
 	if (otg_sx->usb_mode != usb_mode) {
@@ -355,10 +308,6 @@ static void ssusb_set_mode(struct work_struct *work)
 			break;
 		case DUAL_PROP_NONE:
 			if (!ssusb->is_host) {
-				/* killing any outstanding requests */
-				spin_lock_irqsave(&mtu->lock, flags);
-				mtu3_nuke_all_ep(mtu);
-				spin_unlock_irqrestore(&mtu->lock, flags);
 				mtu3_stop(mtu);
 				/* notify gadget driver */
 				ssusb_gadget_disconnect(mtu);
@@ -370,8 +319,6 @@ static void ssusb_set_mode(struct work_struct *work)
 			dev_info(ssusb->dev, "invalid state\n");
 		}
 	}
-
-	kfree(__otg_sx);
 }
 
 
@@ -384,7 +331,6 @@ void ssusb_set_mailbox(struct otg_switch_mtk *otg_sx,
 {
 	struct ssusb_mtk *ssusb =
 		container_of(otg_sx, struct ssusb_mtk, otg_switch);
-	struct otg_switch_mtk *__otg_sx;
 	unsigned long flags;
 	int i;
 
@@ -395,25 +341,18 @@ void ssusb_set_mailbox(struct otg_switch_mtk *otg_sx,
 		return;
 	}
 
-	__otg_sx = kzalloc(sizeof(struct otg_switch_mtk), GFP_KERNEL);
-
-	if (!__otg_sx)
-		return;
-
-	INIT_DELAYED_WORK(&__otg_sx->dr_work, ssusb_set_mode);
-
 	spin_lock_irqsave(&otg_sx->dr_lock, flags);
 	switch (status) {
 	case MTU3_ID_GROUND:
-		__otg_sx->desire_usb_mode = DUAL_PROP_HOST;
+		otg_sx->desire_usb_mode = DUAL_PROP_HOST;
 		break;
 	case MTU3_VBUS_VALID:
 	case MTU3_CMODE_VBUS_VALID:
-		__otg_sx->desire_usb_mode = DUAL_PROP_DEVICE;
+		otg_sx->desire_usb_mode = DUAL_PROP_DEVICE;
 		break;
 	case MTU3_ID_FLOAT:
 	case MTU3_VBUS_OFF:
-		__otg_sx->desire_usb_mode = DUAL_PROP_NONE;
+		otg_sx->desire_usb_mode = DUAL_PROP_NONE;
 		break;
 	default:
 		dev_info(ssusb->dev, "invalid state\n");
@@ -425,8 +364,9 @@ void ssusb_set_mailbox(struct otg_switch_mtk *otg_sx,
 			mtu3_printk(K_CRIT, "dr_wq not ready\n");
 			msleep(500);
 		} else {
+			mtu3_printk(K_CRIT, "dr_wq is ready\n");
 			queue_delayed_work(otg_sx->dr_workq,
-				&__otg_sx->dr_work, 0);
+				&otg_sx->dr_work, 0);
 			break;
 		}
 	}
@@ -436,16 +376,13 @@ static int ssusb_id_notifier(struct notifier_block *nb,
 	unsigned long event, void *ptr)
 {
 	struct otg_switch_mtk *otg_sx =
-        container_of(nb, struct otg_switch_mtk, id_nb);
-        struct ssusb_mtk *ssusb =
-        container_of(otg_sx, struct ssusb_mtk, otg_switch);
-
-        if(ssusb->otg_enable){
-            if (event)
-               ssusb_set_mailbox(otg_sx, MTU3_ID_GROUND);
-            else
-               ssusb_set_mailbox(otg_sx, MTU3_ID_FLOAT);
-        }
+		container_of(nb, struct otg_switch_mtk, id_nb);
+
+	if (event)
+		ssusb_set_mailbox(otg_sx, MTU3_ID_GROUND);
+	else
+		ssusb_set_mailbox(otg_sx, MTU3_ID_FLOAT);
+
 	return NOTIFY_DONE;
 }
 
@@ -480,9 +417,6 @@ static int ssusb_extcon_register(struct otg_switch_mtk *otg_sx)
 	if (ret < 0)
 		dev_info(ssusb->dev, "failed to register notifier for USB\n");
 
-        if (otg_enable == 1)
-            ssusb->otg_enable = 1;
-
 	otg_sx->id_nb.notifier_call = ssusb_id_notifier;
 	ret = extcon_register_notifier(edev, EXTCON_USB_HOST,
 					&otg_sx->id_nb);
@@ -525,9 +459,7 @@ int ssusb_otg_switch_init(struct ssusb_mtk *ssusb)
 
 	INIT_DELAYED_WORK(&otg_sx->extcon_reg_dwork, extcon_register_dwork);
 
-#ifdef CONFIG_PROC_FS
 	ssusb_debugfs_init(ssusb);
-#endif
 
 	/* It is enough to delay 1s for waiting for host initialization */
 	schedule_delayed_work(&otg_sx->extcon_reg_dwork, HZ/2);
@@ -549,8 +481,7 @@ void ssusb_otg_switch_exit(struct ssusb_mtk *ssusb)
 			EXTCON_USB_HOST, &otg_sx->id_nb);
 	}
 
-#ifdef CONFIG_PROC_FS
 	ssusb_debugfs_exit(ssusb);
-#endif
 	g_otg_sx = NULL;
 }
+
diff --git a/drivers/usb/mtu3/mtu3_gadget.c b/drivers/usb/mtu3/mtu3_gadget.c
index 0f49e90..b4c11e8 100644
--- a/drivers/usb/mtu3/mtu3_gadget.c
+++ b/drivers/usb/mtu3/mtu3_gadget.c
@@ -19,9 +19,6 @@
 #include "mtu3.h"
 #include "mtu3_dr.h"
 #include <linux/usb/composite.h>
-#ifdef CONFIG_USB_MTU3_PLAT_PHONE
-#include <mt-plat/mtk_boot.h>
-#endif
 
 void mtu3_req_complete(struct mtu3_ep *mep,
 		     struct usb_request *req, int status)
@@ -39,6 +36,7 @@ __acquires(mep->mtu->lock)
 
 	mtu = mreq->mtu;
 	mep->busy = 1;
+	spin_unlock(&mtu->lock);
 
 	/* ep0 makes use of PIO, needn't unmap it */
 	if (mep->epnum)
@@ -47,8 +45,6 @@ __acquires(mep->mtu->lock)
 	dev_dbg(mtu->dev, "%s complete req: %p, sts %d, %d/%d\n", mep->name,
 		req, req->status, mreq->request.actual, mreq->request.length);
 
-	spin_unlock(&mtu->lock);
-
 	usb_gadget_giveback_request(&mep->ep, &mreq->request);
 
 	spin_lock(&mtu->lock);
@@ -76,17 +72,6 @@ static void nuke(struct mtu3_ep *mep, const int status)
 	}
 }
 
-void mtu3_nuke_all_ep(struct mtu3 *mtu)
-{
-	int i;
-
-	nuke(mtu->ep0, -ESHUTDOWN);
-	for (i = 1; i < mtu->num_eps; i++) {
-		nuke(mtu->in_eps + i, -ESHUTDOWN);
-		nuke(mtu->out_eps + i, -ESHUTDOWN);
-	}
-}
-
 static int is_db_ok(struct mtu3_ep *mep)
 {
 	struct mtu3 *mtu = mep->mtu;
@@ -130,15 +115,22 @@ static int is_db_ok(struct mtu3_ep *mep)
 			epnum = (ep->bEndpointAddress & 0x0f);
 
 			/*
-			 * Under saving mode, ALL EPs will be set
+			 * Under saving mode, some kinds of EPs have to be set
 			 * as Single Buffer
+			 * ACM OUT-BULK - Signle
+			 * ACM IN-BULK - Double
+			 * ADB OUT-BULK - Signle
+			 * ADB IN-BULK - Single
 			 */
 
 			/* ep must be matched */
 			if (ep->bEndpointAddress == (mep->ep).address) {
 
-				if (gadget->speed == USB_SPEED_SUPER)
-					ret = 0;
+				if (gadget->speed == USB_SPEED_SUPER) {
+					if (!strcmp(f->name,
+						"Function FS Gadget"))
+						ret = 0;
+				}
 				goto end;
 			}
 		}
@@ -199,7 +191,6 @@ static int mtu3_ep_enable(struct mtu3_ep *mep)
 	/* slot mainly affects bulk/isoc transfer, so ignore int */
 	mep->slot = usb_endpoint_xfer_int(desc) ? 0 : mtu->slot;
 
-	#ifdef CONFIG_USB_MTU3_PLAT_PHONE
 	if (is_saving_mode()) {
 		if (is_db_ok(mep)) {
 			dev_info(mtu->dev, "Saving mode, but EP%d supports DBBUF\n",
@@ -210,7 +201,6 @@ static int mtu3_ep_enable(struct mtu3_ep *mep)
 			mep->slot = 0;
 		}
 	}
-	#endif
 
 	ret = mtu3_config_ep(mtu, mep, interval, burst, mult);
 	if (ret < 0)
@@ -346,13 +336,7 @@ struct usb_request *mtu3_alloc_request(struct usb_ep *ep, gfp_t gfp_flags)
 
 void mtu3_free_request(struct usb_ep *ep, struct usb_request *req)
 {
-	struct mtu3_ep *mep = to_mtu3_ep(ep);
-	struct mtu3 *mtu = mep->mtu;
-	unsigned long flags;
-
-	spin_lock_irqsave(&mtu->lock, flags);
 	kfree(to_mtu3_request(req));
-	spin_unlock_irqrestore(&mtu->lock, flags);
 }
 
 static int mtu3_gadget_queue(struct usb_ep *ep,
@@ -595,7 +579,7 @@ static int mtu3_gadget_pullup(struct usb_gadget *gadget, int is_on)
 	struct mtu3 *mtu = gadget_to_mtu3(gadget);
 	unsigned long flags;
 
-	dev_info(mtu->dev, "%s (%s) for %sactive device\n", __func__,
+	dev_dbg(mtu->dev, "%s (%s) for %sactive device\n", __func__,
 		is_on ? "on" : "off", mtu->is_active ? "" : "in");
 
 	/* we'd rather not pullup unless the device is active. */
@@ -608,26 +592,19 @@ static int mtu3_gadget_pullup(struct usb_gadget *gadget, int is_on)
 	} else if (is_on != mtu->softconnect) {
 		mtu->softconnect = is_on;
 		mtu3_dev_on_off(mtu, is_on);
-
-		if (!is_on)
-			mtu3_nuke_all_ep(mtu);
 	}
 
 	if (is_usb_rdy() == false && is_on)
 		set_usb_rdy();
 
-	spin_unlock_irqrestore(&mtu->lock, flags);
-	#ifdef CONFIG_USB_MTU3_PLAT_PHONE
 	/* Trigger connection when force on*/
-	if ((mtu3_cable_mode == CABLE_MODE_FORCEON) ||
-		(get_boot_mode() == META_BOOT) ||
-		(get_boot_mode() == ADVMETA_BOOT)) {
-		dev_info(mtu->dev, "%s CABLE_MODE_FORCEON or META_MODE\n",
-			__func__);
+	if (mtu3_cable_mode == CABLE_MODE_FORCEON) {
+		dev_info(mtu->dev, "%s CABLE_MODE_FORCEON\n", __func__);
 		ssusb_set_mailbox(&mtu->ssusb->otg_switch,
 			MTU3_VBUS_VALID);
 	}
-	#endif
+
+	spin_unlock_irqrestore(&mtu->lock, flags);
 
 	return 0;
 }
@@ -661,11 +638,10 @@ static int mtu3_gadget_start(struct usb_gadget *gadget,
 
 static void stop_activity(struct mtu3 *mtu)
 {
+#if 0
 	struct usb_gadget_driver *driver = mtu->gadget_driver;
 	int i;
 
-	dev_info(mtu->dev, "%s\n", __func__);
-
 	/* don't disconnect if it's not connected */
 	if (mtu->g.speed == USB_SPEED_UNKNOWN)
 		driver = NULL;
@@ -682,12 +658,18 @@ static void stop_activity(struct mtu3 *mtu)
 	 * killing any outstanding requests will quiesce the driver;
 	 * then report disconnect
 	 */
-	mtu3_nuke_all_ep(mtu);
+	nuke(mtu->ep0, -ESHUTDOWN);
+	for (i = 1; i < mtu->num_eps; i++) {
+		nuke(mtu->in_eps + i, -ESHUTDOWN);
+		nuke(mtu->out_eps + i, -ESHUTDOWN);
+	}
+
 	if (driver) {
 		spin_unlock(&mtu->lock);
 		driver->disconnect(&mtu->g);
 		spin_lock(&mtu->lock);
 	}
+#endif
 }
 
 static int mtu3_gadget_stop(struct usb_gadget *g)
@@ -719,21 +701,6 @@ static const struct usb_gadget_ops mtu3_gadget_ops = {
 	.udc_stop = mtu3_gadget_stop,
 };
 
-static void mtu3_state_reset(struct mtu3 *mtu)
-{
-	struct mtu3_ep *mep;
-
-	mtu->address = 0;
-	mtu->ep0_state = MU3D_EP0_STATE_SETUP;
-	mtu->may_wakeup = 0;
-
-	mep = mtu->ep0;
-	if (!list_empty(&mep->req_list)) {
-		pr_info("%s reinit EP[0] req_list\n", __func__);
-		INIT_LIST_HEAD(&mep->req_list);
-	}
-}
-
 static void init_hw_ep(struct mtu3 *mtu, struct mtu3_ep *mep,
 		u32 epnum, u32 is_in)
 {
@@ -838,7 +805,7 @@ void mtu3_gadget_resume(struct mtu3 *mtu)
 /* called when SOF packets stop for 3+ msec or enters U3 */
 void mtu3_gadget_suspend(struct mtu3 *mtu)
 {
-	dev_info(mtu->dev, "gadget SUSPEND\n");
+	dev_dbg(mtu->dev, "gadget SUSPEND\n");
 	if (mtu->gadget_driver && mtu->gadget_driver->suspend) {
 		spin_unlock(&mtu->lock);
 		mtu->gadget_driver->suspend(&mtu->g);
@@ -849,31 +816,33 @@ void mtu3_gadget_suspend(struct mtu3 *mtu)
 /* called when VBUS drops below session threshold, and in other cases */
 void mtu3_gadget_disconnect(struct mtu3 *mtu)
 {
-	struct usb_gadget_driver *driver;
-
-	dev_info(mtu->dev, "gadget DISCONNECT\n");
+	dev_dbg(mtu->dev, "gadget DISCONNECT\n");
 	if (mtu->gadget_driver && mtu->gadget_driver->disconnect) {
-		driver = mtu->gadget_driver;
 		spin_unlock(&mtu->lock);
-		/*
-		 * avoid kernel panic because mtu3_gadget_stop() assigned NULL
-		 * to mtu->gadget_driver.
-		 */
-		driver->disconnect(&mtu->g);
+		mtu->gadget_driver->disconnect(&mtu->g);
 		spin_lock(&mtu->lock);
 	}
 
-	mtu3_state_reset(mtu);
 	usb_gadget_set_state(&mtu->g, USB_STATE_NOTATTACHED);
 }
 
 void mtu3_gadget_reset(struct mtu3 *mtu)
 {
+	struct mtu3_ep *mep;
+
 	dev_info(mtu->dev, "gadget RESET\n");
 
 	/* report disconnect, if we didn't flush EP state */
 	if (mtu->g.speed != USB_SPEED_UNKNOWN)
 		mtu3_gadget_disconnect(mtu);
-	else
-		mtu3_state_reset(mtu);
+
+	mtu->address = 0;
+	mtu->ep0_state = MU3D_EP0_STATE_SETUP;
+	mtu->may_wakeup = 0;
+
+	mep = mtu->ep0;
+	if (!list_empty(&mep->req_list)) {
+		pr_info("%s reinit EP[0] req_list\n", __func__);
+		INIT_LIST_HEAD(&mep->req_list);
+	}
 }
diff --git a/drivers/usb/mtu3/mtu3_gadget_ep0.c b/drivers/usb/mtu3/mtu3_gadget_ep0.c
index b1dbea4..7c6cb23 100644
--- a/drivers/usb/mtu3/mtu3_gadget_ep0.c
+++ b/drivers/usb/mtu3/mtu3_gadget_ep0.c
@@ -2,6 +2,7 @@
  * mtu3_gadget_ep0.c - MediaTek USB3 DRD peripheral driver ep0 handling
  *
  * Copyright (c) 2016 MediaTek Inc.
+ * Copyright (C) 2019 XiaoMi, Inc.
  *
  * Author:  Chunfeng.Yun <chunfeng.yun@mediatek.com>
  *
@@ -63,13 +64,22 @@ static void ep0_req_giveback(struct mtu3 *mtu, struct usb_request *req)
 	mtu3_req_complete(mtu->ep0, req, 0);
 }
 
+static void musb_sync_with_chg(struct mtu3 *mtu, int usb_state)
+{
+	dev_dbg(mtu->dev, "%s.\n", __func__);
+
+	/*chargr get usb_state*/
+	BATTERY_SetUSBState(usb_state);
+}
+
+
 static int
 forward_to_driver(struct mtu3 *mtu, const struct usb_ctrlrequest *setup)
 __releases(mtu->lock)
 __acquires(mtu->lock)
 {
 	int ret;
-
+	int usb_state;
 	if (!mtu->gadget_driver || !mtu->softconnect) {
 		pr_info("%s !softconnect\n", __func__);
 		return -EOPNOTSUPP;
@@ -77,6 +87,13 @@ __acquires(mtu->lock)
 
 	spin_unlock(&mtu->lock);
 	ret = mtu->gadget_driver->setup(&mtu->g, setup);
+	if (setup->bRequest == USB_REQ_SET_CONFIGURATION) {
+		if (setup->wValue & 0xff)
+			usb_state = USB_CONFIGURED;
+		else
+			usb_state = USB_UNCONFIGURED;
+		musb_sync_with_chg(mtu, usb_state);
+	}
 	spin_lock(&mtu->lock);
 
 	dev_dbg(mtu->dev, "%s ret %d\n", __func__, ret);
@@ -300,16 +317,6 @@ static int handle_test_mode(struct mtu3 *mtu, struct usb_ctrlrequest *setup)
 	if (mtu->test_mode_nr == TEST_PACKET_MODE)
 		ep0_load_test_packet(mtu);
 
-	mtu3_writel(mbase, U3D_EP0CSR,
-				(mtu3_readl(mbase, U3D_EP0CSR) & EP0_W1C_BITS)
-				| EP0_SETUPPKTRDY | EP0_DATAEND);
-	mtu->ep0_state = MU3D_EP0_STATE_SETUP;
-
-	while ((mtu3_readl(mbase, U3D_EP0CSR) & EP0_DATAEND) != 0) {
-		/* Need to wait for status really loaded by host */
-		mdelay(1);/* Without this delay, it will fail. */
-	}
-
 	mtu3_writel(mbase, U3D_USB2_TEST_MODE, mtu->test_mode_nr);
 
 	mtu->ep0_state = MU3D_EP0_STATE_SETUP;
@@ -347,9 +354,9 @@ static int ep0_handle_feature_dev(struct mtu3 *mtu,
 
 		lpc = mtu3_readl(mbase, U3D_LINK_POWER_CONTROL);
 		if (set)
-			lpc |= SW_U1_REQUEST_ENABLE;
+			lpc |= SW_U1_ACCEPT_ENABLE;
 		else
-			lpc &= ~SW_U1_REQUEST_ENABLE;
+			lpc &= ~SW_U1_ACCEPT_ENABLE;
 		mtu3_writel(mbase, U3D_LINK_POWER_CONTROL, lpc);
 
 		mtu->u1_enable = !!set;
@@ -365,9 +372,9 @@ static int ep0_handle_feature_dev(struct mtu3 *mtu,
 
 		lpc = mtu3_readl(mbase, U3D_LINK_POWER_CONTROL);
 		if (set)
-			lpc |= SW_U2_REQUEST_ENABLE;
+			lpc |= SW_U2_ACCEPT_ENABLE;
 		else
-			lpc &= ~SW_U2_REQUEST_ENABLE;
+			lpc &= ~SW_U2_ACCEPT_ENABLE;
 		mtu3_writel(mbase, U3D_LINK_POWER_CONTROL, lpc);
 
 		mtu->u2_enable = !!set;
@@ -570,7 +577,7 @@ static void ep0_tx_state(struct mtu3 *mtu)
 	struct usb_request *req;
 	u32 csr;
 	u8 *src;
-	u16 count;
+	u8 count;
 	u32 maxp;
 
 	dev_dbg(mtu->dev, "%s\n", __func__);
@@ -647,7 +654,6 @@ __acquires(mtu->lock)
 	void __iomem *mbase = mtu->mac_base;
 	int handled = 0;
 
-	memset(&setup, 0, sizeof(setup));
 	ep0_read_setup(mtu, &setup);
 
 	if ((setup.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD)
@@ -794,6 +800,9 @@ static int ep0_queue(struct mtu3_ep *mep, struct mtu3_request *mreq)
 	dev_dbg(mtu->dev, "%s %s (ep0_state: %s), len#%d\n", __func__,
 		mep->name, decode_ep0_state(mtu), mreq->request.length);
 
+	if (!list_empty(&mep->req_list))
+		return -EBUSY;
+
 	switch (mtu->ep0_state) {
 	case MU3D_EP0_STATE_SETUP:
 	case MU3D_EP0_STATE_RX:	/* control-OUT data */
@@ -805,9 +814,6 @@ static int ep0_queue(struct mtu3_ep *mep, struct mtu3_request *mreq)
 		return -EINVAL;
 	}
 
-	if (!list_empty(&mep->req_list))
-		return -EBUSY;
-
 	list_add_tail(&mreq->list, &mep->req_list);
 
 	/* sequence #1, IN ... start writing the data */
diff --git a/drivers/usb/mtu3/mtu3_hal.h b/drivers/usb/mtu3/mtu3_hal.h
index 39954b3..605ddca 100644
--- a/drivers/usb/mtu3/mtu3_hal.h
+++ b/drivers/usb/mtu3/mtu3_hal.h
@@ -21,16 +21,8 @@ enum {
 	USB_DPIDLE_SRAM,
 	USB_DPIDLE_TIMER,
 	USB_DPIDLE_AUDIO,
-	USB_DPIDLE_SUSPEND,
-	USB_DPIDLE_RESUME,
 };
 
-enum USB_DEV_SPEED {
-	DEV_SPEED_INACTIVE = 0,
-	DEV_SPEED_FULL = 1,
-	DEV_SPEED_HIGH = 3,
-	DEV_SPEED_SUPER = 4,
-};
 
 extern int xhci_mtk_register_plat(void);
 extern void xhci_mtk_unregister_plat(void);
@@ -52,11 +44,10 @@ extern void phy_hal_exit(struct phy *phy);
 extern bool ssusb_u3loop_back_test(struct ssusb_mtk *ssusb);
 
 
-extern void ssusb_wakeup_mode_enable(struct ssusb_mtk *ssusb);
-extern void ssusb_wakeup_mode_disable(struct ssusb_mtk *ssusb);
+extern void usb_wakeup_enable(struct ssusb_mtk *ssusb);
+extern void usb_wakeup_disable(struct ssusb_mtk *ssusb);
 
 extern void ssusb_dpidle_request(int mode);
-extern void ssusb_set_phy_mode(int speed);
 
 extern void ssusb_debugfs_init(struct ssusb_mtk *ssusb);
 extern void ssusb_debugfs_exit(struct ssusb_mtk *ssusb);
diff --git a/drivers/usb/mtu3/mtu3_host.c b/drivers/usb/mtu3/mtu3_host.c
index 0f17ed1..fbf4ae0 100644
--- a/drivers/usb/mtu3/mtu3_host.c
+++ b/drivers/usb/mtu3/mtu3_host.c
@@ -236,8 +236,7 @@ static void ssusb_host_setup(struct ssusb_mtk *ssusb)
 	ssusb_host_enable(ssusb);
 
 	/* if port0 supports dual-role, works as host mode by default */
-	if (ssusb->dr_mode == USB_DR_MODE_HOST)
-		ssusb_set_vbus(&ssusb->otg_switch, 1);
+	ssusb_set_vbus(&ssusb->otg_switch, 1);
 }
 
 static void ssusb_host_cleanup(struct ssusb_mtk *ssusb)
diff --git a/drivers/usb/mtu3/mtu3_host_v2.c b/drivers/usb/mtu3/mtu3_host_v2.c
index 8651479..b557af1 100644
--- a/drivers/usb/mtu3/mtu3_host_v2.c
+++ b/drivers/usb/mtu3/mtu3_host_v2.c
@@ -22,96 +22,9 @@
 
 #include "mtu3.h"
 #include "mtu3_hal.h"
-#include "mtu3_dr.h"
 
 #include <linux/phy/mediatek/mtk_usb_phy.h>
 
-/* mt8173 etc */
-#define PERI_WK_CTRL1	0x4
-#define WC1_IS_C(x)	(((x) & 0xf) << 26)  /* cycle debounce */
-#define WC1_IS_EN	BIT(25)
-#define WC1_IS_P	BIT(6)  /* polarity for ip sleep */
-
-/* mt8183 */
-#define PERI_WK_CTRL0	0x0
-#define WC0_IS_C(x)	(((x) & 0xfU) << 28) /* cycle debounce */
-#define WC0_IS_P	BIT(12) /* polarity */
-#define WC0_IS_EN	BIT(6)
-
-/* mt2712 etc */
-#define PERI_SSUSB_SPM_CTRL	0x0
-#define SSC_IP_SLEEP_EN	BIT(4)
-#define SSC_SPM_INT_EN		BIT(1)
-
-enum ssusb_uwk_vers {
-	SSUSB_UWK_V1 = 1,
-	SSUSB_UWK_V2,
-	SSUSB_UWK_V1_1 = 101, /* specific revision 1.01 */
-};
-
-/*
- * ip-sleep wakeup mode:
- * all clocks can be turn off, but power domain should be kept on
- */
-static void ssusb_wakeup_ip_sleep_set(struct ssusb_mtk *ssusb, bool enable)
-{
-	u32 reg, msk, val;
-
-	dev_info(ssusb->dev, "%s %d\n", __func__, enable);
-
-	switch (ssusb->uwk_vers) {
-	case SSUSB_UWK_V1:
-		reg = ssusb->uwk_reg_base + PERI_WK_CTRL1;
-		msk = WC1_IS_EN | WC1_IS_C(0xf) | WC1_IS_P;
-		val = enable ? (WC1_IS_EN | WC1_IS_C(0x8)) : 0;
-		break;
-	case SSUSB_UWK_V2:
-		reg = ssusb->uwk_reg_base + PERI_SSUSB_SPM_CTRL;
-		msk = SSC_IP_SLEEP_EN | SSC_SPM_INT_EN;
-		val = enable ? msk : 0;
-		break;
-	case SSUSB_UWK_V1_1:
-		reg = ssusb->uwk_reg_base + PERI_WK_CTRL0;
-		msk = WC0_IS_EN | WC0_IS_C(0xf) | WC0_IS_P;
-		val = enable ? (WC0_IS_EN | WC0_IS_C(0x8)) : 0;
-		break;
-	default:
-		return;
-	}
-	regmap_update_bits(ssusb->uwk, reg, msk, val);
-}
-
-int ssusb_wakeup_of_property_parse(struct ssusb_mtk *ssusb,
-				struct device_node *dn)
-{
-	struct of_phandle_args args;
-	int ret;
-
-	/* wakeup function is optional */
-	ssusb->wakeup_en = of_property_read_bool(dn, "wakeup-source");
-	if (!ssusb->wakeup_en)
-		return 0;
-
-	ret = of_parse_phandle_with_fixed_args(dn,
-				"mediatek,syscon-wakeup", 2, 0, &args);
-	if (ret)
-		return ret;
-
-	ssusb->uwk_reg_base = args.args[0];
-	ssusb->uwk_vers = args.args[1];
-	ssusb->uwk = syscon_node_to_regmap(args.np);
-	of_node_put(args.np);
-	dev_info(ssusb->dev, "uwk - reg:0x%x, version:%d\n",
-			ssusb->uwk_reg_base, ssusb->uwk_vers);
-
-	return PTR_ERR_OR_ZERO(ssusb->uwk);
-}
-
-void ssusb_wakeup_set(struct ssusb_mtk *ssusb, bool enable)
-{
-	if (ssusb->wakeup_en)
-		ssusb_wakeup_ip_sleep_set(ssusb, enable);
-}
 
 static void host_ports_num_get(struct ssusb_mtk *ssusb)
 {
diff --git a/drivers/usb/mtu3/mtu3_hw_regs.h b/drivers/usb/mtu3/mtu3_hw_regs.h
index 66608ef..264bbfb 100644
--- a/drivers/usb/mtu3/mtu3_hw_regs.h
+++ b/drivers/usb/mtu3/mtu3_hw_regs.h
@@ -25,7 +25,6 @@
 #define SSUSB_USB3_MAC_CSR_BASE	0x1400
 #define SSUSB_USB3_SYS_CSR_BASE	0x1400
 #define SSUSB_USB2_CSR_BASE	0x2400
-#define SSUSB_XHCI_PORT0_BASE	0x420
 
 /* IPPC register in Infra */
 #define SSUSB_SIFSLV_IPPC_BASE	0x0000
@@ -340,7 +339,6 @@
 #define U3D_USB2_TEST_MODE		(SSUSB_USB2_CSR_BASE + 0x0014)
 #define U3D_COMMON_USB_INTR_ENABLE	(SSUSB_USB2_CSR_BASE + 0x0018)
 #define U3D_COMMON_USB_INTR		(SSUSB_USB2_CSR_BASE + 0x001C)
-#define U3D_USB_BUS_PERFORMANCE		(SSUSB_USB2_CSR_BASE + 0x0020)
 #define U3D_LINK_RESET_INFO		(SSUSB_USB2_CSR_BASE + 0x0024)
 #define U3D_USB20_FRAME_NUM		(SSUSB_USB2_CSR_BASE + 0x003C)
 #define U3D_USB20_LPM_PARAMETER		(SSUSB_USB2_CSR_BASE + 0x0044)
@@ -386,9 +384,6 @@
 #define RESUME_INTR		BIT(1)
 #define SUSPEND_INTR		BIT(0)
 
-/* U3D_USB_UBS_PERFORMANCE */
-#define NOISE_STILL_TRANSFER		BIT(21)
-
 /* U3D_LINK_RESET_INFO */
 #define WTCHRP_MSK		GENMASK(19, 16)
 
@@ -470,16 +465,8 @@
 #define SSUSB_U3_PORT_DIS		BIT(0)
 
 /* U3D_SSUSB_U2_CTRL_0P */
-#define SSUSB_U2_PORT_RG_IDDIG		BIT(12)
-#define SSUSB_U2_PORT_FORCE_IDDIG	BIT(11)
-#define SSUSB_U2_PORT_VBUSVALID		BIT(9)
 #define SSUSB_U2_PORT_OTG_SEL		BIT(7)
-#if IS_ENABLED(CONFIG_USB_MTU3_PLAT_PHONE)
 #define SSUSB_U2_PORT_HOST_SEL		BIT(2)
-#else
-#define SSUSB_U2_PORT_HOST_SEL	(SSUSB_U2_PORT_VBUSVALID | SSUSB_U2_PORT_HOST)
-#endif
-#define SSUSB_U2_PORT_HOST		BIT(2)
 #define SSUSB_U2_PORT_PDN		BIT(1)
 #define SSUSB_U2_PORT_DIS		BIT(0)
 
diff --git a/drivers/usb/mtu3/mtu3_plat.c b/drivers/usb/mtu3/mtu3_plat.c
index 30b0f78..b3381dd 100644
--- a/drivers/usb/mtu3/mtu3_plat.c
+++ b/drivers/usb/mtu3/mtu3_plat.c
@@ -26,27 +26,11 @@
 
 #include "mtu3.h"
 #include "mtu3_dr.h"
-#include <mtk_sloa_fs.h>
-
-#ifdef CONFIG_MTK_USB2JTAG_SUPPORT
-#include <mtk_usb2jtag.h>
-#endif
-
-#define PORT_PLS_MASK   (0xf << 5)
-#define XDEV_U0         (0x0 << 5)
-#define XDEV_U1         (0x1 << 5)
-#define XDEV_U2         (0x2 << 5)
-#define XDEV_U3         (0x3 << 5)
-#define XDEV_DISABLED   (0x4 << 5)
-#define XDEV_RXDETECT   (0x5 << 5)
-#define XDEV_INACTIVE   (0x6 << 5)
-#define XDEV_POLLING    (0x7 << 5)
-#define XDEV_RECOVERY   (0x8 << 5)
-#define XDEV_HOT_RESET  (0x9 << 5)
-#define XDEV_COMP_MODE  (0xa << 5)
-#define XDEV_TEST_MODE  (0xb << 5)
-#define XDEV_RESUME     (0xf << 5)
 
+bool is_saving_mode(void)
+{
+	return false;
+}
 
 /* u2-port0 should be powered on and enabled; */
 int ssusb_check_clocks(struct ssusb_mtk *ssusb, u32 ex_clks)
@@ -104,7 +88,7 @@ static int ssusb_phy_exit(struct ssusb_mtk *ssusb)
 	return 0;
 }
 
-int ssusb_phy_power_on(struct ssusb_mtk *ssusb)
+static int ssusb_phy_power_on(struct ssusb_mtk *ssusb)
 {
 	int i;
 	int ret;
@@ -123,7 +107,7 @@ power_off_phy:
 	return ret;
 }
 
-void ssusb_phy_power_off(struct ssusb_mtk *ssusb)
+static void ssusb_phy_power_off(struct ssusb_mtk *ssusb)
 {
 	unsigned int i;
 
@@ -131,9 +115,15 @@ void ssusb_phy_power_off(struct ssusb_mtk *ssusb)
 		phy_power_off(ssusb->phys[i]);
 }
 
-int ssusb_clks_enable(struct ssusb_mtk *ssusb)
+static int ssusb_rscs_init(struct ssusb_mtk *ssusb)
 {
-	int ret;
+	int ret = 0;
+
+	ret = regulator_enable(ssusb->vusb33);
+	if (ret) {
+		dev_err(ssusb->dev, "failed to enable vusb33\n");
+		goto vusb33_err;
+	}
 
 	ret = clk_prepare_enable(ssusb->sys_clk);
 	if (ret) {
@@ -147,61 +137,6 @@ int ssusb_clks_enable(struct ssusb_mtk *ssusb)
 		goto ref_clk_err;
 	}
 
-	ret = clk_prepare_enable(ssusb->mcu_clk);
-	if (ret) {
-		dev_err(ssusb->dev, "failed to enable mcu_clk\n");
-		goto mcu_clk_err;
-	}
-
-	ret = clk_prepare_enable(ssusb->dma_clk);
-	if (ret) {
-		dev_err(ssusb->dev, "failed to enable dma_clk\n");
-		goto dma_clk_err;
-	}
-
-	ret = clk_prepare_enable(ssusb->xhci_clk);
-	if (ret) {
-		dev_err(ssusb->dev, "failed to enable xhci_clk\n");
-		goto xhci_clk_err;
-	}
-
-	return 0;
-
-xhci_clk_err:
-	clk_disable_unprepare(ssusb->dma_clk);
-dma_clk_err:
-	clk_disable_unprepare(ssusb->mcu_clk);
-mcu_clk_err:
-	clk_disable_unprepare(ssusb->ref_clk);
-ref_clk_err:
-	clk_disable_unprepare(ssusb->sys_clk);
-sys_clk_err:
-	return ret;
-}
-
-void ssusb_clks_disable(struct ssusb_mtk *ssusb)
-{
-	clk_disable_unprepare(ssusb->xhci_clk);
-	clk_disable_unprepare(ssusb->dma_clk);
-	clk_disable_unprepare(ssusb->mcu_clk);
-	clk_disable_unprepare(ssusb->ref_clk);
-	clk_disable_unprepare(ssusb->sys_clk);
-}
-
-static int ssusb_rscs_init(struct ssusb_mtk *ssusb)
-{
-	int ret = 0;
-
-	ret = regulator_enable(ssusb->vusb33);
-	if (ret) {
-		dev_err(ssusb->dev, "failed to enable vusb33\n");
-		goto vusb33_err;
-	}
-
-	ret = ssusb_clks_enable(ssusb);
-	if (ret)
-		goto clks_err;
-
 	ret = ssusb_phy_init(ssusb);
 	if (ret) {
 		dev_err(ssusb->dev, "failed to init phy\n");
@@ -219,22 +154,26 @@ static int ssusb_rscs_init(struct ssusb_mtk *ssusb)
 phy_err:
 	ssusb_phy_exit(ssusb);
 phy_init_err:
-	ssusb_clks_disable(ssusb);
-clks_err:
+	clk_disable_unprepare(ssusb->ref_clk);
+ref_clk_err:
+	clk_disable_unprepare(ssusb->sys_clk);
+sys_clk_err:
 	regulator_disable(ssusb->vusb33);
 vusb33_err:
+
 	return ret;
 }
 
 static void ssusb_rscs_exit(struct ssusb_mtk *ssusb)
 {
-	ssusb_clks_disable(ssusb);
+	clk_disable_unprepare(ssusb->sys_clk);
+	clk_disable_unprepare(ssusb->ref_clk);
 	regulator_disable(ssusb->vusb33);
 	ssusb_phy_power_off(ssusb);
 	ssusb_phy_exit(ssusb);
 }
 
-void ssusb_ip_sw_reset(struct ssusb_mtk *ssusb)
+static void ssusb_ip_sw_reset(struct ssusb_mtk *ssusb)
 {
 	/* reset whole ip (xhci & u3d) */
 	mtu3_setbits(ssusb->ippc_base, U3D_SSUSB_IP_PW_CTRL0, SSUSB_IP_SW_RST);
@@ -242,19 +181,6 @@ void ssusb_ip_sw_reset(struct ssusb_mtk *ssusb)
 	mtu3_clrbits(ssusb->ippc_base, U3D_SSUSB_IP_PW_CTRL0, SSUSB_IP_SW_RST);
 }
 
-/* ignore the error if the clock does not exist */
-static struct clk *get_optional_clk(struct device *dev, const char *id)
-{
-	struct clk *opt_clk;
-
-	opt_clk = devm_clk_get(dev, id);
-	/* ignore error number except EPROBE_DEFER */
-	if (IS_ERR(opt_clk) && (PTR_ERR(opt_clk) != -EPROBE_DEFER))
-		opt_clk = NULL;
-
-	return opt_clk;
-}
-
 static int get_iddig_pinctrl(struct ssusb_mtk *ssusb)
 {
 	struct otg_switch_mtk *otg_sx = &ssusb->otg_switch;
@@ -304,27 +230,24 @@ static int get_ssusb_rscs(struct platform_device *pdev, struct ssusb_mtk *ssusb)
 		return PTR_ERR(ssusb->sys_clk);
 	}
 
-	ssusb->ref_clk = get_optional_clk(dev, "ref_ck");
-	if (IS_ERR(ssusb->ref_clk))
-		return PTR_ERR(ssusb->ref_clk);
-
-	ssusb->mcu_clk = get_optional_clk(dev, "mcu_ck");
-	if (IS_ERR(ssusb->mcu_clk))
-		return PTR_ERR(ssusb->mcu_clk);
-
-	ssusb->dma_clk = get_optional_clk(dev, "dma_ck");
-	if (IS_ERR(ssusb->dma_clk))
-		return PTR_ERR(ssusb->dma_clk);
+	/*
+	 * reference clock is usually a "fixed-clock", make it optional
+	 * for backward compatibility and ignore the error if it does
+	 * not exist.
+	 */
+	ssusb->ref_clk = devm_clk_get(dev, "ref_ck");
+	if (IS_ERR(ssusb->ref_clk)) {
+		if (PTR_ERR(ssusb->ref_clk) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
 
-	ssusb->xhci_clk = get_optional_clk(dev, "xhci_ck");
-	if (IS_ERR(ssusb->xhci_clk))
-		return PTR_ERR(ssusb->xhci_clk);
+		ssusb->ref_clk = NULL;
+	}
 
 	ssusb->num_phys = of_count_phandle_with_args(node,
 			"phys", "#phy-cells");
 	if (ssusb->num_phys > 0) {
 		ssusb->phys = devm_kcalloc(dev, ssusb->num_phys,
-				sizeof(*ssusb->phys), GFP_KERNEL);
+					sizeof(*ssusb->phys), GFP_KERNEL);
 		if (!ssusb->phys)
 			return -ENOMEM;
 	} else {
@@ -339,18 +262,12 @@ static int get_ssusb_rscs(struct platform_device *pdev, struct ssusb_mtk *ssusb)
 		}
 	}
 
-	if (ssusb->num_phys > 1)
-		ssusb->keep_ao = true;
-
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ippc");
 	ssusb->ippc_base = devm_ioremap_resource(dev, res);
-	if (IS_ERR(ssusb->ippc_base))
+	if (IS_ERR(ssusb->ippc_base)) {
+		dev_info(dev, "failed to map memory for ippc\n");
 		return PTR_ERR(ssusb->ippc_base);
-
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "xhci");
-	ssusb->xhci_base = devm_ioremap(dev, res->start, resource_size(res));
-	if (IS_ERR(ssusb->xhci_base))
-		return PTR_ERR(ssusb->xhci_base);
+	}
 
 	ssusb->dr_mode = usb_get_dr_mode(dev);
 	if (ssusb->dr_mode == USB_DR_MODE_UNKNOWN) {
@@ -397,21 +314,12 @@ static int get_ssusb_rscs(struct platform_device *pdev, struct ssusb_mtk *ssusb)
 		}
 	}
 
-	dev_info(dev, "dr_mode: %d, is_u3_dr: %d keep-ao: %d\n",
-		ssusb->dr_mode, otg_sx->is_u3_drd, ssusb->keep_ao);
+	dev_info(dev, "dr_mode: %d, is_u3_dr: %d\n",
+		ssusb->dr_mode, otg_sx->is_u3_drd);
 
 	return 0;
 }
 
-static void otg_detect_work_func(struct work_struct *work)
-{
-	struct delayed_work *dwork = to_delayed_work(work);
-	struct ssusb_mtk *ssusb =
-		container_of(dwork, struct ssusb_mtk, otg_detect_dwork);
-
-	ssusb_otg_detect(ssusb);
-}
-
 static int mtu3_probe(struct platform_device *pdev)
 {
 	struct device_node *node = pdev->dev.of_node;
@@ -419,11 +327,6 @@ static int mtu3_probe(struct platform_device *pdev)
 	struct ssusb_mtk *ssusb;
 	int ret = -ENOMEM;
 
-#ifdef CONFIG_MTK_USB2JTAG_SUPPORT
-	if (usb2jtag_mode())
-		return 0;
-#endif
-
 	/* all elements are set to ZERO as default value */
 	ssusb = devm_kzalloc(dev, sizeof(*ssusb), GFP_KERNEL);
 	if (!ssusb)
@@ -458,6 +361,9 @@ static int mtu3_probe(struct platform_device *pdev)
 	else if (IS_ENABLED(CONFIG_USB_MTU3_GADGET))
 		ssusb->dr_mode = USB_DR_MODE_PERIPHERAL;
 
+	/* default as host */
+	ssusb->is_host = !(ssusb->dr_mode == USB_DR_MODE_PERIPHERAL);
+
 	switch (ssusb->dr_mode) {
 	case USB_DR_MODE_PERIPHERAL:
 		ret = ssusb_gadget_init(ssusb);
@@ -480,16 +386,10 @@ static int mtu3_probe(struct platform_device *pdev)
 			goto comm_exit;
 		}
 
-		if (ssusb->keep_ao) {
-			ret = ssusb_host_init(ssusb, node);
-			if (ret) {
-				dev_err(dev, "failed to initialize host\n");
-				goto gadget_exit;
-			}
-		}
-		if (!ssusb->keep_ao) {
-			ssusb_clks_disable(ssusb);
-			ssusb_phy_power_off(ssusb);
+		ret = ssusb_host_init(ssusb, node);
+		if (ret) {
+			dev_err(dev, "failed to initialize host\n");
+			goto gadget_exit;
 		}
 
 		ssusb_otg_switch_init(ssusb);
@@ -500,9 +400,6 @@ static int mtu3_probe(struct platform_device *pdev)
 		goto comm_exit;
 	}
 
-	sloa_suspend_infra_power(true);
-	INIT_DELAYED_WORK(&ssusb->otg_detect_dwork, otg_detect_work_func);
-
 	return 0;
 
 gadget_exit:
@@ -520,11 +417,6 @@ static int mtu3_remove(struct platform_device *pdev)
 {
 	struct ssusb_mtk *ssusb = platform_get_drvdata(pdev);
 
-#ifdef CONFIG_MTK_USB2JTAG_SUPPORT
-	if (usb2jtag_mode())
-		return 0;
-#endif
-
 	switch (ssusb->dr_mode) {
 	case USB_DR_MODE_PERIPHERAL:
 		ssusb_gadget_exit(ssusb);
@@ -548,23 +440,6 @@ static int mtu3_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static bool is_usb_dev_connect(struct ssusb_mtk *ssusb, u32 port_num)
-{
-	u32 portsc;
-
-	portsc = mtu3_readl(ssusb->xhci_base,
-			(SSUSB_XHCI_PORT0_BASE+(port_num * 0x10)));
-	switch (portsc & PORT_PLS_MASK) {
-	case XDEV_U0:
-	case XDEV_U1:
-	case XDEV_U2:
-	case XDEV_U3:
-		return true;
-	default:
-		return false;
-	}
-}
-
 /*
  * when support dual-role mode, we reject suspend when
  * it works as device mode;
@@ -573,42 +448,18 @@ static int __maybe_unused mtu3_suspend(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct ssusb_mtk *ssusb = platform_get_drvdata(pdev);
-	bool port0_dev_exist = false;
-	bool port1_dev_exist = false;
 
 	dev_dbg(dev, "%s\n", __func__);
 
-#ifdef CONFIG_MTK_USB2JTAG_SUPPORT
-	if (usb2jtag_mode())
+	/* REVISIT: disconnect it for only device mode? */
+	if (!ssusb->is_host)
 		return 0;
-#endif
-
-	if (ssusb->is_host)
-		port0_dev_exist = is_usb_dev_connect(ssusb, 0);
-	if (ssusb->keep_ao)
-		port1_dev_exist = is_usb_dev_connect(ssusb, 1);
-
-	/*Current USB IP enter idle mode, do not need suspend*/
-	if (port0_dev_exist || port1_dev_exist)
-		ssusb->infra_on = true;
-	else
-		ssusb->infra_on = false;
-
-	if (ssusb->keep_ao || ssusb->is_host) {
-		if (!ssusb->infra_on)
-			ssusb_host_exit(ssusb);
 
-		if (ssusb->is_host || ssusb->keep_ao)
-			ssusb_wakeup_enable(ssusb);
-
-		dev_dbg(dev, "Do phy power and clock off\n");
-		ssusb_phy_power_off(ssusb);
-		ssusb_clks_disable(ssusb);
-	}
-	if (!ssusb->infra_on) {
-		dev_dbg(dev, "Infra power off\n");
-		sloa_suspend_infra_power(false);
-	}
+	ssusb_host_disable(ssusb, true);
+	ssusb_phy_power_off(ssusb);
+	clk_disable_unprepare(ssusb->sys_clk);
+	clk_disable_unprepare(ssusb->ref_clk);
+	ssusb_wakeup_enable(ssusb);
 
 	return 0;
 }
@@ -616,58 +467,20 @@ static int __maybe_unused mtu3_suspend(struct device *dev)
 static int __maybe_unused mtu3_resume(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	struct device_node *node = pdev->dev.of_node;
 	struct ssusb_mtk *ssusb = platform_get_drvdata(pdev);
-	void __iomem *ibase;
-	int ret;
-
-#ifdef CONFIG_MTK_USB2JTAG_SUPPORT
-	if (usb2jtag_mode())
-		return 0;
-#endif
-	ibase = ssusb->ippc_base;
 
-	if (!ssusb->infra_on)
-		sloa_suspend_infra_power(true);
-
-	if (ssusb->keep_ao || ssusb->is_host) {
-		ret = ssusb_clks_enable(ssusb);
-		if (ret)
-			goto clks_err;
+	dev_dbg(dev, "%s\n", __func__);
 
-		ret = ssusb_phy_power_on(ssusb);
-		if (ret)
-			goto err_power_on;
-
-		if (ssusb->keep_ao && !ssusb->infra_on) {
-			ssusb_ip_sw_reset(ssusb);
-			mtu3_setbits(ibase, U3D_SSUSB_DEV_RST_CTRL,
-				SSUSB_DEV_SW_RST);
-			udelay(1);
-			mtu3_clrbits(ibase, U3D_SSUSB_DEV_RST_CTRL,
-				SSUSB_DEV_SW_RST);
-			ret = ssusb_host_init(ssusb, node);
-			if (ret) {
-				dev_err(dev, "failed to initialize host\n");
-				goto err_host_init;
-			}
-		}
-	}
-	if (ssusb->is_host)
-		ssusb_wakeup_disable(ssusb);
+	if (!ssusb->is_host)
+		return 0;
 
-	if (!ssusb->infra_on)
-		schedule_delayed_work(&ssusb->otg_detect_dwork, 1*HZ);
+	ssusb_wakeup_disable(ssusb);
+	clk_prepare_enable(ssusb->sys_clk);
+	clk_prepare_enable(ssusb->ref_clk);
+	ssusb_phy_power_on(ssusb);
+	ssusb_host_enable(ssusb);
 
 	return 0;
-
-err_host_init:
-	ssusb_phy_power_off(ssusb);
-err_power_on:
-	ssusb_clks_disable(ssusb);
-clks_err:
-	sloa_suspend_infra_power(false);
-	return ret;
 }
 
 static const struct dev_pm_ops mtu3_pm_ops = {
@@ -680,7 +493,6 @@ static const struct dev_pm_ops mtu3_pm_ops = {
 
 static const struct of_device_id mtu3_of_match[] = {
 	{.compatible = "mediatek,mt8173-mtu3",},
-	{.compatible = "mediatek,mtu3",},
 	{},
 };
 
diff --git a/drivers/usb/mtu3/mtu3_plat_v2.c b/drivers/usb/mtu3/mtu3_plat_v2.c
index 4d7f794..a1a95fb 100644
--- a/drivers/usb/mtu3/mtu3_plat_v2.c
+++ b/drivers/usb/mtu3/mtu3_plat_v2.c
@@ -40,6 +40,29 @@ MODULE_PARM_DESC(debug_level, "Debug Print Log Lvl");
  * 1: Super Speed
  */
 u32 mtu3_speed;
+static int set_musb_speed(const char *val, const struct kernel_param *kp)
+{
+	int ret;
+	u32 u3_en;
+
+	ret = kstrtou32(val, 10, &u3_en);
+	if (ret)
+		return ret;
+
+	if (u3_en != 0 && u3_en != 1)
+		return -EINVAL;
+
+	mtu3_speed = u3_en;
+
+	return 0;
+}
+static struct kernel_param_ops musb_speed_param_ops = {
+	.set = set_musb_speed,
+	.get = param_get_int,
+};
+module_param_cb(speed, &musb_speed_param_ops, &mtu3_speed, 0644);
+MODULE_PARM_DESC(debug, "USB speed configuration. default = 1, spuper speed.");
+
 
 #ifdef CONFIG_SYSFS
 const char *const mtu3_mode_str[CABLE_MODE_MAX] = { "CHRG_ONLY",
@@ -64,7 +87,6 @@ ssize_t musb_cmode_store(struct device *dev, struct device_attribute *attr,
 {
 	unsigned int cmode;
 	struct ssusb_mtk *ssusb;
-	struct extcon_dev *edev;
 
 	if (!dev) {
 		pr_info("dev is null!!\n");
@@ -78,8 +100,6 @@ ssize_t musb_cmode_store(struct device *dev, struct device_attribute *attr,
 		return count;
 	}
 
-	edev = (&ssusb->otg_switch)->edev;
-
 	if (sscanf(buf, "%ud", &cmode) == 1) {
 		if (cmode >= CABLE_MODE_MAX)
 			cmode = CABLE_MODE_NORMAL;
@@ -101,12 +121,8 @@ ssize_t musb_cmode_store(struct device *dev, struct device_attribute *attr,
 				ssusb_set_mailbox(&ssusb->otg_switch,
 					MTU3_VBUS_VALID);
 			} else {	/* IPO bootup, enable USB */
-				if (extcon_get_state(edev, EXTCON_USB_HOST))
-					ssusb_set_mailbox(&ssusb->otg_switch,
-						   MTU3_ID_GROUND);
-				else
-					ssusb_set_mailbox(&ssusb->otg_switch,
-						   MTU3_CMODE_VBUS_VALID);
+				ssusb_set_mailbox(&ssusb->otg_switch,
+					MTU3_CMODE_VBUS_VALID);
 			}
 			msleep(200);
 		}
@@ -150,55 +166,9 @@ bool is_saving_mode(void)
 	return saving_mode;
 }
 
-static ssize_t otg_enable_show(struct device *dev,
-               struct device_attribute *attr, char *buf)
-{
-   struct ssusb_mtk *ssusb;
-
-	if (!dev) {
-		pr_debug("dev is null!!\n");
-		return 0;
-	}
-
-	ssusb  = dev_to_ssusb(dev);
-   if(ssusb->otg_enable)
-       return snprintf(buf, PAGE_SIZE, "y\n");
-   else
-       return snprintf(buf, PAGE_SIZE, "n\n");
-}
-
-static ssize_t otg_enable_store(struct device *dev,
-               struct device_attribute *attr, const char *buf, size_t count)
-{
-   bool value;
-   int ret;
-   struct ssusb_mtk *ssusb;
-
-	if (!dev) {
-		pr_info("dev is null!!\n");
-		return count;
-	}
-
-	ssusb = dev_to_ssusb(dev);
-
-	if (!ssusb) {
-		pr_info("ssusb is null!!\n");
-		return count;
-	}
-
-   ret = strtobool(buf, &value);
-   if (!ret) {
-       ssusb->otg_enable = value;
-       return count;
-   }
-
-   return ret;
-}
-
 
 DEVICE_ATTR(cmode, 0664, musb_cmode_show, musb_cmode_store);
 DEVICE_ATTR(saving, 0664, musb_saving_mode_show, musb_saving_mode_store);
-DEVICE_ATTR(otgenable, 0664, otg_enable_show, otg_enable_store);
 
 #ifdef CONFIG_MTK_UART_USB_SWITCH
 #include <linux/phy/mediatek/mtk_usb_phy.h>
@@ -289,7 +259,7 @@ ssize_t musb_sib_enable_show(struct device *dev,
 ssize_t musb_sib_enable_store(struct device *dev, struct device_attribute *attr,
 			    const char *buf, size_t count)
 {
-	unsigned int mode = 0;
+	unsigned int mode;
 	struct ssusb_mtk *ssusb;
 
 	if (!dev) {
@@ -319,7 +289,6 @@ struct attribute *mtu3_attributes[] = {
 #ifdef CONFIG_MTK_SIB_USB_SWITCH
 	&dev_attr_sib_enable.attr,
 #endif
-        &dev_attr_otgenable.attr,
 	NULL
 };
 
@@ -416,14 +385,6 @@ static int ssusb_rscs_init(struct ssusb_mtk *ssusb)
 {
 	int ret = 0;
 
-#ifdef CONFIG_FPGA_EARLY_PORTING
-	ret = ssusb_phy_init(ssusb);
-	ret |= ssusb_phy_power_on(ssusb);
-	if (ret)
-		dev_info(ssusb->dev, "failed to init phy on FPGA\n");
-
-	return 0;
-#else
 	ret = regulator_enable(ssusb->vusb33);
 	if (ret) {
 		dev_info(ssusb->dev, "failed to enable vusb33\n");
@@ -462,7 +423,6 @@ sys_clk_err:
 vusb33_err:
 
 	return ret;
-#endif
 }
 #endif
 
@@ -484,19 +444,6 @@ static void ssusb_ip_sw_reset(struct ssusb_mtk *ssusb)
 }
 #endif
 
-/* ignore the error if the clock does not exist */
-static struct clk *get_optional_clk(struct device *dev, const char *id)
-{
-	struct clk *opt_clk;
-
-	opt_clk = devm_clk_get(dev, id);
-	/* ignore error number except EPROBE_DEFER */
-	if (IS_ERR(opt_clk) && (PTR_ERR(opt_clk) != -EPROBE_DEFER))
-		opt_clk = NULL;
-
-	return opt_clk;
-}
-
 static int get_ssusb_rscs(struct platform_device *pdev, struct ssusb_mtk *ssusb)
 {
 	struct device_node *node = pdev->dev.of_node;
@@ -504,50 +451,25 @@ static int get_ssusb_rscs(struct platform_device *pdev, struct ssusb_mtk *ssusb)
 	struct device *dev = &pdev->dev;
 	struct resource *res;
 	int i;
-	int ret;
 
-#ifdef CONFIG_FPGA_EARLY_PORTING
-	ret = of_property_read_u32(node, "fpga_phy_ver", &ssusb->fpga_phy_ver);
-	if (ret)
-		dev_info(dev, "unknown FPGA phy version\n");
-#else
 	ssusb->vusb33 = devm_regulator_get(&pdev->dev, "vusb");
 	if (IS_ERR(ssusb->vusb33)) {
 		dev_info(dev, "failed to get vusb33\n");
 		return PTR_ERR(ssusb->vusb33);
 	}
 
-	ssusb->sys_clk = get_optional_clk(dev, "sys_ck");
+	ssusb->sys_clk = devm_clk_get(dev, "sys_ck");
 	if (IS_ERR(ssusb->sys_clk)) {
 		dev_info(dev, "failed to get sys clock\n");
 		return PTR_ERR(ssusb->sys_clk);
 	}
 
-	ssusb->ref_clk = get_optional_clk(dev, "rel_clk");
+	ssusb->ref_clk = devm_clk_get(dev, "rel_clk");
 	if (IS_ERR(ssusb->ref_clk)) {
 		dev_info(dev, "failed to get ref clock\n");
 		return PTR_ERR(ssusb->ref_clk);
 	}
 
-	ssusb->mcu_clk = get_optional_clk(dev, "mcu_ck");
-	if (IS_ERR(ssusb->mcu_clk)) {
-		dev_info(dev, "failed to get mcu clock\n");
-		return PTR_ERR(ssusb->mcu_clk);
-	}
-
-	ssusb->dma_clk = get_optional_clk(dev, "dma_ck");
-	if (IS_ERR(ssusb->dma_clk)) {
-		dev_info(dev, "failed to get dma clock\n");
-		return PTR_ERR(ssusb->dma_clk);
-	}
-
-	ssusb->host_clk = get_optional_clk(dev, "host_ck");
-	if (IS_ERR(ssusb->host_clk)) {
-		dev_info(dev, "failed to get host clock\n");
-		return PTR_ERR(ssusb->host_clk);
-	}
-
-#endif
 	ssusb->num_phys = of_count_phandle_with_args(node,
 			"phys", "#phy-cells");
 
@@ -570,11 +492,6 @@ static int get_ssusb_rscs(struct platform_device *pdev, struct ssusb_mtk *ssusb)
 	}
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ippc");
-	if (IS_ERR_OR_NULL(res)) {
-		dev_info(dev, "failed to get resource for ippc\n");
-		return -ENOMEM;
-	}
-
 	ssusb->ippc_base = devm_ioremap(dev, res->start, resource_size(res));
 	if (IS_ERR(ssusb->ippc_base)) {
 		dev_info(dev, "failed to map memory for ippc\n");
@@ -589,19 +506,10 @@ static int get_ssusb_rscs(struct platform_device *pdev, struct ssusb_mtk *ssusb)
 
 	ssusb->force_vbus =
 		of_property_read_bool(node, "mediatek,force_vbus_det");
-	ssusb->noise_still_tr =
-		of_property_read_bool(node, "mediatek,noise_still_tr");
 
 	if (ssusb->dr_mode == USB_DR_MODE_PERIPHERAL)
 		return 0;
 
-	/* if host role is supported */
-	ret = ssusb_wakeup_of_property_parse(ssusb, node);
-	if (ret) {
-		dev_err(dev, "failed to parse uwk property\n");
-		return ret;
-	}
-
 	if (ssusb->dr_mode != USB_DR_MODE_OTG)
 		return 0;
 
@@ -611,9 +519,6 @@ static int get_ssusb_rscs(struct platform_device *pdev, struct ssusb_mtk *ssusb)
 	otg_sx->is_u3h_drd = of_property_read_bool(node,
 				"mediatek,usb3h-drd");
 
-#ifdef CONFIG_FPGA_EARLY_PORTING
-	/* May be no extcon in FPGA stage */
-#else
 	if (of_property_read_bool(node, "extcon")) {
 		otg_sx->edev = extcon_get_edev_by_phandle(ssusb->dev, 0);
 		if (IS_ERR(otg_sx->edev)) {
@@ -621,7 +526,6 @@ static int get_ssusb_rscs(struct platform_device *pdev, struct ssusb_mtk *ssusb)
 			return -EPROBE_DEFER;
 		}
 	}
-#endif
 
 	dev_info(dev, "dr_mode: %d, is_u3_dr: %d, is_u3h_dr: %d\n",
 		ssusb->dr_mode, otg_sx->is_u3_drd, otg_sx->is_u3h_drd);
@@ -651,11 +555,6 @@ static int mtu3_probe(struct platform_device *pdev)
 	ssusb->dev = dev;
 
 	dev_set_name(dev, "musb-hdrc");
-	/*
-	 * fix uaf(use afer free) issue:backup pdev->name,
-	 * device_rename will free pdev->name
-	 */
-	pdev->name = pdev->dev.kobj.name;
 
 	ret = get_ssusb_rscs(pdev, ssusb);
 	if (ret)
@@ -796,9 +695,7 @@ static int __maybe_unused mtu3_suspend(struct device *dev)
 	ssusb_host_disable(ssusb, ssusb->is_host);
 	/* ssusb_phy_power_off(ssusb); */
 	ssusb_clk_off(ssusb, ssusb->is_host);
-	ssusb_wakeup_mode_enable(ssusb);
-	ssusb_wakeup_set(ssusb, true);
-	ssusb_dpidle_request(USB_DPIDLE_SUSPEND);
+	usb_wakeup_enable(ssusb);
 	return 0;
 }
 
@@ -812,9 +709,7 @@ static int __maybe_unused mtu3_resume(struct device *dev)
 	if (!ssusb->is_host)
 		return 0;
 
-	ssusb_dpidle_request(USB_DPIDLE_RESUME);
-	ssusb_wakeup_set(ssusb, false);
-	ssusb_wakeup_mode_disable(ssusb);
+	usb_wakeup_disable(ssusb);
 	ssusb_clk_on(ssusb, ssusb->is_host);
 	/* ssusb_phy_power_on(ssusb); */
 	ssusb_host_enable(ssusb);
@@ -830,12 +725,10 @@ static const struct dev_pm_ops mtu3_pm_ops = {
 #ifdef CONFIG_OF
 
 static const struct of_device_id mtu3_of_match[] = {
-	{.compatible = "mediatek,mt6885-mtu3",},
-	{.compatible = "mediatek,mt6853-mtu3",},
-	{.compatible = "mediatek,mt6877-mtu3",},
-	{.compatible = "mediatek,mt6873-mtu3",},
+	{.compatible = "mediatek,mt6758-mtu3",},
+	{.compatible = "mediatek,mt3967-mtu3",},
+	{.compatible = "mediatek,mt6779-mtu3",},
 	{.compatible = "mediatek,mt6785-mtu3",},
-	{.compatible = "mediatek,mt6771-mtu3",},
 	{},
 };
 
diff --git a/drivers/usb/mtu3/mtu3_qmu.c b/drivers/usb/mtu3/mtu3_qmu.c
index 2b4c334..a766f7a 100644
--- a/drivers/usb/mtu3/mtu3_qmu.c
+++ b/drivers/usb/mtu3/mtu3_qmu.c
@@ -2,6 +2,7 @@
  * mtu3_qmu.c - Queue Management Unit driver for device controller
  *
  * Copyright (C) 2016 MediaTek Inc.
+ * Copyright (C) 2019 XiaoMi, Inc.
  *
  * Author: Chunfeng Yun <chunfeng.yun@mediatek.com>
  *
@@ -224,8 +225,6 @@ static int mtu3_prepare_tx_gpd(struct mtu3_ep *mep, struct mtu3_request *mreq)
 		gpd->ext_flag |= GPD_EXT_FLAG_ZLP;
 
 	gpd->chksum = qmu_calc_checksum((u8 *)gpd);
-	/* requires a memory barrier */
-	smp_mb();
 	gpd->flag |= GPD_FLAGS_HWO;
 
 	mreq->gpd = gpd;
@@ -265,8 +264,6 @@ static int mtu3_prepare_rx_gpd(struct mtu3_ep *mep, struct mtu3_request *mreq)
 
 	gpd->next_gpd = cpu_to_le32((u32)gpd_virt_to_dma(ring, enq));
 	gpd->chksum = qmu_calc_checksum((u8 *)gpd);
-	/* requires a memory barrier */
-	smp_mb();
 	gpd->flag |= GPD_FLAGS_HWO;
 
 	mreq->gpd = gpd;
@@ -392,7 +389,7 @@ static void qmu_tx_zlp_error_handler(struct mtu3 *mtu, u8 epnum)
 
 	gpd_current = gpd_dma_to_virt(ring, gpd_dma);
 
-	if (!gpd_current || le16_to_cpu(gpd_current->buf_len) != 0) {
+	if (le16_to_cpu(gpd_current->buf_len) != 0) {
 		dev_err(mtu->dev, "TX EP%d buffer length error(!=0)\n", epnum);
 		return;
 	}
@@ -412,9 +409,6 @@ static void qmu_tx_zlp_error_handler(struct mtu3 *mtu, u8 epnum)
 	/* by pass the current GDP */
 	gpd_current->flag |= GPD_FLAGS_BPS;
 	gpd_current->chksum = qmu_calc_checksum((u8 *)gpd_current);
-
-	/* requires a memory barrier */
-	smp_mb();
 	gpd_current->flag |= GPD_FLAGS_HWO;
 
 	/*enable DMAREQEN, switch back to QMU mode */
@@ -446,8 +440,7 @@ static void qmu_done_tx(struct mtu3 *mtu, u8 epnum)
 	dev_dbg(mtu->dev, "%s EP%d, last=%p, current=%p, enq=%p\n",
 		__func__, epnum, gpd, gpd_current, ring->enqueue);
 
-	while (gpd != NULL && gpd != gpd_current &&
-			!(gpd->flag & GPD_FLAGS_HWO)) {
+	while (gpd && gpd != gpd_current && !(gpd->flag & GPD_FLAGS_HWO)) {
 
 		mreq = next_request(mep);
 
@@ -461,6 +454,11 @@ static void qmu_done_tx(struct mtu3 *mtu, u8 epnum)
 		mtu3_req_complete(mep, request, 0);
 
 		gpd = advance_deq_gpd(ring);
+
+		if (!gpd) {
+			pr_err("[TX][ERROR] EP%d, Next GPD is null!!\n", epnum);
+			return;
+		}
 	}
 
 	dev_dbg(mtu->dev, "%s EP%d, deq=%p, enq=%p, complete\n",
@@ -484,8 +482,7 @@ static void qmu_done_rx(struct mtu3 *mtu, u8 epnum)
 	dev_dbg(mtu->dev, "%s EP%d, last=%p, current=%p, enq=%p\n",
 		__func__, epnum, gpd, gpd_current, ring->enqueue);
 
-	while (gpd != NULL && gpd != gpd_current &&
-			!(gpd->flag & GPD_FLAGS_HWO)) {
+	while (gpd && gpd != gpd_current && !(gpd->flag & GPD_FLAGS_HWO)) {
 
 		mreq = next_request(mep);
 
@@ -499,6 +496,11 @@ static void qmu_done_rx(struct mtu3 *mtu, u8 epnum)
 		mtu3_req_complete(mep, req, 0);
 
 		gpd = advance_deq_gpd(ring);
+
+		if (!gpd) {
+			pr_err("[RX][ERROR] EP%d, Next GPD is null!!\n", epnum);
+			return;
+		}
 	}
 
 	dev_dbg(mtu->dev, "%s EP%d, deq=%p, enq=%p, complete\n",
diff --git a/drivers/usb/mtu3/mtu3_qmu.h b/drivers/usb/mtu3/mtu3_qmu.h
index c51d73e..4dafa16 100644
--- a/drivers/usb/mtu3/mtu3_qmu.h
+++ b/drivers/usb/mtu3/mtu3_qmu.h
@@ -19,7 +19,7 @@
 #ifndef __MTK_QMU_H__
 #define __MTK_QMU_H__
 
-#define MAX_GPD_NUM		144
+#define MAX_GPD_NUM		64
 #define QMU_GPD_SIZE		(sizeof(struct qmu_gpd))
 #define QMU_GPD_RING_SIZE	(MAX_GPD_NUM * QMU_GPD_SIZE)
 
