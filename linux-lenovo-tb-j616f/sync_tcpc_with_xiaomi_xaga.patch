diff --git a/drivers/misc/mediatek/typec/tcpc/Kconfig b/drivers/misc/mediatek/typec/tcpc/Kconfig
index 755702d..98134fd 100644
--- a/drivers/misc/mediatek/typec/tcpc/Kconfig
+++ b/drivers/misc/mediatek/typec/tcpc/Kconfig
@@ -3,8 +3,9 @@
 #
 
 config TCPC_CLASS
-	bool "TypeC Port Controller Device Class"
+	tristate "TypeC Port Controller Device Class"
 	select MTK_USB_TYPEC
+	select RT_REGMAP
 	select TYPEC
 	help
 	  Say Y to enable
@@ -13,7 +14,7 @@ config TCPC_CLASS
 	  Class
 
 config USB_POWER_DELIVERY
-	bool "Support USB power delivery Function"
+	tristate "Support USB power delivery Function"
 	depends on TCPC_CLASS
 	default n
 	help
@@ -23,7 +24,7 @@ config USB_POWER_DELIVERY
 	  support
 
 config TCPC_RT1711H
-	bool "Richtek RT1711H TypeC port Controller Driver"
+	tristate "Richtek RT1711H TypeC port Controller Driver"
 	depends on TCPC_CLASS
 	default n
 	help
@@ -33,7 +34,7 @@ config TCPC_RT1711H
 	  Driver
 
 config TCPC_RT5081
-	bool "Richtek RT5081 TypeC port Controller Driver"
+	tristate "Richtek RT5081 TypeC port Controller Driver"
 	depends on TCPC_CLASS
 	default n
 	help
@@ -42,6 +43,15 @@ config TCPC_RT5081
 	  Also Support Power Delivery
 	  Say N to disable
 
+config TCPC_MT6360
+	tristate "MediaTek MT6360 TypeC port Controller Driver"
+	depends on TCPC_CLASS
+	help
+	  Say Y to enable MediaTek MT6370
+	  TypeC port Controller
+	  Also Support Power Delivery
+	  Say N to disable
+
 config TCPC_MT6362
 	tristate "MT6362 SPMI TCPC driver"
 	depends on TCPC_CLASS
@@ -54,7 +64,7 @@ config TCPC_MT6362
 	  If so, the module will be called tcpci_mt6362
 
 config TCPC_MT6370
-	bool "MediaTek MT6370 TypeC port Controller Driver"
+	tristate "MediaTek MT6370 TypeC port Controller Driver"
 	depends on TCPC_CLASS
 	default n
 	help
@@ -63,6 +73,15 @@ config TCPC_MT6370
 	  Also Support Power Delivery
 	  Say N to disable
 
+config TCPC_MT6375
+	tristate "Mediatek MT6375 Type-C chip driver"
+	depends on TCPC_CLASS
+	depends on MFD_MT6375
+	help
+	  Mediatek MT6375 Type-C chip driver that works with
+	  Type-C Port Controller Manager to provide USB PD and USB
+	  Type-C functionalities.
+
 config USB_PD_VBUS_STABLE_TOUT
 	int "PD VBUS Stable Timeout"
 	depends on USB_POWER_DELIVERY
@@ -75,10 +94,29 @@ config USB_PD_VBUS_STABLE_TOUT
 	  stable
 
 config PD_DBG_INFO
-	bool "PD debug information"
+	tristate "PD debug information"
 	depends on TCPC_CLASS
 	default y
 	help
 	  Say Y to enable PD debug
+	  for PD DBG
 	  information
 	  Say N to disable
+
+config MTK_TYPEC_WATER_DETECT
+	tristate "Water detection function for type-c connector"
+	depends on TCPC_CLASS
+	help
+	  Say Yes to enable water detection on type-c connector.
+	  If water is detected on the connector, it will show
+	  warning to notify end user.
+	  If unsure, say N.
+
+config MTK_TYPEC_WATER_DETECT_BY_PCB
+	tristate "Let PCB decides enabling water detection or not"
+	depends on MTK_TYPEC_WATER_DETECT
+	help
+	  Query GPIO on PCB to judge whether type-c water detection
+	  need to be enabled.
+	  Say Yes to let PCB decides enabling water detection or not.
+	  If unsure, say N.
diff --git a/drivers/misc/mediatek/typec/tcpc/Makefile b/drivers/misc/mediatek/typec/tcpc/Makefile
index 3c920da..ba4a4e5 100644
--- a/drivers/misc/mediatek/typec/tcpc/Makefile
+++ b/drivers/misc/mediatek/typec/tcpc/Makefile
@@ -1,13 +1,18 @@
 subdir-ccflags-y += -Wall -Werror
-obj-$(CONFIG_DUAL_ROLE_USB_INTF)	+= tcpci_dual_role.o
+subdir-ccflags-y += -I$(srctree)/drivers/power/supply/
+subdir-ccflags-y += -I$(srctree)/drivers/misc/mediatek/rt-regmap/
+subdir-ccflags-y += -I$(srctree)/drivers/mfd/
+
 obj-$(CONFIG_TCPC_MT6360)		+= tcpc_mt6360.o
 obj-$(CONFIG_TCPC_MT6362)		+= tcpc_mt6362.o
 obj-$(CONFIG_TCPC_MT6370)		+= tcpc_mt6370.o
+obj-$(CONFIG_TCPC_MT6375)		+= tcpc_mt6375.o
 obj-$(CONFIG_TCPC_RT1711H)		+= tcpc_rt1711h.o
-obj-$(CONFIG_TCPC_CLASS)		+= tcpci_core.o tcpci_typec.o tcpci_timer.o \
-		tcpm.o tcpci.o pd_dbg_info.o tcpci_alert.o rt_pd_manager.o
 
-obj-$(CONFIG_USB_POWER_DELIVERY)	+= tcpci_event.o \
+tcpc_class-objs := tcpci_core.o tcpci_typec.o tcpci_timer.o tcpm.o tcpci.o tcpci_alert.o
+
+ifdef CONFIG_USB_POWER_DELIVERY
+tcpc_class-objs += tcpci_event.o \
 		pd_core.o pd_policy_engine.o pd_process_evt.o \
 		pd_dpm_core.o pd_dpm_uvdm.o pd_dpm_alt_mode_dp.o pd_dpm_pdo_select.o\
 		pd_dpm_reaction.o \
@@ -17,3 +22,5 @@ obj-$(CONFIG_USB_POWER_DELIVERY)	+= tcpci_event.o \
 		pd_policy_engine_src.o pd_policy_engine_snk.o pd_policy_engine_ufp.o pd_policy_engine_vcs.o \
 		pd_policy_engine_dfp.o pd_policy_engine_dr.o pd_policy_engine_drs.o pd_policy_engine_prs.o \
 		pd_policy_engine_dbg.o pd_policy_engine_com.o pd_dpm_alt_mode_dc.o
+endif
+obj-$(CONFIG_TCPC_CLASS) += tcpc_class.o tcpci_late_sync.o pd_dbg_info.o rt_pd_manager.o
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/mt6360.h b/drivers/misc/mediatek/typec/tcpc/inc/mt6360.h
index ca91316..84c1f5d 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/mt6360.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/mt6360.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2018 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #ifndef __LINUX_MT6360_H
@@ -182,7 +174,7 @@ enum mt6360_id_rupsel {
 #define MT6360_AUTOIDLE_TOUT			0x07
 
 /* timeout = (tout*2+1) * 6.4ms */
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 #define MT6360_REG_MODE_CTRL2_SET(ship_dis, auto_idle, tout) \
 	((ship_dis << 5) | (auto_idle << 3) | (tout & MT6360_AUTOIDLE_TOUT) | \
 	 MT6360_WAKEUP_EN | MT6360_ENEXTMSG)
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/mt6370.h b/drivers/misc/mediatek/typec/tcpc/inc/mt6370.h
index ec88e99..f7ac930 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/mt6370.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/mt6370.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #ifndef __LINUX_MT6370_H
@@ -143,7 +135,7 @@
 #define MT6370_REG_AUTOIDLE_EN				(1<<3)
 
 /* timeout = (tout*2+1) * 6.4ms */
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 #define MT6370_REG_IDLE_SET(ck300, ship_dis, auto_idle, tout) \
 	((ck300 << 7) | (ship_dis << 5) |\
 	 (auto_idle << 3) | (tout & 0x07) | MT6370_REG_ENEXTMSG)
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/mtk_direct_charge_vdm.h b/drivers/misc/mediatek/typec/tcpc/inc/mtk_direct_charge_vdm.h
index e2bdb66..1dba30e 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/mtk_direct_charge_vdm.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/mtk_direct_charge_vdm.h
@@ -1,15 +1,7 @@
- /*
-  * Copyright (C) 2016 MediaTek Inc.
-  *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-  *
-  * This program is distributed in the hope that it will be useful,
-  * but WITHOUT ANY WARRANTY; without even the implied warranty of
-  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-  * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
-  */
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ */
 
 
 #ifndef __LINUX_TA_VDM_H
@@ -46,7 +38,7 @@ static inline bool mtk_check_pe_ready_snk(void)
 	return false;
 }
 
-#ifdef CONFIG_TCPC_CLASS
+#if IS_ENABLED(CONFIG_TCPC_CLASS)
 
 /* tcpc_is_usb_connect
  * return PD_USB_NOT_SUPPORT : not support
@@ -82,7 +74,7 @@ static inline bool mtk_is_pep30_en_unlock(void)
 
 #endif /* CONFIG_TCPC_RT1711H */
 
-#ifdef CONFIG_RT7207_ADAPTER
+#if CONFIG_RT7207_ADAPTER
 enum { /* charge status */
 	RT7207_CC_MODE,
 	RT7207_CV_MODE,
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/pd_core.h b/drivers/misc/mediatek/typec/tcpc/inc/pd_core.h
index 10b2388..4c1ece1 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/pd_core.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/pd_core.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #ifndef PD_CORE_H_
@@ -24,7 +16,7 @@
 #define PD_BUG_ON(x)	WARN_ON(x)
 /*---------------------------------------------------------------------------*/
 
-#ifndef CONFIG_TCPC_SOURCE_VCONN
+#if !CONFIG_TCPC_SOURCE_VCONN
 #undef CONFIG_USB_PD_VCONN_SWAP
 #undef CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
 #undef CONFIG_USB_PD_DFP_READY_DISCOVER_ID
@@ -34,23 +26,30 @@
 #undef CONFIG_USB_PD_RESET_CABLE
 #endif	/* CONFIG_TCPC_SOURCE_VCONN */
 
-#ifdef CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
-#define CONFIG_PD_DISCOVER_CABLE_ID
+#if CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
+#define CONFIG_PD_DISCOVER_CABLE_ID 1
+#else
+#define CONFIG_PD_DISCOVER_CABLE_ID 0
 #endif /* CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID */
 
-#ifdef CONFIG_USB_PD_DFP_READY_DISCOVER_ID
-#undef CONFIG_PD_DISCOVER_CABLE_ID
-#define CONFIG_PD_DISCOVER_CABLE_ID
+#if CONFIG_USB_PD_DFP_READY_DISCOVER_ID
+#define CONFIG_PD_DISCOVER_CABLE_ID 1
+#else
+#define CONFIG_PD_DISCOVER_CABLE_ID 0
 #endif /* CONFIG_USB_PD_DFP_READY_DISCOVER_ID */
 
-#ifdef CONFIG_USB_PD_RESET_CABLE
+#if CONFIG_USB_PD_RESET_CABLE
 
-#ifdef CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
-#define CONFIG_PD_SRC_RESET_CABLE
+#if CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
+#define CONFIG_PD_SRC_RESET_CABLE 1
+#else
+#define CONFIG_PD_SRC_RESET_CABLE 0
 #endif	/* CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID */
 
-#ifdef CONFIG_USB_PD_DFP_READY_DISCOVER_ID
-#define CONFIG_PD_DFP_RESET_CABLE
+#if CONFIG_USB_PD_DFP_READY_DISCOVER_ID
+#define CONFIG_PD_DFP_RESET_CABLE 1
+#else
+#define CONFIG_PD_DFP_RESET_CABLE 0
 #endif	/* CONFIG_USB_PD_DFP_READY_DISCOVER_ID */
 
 #endif	/* CONFIG_USB_PD_RESET_CABLE */
@@ -511,7 +510,7 @@
  * SVDM Discover SVIDs request -> response
  *
  * Request is properly formatted VDM Header with discover SVIDs command.
- * Response is a set of SVIDs of all all supported SVIDs with all zero's to
+ * Response is a set of SVIDs of all supported SVIDs with all zero's to
  * mark the end of SVIDs.  If more than 12 SVIDs are supported command SHOULD be
  * repeated.
  */
@@ -670,7 +669,6 @@
 #define USB_SID_DISPLAYPORT	0xff01	/* display port */
 #define USB_VID_RICHTEK		0x29cf  /* demo uvdm */
 #define USB_VID_DIRECTCHARGE	0x29cf  /* direct charge */
-#define USB_VID_MQP		0x1748
 
 /* PD counter definitions */
 #define PD_MESSAGE_ID_COUNT	7
@@ -739,15 +737,15 @@ struct pe_data {		/* reset after detached */
 	bool power_cable_present;
 	bool during_swap;	/* pr or dr swap */
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	bool cable_rev_discovered;
 #endif	/* CONFIG_USB_PD_REV30 */
 
-#ifdef CONFIG_USB_PD_KEEP_PARTNER_ID
+#if CONFIG_USB_PD_KEEP_PARTNER_ID
 	bool partner_id_present;
 #endif	/* CONFIG_USB_PD_KEEP_PARTNER_ID */
 
-#ifdef CONFIG_USB_PD_VCONN_SAFE5V_ONLY
+#if CONFIG_USB_PD_VCONN_SAFE5V_ONLY
 	bool vconn_highv_prot;
 	uint8_t vconn_highv_prot_role;
 #endif	/* CONFIG_USB_PD_VCONN_SAFE5V_ONLY */
@@ -777,20 +775,15 @@ struct pe_data {		/* reset after detached */
 	uint32_t pe_state_timer;
 	uint32_t vdm_state_timer;
 
-#ifdef CONFIG_USB_PD_RECV_HRESET_COUNTER
+#if CONFIG_USB_PD_RECV_HRESET_COUNTER
 	uint8_t recv_hard_reset_count;
 #endif	/* CONFIG_USB_PD_RECV_HRESET_COUNTER */
 
-#ifdef CONFIG_USB_PD_RENEGOTIATION_COUNTER
+#if CONFIG_USB_PD_RENEGOTIATION_COUNTER
 	uint8_t renegotiation_count;
 #endif	/* CONFIG_USB_PD_RENEGOTIATION_COUNTER */
 
-#ifdef CONFIG_USB_PD_WAIT_AUTO_RETRY
-	uint8_t wait_retry_cnt;
-	uint8_t wait_retry_type;
-#endif	/* CONFIG_USB_PD_WAIT_AUTO_RETRY */
-
-#ifdef CONFIG_USB_PD_KEEP_PARTNER_ID
+#if CONFIG_USB_PD_KEEP_PARTNER_ID
 	uint32_t partner_vdos[VDO_MAX_NR];
 #endif	/* CONFIG_USB_PD_KEEP_PARTNER_ID */
 
@@ -799,48 +792,47 @@ struct pe_data {		/* reset after detached */
 	struct pd_port_power_caps remote_src_cap;
 	struct pd_port_power_caps remote_snk_cap;
 
-#ifdef CONFIG_USB_PD_KEEP_SVIDS
+#if CONFIG_USB_PD_KEEP_SVIDS
 	struct svdm_svid_list remote_svid_list;
 #endif	/* CONFIG_USB_PD_KEEP_SVIDS */
 
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_ALERT_REMOTE
 	uint32_t remote_alert;
 #endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
+#if CONFIG_USB_PD_REV30_ALERT_LOCAL
 	uint32_t local_alert;
 	bool get_status_once;
 #endif	/* CONFIG_USB_PD_REV30_ALERT_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	bool pd_traffic_idle;	/* source only */
 	uint8_t pd_traffic_control;
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
 #endif	/* CONFIG_USB_PD_REV30 */
 
-#ifdef CONFIG_USB_PD_ALT_MODE_RTDC
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_ALT_MODE_RTDC
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	bool dc_pps_mode;
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 #endif	/* CONFIG_USB_PD_ALT_MODE_RTDC */
 
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 	struct dp_data dp_data;
 #endif	/* CONFIG_USB_PD_ALT_MODE */
 
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
 	uint8_t pd_status_event;
 #endif	/* CONFIG_USB_PD_REV30_STATUS_LOCAL */
-
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
+#if CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
 	bool pd_sent_ams_init_cmd;
 	bool pd_unexpected_event_pending;
 	struct pd_event pd_unexpected_event;
 #endif	/* CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG */
 };
 
-#ifdef CONFIG_USB_PD_REV30_BAT_INFO
+#if CONFIG_USB_PD_REV30_BAT_INFO
 struct pd_battery_info {
 	uint32_t bat_status;
 	struct pd_manufacturer_info mfrs_info;
@@ -848,7 +840,7 @@ struct pd_battery_info {
 };
 #endif /* CONFIG_USB_PD_REV30_BAT_INFO */
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_AUTHORITY
+#if CONFIG_USB_PD_REV30_COUNTRY_AUTHORITY
 struct pd_country_authority {
 	uint16_t code;
 	uint8_t len;
@@ -878,21 +870,21 @@ struct pd_port {
 
 	struct pe_data pe_data;
 
-#ifdef CONFIG_USB_PD_ERROR_RECOVERY_ONCE
+#if CONFIG_USB_PD_ERROR_RECOVERY_ONCE
 	uint8_t error_recovery_once;
 #endif	/* CONFIG_USB_PD_ERROR_RECOVERY_ONCE */
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	struct wakeup_source *pps_request_wake_lock;
 	wait_queue_head_t pps_request_wait_que;
 	atomic_t pps_request;
 	struct task_struct *pps_request_task;
-#ifdef CONFIG_USB_PD_REV30_SYNC_SPEC_REV
+#if CONFIG_USB_PD_REV30_SYNC_SPEC_REV
 	uint8_t pd_revision[2];
 #endif	/* CONFIG_USB_PD_REV30_SYNC_SPEC_REV */
 #endif	/* CONFIG_USB_PD_REV30 */
 
-#ifdef CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP
+#if CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP
 	uint8_t msg_id_pr_swap_last;
 #endif	/* CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP */
 
@@ -914,7 +906,7 @@ struct pd_port {
 	int request_i_op;
 	int request_i_max;
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	int request_v_apdo;
 	int request_i_apdo;
 	bool request_apdo;
@@ -925,7 +917,7 @@ struct pd_port {
 	struct pd_port_power_caps local_snk_cap;
 	struct pd_port_power_caps local_src_cap_default;
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	uint8_t local_snk_cap_nr_pd30;
 	uint8_t local_snk_cap_nr_pd20;
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
@@ -939,35 +931,35 @@ struct pd_port {
 	uint8_t dpm_charging_policy_default;
 
 /* ALT Mode */
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 	uint8_t dp_first_connected;
 	uint8_t dp_second_connected;
 #endif	/* CONFIG_USB_PD_ALT_MODE */
 
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 	bool uvdm_wait_resp;
 	uint8_t uvdm_cnt;
 	uint16_t uvdm_svid;
 	uint32_t uvdm_data[PD_DATA_OBJ_SIZE];
 #endif	/* CONFIG_USB_PD_CUSTOM_VDM */
 
-#ifdef CONFIG_USB_PD_ALT_MODE_RTDC
+#if CONFIG_USB_PD_ALT_MODE_RTDC
 	uint8_t dc_dfp_state;
 	uint32_t dc_pass_code;
 #endif	/* CONFIG_USB_PD_ALT_MODE_RTDC */
 
-#ifdef CONFIG_USB_PD_CUSTOM_DBGACC
+#if CONFIG_USB_PD_CUSTOM_DBGACC
 	bool custom_dbgacc;
 #endif	/* CONFIG_USB_PD_CUSTOM_DBGACC */
 
-#ifdef CONFIG_USB_PD_RICHTEK_UVDM
+#if CONFIG_USB_PD_RICHTEK_UVDM
 	bool richtek_init_done;
 #endif	/* CONFIG_USB_PD_RICHTEK_UVDM */
 
 	struct tcp_dpm_event tcp_event;
 	uint8_t tcp_event_id_1st;
 
-#ifdef CONFIG_USB_PD_TCPM_CB_2ND
+#if CONFIG_USB_PD_TCPM_CB_2ND
 	uint8_t tcp_event_id_2nd;
 	bool tcp_event_drop_reset_once;
 
@@ -975,7 +967,7 @@ struct pd_port {
 	uint8_t tcpm_bk_cb_data_max;
 #endif	/* CONFIG_USB_PD_TCPM_CB_2ND */
 
-#ifdef CONFIG_USB_PD_BLOCK_TCPM
+#if CONFIG_USB_PD_BLOCK_TCPM
 	int tcpm_bk_ret;
 	bool tcpm_bk_done;
 	uint8_t tcpm_bk_event_id;
@@ -1003,15 +995,15 @@ struct pd_port {
 
 	bool curr_unsupported_msg;
 
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
 	struct pd_source_cap_ext src_cap_ext;
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
 	struct pd_manufacturer_info mfrs_info;
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_BAT_INFO
+#if CONFIG_USB_PD_REV30_BAT_INFO
 	uint32_t pid;
 	uint32_t vid;
 	uint8_t bat_nr;
@@ -1019,22 +1011,22 @@ struct pd_port {
 	struct pd_battery_info *swap_bat_info;
 #endif	/* CONFIG_USB_PD_REV30_BAT_INFO */
 
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
 	uint8_t pd_status_bat_in;
 	uint8_t pd_status_present_in;
 
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL_TEMP
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL_TEMP
 	uint8_t pd_status_temp;
 	uint8_t pd_status_temp_status;
 #endif	/* CONFIG_USB_PD_REV30_STATUS_LOCAL_TEMP */
 #endif /* CONFIG_USB_PD_REV30_STATUS_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_AUTHORITY
+#if CONFIG_USB_PD_REV30_COUNTRY_AUTHORITY
 	uint8_t country_nr;
 	struct pd_country_authority *country_info;
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_AUTHORITY */
 
-#ifdef CONFIG_RECV_BAT_ABSENT_NOTIFY
+#if CONFIG_RECV_BAT_ABSENT_NOTIFY
 	/* for MTK only, handle battery plug out */
 	struct work_struct fg_bat_work;
 	struct notifier_block fg_bat_nb;
@@ -1043,7 +1035,7 @@ struct pd_port {
 	uint8_t cap_miss_match; /* For src_cap miss match */
 };
 
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 static inline struct dp_data *pd_get_dp_data(struct pd_port *pd_port)
 {
 	return &pd_port->pe_data.dp_data;
@@ -1097,7 +1089,7 @@ static inline uint32_t pd_get_msg_vdm_hdr(struct pd_port *pd_port)
 	return pd_port->curr_vdm_hdr;
 }
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 static inline uint8_t pd_get_msg_hdr_ext(struct pd_port *pd_port)
 {
 	return PD_HEADER_EXT(pd_port->curr_msg_hdr);
@@ -1153,7 +1145,7 @@ static inline int pd_is_support_modal_operation(struct pd_port *pd_port)
 
 static inline int pd_is_source_support_apdo(struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	uint8_t i;
 	struct pd_port_power_caps *src_cap = &pd_port->pe_data.remote_src_cap;
 
@@ -1182,7 +1174,7 @@ static inline int pd_is_source_support_apdo(struct pd_port *pd_port)
 #define PD_RX_CAP_PE_READY_UFP	\
 	(TCPC_RX_CAP_HARD_RESET|TCPC_RX_CAP_SOP)
 
-#ifdef CONFIG_PD_DISCOVER_CABLE_ID
+#if CONFIG_PD_DISCOVER_CABLE_ID
 #define PD_RX_CAP_PE_READY_DFP	\
 	(TCPC_RX_CAP_HARD_RESET|TCPC_RX_CAP_SOP|TCPC_RX_CAP_SOP_PRIME)
 #else
@@ -1251,11 +1243,11 @@ extern void pd_notify_pe_snk_explicit_contract(struct pd_port *pd_port);
 extern void pd_notify_pe_src_explicit_contract(struct pd_port *pd_port);
 extern void pd_notify_pe_transmit_msg(struct pd_port *pd_port, uint8_t type);
 
-#ifdef CONFIG_USB_PD_DIRECT_CHARGE
+#if CONFIG_USB_PD_DIRECT_CHARGE
 extern void pd_notify_pe_direct_charge(struct pd_port *pd_port, bool en);
 #endif	/* CONFIG_USB_PD_DIRECT_CHARGE */
 
-#ifdef CONFIG_USB_PD_RECV_HRESET_COUNTER
+#if CONFIG_USB_PD_RECV_HRESET_COUNTER
 extern void pd_notify_pe_over_recv_hreset(struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_RECV_HRESET_COUNTER */
 
@@ -1441,7 +1433,7 @@ static inline bool pd_put_hw_event(
 static inline bool pd_put_sink_tx_event(
 		struct tcpc_device *tcpc, uint8_t cc_res)
 {
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	struct pd_event evt = {
 		.event_type = PD_EVT_HW_MSG,
 		.msg = PD_HW_SINK_TX_CHANGE,
@@ -1492,7 +1484,7 @@ int pd_reply_wait_reject_msg_no_resp(struct pd_port *pd_port);
 
 int pd_send_swap_msg(struct pd_port *pd_port, uint8_t msg);
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 int pd_send_ext_msg(struct pd_port *pd_port,
 	uint8_t sop_type, uint8_t msg, bool request,
 	uint8_t chunk_nr, uint8_t size, const uint8_t *data);
@@ -1509,7 +1501,7 @@ static inline int pd_send_sop_ext_msg(struct pd_port *pd_port,
 }
 #endif	/* CONFIG_USB_PD_REV30 */
 
-#ifdef CONFIG_USB_PD_RESET_CABLE
+#if CONFIG_USB_PD_RESET_CABLE
 int pd_send_cable_soft_reset(struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_RESET_CABLE */
 
@@ -1531,7 +1523,7 @@ int pd_send_svdm_request(struct pd_port *pd_port,
 int pd_reply_svdm_request(struct pd_port *pd_port,
 	uint8_t reply, uint8_t cnt, uint32_t *data_obj);
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 
 static inline int pd_send_vdm_discover_id(
 	struct pd_port *pd_port, uint8_t sop_type)
@@ -1604,13 +1596,13 @@ static inline int pd_reply_svdm_request_simply(
 
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 int pd_send_custom_vdm(struct pd_port *pd_port, uint8_t sop_type);
 int pd_reply_custom_vdm(struct pd_port *pd_port, uint8_t sop_type,
 	uint8_t cnt, uint32_t *payload);
 #endif	/* CONFIG_USB_PD_CUSTOM_VDM */
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 
 enum {	/* pd_traffic_control */
 	PD_SINK_TX_OK = 0,
@@ -1630,6 +1622,8 @@ bool pd_is_multi_chunk_msg(struct pd_port *pd_port);
 
 static inline uint8_t pd_get_fix_battery_nr(struct pd_port *pd_port)
 {
+
+
 	return PD_SCEDB_FIX_BAT_NR(pd_port->bat_nr);
 }
 
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/pd_dbg_info.h b/drivers/misc/mediatek/typec/tcpc/inc/pd_dbg_info.h
index 510e139..9c8b121 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/pd_dbg_info.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/pd_dbg_info.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #ifndef PD_DBG_INFO_H_INCLUDED
@@ -18,7 +10,7 @@
 #include <linux/module.h>
 #include "tcpci_config.h"
 
-#ifdef CONFIG_PD_DBG_INFO
+#if IS_ENABLED(CONFIG_PD_DBG_INFO)
 extern int pd_dbg_info(const char *fmt, ...);
 extern void pd_dbg_info_lock(void);
 extern void pd_dbg_info_unlock(void);
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/pd_dpm_core.h b/drivers/misc/mediatek/typec/tcpc/inc/pd_dpm_core.h
index aed811f..37aa220 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/pd_dpm_core.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/pd_dpm_core.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #ifndef PD_DPM_CORE_H
@@ -31,7 +23,7 @@ void pd_dpm_dynamic_disable_vconn(struct pd_port *pd_port);
 
 /* ---- SNK ---- */
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 void pd_dpm_start_pps_request_thread(struct pd_port *pd_port, bool en);
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 
@@ -64,7 +56,7 @@ void pd_dpm_ufp_request_exit_mode(struct pd_port *pd_port);
 
 /* ---- UFP : DP Only ---- */
 
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 int pd_dpm_ufp_request_dp_status(struct pd_port *pd_port);
 int pd_dpm_ufp_request_dp_config(struct pd_port *pd_port);
 void pd_dpm_ufp_send_dp_attention(struct pd_port *pd_port);
@@ -81,7 +73,7 @@ void pd_dpm_dfp_inform_attention(struct pd_port *pd_port);
 
 /* ---- DFP : DP Only  ---- */
 
-#ifdef CONFIG_USB_PD_ALT_MODE_DFP
+#if CONFIG_USB_PD_ALT_MODE_DFP
 void pd_dpm_dfp_send_dp_status_update(struct pd_port *pd_port);
 void pd_dpm_dfp_inform_dp_status_update(struct pd_port *pd_port, bool ack);
 
@@ -91,7 +83,7 @@ void pd_dpm_dfp_inform_dp_configuration(struct pd_port *pd_port, bool ack);
 
 /* ---- SVDM/UVDM  ---- */
 
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 
 void pd_dpm_ufp_recv_uvdm(struct pd_port *pd_port);
 void pd_dpm_dfp_send_uvdm(struct pd_port *pd_port);
@@ -128,73 +120,73 @@ void pd_dpm_vcs_enable_vconn(struct pd_port *pd_port, uint8_t role);
  * PE : PD3.0
  */
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
 int pd_dpm_send_source_cap_ext(struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
 void pd_dpm_inform_source_cap_ext(struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_BAT_CAP_LOCAL
+#if CONFIG_USB_PD_REV30_BAT_CAP_LOCAL
 int pd_dpm_send_battery_cap(struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_BAT_CAP_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
+#if CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
 void pd_dpm_inform_battery_cap(struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_BAT_CAP_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL
 int pd_dpm_send_battery_status(struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
 void pd_dpm_inform_battery_status(struct pd_port *pd_port);
-#endif	/* #ifdef CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE */
+#endif	/* #if CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
 int pd_dpm_send_mfrs_info(struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
+#if CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
 void pd_dpm_inform_mfrs_info(struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
+#if CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
 int pd_dpm_send_country_codes(struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
+#if CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
 void pd_dpm_inform_country_codes(struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL
 int pd_dpm_send_country_info(struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
+#if CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
 void pd_dpm_inform_country_info(struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
+#if CONFIG_USB_PD_REV30_ALERT_LOCAL
 int pd_dpm_send_alert(struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_ALERT_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
+#if CONFIG_USB_PD_REV30_ALERT_REMOTE
 void pd_dpm_inform_alert(struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
 int pd_dpm_send_status(struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_STATUS_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_STATUS_REMOTE
 void pd_dpm_inform_status(struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_STATUS_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 void pd_dpm_inform_pps_status(struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 
@@ -232,8 +224,8 @@ static inline int pd_dpm_source_vbus(struct pd_port *pd_port, bool en)
 
 /* Mode Operations */
 
-#ifdef CONFIG_USB_PD_ALT_MODE
-#ifdef CONFIG_USB_PD_ALT_MODE_DFP
+#if CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE_DFP
 
 extern bool dp_dfp_u_notify_discover_id(struct pd_port *pd_port,
 	struct svdm_svid_data *svid_data, bool ack);
@@ -261,7 +253,7 @@ extern void dp_ufp_u_request_enter_mode(
 extern void dp_ufp_u_request_exit_mode(
 	struct pd_port *pd_port, struct svdm_svid_data *svid_data, uint8_t ops);
 
-#ifdef CONFIG_USB_PD_ALT_MODE_DFP
+#if CONFIG_USB_PD_ALT_MODE_DFP
 extern bool dp_dfp_u_notify_pe_startup(
 	struct pd_port *pd_port, struct svdm_svid_data *svid_data);
 
@@ -276,7 +268,7 @@ extern bool dp_parse_svid_data(
 	struct pd_port *pd_port, struct svdm_svid_data *svid_data);
 #endif	/* CONFIG_USB_PD_ALT_MODE */
 
-#ifdef CONFIG_USB_PD_RICHTEK_UVDM
+#if CONFIG_USB_PD_RICHTEK_UVDM
 extern bool richtek_dfp_notify_pe_startup(
 	struct pd_port *pd_port, struct svdm_svid_data *svid_data);
 
@@ -290,7 +282,7 @@ extern bool richtek_ufp_notify_uvdm(struct pd_port *pd_port,
 #endif	/* CONFIG_USB_PD_RICHTEK_UVDM */
 
 
-#ifdef CONFIG_USB_PD_ALT_MODE_RTDC
+#if CONFIG_USB_PD_ALT_MODE_RTDC
 extern bool dc_dfp_notify_discover_id(struct pd_port *pd_port,
 		struct svdm_svid_data *svid_data, bool ack);
 
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/pd_dpm_pdo_select.h b/drivers/misc/mediatek/typec/tcpc/inc/pd_dpm_pdo_select.h
index 3c1d00d..9e3edf1 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/pd_dpm_pdo_select.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/pd_dpm_pdo_select.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #ifndef PD_DPM_PDO_SELECT_H
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/pd_policy_engine.h b/drivers/misc/mediatek/typec/tcpc/inc/pd_policy_engine.h
index 88a889a..098c9d0 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/pd_policy_engine.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/pd_policy_engine.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #ifndef PD_POLICY_ENGINE_H_
@@ -147,7 +139,7 @@ static inline bool pd_check_pe_during_hard_reset(struct pd_port *pd_port)
 enum pd_pe_state {
 	PE_STATE_START_ID = -1,
 /******************* Source *******************/
-#ifdef CONFIG_USB_PD_PE_SOURCE
+#if CONFIG_USB_PD_PE_SOURCE
 	PE_SRC_STARTUP,
 	PE_SRC_DISCOVERY,
 	PE_SRC_SEND_CAPABILITIES,
@@ -166,8 +158,8 @@ enum pd_pe_state {
 	PE_SRC_SOFT_RESET,
 
 /* Source Startup Discover Cable */
-#ifdef CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
-#ifdef CONFIG_PD_SRC_RESET_CABLE
+#if CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
+#if CONFIG_PD_SRC_RESET_CABLE
 	PE_SRC_CBL_SEND_SOFT_RESET,
 #endif	/* CONFIG_PD_SRC_RESET_CABLE */
 	PE_SRC_VDM_IDENTITY_REQUEST,
@@ -176,33 +168,33 @@ enum pd_pe_state {
 #endif	/* PD_CAP_PE_SRC_STARTUP_DISCOVER_ID */
 
 /* Source for PD30 */
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	PE_SRC_SEND_NOT_SUPPORTED,
 	PE_SRC_NOT_SUPPORTED_RECEIVED,
 	PE_SRC_CHUNK_RECEIVED,
-#ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
+#if CONFIG_USB_PD_REV30_ALERT_LOCAL
 	PE_SRC_SEND_SOURCE_ALERT,
 #endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
+#if CONFIG_USB_PD_REV30_ALERT_REMOTE
 	PE_SRC_SINK_ALERT_RECEIVED,
 #endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
 	PE_SRC_GIVE_SOURCE_CAP_EXT,
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
 	PE_SRC_GIVE_SOURCE_STATUS,
 #endif	/* CONFIG_USB_PD_REV30_STATUS_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_STATUS_REMOTE
 	PE_SRC_GET_SINK_STATUS,
 #endif	/* CONFIG_USB_PD_REV30_STATUS_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_PPS_SOURCE
+#if CONFIG_USB_PD_REV30_PPS_SOURCE
 	PE_SRC_GIVE_PPS_STATUS,
 #endif	/* CONFIG_USB_PD_REV30_PPS_SOURCE */
 #endif	/* CONFIG_USB_PD_REV30 */
 #endif	/* CONFIG_USB_PD_PE_SOURCE */
 
 /******************* Sink *******************/
-#ifdef CONFIG_USB_PD_PE_SINK
+#if CONFIG_USB_PD_PE_SINK
 /* Sink Init */
 	PE_SNK_STARTUP,
 	PE_SNK_DISCOVERY,
@@ -220,33 +212,33 @@ enum pd_pe_state {
 	PE_SNK_SOFT_RESET,
 
 /* Sink for PD30 */
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	PE_SNK_SEND_NOT_SUPPORTED,
 	PE_SNK_NOT_SUPPORTED_RECEIVED,
 	PE_SNK_CHUNK_RECEIVED,
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
+#if CONFIG_USB_PD_REV30_ALERT_REMOTE
 	PE_SNK_SOURCE_ALERT_RECEIVED,
 #endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
+#if CONFIG_USB_PD_REV30_ALERT_LOCAL
 	PE_SNK_SEND_SINK_ALERT,
 #endif	/* CONFIG_USB_PD_REV30_ALERT_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
 	PE_SNK_GET_SOURCE_CAP_EXT,
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_STATUS_REMOTE
 	PE_SNK_GET_SOURCE_STATUS,
 #endif	/* CONFIG_USB_PD_REV30_STATUS_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
 	PE_SNK_GIVE_SINK_STATUS,
 #endif	/* CONFIG_USB_PD_REV30_STATUS_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	PE_SNK_GET_PPS_STATUS,
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 #endif	/* CONFIG_USB_PD_REV30 */
 #endif	/* CONFIG_USB_PD_PE_SINK */
 
 /******************* DR_SWAP *******************/
-#ifdef CONFIG_USB_PD_DR_SWAP
+#if CONFIG_USB_PD_DR_SWAP
 /* DR_SWAP_DFP */
 	PE_DRS_DFP_UFP_EVALUATE_DR_SWAP,
 	PE_DRS_DFP_UFP_ACCEPT_DR_SWAP,
@@ -262,7 +254,7 @@ enum pd_pe_state {
 #endif	/* CONFIG_USB_PD_DR_SWAP */
 
 /******************* PR_SWAP *******************/
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 /* PR_SWAP_SRC */
 	PE_PRS_SRC_SNK_EVALUATE_PR_SWAP,
 	PE_PRS_SRC_SNK_ACCEPT_PR_SWAP,
@@ -288,18 +280,18 @@ enum pd_pe_state {
 	PE_DR_SNK_GIVE_SOURCE_CAP,
 
 /* get same role cap for PD30 */
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
 	PE_DR_SNK_GIVE_SOURCE_CAP_EXT,
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
 	PE_DR_SRC_GET_SOURCE_CAP_EXT,
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE */
 #endif	/* CONFIG_USB_PD_REV30 */
 #endif	/* CONFIG_USB_PD_PR_SWAP */
 
 /******************* VCONN_SWAP *******************/
-#ifdef CONFIG_USB_PD_VCONN_SWAP
+#if CONFIG_USB_PD_VCONN_SWAP
 	PE_VCS_SEND_SWAP,
 	PE_VCS_EVALUATE_SWAP,
 	PE_VCS_ACCEPT_SWAP,
@@ -318,7 +310,7 @@ enum pd_pe_state {
 	PE_UFP_VDM_MODE_EXIT,
 	PE_UFP_VDM_ATTENTION_REQUEST,
 
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 	PE_UFP_VDM_DP_STATUS_UPDATE,
 	PE_UFP_VDM_DP_CONFIGURE,
 #endif/* CONFIG_USB_PD_ALT_MODE */
@@ -344,12 +336,12 @@ enum pd_pe_state {
 	PE_DFP_VDM_MODE_EXIT_ACKED,
 	PE_DFP_VDM_ATTENTION_REQUEST,
 
-#ifdef CONFIG_PD_DFP_RESET_CABLE
+#if CONFIG_PD_DFP_RESET_CABLE
 	PE_DFP_CBL_SEND_SOFT_RESET,
 	PE_DFP_CBL_SEND_CABLE_RESET,
 #endif	/* CONFIG_PD_DFP_RESET_CABLE */
 
-#ifdef CONFIG_USB_PD_ALT_MODE_DFP
+#if CONFIG_USB_PD_ALT_MODE_DFP
 	PE_DFP_VDM_DP_STATUS_UPDATE_REQUEST,
 	PE_DFP_VDM_DP_STATUS_UPDATE_ACKED,
 	PE_DFP_VDM_DP_STATUS_UPDATE_NAKED,
@@ -361,7 +353,7 @@ enum pd_pe_state {
 
 /******************* UVDM & SVDM *******************/
 
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 	PE_UFP_UVDM_RECV,
 	PE_DFP_UVDM_SEND,
 	PE_DFP_UVDM_ACKED,
@@ -371,58 +363,58 @@ enum pd_pe_state {
 	PE_UFP_VDM_SEND_NAK,
 
 /******************* PD30 Common *******************/
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
 	PE_GET_BATTERY_CAP,
 #endif	/* CONFIG_USB_PD_REV30_BAT_CAP_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_BAT_CAP_LOCAL
+#if CONFIG_USB_PD_REV30_BAT_CAP_LOCAL
 	PE_GIVE_BATTERY_CAP,
 #endif	/* CONFIG_USB_PD_REV30_BAT_CAP_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
 	PE_GET_BATTERY_STATUS,
 #endif	/* CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL
 	PE_GIVE_BATTERY_STATUS,
 #endif	/* CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
+#if CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
 	PE_GET_MANUFACTURER_INFO,
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
 	PE_GIVE_MANUFACTURER_INFO,
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
+#if CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
 	PE_GET_COUNTRY_CODES,
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
+#if CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
 	PE_GIVE_COUNTRY_CODES,
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
+#if CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
 	PE_GET_COUNTRY_INFO,
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL
 	PE_GIVE_COUNTRY_INFO,
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL */
 	PE_VDM_NOT_SUPPORTED,
 #endif /* CONFIG_USB_PD_REV30 */
 
 /******************* Others *******************/
-#ifdef CONFIG_USB_PD_CUSTOM_DBGACC
+#if CONFIG_USB_PD_CUSTOM_DBGACC
 	PE_DBG_READY,
 #endif/* CONFIG_USB_PD_CUSTOM_DBGACC */
 
-#ifdef CONFIG_USB_PD_RECV_HRESET_COUNTER
+#if CONFIG_USB_PD_RECV_HRESET_COUNTER
 	PE_OVER_RECV_HRESET_LIMIT,
 #endif/* CONFIG_USB_PD_RECV_HRESET_COUNTER */
 
 	PE_REJECT,
 	PE_ERROR_RECOVERY,
-#ifdef CONFIG_USB_PD_ERROR_RECOVERY_ONCE
+#if CONFIG_USB_PD_ERROR_RECOVERY_ONCE
 	PE_ERROR_RECOVERY_ONCE,
 #endif	/* CONFIG_USB_PD_ERROR_RECOVERY_ONCE */
 	PE_BIST_TEST_DATA,
 	PE_BIST_CARRIER_MODE_2,
 
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
+#if CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
 	PE_UNEXPECTED_TX_WAIT,
 	PE_SEND_SOFT_RESET_TX_WAIT,
 	PE_RECV_SOFT_RESET_TX_WAIT,
@@ -461,7 +453,7 @@ static inline void pe_send_swap_request_entry(
 }
 
 /******************* Source *******************/
-#ifdef CONFIG_USB_PD_PE_SOURCE
+#if CONFIG_USB_PD_PE_SOURCE
 void pe_src_startup_entry(
 	struct pd_port *pd_port);
 void pe_src_discovery_entry(
@@ -502,8 +494,8 @@ void pe_src_soft_reset_entry(
 	struct pd_port *pd_port);
 
 /* Source Startup Discover Cable */
-#ifdef CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
-#ifdef CONFIG_PD_SRC_RESET_CABLE
+#if CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
+#if CONFIG_PD_SRC_RESET_CABLE
 void pe_src_cbl_send_soft_reset_entry(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_PD_SRC_RESET_CABLE */
@@ -516,36 +508,36 @@ void pe_src_vdm_identity_naked_entry(
 #endif	/* PD_CAP_PE_SRC_STARTUP_DISCOVER_ID */
 
 /* Source for PD30 */
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 void pe_src_send_not_supported_entry(
 	struct pd_port *pd_port);
 void pe_src_not_supported_received_entry(
 	struct pd_port *pd_port);
 void pe_src_chunk_received_entry(
 	struct pd_port *pd_port);
-#ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
+#if CONFIG_USB_PD_REV30_ALERT_LOCAL
 void pe_src_send_source_alert_entry(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
+#if CONFIG_USB_PD_REV30_ALERT_REMOTE
 void pe_src_sink_alert_received_entry(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
 void pe_src_give_source_cap_ext_entry(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
 void pe_src_give_source_status_entry(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_STATUS_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_STATUS_REMOTE
 void pe_src_get_sink_status_entry(
 	struct pd_port *pd_port);
 void pe_src_get_sink_status_exit(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_STATUS_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_PPS_SOURCE
+#if CONFIG_USB_PD_REV30_PPS_SOURCE
 void pe_src_give_pps_status_entry(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_PPS_SOURCE */
@@ -553,7 +545,7 @@ void pe_src_give_pps_status_entry(
 #endif	/* CONFIG_USB_PD_PE_SOURCE */
 
 /******************* Sink *******************/
-#ifdef CONFIG_USB_PD_PE_SINK
+#if CONFIG_USB_PD_PE_SINK
 /* Sink Init */
 void pe_snk_startup_entry(
 	struct pd_port *pd_port);
@@ -588,38 +580,38 @@ void pe_snk_soft_reset_entry(
 	struct pd_port *pd_port);
 
 /* Sink for PD30 */
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 void pe_snk_send_not_supported_entry(
 	struct pd_port *pd_port);
 void pe_snk_not_supported_received_entry(
 	struct pd_port *pd_port);
 void pe_snk_chunk_received_entry(
 	struct pd_port *pd_port);
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
+#if CONFIG_USB_PD_REV30_ALERT_REMOTE
 void pe_snk_source_alert_received_entry(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
+#if CONFIG_USB_PD_REV30_ALERT_LOCAL
 void pe_snk_send_sink_alert_entry(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_ALERT_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
 void pe_snk_get_source_cap_ext_entry(
 	struct pd_port *pd_port);
 void pe_snk_get_source_cap_ext_exit(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_STATUS_REMOTE
 void pe_snk_get_source_status_entry(
 	struct pd_port *pd_port);
 void pe_snk_get_source_status_exit(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_STATUS_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
 void pe_snk_give_sink_status_entry(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_STATUS_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 void pe_snk_get_pps_status_entry(
 	struct pd_port *pd_port);
 void pe_snk_get_pps_status_exit(
@@ -629,7 +621,7 @@ void pe_snk_get_pps_status_exit(
 #endif	/* CONFIG_USB_PD_PE_SINK */
 
 /******************* DR_SWAP *******************/
-#ifdef CONFIG_USB_PD_DR_SWAP
+#if CONFIG_USB_PD_DR_SWAP
 /* DR_SWAP_DFP */
 void pe_drs_dfp_ufp_evaluate_dr_swap_entry(
 	struct pd_port *pd_port);
@@ -655,7 +647,7 @@ void pe_drs_ufp_dfp_reject_dr_swap_entry(
 #endif	/* CONFIG_USB_PD_DR_SWAP */
 
 /******************* PR_SWAP *******************/
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 /* PR_SWAP_SRC */
 void pe_prs_src_snk_evaluate_pr_swap_entry(
 	struct pd_port *pd_port);
@@ -709,12 +701,12 @@ void pe_dr_snk_give_source_cap_entry(
 	struct pd_port *pd_port);
 
 /* get same role cap for PD30 */
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
 void pe_dr_snk_give_source_cap_ext_entry(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
 void pe_dr_src_get_source_cap_ext_entry(
 	struct pd_port *pd_port);
 void pe_dr_src_get_source_cap_ext_exit(
@@ -724,7 +716,7 @@ void pe_dr_src_get_source_cap_ext_exit(
 #endif	/* CONFIG_USB_PD_PR_SWAP */
 
 /******************* VCONN_SWAP *******************/
-#ifdef CONFIG_USB_PD_VCONN_SWAP
+#if CONFIG_USB_PD_VCONN_SWAP
 void pe_vcs_send_swap_entry(
 	struct pd_port *pd_port);
 void pe_vcs_evaluate_swap_entry(
@@ -780,7 +772,7 @@ void pe_ufp_vdm_mode_exit_nak_entry(
 void pe_ufp_vdm_attention_request_entry(
 	struct pd_port *pd_port);
 
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 void pe_ufp_vdm_dp_status_update_entry(
 	struct pd_port *pd_port);
 void pe_ufp_vdm_dp_configure_entry(
@@ -825,13 +817,13 @@ void pe_dfp_vdm_mode_exit_acked_entry(
 void pe_dfp_vdm_attention_request_entry(
 	struct pd_port *pd_port);
 
-#ifdef CONFIG_PD_DFP_RESET_CABLE
+#if CONFIG_PD_DFP_RESET_CABLE
 void pe_dfp_cbl_send_soft_reset_entry(
 	struct pd_port *pd_port);
 void pe_dfp_cbl_send_cable_reset_entry(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_PD_DFP_RESET_CABLE */
-#ifdef CONFIG_USB_PD_ALT_MODE_DFP
+#if CONFIG_USB_PD_ALT_MODE_DFP
 void pe_dfp_vdm_dp_status_update_request_entry(
 	struct pd_port *pd_port);
 void pe_dfp_vdm_dp_status_update_acked_entry(
@@ -847,7 +839,7 @@ void pe_dfp_vdm_dp_configuration_naked_entry(
 	struct pd_port *pd_port);
 #endif/* CONFIG_USB_PD_ALT_MODE_DFP */
 /******************* UVDM & SVDM *******************/
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 void pe_ufp_uvdm_recv_entry(
 	struct pd_port *pd_port);
 void pe_dfp_uvdm_send_entry(
@@ -861,54 +853,54 @@ void pe_ufp_vdm_send_nak_entry(
 	struct pd_port *pd_port);
 
 /******************* PD30 Common *******************/
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
 void pe_get_battery_cap_entry(
 	struct pd_port *pd_port);
 void pe_get_battery_cap_exit(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_BAT_CAP_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_BAT_CAP_LOCAL
+#if CONFIG_USB_PD_REV30_BAT_CAP_LOCAL
 void pe_give_battery_cap_entry(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_BAT_CAP_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
 void pe_get_battery_status_entry(
 	struct pd_port *pd_port);
 void pe_get_battery_status_exit(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL
 void pe_give_battery_status_entry(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
+#if CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
 void pe_get_manufacturer_info_entry(
 	struct pd_port *pd_port);
 void pe_get_manufacturer_info_exit(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
 void pe_give_manufacturer_info_entry(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
+#if CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
 void pe_get_country_codes_entry(
 	struct pd_port *pd_port);
 void pe_get_country_codes_exit(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
+#if CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
 void pe_give_country_codes_entry(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
+#if CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
 void pe_get_country_info_entry(
 	struct pd_port *pd_port);
 void pe_get_country_info_exit(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL
 void pe_give_country_info_entry(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL */
@@ -916,12 +908,12 @@ void pe_vdm_not_supported_entry(
 	struct pd_port *pd_port);
 #endif /* CONFIG_USB_PD_REV30 */
 /******************* Others *******************/
-#ifdef CONFIG_USB_PD_CUSTOM_DBGACC
+#if CONFIG_USB_PD_CUSTOM_DBGACC
 void pe_dbg_ready_entry(
 	struct pd_port *pd_port);
 #endif/* CONFIG_USB_PD_CUSTOM_DBGACC */
 
-#ifdef CONFIG_USB_PD_RECV_HRESET_COUNTER
+#if CONFIG_USB_PD_RECV_HRESET_COUNTER
 void pe_over_recv_hreset_limit_entry(
 	struct pd_port *pd_port);
 #endif/* CONFIG_USB_PD_RECV_HRESET_COUNTER */
@@ -929,7 +921,7 @@ void pe_reject_entry(
 	struct pd_port *pd_port);
 void pe_error_recovery_entry(
 	struct pd_port *pd_port);
-#ifdef CONFIG_USB_PD_ERROR_RECOVERY_ONCE
+#if CONFIG_USB_PD_ERROR_RECOVERY_ONCE
 void pe_error_recovery_once_entry(
 	struct pd_port *pd_port);
 #endif	/* CONFIG_USB_PD_ERROR_RECOVERY_ONCE */
@@ -941,7 +933,7 @@ void pe_bist_carrier_mode_2_entry(
 	struct pd_port *pd_port);
 void pe_bist_carrier_mode_2_exit(
 	struct pd_port *pd_port);
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
+#if CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
 void pe_unexpected_tx_wait_entry(
 	struct pd_port *pd_port);
 void pe_send_soft_reset_tx_wait_entry(
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/pd_process_evt.h b/drivers/misc/mediatek/typec/tcpc/inc/pd_process_evt.h
index d8d377f..96f55a9 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/pd_process_evt.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/pd_process_evt.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #ifndef PD_PROCESS_EVT_H_
@@ -198,7 +190,7 @@ extern bool pd_process_event_vcs(struct pd_port *pd_port, struct pd_event *evt);
 extern bool pd_process_event_com(struct pd_port *pd_port, struct pd_event *evt);
 extern bool pd_process_event_tcp(struct pd_port *pd_port, struct pd_event *evt);
 
-#ifdef CONFIG_USB_PD_CUSTOM_DBGACC
+#if CONFIG_USB_PD_CUSTOM_DBGACC
 extern bool pd_process_event_dbg(struct pd_port *pd_port, struct pd_event *evt);
 #endif	/* CONFIG_USB_PD_CUSTOM_DBGACC */
 
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/rt1711h.h b/drivers/misc/mediatek/typec/tcpc/inc/rt1711h.h
index 19bec15..0655cf5 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/rt1711h.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/rt1711h.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #ifndef __LINUX_RT1711H_H
@@ -154,7 +146,7 @@
 
 /* timeout = (tout*2+1) * 6.4ms */
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 #define RT1711H_REG_IDLE_SET(ck300, ship_dis, auto_idle, tout) \
 	((ck300 << 7) | (ship_dis << 5) | (auto_idle << 3) \
 	| (tout & 0x07) | RT1711H_REG_ENEXTMSG)
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/rt5081.h b/drivers/misc/mediatek/typec/tcpc/inc/rt5081.h
index 0cc613a..cdacc89 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/rt5081.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/rt5081.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #ifndef __LINUX_RT5081_H
@@ -139,7 +131,7 @@
 #define RT5081_REG_AUTOIDLE_EN				(1<<3)
 
 /* timeout = (tout*2+1) * 6.4ms */
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 #define RT5081_REG_IDLE_SET(ck300, ship_dis, auto_idle, tout) \
 	((ck300 << 7) | (ship_dis << 5) |\
 	 (auto_idle << 3) | (tout & 0x07) | RT5081_REG_ENEXTMSG)
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/std_tcpci_v10.h b/drivers/misc/mediatek/typec/tcpc/inc/std_tcpci_v10.h
index 588cd87..7b2ecfc 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/std_tcpci_v10.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/std_tcpci_v10.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #ifndef STD_TCPCI_V10_H_
@@ -55,6 +47,7 @@
 #define TCPC_V10_REG_TX_HDR				(0x52)
 #define TCPC_V10_REG_TX_DATA				(0x54)/* through 0x6f */
 
+#define TCPC_V10_REG_VBUS_VOLTAGE_L                     (0x70)
 #define TCPC_V10_REG_VBUS_SINK_DISCONNECT_THD		(0x72)
 #define TCPC_V10_REG_VBUS_STOP_DISCHARGE_THD		(0x74)
 #define TCPC_V10_REG_VBUS_VOLTAGE_ALARM_HI		(0x76)
@@ -142,6 +135,7 @@
  */
 
 #define TCPC_V10_REG_VBUS_MONITOR		(1<<6)
+#define TCPC_V10_REG_AUTO_DISCHG_DISCNT         (1<<4)
 #define TCPC_V10_REG_BLEED_DISC_EN		(1<<3)
 #define TCPC_V10_REG_FORCE_DISC_EN		(1<<2)
 #define TCPC_V10_REG_POWER_CTRL_VCONN		(1<<0)
@@ -190,7 +184,7 @@ enum tcpm_v10_command {
  * TCPC_V10_REG_TRANSMIT				(0x50)
  */
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 #define TCPC_V10_REG_TRANSMIT_SET(retry, type) \
 		((retry) << 4 | (type))
 #else
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/tcpci.h b/drivers/misc/mediatek/typec/tcpc/inc/tcpci.h
index 3aa92db..ad96b78 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/tcpci.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/tcpci.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #ifndef __LINUX_RT_TCPC_H
@@ -23,17 +15,13 @@
 #include <linux/delay.h>
 #include <linux/sched.h>
 
-#ifdef CONFIG_DUAL_ROLE_USB_INTF
-#include <linux/usb/class-dual-role.h>
-#endif /* CONFIG_DUAL_ROLE_USB_INTF */
-
 #include "tcpci_core.h"
 
-#ifdef CONFIG_PD_DBG_INFO
+#if IS_ENABLED(CONFIG_PD_DBG_INFO)
 #include "pd_dbg_info.h"
 #endif /* CONFIG_PD_DBG_INFO */
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 #include "pd_core.h"
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
@@ -49,7 +37,6 @@ extern int tcpci_set_wake_lock(
 extern int tcpci_report_power_control(struct tcpc_device *tcpc, bool en);
 extern int tcpc_typec_init(struct tcpc_device *tcpc, uint8_t typec_role);
 extern void tcpc_typec_deinit(struct tcpc_device *tcpc);
-extern int tcpc_dual_role_phy_init(struct tcpc_device *tcpc);
 
 extern struct tcpc_device *tcpc_device_register(
 		struct device *parent, struct tcpc_desc *tcpc_desc,
@@ -59,6 +46,8 @@ extern void tcpc_device_unregister(
 
 extern int tcpc_schedule_init_work(struct tcpc_device *tcpc);
 
+extern int tcpc_device_irq_enable(struct tcpc_device *tcpc);
+
 extern void *tcpc_get_dev_data(struct tcpc_device *tcpc);
 extern void tcpci_lock_typec(struct tcpc_device *tcpc);
 extern void tcpci_unlock_typec(struct tcpc_device *tcpc);
@@ -86,44 +75,43 @@ int tcpci_init_alert_mask(struct tcpc_device *tcpc);
 
 int tcpci_get_cc(struct tcpc_device *tcpc);
 int tcpci_set_cc(struct tcpc_device *tcpc, int pull);
-static inline int __tcpci_set_cc(struct tcpc_device *tcpc, int pull)
-{
-	PD_BUG_ON(tcpc->ops->set_cc == NULL);
-
-	if (pull & TYPEC_CC_DRP) {
-		tcpc->typec_remote_cc[0] =
-		tcpc->typec_remote_cc[1] =
-			TYPEC_CC_DRP_TOGGLING;
-	}
-
-	tcpc->typec_local_cc = pull;
-	return tcpc->ops->set_cc(tcpc, pull);
-}
 int tcpci_set_polarity(struct tcpc_device *tcpc, int polarity);
 int tcpci_set_low_rp_duty(struct tcpc_device *tcpc, bool low_rp);
 int tcpci_set_vconn(struct tcpc_device *tcpc, int enable);
 
 int tcpci_is_low_power_mode(struct tcpc_device *tcpc);
 int tcpci_set_low_power_mode(struct tcpc_device *tcpc, bool en, int pull);
-int tcpci_idle_poll_ctrl(struct tcpc_device *tcpc, bool en, bool lock);
 int tcpci_set_watchdog(struct tcpc_device *tcpc, bool en);
 int tcpci_alert_vendor_defined_handler(struct tcpc_device *tcpc);
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+int tcpci_set_auto_dischg_discnt(struct tcpc_device *tcpc, bool en);
+int tcpci_get_vbus_voltage(struct tcpc_device *tcpc, u32 *vbus);
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 int tcpci_is_vsafe0v(struct tcpc_device *tcpc);
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 int tcpci_is_water_detected(struct tcpc_device *tcpc);
 int tcpci_set_water_protection(struct tcpc_device *tcpc, bool en);
 int tcpci_set_usbid_polling(struct tcpc_device *tcpc, bool en);
 int tcpci_notify_wd_status(struct tcpc_device *tcpc, bool water_detected);
 #endif /* CONFIG_WATER_DETECTION */
 
-#ifdef CONFIG_CABLE_TYPE_DETECTION
+#if CONFIG_CABLE_TYPE_DETECTION
 int tcpci_notify_cable_type(struct tcpc_device *tcpc);
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+int tcpci_notify_fod_status(struct tcpc_device *tcpc);
+
+int tcpci_notify_typec_otp(struct tcpc_device *tcpc);
+
+int tcpci_set_cc_hidet(struct tcpc_device *tcpc, bool en);
+int tcpci_notify_plug_out(struct tcpc_device *tcpc);
+
+int tcpci_set_floating_ground(struct tcpc_device *tcpc, bool en);
+
+int tcpci_set_otp_fwen(struct tcpc_device *tcpc, bool en);
+
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 
 int tcpci_set_msg_header(struct tcpc_device *tcpc,
 	uint8_t power_role, uint8_t data_role);
@@ -142,7 +130,7 @@ int tcpci_set_bist_test_mode(struct tcpc_device *tcpc, bool en);
 
 int tcpci_set_bist_carrier_mode(struct tcpc_device *tcpc, uint8_t pattern);
 
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 int tcpci_retransmit(struct tcpc_device *tcpc);
 #endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
 #endif	/* CONFIG_USB_POWER_DELIVERY */
@@ -163,7 +151,7 @@ int tcpci_notify_attachwait_state(struct tcpc_device *tcpc, bool as_sink);
 int tcpci_enable_auto_discharge(struct tcpc_device *tcpc, bool en);
 int tcpci_enable_force_discharge(struct tcpc_device *tcpc, bool en, int mv);
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 
 int tcpci_notify_hard_reset_state(struct tcpc_device *tcpc, uint8_t state);
 
@@ -171,7 +159,7 @@ int tcpci_enter_mode(struct tcpc_device *tcpc,
 	uint16_t svid, uint8_t ops, uint32_t mode);
 int tcpci_exit_mode(struct tcpc_device *tcpc, uint16_t svid);
 
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 int tcpci_report_hpd_state(struct tcpc_device *tcpc, uint32_t dp_status);
 int tcpci_dp_status_update(struct tcpc_device *tcpc, uint32_t dp_status);
 int tcpci_dp_configure(struct tcpc_device *tcpc, uint32_t dp_config);
@@ -185,25 +173,25 @@ int tcpci_dp_notify_config_done(struct tcpc_device *tcpc,
 	uint32_t local_cfg, uint32_t remote_cfg, bool ack);
 #endif	/* CONFIG_USB_PD_ALT_MODE */
 
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 int tcpci_notify_uvdm(struct tcpc_device *tcpc, bool ack);
 #endif	/* CONFIG_USB_PD_CUSTOM_VDM */
 
-#ifdef CONFIG_USB_PD_ALT_MODE_RTDC
+#if CONFIG_USB_PD_ALT_MODE_RTDC
 int tcpci_dc_notify_en_unlock(struct tcpc_device *tcpc);
 #endif	/* CONFIG_USB_PD_ALT_MODE_RTDC */
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
+#if CONFIG_USB_PD_REV30_ALERT_REMOTE
 int tcpci_notify_alert(struct tcpc_device *tcpc, uint32_t ado);
 #endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_STATUS_REMOTE
 int tcpci_notify_status(struct tcpc_device *tcpc, struct pd_status *sdb);
 #endif	/* CONFIG_USB_PD_REV30_STATUS_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_BAT_INFO
+#if CONFIG_USB_PD_REV30_BAT_INFO
 int tcpci_notify_request_bat_info(
 	struct tcpc_device *tcpc, enum pd_battery_reference ref);
 #endif	/* CONFIG_USB_PD_REV30_BAT_INFO */
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/tcpci_config.h b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_config.h
index 08b13ca..6643249 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/tcpci_config.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_config.h
@@ -1,77 +1,69 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #ifndef __LINUX_TCPC_CONFIG_H
 #define __LINUX_TCPC_CONFIG_H
 
-#ifdef CONFIG_TCPC_CLASS
+#if IS_ENABLED(CONFIG_TCPC_CLASS)
 /* default config */
 
-/* #define CONFIG_TYPEC_USE_DIS_VBUS_CTRL */
-#define CONFIG_TYPEC_POWER_CTRL_INIT
+#define CONFIG_TYPEC_CAP_A2C_C2C 0
+#define CONFIG_TYPEC_USE_DIS_VBUS_CTRL	0
+#define CONFIG_TYPEC_POWER_CTRL_INIT	1
 
-#define CONFIG_TYPEC_CAP_TRY_SOURCE
-#define CONFIG_TYPEC_CAP_TRY_SINK
+#define CONFIG_TYPEC_CAP_TRY_SOURCE	1
+#define CONFIG_TYPEC_CAP_TRY_SINK	1
 
-#define CONFIG_TYPEC_CAP_DBGACC
-/* #define CONFIG_TYPEC_CAP_DBGACC_SNK */
-#define CONFIG_TYPEC_CAP_CUSTOM_SRC
-#define CONFIG_TYPEC_CAP_NORP_SRC
-/* #define CONFIG_COMPATIBLE_APPLE_TA */
+#define CONFIG_TYPEC_CAP_DBGACC		1
+#define CONFIG_TYPEC_CAP_DBGACC_SNK	0
+#define CONFIG_TYPEC_CAP_CUSTOM_SRC	1
+#define CONFIG_TYPEC_CAP_NORP_SRC	1
+#define CONFIG_COMPATIBLE_APPLE_TA	1
 
-#define CONFIG_RECV_BAT_ABSENT_NOTIFY
+#define CONFIG_RECV_BAT_ABSENT_NOTIFY	0
 
-/* #define CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_DELAY */
-#define CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_TIMEOUT
+#define CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_DELAY	0
+#define CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_TIMEOUT	1
 
-#define CONFIG_TYPEC_CHECK_LEGACY_CABLE
-#define CONFIG_TYPEC_CHECK_LEGACY_CABLE2
-#define CONFIG_TYPEC_LEGACY2_AUTO_RECYCLE
-/* #define CONFIG_TYPEC_CHECK_SRC_UNATTACH_OPEN */
-#define CONFIG_TYPEC_LEGACY3_ALWAYS_LOCAL_RP
+#define CONFIG_TYPEC_CHECK_LEGACY_CABLE		1
+#define CONFIG_TYPEC_CHECK_LEGACY_CABLE2	1
+#define CONFIG_TYPEC_LEGACY2_AUTO_RECYCLE	1
+#define CONFIG_TYPEC_CHECK_SRC_UNATTACH_OPEN	0
 
-#define CONFIG_TYPEC_CAP_RA_DETACH
-#define CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
+#define CONFIG_TYPEC_CAP_RA_DETACH		1
+#define CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG	1
 
-#define CONFIG_TYPEC_CAP_POWER_OFF_CHARGE
+#define CONFIG_TYPEC_CAP_POWER_OFF_CHARGE	1
 
-#define CONFIG_TYPEC_CAP_ROLE_SWAP
+#define CONFIG_TYPEC_CAP_ROLE_SWAP		1
 #define CONFIG_TYPEC_CAP_ROLE_SWAP_TOUT		1200
 
 #define CONFIG_TYPEC_CAP_DISCHARGE_TOUT		50
 
-#define CONFIG_TYPEC_CAP_AUTO_DISCHARGE
-/* #define CONFIG_TCPC_AUTO_DISCHARGE_IC */
+#define CONFIG_TYPEC_CAP_AUTO_DISCHARGE		1
+#define CONFIG_TCPC_AUTO_DISCHARGE_IC		0
 
-#define CONFIG_TYPEC_CAP_FORCE_DISCHARGE
-/* #define CONFIG_TCPC_FORCE_DISCHARGE_IC */
-#define CONFIG_TCPC_FORCE_DISCHARGE_EXT
+#define CONFIG_TYPEC_CAP_FORCE_DISCHARGE	1
+#define CONFIG_TCPC_FORCE_DISCHARGE_IC		1
+#define CONFIG_TCPC_FORCE_DISCHARGE_EXT		1
 
-#define CONFIG_TYPEC_CAP_AUDIO_ACC_SINK_VBUS
+#define CONFIG_TYPEC_CAP_AUDIO_ACC_SINK_VBUS	1
 
-#define CONFIG_TYPEC_CAP_LOW_RP_DUTY
-#define CONFIG_TYPEC_WAKEUP_ONCE_LOW_DUTY
+#define CONFIG_TYPEC_CAP_LOW_RP_DUTY		1
+#define CONFIG_TYPEC_WAKEUP_ONCE_LOW_DUTY	1
 
-/* #define CONFIG_TYPEC_CAP_CUSTOM_HV */
+#define CONFIG_TYPEC_CAP_CUSTOM_HV		0
 
-#define CONFIG_TYPEC_NOTIFY_ATTACHWAIT_SNK
-/* #define CONFIG_TYPEC_NOTIFY_ATTACHWAIT_SRC */
+#define CONFIG_TYPEC_NOTIFY_ATTACHWAIT_SNK	1
+#define CONFIG_TYPEC_NOTIFY_ATTACHWAIT_SRC	0
 
 #define CONFIG_TCPC_ATTACH_WAKE_LOCK_TOUT	5000
 
-/* #define CONFIG_TCPC_LOG_WITH_PORT_NAME */
+#define CONFIG_TCPC_LOG_WITH_PORT_NAME		0
 
-#ifdef CONFIG_TCPC_LOG_WITH_PORT_NAME
+#if CONFIG_TCPC_LOG_WITH_PORT_NAME
 #define CONFIG_TCPC_DBG_PRESTR		"{%s}TCPC-"
 #else
 #define CONFIG_TCPC_DBG_PRESTR		"TCPC-"
@@ -88,336 +80,210 @@
 #define CONFIG_TYPEC_SRC_CURR_DFT		500
 #define CONFIG_TYPEC_SNK_CURR_LIMIT		0
 
-#define CONFIG_TCPC_SOURCE_VCONN
-#define CONFIG_TCPC_VCONN_SUPPLY_MODE
+#define CONFIG_TCPC_SOURCE_VCONN		1
+#define CONFIG_TCPC_VCONN_SUPPLY_MODE		1
 
-#define CONFIG_TCPC_VSAFE0V_DETECT
-/* #define CONFIG_TCPC_VSAFE0V_DETECT_EXT */
-#define CONFIG_TCPC_VSAFE0V_DETECT_IC
+#define CONFIG_TCPC_VSAFE0V_DETECT		1
+#define CONFIG_TCPC_VSAFE0V_DETECT_EXT		0
+#define CONFIG_TCPC_VSAFE0V_DETECT_IC		1
 
-#define CONFIG_TCPC_LPM_CONFIRM
-#define CONFIG_TCPC_LPM_POSTPONE
+#define CONFIG_TCPC_LPM_CONFIRM		1
+#define CONFIG_TCPC_LPM_POSTPONE	1
 
-#define CONFIG_TCPC_LOW_POWER_MODE
-#define CONFIG_TCPC_CLOCK_GATING
+#define CONFIG_TCPC_LOW_POWER_MODE	1
+#define CONFIG_TCPC_CLOCK_GATING	1
 
-/* #define CONFIG_TCPC_WATCHDOG_EN */
-/* #define CONFIG_TCPC_INTRST_EN */
-#define CONFIG_TCPC_I2CRST_EN
+#define CONFIG_TCPC_WATCHDOG_EN		0
+#define CONFIG_TCPC_INTRST_EN		0
+#define CONFIG_TCPC_I2CRST_EN		1
 
-#define CONFIG_TCPC_SHUTDOWN_CC_DETACH
-#define CONFIG_TCPC_SHUTDOWN_VBUS_DISABLE
+#define CONFIG_TCPC_SHUTDOWN_CC_DETACH	1
+#define CONFIG_TCPC_SHUTDOWN_VBUS_DISABLE	1
 
-#define CONFIG_TCPC_NOTIFIER_LATE_SYNC
+#define CONFIG_TCPC_NOTIFIER_LATE_SYNC	1
 
-#define CONFIG_TCPC_NOTIFICATION_NON_BLOCKING
+#define CONFIG_TCPC_NOTIFICATION_NON_BLOCKING	1
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+/* debug config */
+#define CONFIG_PD_BEGUG_ON 0
 
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
+#include "tcpci_pd_config.h"
+#else /* No CONFIG_USB_POWER_DELIVERY */
 /* Experimental for CodeSize */
-#define CONFIG_USB_PD_DR_SWAP
-#define CONFIG_USB_PD_PR_SWAP
-#define CONFIG_USB_PD_VCONN_SWAP
-#define CONFIG_USB_PD_PE_SINK
-#define CONFIG_USB_PD_PE_SOURCE
-#define CONFIG_USB_PD_DISABLE_PE
+#define CONFIG_USB_PD_DR_SWAP	0
+#define CONFIG_USB_PD_PR_SWAP	0
+#define CONFIG_USB_PD_VCONN_SWAP	0
+#define CONFIG_USB_PD_PE_SINK	0
+#define CONFIG_USB_PD_PE_SOURCE	0
+#define CONFIG_USB_PD_DISABLE_PE	0
 
-#define CONFIG_USB_PD_TCPM_CB_RETRY		3
-#define CONFIG_USB_PD_TCPM_CB_2ND
-#define CONFIG_USB_PD_BLOCK_TCPM
+#define CONFIG_USB_PD_TCPM_CB_RETRY		0
+#define CONFIG_USB_PD_TCPM_CB_2ND	0
+#define CONFIG_USB_PD_BLOCK_TCPM	0
 
-/* #define CONFIG_USB_PD_RICHTEK_UVDM */
+#define CONFIG_USB_PD_RICHTEK_UVDM	0
 
 /**********************************************************
  * Mode Operation
  **********************************************************/
 
-#define CONFIG_USB_PD_MODE_OPERATION
-
-#ifdef CONFIG_USB_PD_MODE_OPERATION
-
-#define CONFIG_USB_PD_ATTEMP_ENTER_MODE
-
-#define CONFIG_USB_PD_ALT_MODE
-#ifdef CONFIG_USB_PD_ALT_MODE
-#define CONFIG_USB_PD_ALT_MODE_DFP
-#define CONFIG_USB_PD_ALT_MODE_RTDC
-#endif	/* CONFIG_USB_PD_ALT_MODE */
+#define CONFIG_USB_PD_MODE_OPERATION		0
+#define CONFIG_USB_PD_ATTEMPT_ENTER_MODE	0
 
-/* #define CONFIG_USB_PD_DP_CHECK_CABLE */
-/* #define CONFIG_USB_PD_RTDC_CHECK_CABLE */
-
-#endif	/* CONFIG_USB_PD_MODE_OPERATION */
+#define CONFIG_USB_PD_ALT_MODE	0
+#define CONFIG_USB_PD_ALT_MODE_DFP	0
+#define CONFIG_USB_PD_ALT_MODE_RTDC	0
+#define CONFIG_USB_PD_DP_CHECK_CABLE	0
+#define CONFIG_USB_PD_RTDC_CHECK_CABLE	0
 
 /**********************************************************
  * PD revision 3.0 feature
  **********************************************************/
 
-#define CONFIG_USB_PD_REV30
-
-#ifdef CONFIG_USB_PD_REV30
-
-#define CONFIG_USB_PD_REV30_SYNC_SPEC_REV
-#define CONFIG_USB_PD_REV30_COLLISION_AVOID
-
-/*
- * If DUT send a PD command immediately after Policy Engine is ready,
- * it may interrupt the compliance test process and getting a failed result.
- * even you make sure the CC state is SinkTxNG or SinkTxOK.
- *
- * SRC_FLOW_DELAY_STARTUP: For Ellisys
- * SNK_FLOW_DELAY_STARTUP: For MQP
- */
-
-#define CONFIG_USB_PD_REV30_SRC_FLOW_DELAY_STARTUP
-#define CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
-
-#define CONFIG_USB_PD_REV30_DISCOVER_CABLE_WITH_VCONN
-
-/* PD30 Common Feature */
-
-#define CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
-#define CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
-
-#define CONFIG_USB_PD_REV30_BAT_CAP_LOCAL
-#define CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
-
-#define CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL
-#define CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
-
-#define CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
-#define CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
-
-#define CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
-#define CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
-
-#define CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL
-#define CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
-
-#define CONFIG_USB_PD_REV30_ALERT_LOCAL
-#define CONFIG_USB_PD_REV30_ALERT_REMOTE
-
-#define CONFIG_USB_PD_REV30_STATUS_LOCAL
-#define CONFIG_USB_PD_REV30_STATUS_REMOTE
-
-/* #define CONFIG_USB_PD_REV30_CHUNKING_BY_PE */
-
-#define CONFIG_USB_PD_REV30_PPS_SINK
-/* #define CONFIG_USB_PD_REV30_PPS_SOURCE */
-
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
-#define CONFIG_USB_PD_REV30_STATUS_LOCAL_TEMP
-#endif	/* CONFIG_USB_PD_REV30_STATUS_LOCAL */
-
-#ifdef CONFIG_USB_PD_REV30_BAT_CAP_LOCAL
-#define CONFIG_USB_PD_REV30_BAT_INFO
-#endif	/* CONFIG_USB_PD_REV30_BAT_CAP_LOCAL */
-
-#ifdef CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL
-#undef CONFIG_USB_PD_REV30_BAT_INFO
-#define CONFIG_USB_PD_REV30_BAT_INFO
-#endif	/* CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL */
-
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
-#define CONFIG_USB_PD_REV30_COUNTRY_AUTHORITY
-#endif	/* CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL */
-
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL
-#undef CONFIG_USB_PD_REV30_COUNTRY_AUTHORITY
-#define CONFIG_USB_PD_REV30_COUNTRY_AUTHORITY
-#endif	/* CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL */
-
-#ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
-#define CONFIG_USB_PD_DPM_AUTO_SEND_ALERT
-#endif	/* CONFIG_USB_PD_REV30_ALERT_LOCAL */
-
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
-#define CONFIG_USB_PD_DPM_AUTO_GET_STATUS
-#endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
-
-#define CONFIG_MTK_HANDLE_PPS_TIMEOUT
-
-#endif	/* CONFIG_USB_PD_REV30 */
+#define CONFIG_USB_PD_REV30	0
+
+#define CONFIG_USB_PD_REV30_SYNC_SPEC_REV	0
+#define CONFIG_USB_PD_REV30_COLLISION_AVOID	0
+#define CONFIG_USB_PD_REV30_SRC_FLOW_DELAY_STARTUP	0
+#define CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP	0
+#define CONFIG_USB_PD_REV30_DISCOVER_CABLE_WITH_VCONN	0
+#define CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL	0
+#define CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE	0
+#define CONFIG_USB_PD_REV30_BAT_CAP_LOCAL	0
+#define CONFIG_USB_PD_REV30_BAT_CAP_REMOTE	0
+#define CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL	0
+#define CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE	0
+#define CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL	0
+#define CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE	0
+#define CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL	0
+#define CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE	0
+#define CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL	0
+#define CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE	0
+#define CONFIG_USB_PD_REV30_ALERT_LOCAL	0
+#define CONFIG_USB_PD_REV30_ALERT_REMOTE	0
+#define CONFIG_USB_PD_REV30_STATUS_LOCAL	0
+#define CONFIG_USB_PD_REV30_STATUS_REMOTE	0
+#define CONFIG_USB_PD_REV30_CHUNKING_BY_PE	0
+#define CONFIG_USB_PD_REV30_PPS_SINK		0
+#define CONFIG_USB_PD_REV30_PPS_SOURCE		0
+#define CONFIG_USB_PD_REV30_STATUS_LOCAL_TEMP	0
+#define CONFIG_USB_PD_REV30_BAT_INFO		0
+#define CONFIG_USB_PD_REV30_COUNTRY_AUTHORITY	0
+#define CONFIG_USB_PD_DPM_AUTO_SEND_ALERT	0
+#define CONFIG_USB_PD_DPM_AUTO_GET_STATUS	0
+#define CONFIG_MTK_HANDLE_PPS_TIMEOUT		0
+
+/* CONFIG_USB_PD_REV30 */
 
 /**********************************************************
  * PD direct charge support
  **********************************************************/
 
-#ifdef CONFIG_USB_PD_ALT_MODE_RTDC
-#define CONFIG_USB_PD_DIRECT_CHARGE
-#endif	/* CONFIG_USB_PD_ALT_MODE_RTDC */
-
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
-#undef CONFIG_USB_PD_DIRECT_CHARGE
-#define CONFIG_USB_PD_DIRECT_CHARGE
-#endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
-
-#define CONFIG_USB_PD_KEEP_PARTNER_ID
-#define CONFIG_USB_PD_KEEP_SVIDS
-#define CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
-#define CONFIG_USB_PD_DFP_READY_DISCOVER_ID
-#define CONFIG_USB_PD_RESET_CABLE
-
-#define CONFIG_USB_PD_RANDOM_FLOW_DELAY
-
-#define CONFIG_USB_PD_DFP_FLOW_DELAY
-#define CONFIG_USB_PD_DFP_FLOW_DELAY_STARTUP
-#define CONFIG_USB_PD_DFP_FLOW_DELAY_DRSWAP
-#define CONFIG_USB_PD_DFP_FLOW_DELAY_RESET
-
-#define CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
+#define CONFIG_USB_PD_DIRECT_CHARGE	0
+#define CONFIG_USB_PD_DIRECT_CHARGE	0
+#define CONFIG_USB_PD_KEEP_PARTNER_ID	0
+#define CONFIG_USB_PD_KEEP_SVIDS	0
+#define CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID	0
+#define CONFIG_USB_PD_DFP_READY_DISCOVER_ID	0
+#define CONFIG_USB_PD_RESET_CABLE	0
+#define CONFIG_USB_PD_RANDOM_FLOW_DELAY	0
+#define CONFIG_USB_PD_DFP_FLOW_DELAY	0
+#define CONFIG_USB_PD_DFP_FLOW_DELAY_STARTUP	0
+#define CONFIG_USB_PD_DFP_FLOW_DELAY_DRSWAP	0
+#define CONFIG_USB_PD_DFP_FLOW_DELAY_RESET	0
+
+#define CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG	0
 
 /* Only in startup */
-#define CONFIG_USB_PD_UFP_FLOW_DELAY
-#define CONFIG_USB_PD_VCONN_STABLE_DELAY
-#define CONFIG_USB_PD_VCONN_SAFE5V_ONLY
-
-#define CONFIG_USB_PD_ATTEMP_DISCOVER_ID
-#define CONFIG_USB_PD_ATTEMP_DISCOVER_SVID
-
-#define CONFIG_USB_PD_DISCOVER_CABLE_REQUEST_VCONN
-#define CONFIG_USB_PD_DISCOVER_CABLE_RETURN_VCONN
-
-#define CONFIG_USB_PD_PR_SWAP_ERROR_RECOVERY
-
-#define CONFIG_USB_PD_CUSTOM_VDM
-
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
-#define CONFIG_USB_PD_SVDM
-#define CONFIG_USB_PD_UVDM
-#endif	/* CONFIG_USB_PD_CUSTOM_VDM */
-
-#ifdef CONFIG_TYPEC_CAP_DBGACC_SNK
-/* #define CONFIG_USB_PD_CUSTOM_DBGACC */
-#endif	/* CONFIG_TYPEC_CAP_DBGACC_SNK */
+#define CONFIG_USB_PD_UFP_FLOW_DELAY		0
+#define CONFIG_USB_PD_VCONN_STABLE_DELAY	0
+#define CONFIG_USB_PD_VCONN_SAFE5V_ONLY		0
+
+#define CONFIG_USB_PD_ATTEMPT_DISCOVER_ID	0
+#define CONFIG_USB_PD_ATTEMPT_DISCOVER_SVID	0
+
+#define CONFIG_USB_PD_DISCOVER_CABLE_REQUEST_VCONN	0
+#define CONFIG_USB_PD_DISCOVER_CABLE_RETURN_VCONN	0
+
+#define CONFIG_USB_PD_PR_SWAP_ERROR_RECOVERY	0
+
+#define CONFIG_USB_PD_CUSTOM_VDM	0
+#define CONFIG_USB_PD_SVDM	0
+#define CONFIG_USB_PD_UVDM	0
+
+#define CONFIG_USB_PD_CUSTOM_DBGACC	0
+#define CONFIG_USB_PD_SNK_DFT_NO_GOOD_CRC	0
+#define CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP	0
+#define CONFIG_USB_PD_VBUS_DETECTION_DURING_PR_SWAP	0
+#define CONFIG_USB_PD_CHECK_RX_PENDING_IF_SRTOUT	0
+#define CONFIG_USB_PD_ONLY_PRINT_SYSTEM_BUSY	0
+#define CONFIG_USB_PD_TRY_TIMEDELAY_IF_SRTOUT   0
+#define CONFIG_USB_PD_TRY_TIMEDELAY_MAX		0
+#define CONFIG_USB_PD_RENEGOTIATION_COUNTER	0
+#define CONFIG_USB_PD_ERROR_RECOVERY_ONCE	0
+
+#define CONFIG_USB_PD_IGNORE_HRESET_COMPLETE_TIMER	0
+#define CONFIG_USB_PD_DROP_REPEAT_PING			0
+#define CONFIG_USB_PD_CHECK_DATA_ROLE			0
+#define CONFIG_USB_PD_RETRY_CRC_DISCARD			0
+#define CONFIG_USB_PD_PARTNER_CTRL_MSG_FIRST		0
+
+#define CONFIG_USB_PD_SNK_HRESET_KEEP_DRAW		0
+#define CONFIG_USB_PD_SNK_IGNORE_HRESET_IF_TYPEC_ONLY	0
+#define CONFIG_USB_PD_SNK_STANDBY_POWER			0
+#define CONFIG_USB_PD_SNK_GOTOMIN			0
+
+#define CONFIG_USB_PD_SRC_HIGHCAP_POWER			0
+#define CONFIG_USB_PD_SRC_TRY_PR_SWAP_IF_BAD_PW		0
+#define CONFIG_USB_PD_SRC_REJECT_PR_SWAP_IF_GOOD_PW	0
+
+#define CONFIG_USB_PD_TRANSMIT_BIST2		0
+#define CONFIG_USB_PD_POSTPONE_VDM		0
+#define CONFIG_USB_PD_POSTPONE_RETRY_VDM	0
+#define CONFIG_USB_PD_POSTPONE_FIRST_VDM	0
+#define CONFIG_USB_PD_POSTPONE_OTHER_VDM	0
+#define CONFIG_USB_PD_STOP_SEND_VDM_IF_RX_BUSY	0
+#define CONFIG_USB_PD_STOP_REPLY_VDM_IF_RX_BUSY	0
+
+#define CONFIG_USB_PD_SAFE0V_DELAY		0
+#define CONFIG_USB_PD_SAFE0V_TIMEOUT		1
+
+#define CONFIG_USB_PD_DPM_SVDM_RETRY		0
+#define CONFIG_USB_PD_DFP_FLOW_RETRY_MAX 0
+#define CONFIG_USB_PD_VBUS_STABLE_TOUT 0
+#define CONFIG_USB_PD_VBUS_PRESENT_TOUT	0
+#define CONFIG_USB_PD_CUSTOM_VDM_TOUT	0
+#define CONFIG_USB_PD_VCONN_READY_TOUT		0
+#define CONFIG_USB_PD_DFP_FLOW_DLY	0
+#define CONFIG_USB_PD_UFP_FLOW_DLY			0
+#define CONFIG_USB_PD_PPS_REQUEST_INTERVAL	0
+#define CONFIG_USB_PD_WAIT_BC12	0
 
-/* S/W patch for ESD issue: repeat HReset Alert */
-/* #define CONFIG_USB_PD_RECV_HRESET_COUNTER */
-
-/* S/W patch for NoGoodCRC if SNK_DFT */
-#define CONFIG_USB_PD_SNK_DFT_NO_GOOD_CRC
-
-/* S/W patch for NoGoodCRC after PR_SWAP (repeat PS_RDY) */
-#define CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP
-
-/* S/W patch for delayed ps_change related to PS_RDY during PR_SWAP */
-#define CONFIG_USB_PD_VBUS_DETECTION_DURING_PR_SWAP
-
-/*
- * S/W patch for INT handler was stuck by other task (system busy)
- *
- * If the communication fails due to a timeout,
- * check the rx buffer is empty or not.
- *
- * If the rx buffer isn't empty, postpone timer.
- */
-
-#define CONFIG_USB_PD_CHECK_RX_PENDING_IF_SRTOUT
-#define CONFIG_USB_PD_ONLY_PRINT_SYSTEM_BUSY
-
-/*
- * S/W patch for
- * If the CC pin is shorted to ground and our receive ability is better,
- * then we may receive message however always send failed.
- *
- * For the source role, it becomes an infinite hard reset loop.
- * For the sink role, it becomes an infinite error recovery loop.
- *
- * RENEGOTIATION_COUNTER:
- *     Auto error recovery
- *     if retried hard reset many times still negotiation failed.
- *
- * ERROR_RECOVERY_ONCE:
- *     If we have tried an error recovery,
- *     using pure typec mode during next time we reconnect.
- *
- */
-
-#define CONFIG_USB_PD_RENEGOTIATION_COUNTER
-#define CONFIG_USB_PD_ERROR_RECOVERY_ONCE
-
-#define CONFIG_USB_PD_IGNORE_HRESET_COMPLETE_TIMER
-#define CONFIG_USB_PD_DROP_REPEAT_PING
-#define CONFIG_USB_PD_CHECK_DATA_ROLE
-#define CONFIG_USB_PD_RETRY_CRC_DISCARD
-#define CONFIG_USB_PD_PARTNER_CTRL_MSG_FIRST
-
-#define CONFIG_USB_PD_SNK_HRESET_KEEP_DRAW
-/* #define CONFIG_USB_PD_SNK_IGNORE_HRESET_IF_TYPEC_ONLY */
-#define CONFIG_USB_PD_SNK_STANDBY_POWER
-#define CONFIG_USB_PD_SNK_GOTOMIN
-
-/* #define CONFIG_USB_PD_SRC_HIGHCAP_POWER */
-#define CONFIG_USB_PD_SRC_TRY_PR_SWAP_IF_BAD_PW
-
-#define CONFIG_USB_PD_TRANSMIT_BIST2
-#define CONFIG_USB_PD_POSTPONE_VDM
-#define CONFIG_USB_PD_POSTPONE_RETRY_VDM
-#define CONFIG_USB_PD_POSTPONE_FIRST_VDM
-#define CONFIG_USB_PD_POSTPONE_OTHER_VDM
-/* #define CONFIG_USB_PD_STOP_SEND_VDM_IF_RX_BUSY */
-#define CONFIG_USB_PD_STOP_REPLY_VDM_IF_RX_BUSY
-
-/* #define CONFIG_USB_PD_SAFE0V_DELAY */
-/* #define CONFIG_USB_PD_SAFE0V_TIMEOUT */
-
-#ifndef CONFIG_USB_PD_DPM_SVDM_RETRY
-#define CONFIG_USB_PD_DPM_SVDM_RETRY     2
-#endif     /* CONFIG_USB_PD_DPM_SVDM_RETRY */
-
-#ifndef CONFIG_USB_PD_DFP_FLOW_RETRY_MAX
-#define CONFIG_USB_PD_DFP_FLOW_RETRY_MAX 2
-#endif	/* CONFIG_USB_PD_DFP_FLOW_RETRY_MAX */
-
-#ifndef CONFIG_USB_PD_VBUS_STABLE_TOUT
-#define CONFIG_USB_PD_VBUS_STABLE_TOUT 125
-#endif	/* CONFIG_USB_PD_VBUS_STABLE_TOUT */
-
-#ifndef CONFIG_USB_PD_VBUS_PRESENT_TOUT
-#define CONFIG_USB_PD_VBUS_PRESENT_TOUT	20
-#endif	/* CONFIG_USB_PD_VBUS_PRESENT_TOUT */
-
-#ifndef CONFIG_USB_PD_CUSTOM_VDM_TOUT
-#define CONFIG_USB_PD_CUSTOM_VDM_TOUT	500
-#endif	/* CONFIG_USB_PD_CUSTOM_VDM_TOUT */
-
-#ifndef CONFIG_USB_PD_VCONN_READY_TOUT
-#define CONFIG_USB_PD_VCONN_READY_TOUT		5
-#endif	/* CONFIG_USB_PD_VCONN_READY_TOUT */
-
-#ifndef CONFIG_USB_PD_DFP_FLOW_DLY
-#define CONFIG_USB_PD_DFP_FLOW_DLY	30
-#endif	/* CONFIG_USB_PD_DFP_FLOW_DLY */
-
-#ifndef CONFIG_USB_PD_UFP_FLOW_DLY
-#define CONFIG_USB_PD_UFP_FLOW_DLY			300
-#endif	/* CONFIG_USB_PD_UFP_FLOW_DLY */
-
-#ifndef CONFIG_USB_PD_PPS_REQUEST_INTERVAL
-#define CONFIG_USB_PD_PPS_REQUEST_INTERVAL	7000
-#endif	/* CONFIG_USB_PD_PPS_REQUEST_INTERVAL */
-
-#ifdef CONFIG_MTK_CHARGER
-#define CONFIG_USB_PD_WAIT_BC12
-#endif /* CONFIG_MTK_CHARGER */
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
+#define CONFIG_USB_PD_DBG_ALWAYS_LOCAL_RP 0
+#define CONFIG_USB_PD_DBG_IGRONE_TIMEOUT 0
 /* debug config */
-/* #define CONFIG_USB_PD_DBG_ALERT_STATUS */
-/* #define CONFIG_USB_PD_DBG_SKIP_ALERT_HANDLER */
-#define CONFIG_USB_PD_DBG_DP_DFP_D_AUTO_UPDATE
+#define CONFIG_USB_PD_DBG_ALERT_STATUS	0
+#define CONFIG_USB_PD_DBG_SKIP_ALERT_HANDLER	0
+#define CONFIG_USB_PD_DBG_DP_DFP_D_AUTO_UPDATE	1
+#define CONFIG_USB_PD_DBG_DP_UFP_U_AUTO_UPDATE 0
+#define CONFIG_USB_PD_DBG_DP_UFP_U_AUTO_ATTENTION 0
 
 /**********************************************************
  * TypeC Shield Protection
  **********************************************************/
 
-#ifdef CONFIG_MTK_TYPEC_WATER_DETECT
-#define CONFIG_WATER_DETECTION
+#if IS_ENABLED(CONFIG_MTK_TYPEC_WATER_DETECT)
+#define CONFIG_WATER_DETECTION	1
+#else
+#define CONFIG_WATER_DETECTION	0
 #endif /* CONFIG_MTK_TYPEC_WATER_DETECT */
 
-#ifdef CONFIG_WATER_DETECTION
-#define CONFIG_WD_SBU_POLLING
-/* #define CONFIG_WATER_CALIBRATION */
+#if CONFIG_WATER_DETECTION
+#define CONFIG_WD_SBU_POLLING	1
+#define CONFIG_WATER_CALIBRATION	0
 #define CONFIG_WD_SBU_CALIB_INIT	1800 /* mV */
 #define CONFIG_WD_SBU_PL_BOUND		200 /* mV */
 #define CONFIG_WD_SBU_PL_LBOUND_C2C	1100 /* mV */
@@ -431,13 +297,17 @@
 #define CONFIG_WD_SBU_PH_UBOUND2_C2C	3800 /* mV */
 #define CONFIG_WD_SBU_AUD_UBOUND	1600 /* mV */
 #define CONFIG_WD_PROTECT_RETRY_COUNT	3
+#else
+#define CONFIG_WD_SBU_POLLING	0
 #endif /* CONFIG_WATER_DETECTION */
 
-#ifdef CONFIG_WD_SBU_POLLING
-#define CONFIG_WD_POLLING_ONLY
+#if CONFIG_WD_SBU_POLLING
+#define CONFIG_WD_POLLING_ONLY	1
+#else
+#define CONFIG_WD_POLLING_ONLY	0
 #endif /* CONFIG_WD_SBU_POLLING */
 
-#define CONFIG_CABLE_TYPE_DETECTION
+#define CONFIG_CABLE_TYPE_DETECTION	1
 
 #endif /* CONFIG_TCPC_CLASS */
 #endif /* __LINUX_TCPC_CONFIG_H */
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/tcpci_core.h b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_core.h
index f1e791b..d6b6138 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/tcpci_core.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_core.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #ifndef __LINUX_RT_TCPCI_CORE_H
@@ -27,10 +19,10 @@
 #include "tcpci_timer.h"
 #include "tcpci_config.h"
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 #include "pd_core.h"
-#ifdef CONFIG_USB_PD_WAIT_BC12
-#include <mt-plat/charger_type.h>
+#if CONFIG_USB_PD_WAIT_BC12
+#include <linux/power_supply.h>
 #endif /* CONFIG_USB_PD_WAIT_BC12 */
 #endif
 
@@ -59,7 +51,7 @@
 #define UVDM_INFO_ENABLE	1
 #define TCPM_DBG_ENABLE		1
 
-#ifdef CONFIG_USB_PD_ALT_MODE_RTDC
+#if CONFIG_USB_PD_ALT_MODE_RTDC
 #define DC_INFO_ENABLE		1
 #define DC_DBG_ENABLE		1
 #endif	/* CONFIG_USB_PD_ALT_MODE_RTDC */
@@ -80,6 +72,9 @@
 #define PE_EVT_INFO_VDM_DIS	0
 #define PE_DBG_RESET_VDM_DIS	1
 
+/* sender response timer will sub delta between transmit & tx_success */
+#define PD_DYNAMIC_SENDER_RESPONSE	1
+
 #define PD_BUG_ON(x)	WARN_ON(x)
 
 struct tcpc_device;
@@ -89,8 +84,14 @@ struct tcpc_desc {
 	uint8_t rp_lvl;
 	uint8_t vconn_supply;
 	int notifier_supply_num;
-	char *name;
-#ifdef CONFIG_WATER_DETECTION
+	const char *name;
+	bool en_wd;
+	bool en_wd_sbu_polling;
+	bool en_wd_polling_only;
+	bool en_ctd;
+	bool en_fod;
+	bool en_typec_otp;
+	bool en_floatgnd;
 	u32 wd_sbu_calib_init;
 	u32 wd_sbu_pl_bound;
 	u32 wd_sbu_pl_lbound_c2c;
@@ -101,25 +102,23 @@ struct tcpc_desc {
 	u32 wd_sbu_ph_ubound1_c2c;
 	u32 wd_sbu_ph_ubound2_c2c;
 	u32 wd_sbu_aud_ubound;
-#endif /* CONFIG_WATER_DETECTION */
 };
 
 /*---------------------------------------------------------------------------*/
 
-#ifdef CONFIG_TYPEC_NOTIFY_ATTACHWAIT_SNK
-#define CONFIG_TYPEC_NOTIFY_ATTACHWAIT
+#if CONFIG_TYPEC_NOTIFY_ATTACHWAIT_SNK
+#define CONFIG_TYPEC_NOTIFY_ATTACHWAIT 1
 #endif	/* CONFIG_TYPEC_NOTIFY_ATTACHWAIT_SNK */
 
-#ifdef CONFIG_TYPEC_NOTIFY_ATTACHWAIT_SRC
+#if CONFIG_TYPEC_NOTIFY_ATTACHWAIT_SRC
 #undef CONFIG_TYPEC_NOTIFY_ATTACHWAIT
-#define CONFIG_TYPEC_NOTIFY_ATTACHWAIT
+#define CONFIG_TYPEC_NOTIFY_ATTACHWAIT 1
 #endif	/* CONFIG_TYPEC_NOTIFY_ATTACHWAIT_SNK */
 
 
-#ifdef CONFIG_TCPC_FORCE_DISCHARGE_EXT
-#define CONFIG_TCPC_EXT_DISCHARGE
+#if CONFIG_TCPC_FORCE_DISCHARGE_EXT
+#define CONFIG_TCPC_EXT_DISCHARGE 1
 #endif	/* CONFIG_TCPC_FORCE_DISCHARGE_EXT */
-
 /*---------------------------------------------------------------------------*/
 
 /* TCPC Power Register Define */
@@ -158,7 +157,7 @@ struct tcpc_desc {
 	TCPC_REG_ALERT_TX_FAILED | TCPC_REG_ALERT_TX_DISCARDED)
 
 #define TCPC_REG_ALERT_TXRX_MASK	\
-	(TCPC_REG_ALERT_TX_MASK | TCPC_REG_ALERT_RX_MASK)
+	(TCPC_REG_ALERT_TX_MASK | TCPC_REG_ALERT_RX_ALL_MASK)
 
 /* TCPC Behavior Flags */
 #define TCPC_FLAGS_RETRY_CRC_DISCARD		(1<<0)
@@ -175,34 +174,30 @@ struct tcpc_desc {
 #define TCPC_FLAGS_WATER_DETECTION		(1<<9)
 #define TCPC_FLAGS_CABLE_TYPE_DETECTION		(1<<10)
 #define TCPC_FLAGS_VCONN_SAFE5V_ONLY		(1<<11)
-#define TCPC_FLAGS_ALERT_V10			(1<<12)
-
-#define TYPEC_CC_PULL(rp_lvl, res)	((rp_lvl & 0x03) << 3 | (res & 0x07))
-
-enum tcpc_rp_lvl {
-	TYPEC_RP_DFT,
-	TYPEC_RP_1_5,
-	TYPEC_RP_3_0,
-	TYPEC_RP_RSV,
-};
+#define TCPC_FLAGS_ALERT_V10                    (1<<12)
+#define TCPC_FLAGS_FOREIGN_OBJECT_DETECTION	(1<<13)
+#define TCPC_FLAGS_TYPEC_OTP			(1<<14)
+#define TCPC_FLAGS_FLOATING_GROUND		(1<<15)
+#define TCPC_FLAGS_SBU_POLLING			(1<<16)
+#define TCPC_FLAGS_WD_POLLING_ONLY		(1<<17)
 
 enum tcpc_cc_pull {
 	TYPEC_CC_RA = 0,
 	TYPEC_CC_RP = 1,
 	TYPEC_CC_RD = 2,
 	TYPEC_CC_OPEN = 3,
-	TYPEC_CC_DRP = 4,		/* from Rd */
+	TYPEC_CC_DRP = 4,	/* from Rd */
 
-	TYPEC_CC_RP_DFT = TYPEC_CC_PULL(TYPEC_RP_DFT, TYPEC_CC_RP),
-	TYPEC_CC_RP_1_5 = TYPEC_CC_PULL(TYPEC_RP_1_5, TYPEC_CC_RP),
-	TYPEC_CC_RP_3_0 = TYPEC_CC_PULL(TYPEC_RP_3_0, TYPEC_CC_RP),
+	TYPEC_CC_RP_DFT = 1,		/* 0x00 + 1 */
+	TYPEC_CC_RP_1_5 = 9,		/* 0x08 + 1*/
+	TYPEC_CC_RP_3_0 = 17,		/* 0x10 + 1 */
 
-	TYPEC_CC_DRP_DFT = TYPEC_CC_PULL(TYPEC_RP_DFT, TYPEC_CC_DRP),
-	TYPEC_CC_DRP_1_5 = TYPEC_CC_PULL(TYPEC_RP_1_5, TYPEC_CC_DRP),
-	TYPEC_CC_DRP_3_0 = TYPEC_CC_PULL(TYPEC_RP_3_0, TYPEC_CC_DRP),
+	TYPEC_CC_DRP_DFT = 4,		/* 0x00 + 4 */
+	TYPEC_CC_DRP_1_5 = 12,		/* 0x08 + 4 */
+	TYPEC_CC_DRP_3_0 = 20,		/* 0x10 + 4 */
 };
 
-#define TYPEC_CC_PULL_GET_RES(pull)	(pull & 0x07)
+#define TYPEC_CC_PULL_GET_RES(pull)		(pull & 0x07)
 #define TYPEC_CC_PULL_GET_RP_LVL(pull)	((pull & 0x18) >> 3)
 
 enum tcpm_rx_cap_type {
@@ -232,35 +227,42 @@ struct tcpc_ops {
 	int (*set_vconn)(struct tcpc_device *tcpc, int enable);
 	int (*deinit)(struct tcpc_device *tcpc);
 	int (*alert_vendor_defined_handler)(struct tcpc_device *tcpc);
+	int (*set_auto_dischg_discnt)(struct tcpc_device *tcpc, bool en);
+	int (*get_vbus_voltage)(struct tcpc_device *tcpc, u32 *vbus);
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	int (*is_vsafe0v)(struct tcpc_device *tcpc);
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 	int (*is_water_detected)(struct tcpc_device *tcpc);
 	int (*set_water_protection)(struct tcpc_device *tcpc, bool en);
 	int (*set_usbid_polling)(struct tcpc_device *tcpc, bool en);
 #endif /* CONFIG_WATER_DETECTION */
+	int (*set_cc_hidet)(struct tcpc_device *tcpc, bool en);
 
-#ifdef CONFIG_TCPC_LOW_POWER_MODE
+	int (*set_floating_ground)(struct tcpc_device *tcpc, bool en);
+
+	int (*set_otp_fwen)(struct tcpc_device *tcpc, bool en);
+
+#if CONFIG_TCPC_LOW_POWER_MODE
 	int (*is_low_power_mode)(struct tcpc_device *tcpc);
 	int (*set_low_power_mode)(struct tcpc_device *tcpc, bool en, int pull);
 #endif /* CONFIG_TCPC_LOW_POWER_MODE */
 
 	int (*set_watchdog)(struct tcpc_device *tcpc, bool en);
 
-#ifdef CONFIG_TCPC_INTRST_EN
+#if CONFIG_TCPC_INTRST_EN
 	int (*set_intrst)(struct tcpc_device *tcpc, bool en);
 #endif /* CONFIG_TCPC_INTRST_EN */
 
-#ifdef CONFIG_TYPEC_CAP_AUTO_DISCHARGE
-#ifdef CONFIG_TCPC_AUTO_DISCHARGE_IC
+#if CONFIG_TYPEC_CAP_AUTO_DISCHARGE
+#if CONFIG_TCPC_AUTO_DISCHARGE_IC
 	int (*set_auto_discharge)(struct tcpc_device *tcpc, bool en);
 #endif	/* CONFIG_TCPC_AUTO_DISCHARGE_IC */
 #endif	/* CONFIG_TYPEC_CAP_AUTO_DISCHARGE */
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	int (*set_msg_header)(struct tcpc_device *tcpc,
 			uint8_t power_role, uint8_t data_role);
 	int (*set_rx_enable)(struct tcpc_device *tcpc, uint8_t enable);
@@ -273,12 +275,12 @@ struct tcpc_ops {
 	int (*set_bist_test_mode)(struct tcpc_device *tcpc, bool en);
 	int (*set_bist_carrier_mode)(struct tcpc_device *tcpc, uint8_t pattern);
 
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 	int (*retransmit)(struct tcpc_device *tcpc);
 #endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
 
-#ifdef CONFIG_TYPEC_CAP_FORCE_DISCHARGE
-#ifdef CONFIG_TCPC_FORCE_DISCHARGE_IC
+#if CONFIG_TYPEC_CAP_FORCE_DISCHARGE
+#if CONFIG_TCPC_FORCE_DISCHARGE_IC
 	int (*set_force_discharge)(struct tcpc_device *tcpc, bool en, int mv);
 #endif	/* CONFIG_TCPC_FORCE_DISCHARGE_IC */
 #endif	/* CONFIG_TYPEC_CAP_FORCE_DISCHARGE */
@@ -325,6 +327,12 @@ struct tcpc_device {
 	struct wakeup_source *attach_wake_lock;
 	struct wakeup_source *detach_wake_lock;
 
+	/* time test */
+#if PD_DYNAMIC_SENDER_RESPONSE
+	long long t[2];
+	uint32_t tx_time_diff;
+#endif /* PD_DYNAMIC_SENDER_RESPONSE */
+
 	/* For tcpc timer & event */
 	uint32_t timer_handle_index;
 	struct hrtimer tcpc_timer[PD_TIMER_NR];
@@ -340,6 +348,7 @@ struct tcpc_device {
 	struct semaphore timer_enable_mask_lock;
 	spinlock_t timer_tick_lock;
 	atomic_t pending_event;
+	atomic_t suspend_pending;
 	uint64_t timer_tick;
 	uint64_t timer_enable_mask;
 	wait_queue_head_t event_wait_que;
@@ -376,63 +385,54 @@ struct tcpc_device {
 
 	int typec_usb_sink_curr;
 
-#ifdef CONFIG_TYPEC_CAP_CUSTOM_HV
+#if CONFIG_TYPEC_CAP_CUSTOM_HV
 	bool typec_during_custom_hv;
 #endif	/* CONFIG_TYPEC_CAP_CUSTOM_HV */
 
 	uint8_t typec_lpm_pull;
 	uint8_t typec_lpm_retry;
 
-#ifdef CONFIG_TYPEC_WAKEUP_ONCE_LOW_DUTY
+#if CONFIG_TYPEC_WAKEUP_ONCE_LOW_DUTY
 	bool typec_wakeup_once;
 	bool typec_low_rp_duty_cntdown;
 #endif	/* CONFIG_TYPEC_WAKEUP_ONCE_LOW_DUTY */
 
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE
 	uint8_t typec_legacy_cable;
 #if TCPC_LEGACY_CABLE_SUSPECT_THD
 	uint8_t typec_legacy_cable_suspect;
 #endif	/* TCPC_LEGACY_CABLE_SUSPECT_THD */
 
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE2
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE2
 	uint8_t typec_legacy_retry_wk;
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE2 */
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE */
 
-#ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
+#if CONFIG_TYPEC_CAP_ROLE_SWAP
 	uint8_t typec_during_role_swap;
 #endif	/* CONFIG_TYPEC_CAP_ROLE_SWAP */
 
-#ifdef CONFIG_TYPEC_CAP_AUTO_DISCHARGE
-#ifdef CONFIG_TCPC_AUTO_DISCHARGE_IC
+#if CONFIG_TYPEC_CAP_AUTO_DISCHARGE
+#if CONFIG_TCPC_AUTO_DISCHARGE_IC
 	bool typec_auto_discharge;
 #endif	/* CONFIG_TCPC_AUTO_DISCHARGE_IC */
 #endif	/* CONFIG_TYPEC_CAP_AUTO_DISCHARGE */
 
-#ifdef CONFIG_TCPC_EXT_DISCHARGE
+#if CONFIG_TCPC_EXT_DISCHARGE
 	bool typec_ext_discharge;
 #endif	/* CONFIG_TCPC_EXT_DISCHARGE */
 
-#ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
+#if CONFIG_TCPC_VCONN_SUPPLY_MODE
 	uint8_t tcpc_vconn_supply;
 #endif	/* CONFIG_TCPC_VCONN_SUPPLY_MODE */
 
-#ifdef CONFIG_TCPC_SOURCE_VCONN
+#if CONFIG_TCPC_SOURCE_VCONN
 	bool tcpc_source_vconn;
 #endif	/* CONFIG_TCPC_SOURCE_VCONN */
 
 	uint32_t tcpc_flags;
 
-#ifdef CONFIG_DUAL_ROLE_USB_INTF
-	struct dual_role_phy_instance *dr_usb;
-	uint8_t dual_role_supported_modes;
-	uint8_t dual_role_mode;
-	uint8_t dual_role_pr;
-	uint8_t dual_role_dr;
-	uint8_t dual_role_vconn;
-#endif /* CONFIG_DUAL_ROLE_USB_INTF */
-
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	/* Event */
 	uint8_t pd_event_count;
 	uint8_t pd_event_head_index;
@@ -467,38 +467,39 @@ struct tcpc_device {
 	uint8_t pd_transmit_state;
 	uint8_t pd_wait_vbus_once;
 
-#ifdef CONFIG_USB_PD_DIRECT_CHARGE
+#if CONFIG_USB_PD_DIRECT_CHARGE
 	bool pd_during_direct_charge;
 #endif	/* CONFIG_USB_PD_DIRECT_CHARGE */
 
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 	bool pd_discard_pending;
 #endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
 
-#ifdef CONFIG_TYPEC_CAP_FORCE_DISCHARGE
-#ifdef CONFIG_TCPC_FORCE_DISCHARGE_IC
+#if CONFIG_TYPEC_CAP_FORCE_DISCHARGE
+#if CONFIG_TCPC_FORCE_DISCHARGE_IC
 	bool pd_force_discharge;
 #endif	/* CONFIG_TCPC_FORCE_DISCHARGE_IC */
 #endif	/* CONFIG_TYPEC_CAP_FORCE_DISCHARGE */
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	uint8_t pd_retry_count;
 #endif	/* CONFIG_USB_PD_REV30 */
 
-#ifdef CONFIG_USB_PD_DISABLE_PE
+#if CONFIG_USB_PD_DISABLE_PE
 	bool disable_pe; /* typec only */
 #endif	/* CONFIG_USB_PD_DISABLE_PE */
 
 	struct pd_port pd_port;
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	struct notifier_block bat_nb;
 	struct delayed_work bat_update_work;
 	struct power_supply *bat_psy;
 	uint8_t charging_status;
 	int bat_soc;
 #endif /* CONFIG_USB_PD_REV30 */
-#ifdef CONFIG_USB_PD_WAIT_BC12
+#if CONFIG_USB_PD_WAIT_BC12
 	uint8_t pd_wait_bc12_count;
+	struct power_supply *chg_psy;
 #endif /* CONFIG_USB_PD_WAIT_BC12 */
 #endif /* CONFIG_USB_POWER_DELIVERY */
 	u8 vbus_level:2;
@@ -508,22 +509,29 @@ struct tcpc_device {
 	u8 pd_inited_flag:1; /* MTK Only */
 
 	/* TypeC Shield Protection */
-#ifdef CONFIG_WATER_DETECTION
 	int usbid_calib;
-#endif /* CONFIG_WATER_DETECTION */
-#ifdef CONFIG_CABLE_TYPE_DETECTION
+	enum tcpc_fod_status typec_fod;
+	int bootmode;
+#if CONFIG_CABLE_TYPE_DETECTION
 	enum tcpc_cable_type typec_cable_type;
-	enum tcpc_cable_type pre_typec_cable_type;
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
+	bool typec_otp;
+	u32 boot_mode;
+	u32 boot_type;
+	u32 alert_mask;
+#if CONFIG_USB_PD_CHECK_RX_PENDING_IF_SRTOUT
+	struct completion alert_done;
+	long long alert_max_access_time;
+#endif /* CONFIG_USB_PD_CHECK_RX_PENDING_IF_SRTOUT */
 };
 
 #define to_tcpc_device(obj) container_of(obj, struct tcpc_device, dev)
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 static inline uint8_t pd_get_rev(struct pd_port *pd_port, uint8_t sop_type)
 {
 	uint8_t pd_rev = PD_REV20;
-#ifdef CONFIG_USB_PD_REV30_SYNC_SPEC_REV
+#if CONFIG_USB_PD_REV30_SYNC_SPEC_REV
 	struct pe_data *pe_data = &pd_port->pe_data;
 	struct tcpc_device *tcpc = pd_port->tcpc;
 
@@ -546,13 +554,13 @@ static inline bool pd_check_rev30(struct pd_port *pd_port)
 }
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
-#ifdef CONFIG_PD_DBG_INFO
+#if IS_ENABLED(CONFIG_PD_DBG_INFO)
 #define __RT_DBG_INFO	pd_dbg_info
 #else
 #define __RT_DBG_INFO	pr_info
 #endif /* CONFIG_PD_DBG_INFO */
 
-#ifdef CONFIG_TCPC_LOG_WITH_PORT_NAME
+#if CONFIG_TCPC_LOG_WITH_PORT_NAME
 #define RT_DBG_INFO(format, args...)	__RT_DBG_INFO(format,	\
 						      tcpc->desc.name, ##args)
 #else
@@ -691,7 +699,7 @@ static inline bool pd_check_rev30(struct pd_port *pd_port)
 #define TCPM_DBG(format, args...)
 #endif
 
-#ifdef CONFIG_USB_PD_ALT_MODE_RTDC
+#if CONFIG_USB_PD_ALT_MODE_RTDC
 
 #if DC_INFO_ENABLE
 #define DC_INFO(format, args...)	\
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/tcpci_event.h b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_event.h
index 7fae448..82cc9ad 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/tcpci_event.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_event.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #ifndef TCPC_EVENT_BUF_H_INCLUDED
@@ -78,7 +70,7 @@ enum pd_event_type {
 	PD_EVT_CTRL_MSG,
 	PD_EVT_DATA_MSG,
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	PD_EVT_EXT_MSG,
 #endif	/* CONFIG_USB_PD_REV30 */
 
@@ -110,7 +102,7 @@ enum pd_msg_type {
 	PD_CTRL_SOFT_RESET = 13,
 	/* 14-15 Reserved */
 	PD_CTRL_PD30_START = 0x10 + 0,
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	PD_CTRL_NOT_SUPPORTED = 0x10 + 0,
 	PD_CTRL_GET_SOURCE_CAP_EXT = 0x10 + 1,
 	PD_CTRL_GET_STATUS = 0x10 + 2,
@@ -127,7 +119,7 @@ enum pd_msg_type {
 	PD_DATA_BIST = 3,
 	PD_DATA_SINK_CAP = 4,
 	PD_DATA_PD30_START = 5,
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	PD_DATA_BAT_STATUS = 5,
 	PD_DATA_ALERT = 6,
 	PD_DATA_GET_COUNTRY_INFO = 7,
@@ -135,7 +127,7 @@ enum pd_msg_type {
 	/* 7-14 Reserved */
 	PD_DATA_VENDOR_DEF = 15,
 	PD_DATA_MSG_NR,
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 /* Extended message type */
 	/* 0 Reserved */
 	PD_EXT_SOURCE_CAP_EXT = 1,
@@ -163,10 +155,10 @@ enum pd_msg_type {
 	PD_HW_VBUS_ABSENT,
 	PD_HW_VBUS_SAFE0V,
 	PD_HW_VBUS_STABLE,
-	PD_HW_TX_FAILED,	/* no good crc */
-	PD_HW_TX_DISCARD,	/* discard msg */
+	PD_HW_TX_FAILED,	/* no good crc or discard */
+	PD_HW_TX_DISCARD,	/* discard vdm msg */
 	PD_HW_RETRY_VDM,	/* discard vdm msg (retry) */
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	PD_HW_SINK_TX_CHANGE,
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
 	PD_HW_MSG_NR,
@@ -252,7 +244,7 @@ static inline bool pd_event_timer_msg_match(
 	return pd_event_msg_match(pd_event, PD_EVT_TIMER_MSG, msg);
 }
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 
 static inline bool pd_event_ext_msg_match(
 	struct pd_event *pd_event, uint8_t msg)
diff --git a/./inc/tcpci_pd30_config.h b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_pd30_config.h
new file mode 100644
index 0000000..3d3fa0b
--- /dev/null
+++ b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_pd30_config.h
@@ -0,0 +1,98 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ */
+#ifndef __LINUX_TCPC_PD30_CONFIG_H
+#define __LINUX_TCPC_PD30_CONFIG_H
+
+#define CONFIG_USB_PD_REV30_SYNC_SPEC_REV	1
+#define CONFIG_USB_PD_REV30_COLLISION_AVOID	1
+
+/*
+ * If DUT send a PD command immediately after Policy Engine is ready,
+ * it may interrupt the compliance test process and getting a failed result.
+ * even you make sure the CC state is SinkTxNG or SinkTxOK.
+ *
+ * SRC_FLOW_DELAY_STARTUP: For Ellisys
+ * SNK_FLOW_DELAY_STARTUP: For MQP
+ */
+
+#define CONFIG_USB_PD_REV30_SRC_FLOW_DELAY_STARTUP	1
+#define CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP	1
+
+#define CONFIG_USB_PD_REV30_DISCOVER_CABLE_WITH_VCONN	1
+
+/* PD30 Common Feature */
+
+#define CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL	1
+#define CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE	1
+
+#define CONFIG_USB_PD_REV30_BAT_CAP_LOCAL	1
+#define CONFIG_USB_PD_REV30_BAT_CAP_REMOTE	1
+
+#define CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL	1
+#define CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE	1
+
+#define CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL	1
+#define CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE	1
+
+#define CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL	1
+#define CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE	1
+
+#define CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL	1
+#define CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE	1
+
+#define CONFIG_USB_PD_REV30_ALERT_LOCAL		1
+#define CONFIG_USB_PD_REV30_ALERT_REMOTE	1
+
+#define CONFIG_USB_PD_REV30_STATUS_LOCAL	1
+#define CONFIG_USB_PD_REV30_STATUS_REMOTE	1
+
+#define CONFIG_USB_PD_REV30_CHUNKING_BY_PE	0
+
+#define CONFIG_USB_PD_REV30_PPS_SINK		1
+#define CONFIG_USB_PD_REV30_PPS_SOURCE		0
+
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
+#define CONFIG_USB_PD_REV30_STATUS_LOCAL_TEMP	1
+#else
+#define CONFIG_USB_PD_REV30_STATUS_LOCAL_TEMP	0
+#endif	/* CONFIG_USB_PD_REV30_STATUS_LOCAL */
+
+#if CONFIG_USB_PD_REV30_BAT_CAP_LOCAL
+#define CONFIG_USB_PD_REV30_BAT_INFO	1
+#else
+#define CONFIG_USB_PD_REV30_BAT_INFO	0
+#endif	/* CONFIG_USB_PD_REV30_BAT_CAP_LOCAL */
+
+#if CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL
+#undef CONFIG_USB_PD_REV30_BAT_INFO
+#define CONFIG_USB_PD_REV30_BAT_INFO	1
+#endif	/* CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL */
+
+#if CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
+#define CONFIG_USB_PD_REV30_COUNTRY_AUTHORITY	1
+#else
+#define CONFIG_USB_PD_REV30_COUNTRY_AUTHORITY	0
+#endif	/* CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL */
+
+#if CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL
+#undef CONFIG_USB_PD_REV30_COUNTRY_AUTHORITY
+#define CONFIG_USB_PD_REV30_COUNTRY_AUTHORITY	1
+#endif	/* CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL */
+
+#if CONFIG_USB_PD_REV30_ALERT_LOCAL
+#define CONFIG_USB_PD_DPM_AUTO_SEND_ALERT	1
+#else
+#define CONFIG_USB_PD_DPM_AUTO_SEND_ALERT	0
+#endif	/* CONFIG_USB_PD_REV30_ALERT_LOCAL */
+
+#if CONFIG_USB_PD_REV30_ALERT_REMOTE
+#define CONFIG_USB_PD_DPM_AUTO_GET_STATUS	1
+#else
+#define CONFIG_USB_PD_DPM_AUTO_GET_STATUS	0
+#endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
+
+#define CONFIG_MTK_HANDLE_PPS_TIMEOUT	1
+
+#endif /* __LINUX_TCPC_PD30_CONFIG_H */
diff --git a/./inc/tcpci_pd_config.h b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_pd_config.h
new file mode 100644
index 0000000..7f192b9
--- /dev/null
+++ b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_pd_config.h
@@ -0,0 +1,271 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ */
+
+#ifndef __LINUX_TCPC_PD_CONFIG_H
+#define __LINUX_TCPC_PD_CONFIG_H
+
+/* Experimental for CodeSize */
+#define CONFIG_USB_PD_DR_SWAP		1
+#define CONFIG_USB_PD_PR_SWAP		1
+#define CONFIG_USB_PD_VCONN_SWAP	1
+#define CONFIG_USB_PD_PE_SINK		1
+#define CONFIG_USB_PD_PE_SOURCE		1
+#define CONFIG_USB_PD_DISABLE_PE	0
+
+#define CONFIG_USB_PD_TCPM_CB_RETRY		3
+#define CONFIG_USB_PD_TCPM_CB_2ND	1
+#define CONFIG_USB_PD_BLOCK_TCPM	1
+
+#define CONFIG_USB_PD_RICHTEK_UVDM	0
+
+/**********************************************************
+ * Mode Operation
+ **********************************************************/
+
+#define CONFIG_USB_PD_MODE_OPERATION	1
+
+#if CONFIG_USB_PD_MODE_OPERATION
+
+#define CONFIG_USB_PD_ATTEMPT_ENTER_MODE	1
+#define CONFIG_USB_PD_ALT_MODE	1
+
+#if CONFIG_USB_PD_ALT_MODE
+#define CONFIG_USB_PD_ALT_MODE_DFP	1
+#define CONFIG_USB_PD_ALT_MODE_RTDC	1
+#else
+#define CONFIG_USB_PD_ALT_MODE_DFP	0
+#define CONFIG_USB_PD_ALT_MODE_RTDC	0
+#endif	/* CONFIG_USB_PD_ALT_MODE */
+
+#define CONFIG_USB_PD_DP_CHECK_CABLE	0
+#define CONFIG_USB_PD_RTDC_CHECK_CABLE	0
+
+#else /* no CONFIG_USB_PD_MODE_OPERATION */
+#define CONFIG_USB_PD_ATTEMPT_ENTER_MODE	0
+#define CONFIG_USB_PD_ALT_MODE	0
+#define CONFIG_USB_PD_ALT_MODE_DFP	0
+#define CONFIG_USB_PD_ALT_MODE_RTDC	0
+#define CONFIG_USB_PD_DP_CHECK_CABLE	0
+#define CONFIG_USB_PD_RTDC_CHECK_CABLE	0
+
+#endif	/* CONFIG_USB_PD_MODE_OPERATION */
+
+/**********************************************************
+ * PD revision 3.0 feature
+ **********************************************************/
+
+#define CONFIG_USB_PD_REV30	1
+
+#if CONFIG_USB_PD_REV30
+#include "tcpci_pd30_config.h"
+#else /* CONFIG_USB_PD_REV30 = 0 */
+#define CONFIG_USB_PD_REV30_SYNC_SPEC_REV	0
+#define CONFIG_USB_PD_REV30_COLLISION_AVOID	0
+#define CONFIG_USB_PD_REV30_SRC_FLOW_DELAY_STARTUP	0
+#define CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP	0
+#define CONFIG_USB_PD_REV30_DISCOVER_CABLE_WITH_VCONN	0
+#define CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL		0
+#define CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE		0
+#define CONFIG_USB_PD_REV30_BAT_CAP_LOCAL		0
+#define CONFIG_USB_PD_REV30_BAT_CAP_REMOTE		0
+#define CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL	0
+#define CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE	0
+#define CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL	0
+#define CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE	0
+#define CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL	0
+#define CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE	0
+#define CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL	0
+#define CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE	0
+#define CONFIG_USB_PD_REV30_ALERT_LOCAL		0
+#define CONFIG_USB_PD_REV30_ALERT_REMOTE	0
+#define CONFIG_USB_PD_REV30_STATUS_LOCAL	0
+#define CONFIG_USB_PD_REV30_STATUS_REMOTE	0
+#define CONFIG_USB_PD_REV30_CHUNKING_BY_PE	0
+#define CONFIG_USB_PD_REV30_PPS_SINK		0
+#define CONFIG_USB_PD_REV30_PPS_SOURCE		0
+#define CONFIG_USB_PD_REV30_STATUS_LOCAL_TEMP	0
+#define CONFIG_USB_PD_REV30_BAT_INFO	0
+#define CONFIG_USB_PD_REV30_COUNTRY_AUTHORITY	0
+#define CONFIG_USB_PD_DPM_AUTO_SEND_ALERT	0
+#define CONFIG_USB_PD_DPM_AUTO_GET_STATUS	0
+#define CONFIG_MTK_HANDLE_PPS_TIMEOUT	0
+#endif	/* CONFIG_USB_PD_REV30 */
+
+/**********************************************************
+ * PD direct charge support
+ **********************************************************/
+
+#if CONFIG_USB_PD_ALT_MODE_RTDC
+#define CONFIG_USB_PD_DIRECT_CHARGE	1
+#else
+#define CONFIG_USB_PD_DIRECT_CHARGE	0
+#endif	/* CONFIG_USB_PD_ALT_MODE_RTDC */
+
+#if CONFIG_USB_PD_REV30_PPS_SINK
+#undef CONFIG_USB_PD_DIRECT_CHARGE
+#define CONFIG_USB_PD_DIRECT_CHARGE	1
+#endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
+
+#define CONFIG_USB_PD_KEEP_PARTNER_ID	1
+#define CONFIG_USB_PD_KEEP_SVIDS	1
+#define CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID	1
+#define CONFIG_USB_PD_DFP_READY_DISCOVER_ID	1
+#define CONFIG_USB_PD_RESET_CABLE		1
+
+#define CONFIG_USB_PD_RANDOM_FLOW_DELAY		1
+
+#define CONFIG_USB_PD_DFP_FLOW_DELAY		1
+#define CONFIG_USB_PD_DFP_FLOW_DELAY_STARTUP	1
+#define CONFIG_USB_PD_DFP_FLOW_DELAY_DRSWAP	1
+#define CONFIG_USB_PD_DFP_FLOW_DELAY_RESET	1
+
+#define CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG	1
+
+/* Only in startup */
+#define CONFIG_USB_PD_UFP_FLOW_DELAY		1
+#define CONFIG_USB_PD_VCONN_STABLE_DELAY	1
+#define CONFIG_USB_PD_VCONN_SAFE5V_ONLY		1
+
+#define CONFIG_USB_PD_ATTEMPT_DISCOVER_ID	1
+#define CONFIG_USB_PD_ATTEMPT_DISCOVER_SVID	1
+
+#define CONFIG_USB_PD_DISCOVER_CABLE_REQUEST_VCONN	1
+#define CONFIG_USB_PD_DISCOVER_CABLE_RETURN_VCONN	1
+
+#define CONFIG_USB_PD_PR_SWAP_ERROR_RECOVERY		1
+
+#define CONFIG_USB_PD_CUSTOM_VDM	1
+
+#if CONFIG_USB_PD_CUSTOM_VDM
+#define CONFIG_USB_PD_SVDM	1
+#define CONFIG_USB_PD_UVDM	1
+#else
+#define CONFIG_USB_PD_SVDM	0
+#define CONFIG_USB_PD_UVDM	0
+#endif	/* CONFIG_USB_PD_CUSTOM_VDM */
+
+#if CONFIG_TYPEC_CAP_DBGACC_SNK
+#define CONFIG_USB_PD_CUSTOM_DBGACC	0
+#else
+#define CONFIG_USB_PD_CUSTOM_DBGACC	1
+#endif	/* CONFIG_TYPEC_CAP_DBGACC_SNK */
+
+/* S/W patch for ESD issue: repeat HReset Alert */
+#define CONFIG_USB_PD_RECV_HRESET_COUNTER	0
+
+/* S/W patch for NoGoodCRC if SNK_DFT */
+#define CONFIG_USB_PD_SNK_DFT_NO_GOOD_CRC	1
+
+/* S/W patch for NoGoodCRC after PR_SWAP (repeat PS_RDY) */
+#define CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP	1
+
+/* S/W patch for delayed ps_change related to PS_RDY during PR_SWAP */
+#define CONFIG_USB_PD_VBUS_DETECTION_DURING_PR_SWAP	1
+
+/*
+ * S/W patch for INT handler was stuck by other task (system busy)
+ *
+ * If the communication fails due to a timeout,
+ * check the rx buffer is empty or not.
+ *
+ * If the rx buffer isn't empty, postpone timer.
+ */
+
+#define CONFIG_USB_PD_CHECK_RX_PENDING_IF_SRTOUT	1
+#define CONFIG_USB_PD_ONLY_PRINT_SYSTEM_BUSY		1
+
+#define CONFIG_USB_PD_TRY_TIMEDELAY_IF_SRTOUT   3000
+#define CONFIG_USB_PD_TRY_TIMEDELAY_MAX 10000
+
+/*
+ * S/W patch for
+ * If the CC pin is shorted to ground and our receive ability is better,
+ * then we may receive message however always send failed.
+ *
+ * For the source role, it becomes an infinite hard reset loop.
+ * For the sink role, it becomes an infinite error recovery loop.
+ *
+ * RENEGOTIATION_COUNTER:
+ *     Auto error recovery
+ *     if retried hard reset many times still negotiation failed.
+ *
+ * ERROR_RECOVERY_ONCE:
+ *     If we have tried an error recovery,
+ *     using pure typec mode during next time we reconnect.
+ *
+ */
+
+#define CONFIG_USB_PD_RENEGOTIATION_COUNTER	1
+#define CONFIG_USB_PD_ERROR_RECOVERY_ONCE	1
+
+#define CONFIG_USB_PD_IGNORE_HRESET_COMPLETE_TIMER	1
+#define CONFIG_USB_PD_DROP_REPEAT_PING		1
+#define CONFIG_USB_PD_CHECK_DATA_ROLE		1
+#define CONFIG_USB_PD_RETRY_CRC_DISCARD		1
+#define CONFIG_USB_PD_PARTNER_CTRL_MSG_FIRST	1
+
+#define CONFIG_USB_PD_SNK_HRESET_KEEP_DRAW	1
+#define CONFIG_USB_PD_SNK_IGNORE_HRESET_IF_TYPEC_ONLY	0
+#define CONFIG_USB_PD_SNK_STANDBY_POWER		1
+#define CONFIG_USB_PD_SNK_GOTOMIN		1
+
+#define CONFIG_USB_PD_SRC_HIGHCAP_POWER			0
+#define CONFIG_USB_PD_SRC_TRY_PR_SWAP_IF_BAD_PW		0
+#define CONFIG_USB_PD_SRC_REJECT_PR_SWAP_IF_GOOD_PW	0
+
+#define CONFIG_USB_PD_TRANSMIT_BIST2		1
+#define CONFIG_USB_PD_POSTPONE_VDM		1
+#define CONFIG_USB_PD_POSTPONE_RETRY_VDM	1
+#define CONFIG_USB_PD_POSTPONE_FIRST_VDM	1
+#define CONFIG_USB_PD_POSTPONE_OTHER_VDM	1
+#define CONFIG_USB_PD_STOP_SEND_VDM_IF_RX_BUSY	0
+#define CONFIG_USB_PD_STOP_REPLY_VDM_IF_RX_BUSY	1
+
+#define CONFIG_USB_PD_SAFE0V_DELAY	0
+#define CONFIG_USB_PD_SAFE0V_TIMEOUT	1
+
+#ifndef CONFIG_USB_PD_DPM_SVDM_RETRY
+#define CONFIG_USB_PD_DPM_SVDM_RETRY     2
+#endif     /* CONFIG_USB_PD_DPM_SVDM_RETRY */
+
+#ifndef CONFIG_USB_PD_DFP_FLOW_RETRY_MAX
+#define CONFIG_USB_PD_DFP_FLOW_RETRY_MAX 2
+#endif	/* CONFIG_USB_PD_DFP_FLOW_RETRY_MAX */
+
+#ifndef CONFIG_USB_PD_VBUS_STABLE_TOUT
+#define CONFIG_USB_PD_VBUS_STABLE_TOUT 125
+#endif	/* CONFIG_USB_PD_VBUS_STABLE_TOUT */
+
+#ifndef CONFIG_USB_PD_VBUS_PRESENT_TOUT
+#define CONFIG_USB_PD_VBUS_PRESENT_TOUT	20
+#endif	/* CONFIG_USB_PD_VBUS_PRESENT_TOUT */
+
+#ifndef CONFIG_USB_PD_CUSTOM_VDM_TOUT
+#define CONFIG_USB_PD_CUSTOM_VDM_TOUT	500
+#endif	/* CONFIG_USB_PD_CUSTOM_VDM_TOUT */
+
+#ifndef CONFIG_USB_PD_VCONN_READY_TOUT
+#define CONFIG_USB_PD_VCONN_READY_TOUT		5
+#endif	/* CONFIG_USB_PD_VCONN_READY_TOUT */
+
+#ifndef CONFIG_USB_PD_DFP_FLOW_DLY
+#define CONFIG_USB_PD_DFP_FLOW_DLY	30
+#endif	/* CONFIG_USB_PD_DFP_FLOW_DLY */
+
+#ifndef CONFIG_USB_PD_UFP_FLOW_DLY
+#define CONFIG_USB_PD_UFP_FLOW_DLY			300
+#endif	/* CONFIG_USB_PD_UFP_FLOW_DLY */
+
+#ifndef CONFIG_USB_PD_PPS_REQUEST_INTERVAL
+#define CONFIG_USB_PD_PPS_REQUEST_INTERVAL	7000
+#endif	/* CONFIG_USB_PD_PPS_REQUEST_INTERVAL */
+
+#if IS_ENABLED(CONFIG_MTK_CHARGER)
+#define CONFIG_USB_PD_WAIT_BC12		1
+#else
+#define CONFIG_USB_PD_WAIT_BC12		0
+#endif /* CONFIG_MTK_CHARGER */
+
+#endif /* __LINUX_TCPC_PD_CONFIG_H */
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/tcpci_timer.h b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_timer.h
index 70bd2bf..e9664ee 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/tcpci_timer.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_timer.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #ifndef TCPC_TIMER_H_INCLUDED
@@ -19,7 +11,7 @@
 
 struct tcpc_device;
 enum {
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	PD_TIMER_DISCOVER_ID = 0,
 	PD_TIMER_BIST_CONT_MODE,
 	PD_TIMER_HARD_RESET_COMPLETE,
@@ -34,7 +26,7 @@ enum {
 	PD_TIMER_SOURCE_CAPABILITY,
 	PD_TIMER_SOURCE_START,
 	PD_TIMER_VCONN_ON,
-#ifdef CONFIG_USB_PD_VCONN_STABLE_DELAY
+#if CONFIG_USB_PD_VCONN_STABLE_DELAY
 	PD_TIMER_VCONN_STABLE,
 #endif	/* CONFIG_USB_PD_VCONN_STABLE_DELAY */
 	PD_TIMER_VDM_MODE_ENTRY,
@@ -42,12 +34,12 @@ enum {
 	PD_TIMER_VDM_RESPONSE,
 	PD_TIMER_SOURCE_TRANSITION,
 	PD_TIMER_SRC_RECOVER,
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	PD_TIMER_CK_NOT_SUPPORTED,
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	PD_TIMER_SINK_TX,
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
-#ifdef CONFIG_USB_PD_REV30_PPS_SOURCE
+#if CONFIG_USB_PD_REV30_PPS_SOURCE
 	PD_TIMER_SOURCE_PPS_TIMEOUT,
 #endif	/* CONFIG_USB_PD_REV30_PPS_SOURCE */
 #endif	/* CONFIG_USB_PD_REV30 */
@@ -64,10 +56,10 @@ enum {
 	PD_TIMER_VCONN_READY,
 	PD_PE_VDM_POSTPONE,
 
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	PD_TIMER_DEFERRED_EVT,
-#ifdef CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
+#if CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
 	PD_TIMER_SNK_FLOW_DELAY,
 #endif	/* CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP */
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
@@ -78,7 +70,7 @@ enum {
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
 /* TYPEC_RT_TIMER (out of spec )*/
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	TYPEC_RT_TIMER_START_ID = PD_PE_TIMER_END_ID,
 #else
 	TYPEC_RT_TIMER_START_ID = 0,
@@ -95,9 +87,9 @@ enum {
 	TYPEC_RT_TIMER_DISCHARGE,
 	TYPEC_RT_TIMER_LOW_POWER_MODE,
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	TYPEC_RT_TIMER_PE_IDLE,
-#ifdef CONFIG_USB_PD_WAIT_BC12
+#if CONFIG_USB_PD_WAIT_BC12
 	TYPEC_RT_TIMER_PD_WAIT_BC12,
 #endif /* CONFIG_USB_PD_WAIT_BC12 */
 #endif	/* CONFIG_USB_POWER_DELIVERY */
@@ -110,13 +102,13 @@ enum {
 	TYPEC_TIMER_START_ID,
 	TYPEC_TIMER_CCDEBOUNCE = TYPEC_TIMER_START_ID,
 	TYPEC_TIMER_PDDEBOUNCE,
-#ifdef CONFIG_COMPATIBLE_APPLE_TA
+#if CONFIG_COMPATIBLE_APPLE_TA
 	TYPEC_TIMER_APPLE_CC_OPEN,
 #endif /* CONFIG_COMPATIBLE_APPLE_TA */
 	TYPEC_TIMER_TRYCCDEBOUNCE,
 	TYPEC_TIMER_SRCDISCONNECT,
 	TYPEC_TIMER_DRP_SRC_TOGGLE,
-#ifdef CONFIG_TYPEC_CAP_NORP_SRC
+#if CONFIG_TYPEC_CAP_NORP_SRC
 	TYPEC_TIMER_NORP_SRC,
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
 	PD_TIMER_NR,
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/tcpci_typec.h b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_typec.h
index 8015030..a14e9cc 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/tcpci_typec.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_typec.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #ifndef __LINUX_TCPCI_TYPEC_H
@@ -16,12 +8,8 @@
 #include "tcpci.h"
 
 struct tcpc_device;
+extern struct class *tcpc_class;
 extern bool tcpc_typec_is_act_as_sink_role(struct tcpc_device *tcpc);
-enum CC_ORIENTATION{
-	POSITIVE = 0,
-	NEGATIVE,
-	ERR_STATUS
-};
 
 /******************************************************************************
  *  Call following function to trigger TYPEC Connection State Change
@@ -31,7 +19,6 @@ enum CC_ORIENTATION{
  * 3. Policy Engine -> PR_SWAP, Error_Recovery, PE_Idle
  *****************************************************************************/
 
-extern int power_supply_get_cc(void);
 extern int tcpc_typec_enter_lpm_again(struct tcpc_device *tcpc);
 extern int tcpc_typec_handle_cc_change(struct tcpc_device *tcpc);
 
@@ -43,7 +30,7 @@ extern int tcpc_typec_handle_timeout(
 
 extern int tcpc_typec_handle_vsafe0v(struct tcpc_device *tcpc);
 
-extern int tcpc_typec_set_rp_level(struct tcpc_device *tcpc, uint8_t rp_lvl);
+extern int tcpc_typec_set_rp_level(struct tcpc_device *tcpc, uint8_t res);
 
 extern int tcpc_typec_error_recovery(struct tcpc_device *tcpc);
 
@@ -53,19 +40,25 @@ extern int tcpc_typec_enable(struct tcpc_device *tcpc);
 extern int tcpc_typec_change_role(
 	struct tcpc_device *tcpc, uint8_t typec_role, bool postpone);
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 extern int tcpc_typec_handle_pe_pr_swap(struct tcpc_device *tcpc);
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
-#ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
+#if CONFIG_TYPEC_CAP_ROLE_SWAP
 extern int tcpc_typec_swap_role(struct tcpc_device *tcpc);
 #endif /* CONFIG_TYPEC_CAP_ROLE_SWAP */
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 extern int tcpc_typec_handle_wd(struct tcpc_device *tcpc, bool wd);
 #endif /* CONFIG_WATER_DETECTION */
 
-#ifdef CONFIG_CABLE_TYPE_DETECTION
+extern int tcpc_typec_handle_fod(struct tcpc_device *tcpc_dev,
+					enum tcpc_fod_status);
+extern bool tcpc_typec_ignore_fod(struct tcpc_device *tcpc_dev);
+
+extern int tcpc_typec_handle_otp(struct tcpc_device *tcpc_dev, bool otp);
+
+#if CONFIG_CABLE_TYPE_DETECTION
 extern int tcpc_typec_handle_ctd(struct tcpc_device *tcpc,
 				 enum tcpc_cable_type cable_type);
 #endif /* CONFIG_CABLE_TYPEC_DETECTION */
@@ -77,4 +70,5 @@ extern int tcpc_typec_handle_ctd(struct tcpc_device *tcpc,
 #define typec_get_cc_res()	\
 	(tcpc->typec_polarity ? typec_get_cc2() : typec_get_cc1())
 
+extern bool tcpc_typec_is_cc_attach(struct tcpc_device *tcpc_dev);
 #endif /* #ifndef __LINUX_TCPCI_TYPEC_H */
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/tcpm.h b/drivers/misc/mediatek/typec/tcpc/inc/tcpm.h
index d2972e3..a88af03 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/tcpm.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/tcpm.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #ifndef TCPM_H_
@@ -129,9 +121,9 @@ enum {
 	TCP_NOTIFY_VBUS_END = TCP_NOTIFY_ATTACHWAIT_SRC,
 
 	/* TCP_NOTIFY_TYPE_USB */
-	TCP_NOTIFY_TYPEC_STATE,
+	TCP_NOTIFY_TYPEC_STATE, //14
 	TCP_NOTIFY_USB_START = TCP_NOTIFY_TYPEC_STATE,
-	TCP_NOTIFY_PD_STATE,
+	TCP_NOTIFY_PD_STATE,   //15
 	TCP_NOTIFY_USB_END = TCP_NOTIFY_PD_STATE,
 
 	/* TCP_NOTIFY_TYPE_MISC */
@@ -144,7 +136,10 @@ enum {
 	TCP_NOTIFY_STATUS,
 	TCP_NOTIFY_REQUEST_BAT_INFO,
 	TCP_NOTIFY_WD_STATUS,
-	TCP_NOTIFY_CABLE_TYPE,
+	TCP_NOTIFY_FOD_STATUS,
+	TCP_NOTIFY_CABLE_TYPE,//25
+	TCP_NOTIFY_TYPEC_OTP,
+	TCP_NOTIFY_PLUG_OUT,
 	TCP_NOTIFY_MISC_END = TCP_NOTIFY_CABLE_TYPE,
 };
 
@@ -293,6 +288,20 @@ struct tcp_ny_wd_status {
 	bool water_detected;
 };
 
+enum tcpc_fod_status {
+	TCPC_FOD_NONE = 0,
+	TCPC_FOD_NORMAL,
+	TCPC_FOD_OV,
+	TCPC_FOD_DISCHG_FAIL,
+	TCPC_FOD_LR,
+	TCPC_FOD_HR,
+	TCPC_FOD_STAT_MAX,
+};
+
+struct tcp_ny_fod_status {
+	enum tcpc_fod_status fod;
+};
+
 enum tcpc_cable_type {
 	TCPC_CABLE_TYPE_NONE = 0,
 	TCPC_CABLE_TYPE_A2C,
@@ -304,6 +313,10 @@ struct tcp_ny_cable_type {
 	enum tcpc_cable_type type;
 };
 
+struct tcp_ny_typec_otp {
+	bool otp;
+};
+
 struct tcp_notify {
 	union {
 		struct tcp_ny_enable_state en_state;
@@ -321,7 +334,9 @@ struct tcp_notify {
 		struct tcp_ny_status status_msg;
 		struct tcp_ny_request_bat request_bat;
 		struct tcp_ny_wd_status wd_status;
+		struct tcp_ny_fod_status fod_status;
 		struct tcp_ny_cable_type cable_type;
+		struct tcp_ny_typec_otp typec_otp;
 	};
 };
 
@@ -371,7 +386,7 @@ enum tcpc_cc_voltage_status {
 };
 
 enum tcpm_vbus_level {
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	TCPC_VBUS_SAFE0V = 0,	/* < 0.8V */
 	TCPC_VBUS_INVALID,		/* > 0.8V */
 	TCPC_VBUS_VALID,		/* > 4.5V */
@@ -428,12 +443,12 @@ enum pd_cable_current_limit {
 #define DPM_CAP_LOCAL_NO_SUSPEND		(1<<7)
 #define DPM_CAP_LOCAL_VCONN_SUPPLY		(1<<8)
 
-#define DPM_CAP_ATTEMP_ENTER_DC_MODE		(1<<11)
-#define DPM_CAP_ATTEMP_DISCOVER_CABLE_DFP	(1<<12)
-#define DPM_CAP_ATTEMP_ENTER_DP_MODE		(1<<13)
-#define DPM_CAP_ATTEMP_DISCOVER_CABLE		(1<<14)
-#define DPM_CAP_ATTEMP_DISCOVER_ID		(1<<15)
-#define DPM_CAP_ATTEMP_DISCOVER_SVID		(1<<16)
+#define DPM_CAP_ATTEMPT_ENTER_DC_MODE		(1<<11)
+#define DPM_CAP_ATTEMPT_DISCOVER_CABLE_DFP	(1<<12)
+#define DPM_CAP_ATTEMPT_ENTER_DP_MODE		(1<<13)
+#define DPM_CAP_ATTEMPT_DISCOVER_CABLE		(1<<14)
+#define DPM_CAP_ATTEMPT_DISCOVER_ID		(1<<15)
+#define DPM_CAP_ATTEMPT_DISCOVER_SVID		(1<<16)
 
 enum dpm_cap_pr_check_prefer {
 	DPM_CAP_PR_CHECK_DISABLE = 0,
@@ -587,7 +602,7 @@ enum TCP_DPM_EVT_ID {
 
 	TCP_DPM_EVT_DUMMY,	/* wakeup event thread */
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	TCP_DPM_EVT_PD30_COMMAND,
 	TCP_DPM_EVT_GET_SOURCE_CAP_EXT = TCP_DPM_EVT_PD30_COMMAND,
 	TCP_DPM_EVT_GET_STATUS,
@@ -613,15 +628,15 @@ enum TCP_DPM_EVT_ID {
 	TCP_DPM_EVT_EXIT_MODE,
 	TCP_DPM_EVT_ATTENTION,
 
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 	TCP_DPM_EVT_DP_ATTENTION,
-#ifdef CONFIG_USB_PD_ALT_MODE_DFP
+#if CONFIG_USB_PD_ALT_MODE_DFP
 	TCP_DPM_EVT_DP_STATUS_UPDATE,
 	TCP_DPM_EVT_DP_CONFIG,
 #endif	/* CONFIG_USB_PD_ALT_MODE_DFP */
 #endif	/* CONFIG_USB_PD_ALT_MODE */
 
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 	TCP_DPM_EVT_UVDM,
 #endif	/* CONFIG_USB_PD_CUSTOM_VDM */
 
@@ -837,7 +852,7 @@ enum dpm_charging_policy {
 		DPM_CHARGING_POLICY_IGNORE_MISMATCH_CURR,
 };
 
-#ifdef CONFIG_TCPC_CLASS
+#if IS_ENABLED(CONFIG_TCPC_CLASS)
 
 extern struct tcpc_device
 		*tcpc_dev_get_by_name(const char *name);
@@ -855,6 +870,8 @@ extern int tcpm_inquire_vbus_level(struct tcpc_device *tcpc, bool from_ic);
 extern int tcpm_inquire_typec_remote_rp_curr(struct tcpc_device *tcpc);
 extern bool tcpm_inquire_cc_polarity(struct tcpc_device *tcpc);
 extern uint8_t tcpm_inquire_typec_attach_state(struct tcpc_device *tcpc);
+extern atomic_t tcpm_inquire_pending_event(struct tcpc_device *tcpc);
+extern atomic_t tcpm_inquire_suspend_pending(struct tcpc_device *tcpc);
 extern uint8_t tcpm_inquire_typec_role(struct tcpc_device *tcpc);
 extern uint8_t tcpm_inquire_typec_local_rp(struct tcpc_device *tcpc);
 
@@ -884,7 +901,7 @@ extern int tcpm_typec_error_recovery(struct tcpc_device *tcpc);
 extern int tcpm_typec_disable_function(
 	struct tcpc_device *tcpc, bool disable);
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 
 extern bool tcpm_inquire_pd_connected(
 	struct tcpc_device *tcpc);
@@ -898,6 +915,9 @@ extern uint8_t tcpm_inquire_pd_data_role(
 extern uint8_t tcpm_inquire_pd_power_role(
 	struct tcpc_device *tcpc);
 
+extern uint8_t tcpm_inquire_pd_state_curr(
+	struct tcpc_device *tcpc_dev);
+
 extern uint8_t tcpm_inquire_pd_vconn_role(
 	struct tcpc_device *tcpc);
 
@@ -974,7 +994,7 @@ extern int tcpm_dpm_pd_request_ex(struct tcpc_device *tcpc,
 extern int tcpm_dpm_pd_bist_cm2(struct tcpc_device *tcpc,
 	const struct tcp_dpm_event_cb_data *data);
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 extern int tcpm_dpm_pd_get_source_cap_ext(struct tcpc_device *tcpc,
 	const struct tcp_dpm_event_cb_data *data,
 	struct pd_source_cap_ext *src_cap_ext);
@@ -1037,7 +1057,7 @@ extern int tcpm_dpm_vdm_attention(struct tcpc_device *tcpc,
 
 /* Request TCPM to send DP Request */
 
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 
 extern int tcpm_inquire_dp_ufp_u_state(
 	struct tcpc_device *tcpc, uint8_t *state);
@@ -1046,7 +1066,7 @@ extern int tcpm_dpm_dp_attention(struct tcpc_device *tcpc,
 	uint32_t dp_status, uint32_t mask,
 	const struct tcp_dpm_event_cb_data *data);
 
-#ifdef CONFIG_USB_PD_ALT_MODE_DFP
+#if CONFIG_USB_PD_ALT_MODE_DFP
 
 extern int tcpm_inquire_dp_dfp_u_state(
 	struct tcpc_device *tcpc, uint8_t *state);
@@ -1063,7 +1083,7 @@ extern int tcpm_dpm_dp_config(struct tcpc_device *tcpc,
 
 /* Request TCPM to send PD-UVDM Request */
 
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 
 extern int tcpm_dpm_send_custom_vdm(
 	struct tcpc_device *tcpc,
@@ -1091,20 +1111,20 @@ extern uint8_t tcpm_inquire_pd_charging_policy(struct tcpc_device *tcpc);
 extern uint8_t tcpm_inquire_pd_charging_policy_default(
 	struct tcpc_device *tcpc);
 
-#ifdef CONFIG_USB_PD_DIRECT_CHARGE
+#if CONFIG_USB_PD_DIRECT_CHARGE
 extern int tcpm_set_direct_charge_en(struct tcpc_device *tcpc, bool en);
 extern bool tcpm_inquire_during_direct_charge(struct tcpc_device *tcpc);
 #endif	/* CONFIG_USB_PD_DIRECT_CHARGE */
 
 
-#ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
+#if CONFIG_TCPC_VCONN_SUPPLY_MODE
 extern int tcpm_dpm_set_vconn_supply_mode(
 	struct tcpc_device *tcpc, uint8_t mode);
 #endif	/* CONFIG_TCPC_VCONN_SUPPLY_MODE */
 
 
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_PPS_SINK
 extern int tcpm_set_apdo_charging_policy(
 	struct tcpc_device *tcpc, uint8_t policy, int mv, int ma,
 	const struct tcp_dpm_event_cb_data *data);
@@ -1113,7 +1133,7 @@ extern int tcpm_inquire_pd_source_apdo(struct tcpc_device *tcpc,
 extern bool tcpm_inquire_during_pps_charge(struct tcpc_device *tcpc);
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 
-#ifdef CONFIG_USB_PD_REV30_BAT_INFO
+#if CONFIG_USB_PD_REV30_BAT_INFO
 
 /**
  * tcpm_update_bat_status
@@ -1169,7 +1189,7 @@ extern int tcpm_update_bat_last_full_no_mutex(struct tcpc_device *tcpc,
 #endif	/* CONFIG_USB_PD_REV30_BAT_INFO */
 
 
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
 
 /**
  * tcpm_update_pd_status
@@ -1230,41 +1250,41 @@ extern int tcpm_update_pd_status_event(
 #define USB_PD_REV30_BAT_INFO_NA
 #define USB_PD_REV30_STATUS_NA
 
-#ifdef CONFIG_TCPC_CLASS
+#if IS_ENABLED(CONFIG_TCPC_CLASS)
 #undef TCPC_CLASS_NA
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 #undef USB_POWER_DELIVERY_NA
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 #undef USB_PD_REV30_NA
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 #undef USB_PD_REV30_PPS_SINK_NA
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
-#ifdef CONFIG_USB_PD_REV30_BAT_INFO
+#if CONFIG_USB_PD_REV30_BAT_INFO
 #undef USB_PD_REV30_BAT_INFO_NA
 #endif	/* CONFIG_USB_PD_REV30_BAT_INFO */
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
 #undef USB_PD_REV30_STATUS_NA
 #endif	/* CONFIG_USB_PD_REV30_STATUS_LOCAL */
 #endif	/* CONFIG_USB_PD_REV30 */
 
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 #undef USB_PD_ALT_MODE_NA
-#ifdef CONFIG_USB_PD_ALT_MODE_DFP
+#if CONFIG_USB_PD_ALT_MODE_DFP
 #undef USB_PD_ALT_MODE_DFP_NA
 #endif	/* CONFIG_USB_PD_ALT_MODE_DFP */
 #endif	/* CONFIG_USB_PD_ALT_MODE */
 
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 #undef USB_PD_CUSTOM_VDM_NA
 #endif	/* CONFIG_USB_PD_CUSTOM_VDM */
 
-#ifdef CONFIG_USB_PD_DIRECT_CHARGE
+#if CONFIG_USB_PD_DIRECT_CHARGE
 #undef USB_PD_DIRECT_CHARGE_NA
 #endif	/* CONFIG_USB_PD_DIRECT_CHARGE */
 
-#ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
+#if CONFIG_TCPC_VCONN_SUPPLY_MODE
 #undef TCPC_VCONN_SUPPLY_MODE_NA
 #endif	/* CONFIG_TCPC_VCONN_SUPPLY_MODE */
 
@@ -1325,6 +1345,16 @@ static inline uint8_t tcpm_inquire_typec_attach_state(
 	return TYPEC_UNATTACHED;
 }
 
+static inline atomic_t tcpm_inquire_pending_event(struct tcpc_device *tcpc)
+{
+	return ATOMIC_INIT(0);
+}
+
+static inline atomic_t tcpm_inquire_suspend_event(struct tcpc_device *tcpc)
+{
+	return ATOMIC_INIT(0);
+}
+
 static inline uint8_t tcpm_inquire_typec_role(struct tcpc_device *tcpc)
 {
 	return TYPEC_ROLE_UNKNOWN;
@@ -1409,6 +1439,12 @@ static inline uint8_t tcpm_inquire_pd_power_role(
 	return 0;
 }
 
+static inline uint8_t tcpm_inquire_pd_state_curr(
+	struct tcpc_device *tcpc_dev)
+{
+	return 0;
+}
+
 static inline uint8_t tcpm_inquire_pd_vconn_role(
 	struct tcpc_device *tcpc)
 {
@@ -1812,7 +1848,6 @@ static inline bool tcpm_inquire_during_direct_charge(
 	return TCPM_ERROR_NO_IMPLEMENT;
 }
 #endif	/* USB_PD_DIRECT_CHARGE_NA */
-
 #ifdef TCPC_VCONN_SUPPLY_MODE_NA
 static inline int tcpm_dpm_set_vconn_supply_mode(
 	struct tcpc_device *tcpc, uint8_t mode)
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/tcpm_pd.h b/drivers/misc/mediatek/typec/tcpc/inc/tcpm_pd.h
index ee2adc8..5cf25a2 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/tcpm_pd.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/tcpm_pd.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #ifndef TCPM_PD_H_
@@ -31,7 +23,7 @@
 
 /******************* PD30 *******************/
 
-#ifdef CONFIG_USB_PD_REV30_CHUNKING_BY_PE
+#if CONFIG_USB_PD_REV30_CHUNKING_BY_PE
 #define MAX_EXTENDED_MSG_LEN	260
 #else
 #define MAX_EXTENDED_MSG_LEN	26
@@ -297,7 +289,7 @@ struct pd_country_info {
 struct pd_status {
 	uint8_t internal_temp;	/* 0 means no support */
 	uint8_t present_input;	/* bit filed */
-	uint8_t present_battery_input;
+	uint8_t present_battery_input; /* bit filed */
 	uint8_t event_flags;	/* bit filed */
 	uint8_t temp_status;	/* bit filed */
 	uint8_t power_status;	/* bit filed */
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_core.c b/drivers/misc/mediatek/typec/tcpc/pd_core.c
index b9be018..bfb1f99 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_core.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_core.c
@@ -1,16 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * Power Delivery Core Driver
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include <linux/of.h>
@@ -21,13 +11,10 @@
 #include "inc/tcpci_typec.h"
 #include "inc/tcpci_event.h"
 #include "inc/pd_policy_engine.h"
-#ifdef CONFIG_DUAL_ROLE_USB_INTF
-#include <linux/usb/class-dual-role.h>
-#endif /* CONFIG_DUAL_ROLE_USB_INTF */
 
 /* From DTS */
 
-#ifdef CONFIG_USB_PD_REV30_BAT_INFO
+#if CONFIG_USB_PD_REV30_BAT_INFO
 static inline void pd_parse_pdata_bat_info(
 	struct pd_port *pd_port, struct device_node *sub,
 	struct pd_battery_info *bat_info)
@@ -39,7 +26,7 @@ static inline void pd_parse_pdata_bat_info(
 
 	struct pd_battery_capabilities *bat_cap = &bat_info->bat_cap;
 
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
 	struct pd_manufacturer_info *mfrs_info = &bat_info->mfrs_info;
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL */
 
@@ -55,7 +42,7 @@ static inline void pd_parse_pdata_bat_info(
 		pid = PD_PRODUCT_PID(pd_port->id_vdos[2]);
 	}
 
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
 	mfrs_info->vid = vid;
 	mfrs_info->pid = pid;
 
@@ -140,7 +127,7 @@ static inline int pd_parse_pdata_bats(
 }
 #endif	/* CONFIG_USB_PD_REV30_BAT_INFO */
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_AUTHORITY
+#if CONFIG_USB_PD_REV30_COUNTRY_AUTHORITY
 static inline int pd_parse_pdata_country(
 	struct pd_port *pd_port,  struct device_node *sub,
 	struct pd_country_authority *country_info)
@@ -249,7 +236,7 @@ static inline int pd_parse_pdata_countries(
 }
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_AUTHORITY */
 
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
 static void pd_parse_log_src_cap_ext(struct pd_source_cap_ext *cap)
 {
 	pr_info("%s vid = 0x%x, pid = 0x%x, xid = 0x%x, fw_ver = 0x%x, hw_ver = 0x%0x\n",
@@ -279,7 +266,7 @@ static void pd_parse_log_src_cap_ext(struct pd_source_cap_ext *cap)
 static inline void pd_parse_pdata_src_cap_ext(
 	struct pd_port *pd_port, struct device_node *np)
 {
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
 	int ret = 0;
 
 	ret = of_property_read_u32_array(np, "pd,source-cap-ext",
@@ -291,7 +278,7 @@ static inline void pd_parse_pdata_src_cap_ext(
 	else
 		pd_parse_log_src_cap_ext(&pd_port->src_cap_ext);
 
-#ifdef CONFIG_USB_PD_REV30_BAT_INFO
+#if CONFIG_USB_PD_REV30_BAT_INFO
 	pd_port->src_cap_ext.batteries =
 		PD_SCEDB_BATTERIES(0, pd_port->bat_nr);
 
@@ -306,11 +293,11 @@ static inline void pd_parse_pdata_mfrs(
 {
 	int ret = 0;
 	uint32_t vid, pid;
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
 	const char *mstring;
 #endif /* CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
 	struct pd_manufacturer_info *mfrs_info = &pd_port->mfrs_info;
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL */
 
@@ -328,7 +315,7 @@ static inline void pd_parse_pdata_mfrs(
 
 	pr_info("%s VID = 0x%x, PID = 0x%x\n", __func__, vid, pid);
 
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
 	mfrs_info->vid = vid;
 	mfrs_info->pid = pid;
 
@@ -346,7 +333,7 @@ static inline void pd_parse_pdata_mfrs(
 		__func__, mfrs_info->mfrs_string);
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
 	pd_port->src_cap_ext.vid = vid;
 	pd_port->src_cap_ext.pid = pid;
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL */
@@ -403,14 +390,14 @@ static int pd_parse_pdata(struct pd_port *pd_port)
 			pr_info("%s %d: 0x%08x\n", __func__, i,
 				pd_port->local_snk_cap.pdos[i]);
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 			if (PDO_TYPE(pd_port->local_snk_cap.pdos[i]) !=
 				PDO_TYPE_APDO)
 				pd_port->local_snk_cap_nr_pd20++;
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 		}
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 		pd_port->local_snk_cap_nr_pd30 = pd_port->local_snk_cap.nr;
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 
@@ -438,13 +425,13 @@ static int pd_parse_pdata(struct pd_port *pd_port)
 		pd_port->dpm_charging_policy_default = val;
 		pr_info("%s charging_policy = %d\n", __func__, val);
 
-#ifdef CONFIG_USB_PD_REV30_BAT_INFO
+#if CONFIG_USB_PD_REV30_BAT_INFO
 		ret = pd_parse_pdata_bats(pd_port, np);
 		if (ret < 0)
 			return ret;
 #endif	/* CONFIG_USB_PD_REV30_BAT_INFO */
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_AUTHORITY
+#if CONFIG_USB_PD_REV30_COUNTRY_AUTHORITY
 		ret = pd_parse_pdata_countries(pd_port, np);
 		if (ret < 0)
 			return ret;
@@ -471,11 +458,11 @@ static const struct {
 	{"local_no_suspend", DPM_CAP_LOCAL_NO_SUSPEND},
 	{"local_vconn_supply", DPM_CAP_LOCAL_VCONN_SUPPLY},
 
-	{"attemp_discover_cable_dfp", DPM_CAP_ATTEMP_DISCOVER_CABLE_DFP},
-	{"attemp_enter_dp_mode", DPM_CAP_ATTEMP_ENTER_DP_MODE},
-	{"attemp_discover_cable", DPM_CAP_ATTEMP_DISCOVER_CABLE},
-	{"attemp_discover_id", DPM_CAP_ATTEMP_DISCOVER_ID},
-	{"attemp_discover_svid", DPM_CAP_ATTEMP_DISCOVER_SVID},
+	{"attempt_discover_cable_dfp", DPM_CAP_ATTEMPT_DISCOVER_CABLE_DFP},
+	{"attempt_enter_dp_mode", DPM_CAP_ATTEMPT_ENTER_DP_MODE},
+	{"attempt_discover_cable", DPM_CAP_ATTEMPT_DISCOVER_CABLE},
+	{"attempt_discover_id", DPM_CAP_ATTEMPT_DISCOVER_ID},
+	{"attempt_discover_svid", DPM_CAP_ATTEMPT_DISCOVER_SVID},
 
 	{"pr_reject_as_source", DPM_CAP_PR_SWAP_REJECT_AS_SRC},
 	{"pr_reject_as_sink", DPM_CAP_PR_SWAP_REJECT_AS_SNK},
@@ -543,7 +530,7 @@ static void pd_core_power_flags_init(struct pd_port *pd_port)
 	src_cap->pdos[0] |= src_flag;
 }
 
-#ifdef CONFIG_RECV_BAT_ABSENT_NOTIFY
+#if CONFIG_RECV_BAT_ABSENT_NOTIFY
 static void fg_bat_absent_work(struct work_struct *work)
 {
 	struct pd_port *pd_port = container_of(work, struct pd_port,
@@ -564,7 +551,7 @@ int pd_core_init(struct tcpc_device *tcpc)
 
 	mutex_init(&pd_port->pd_lock);
 
-#ifdef CONFIG_USB_PD_BLOCK_TCPM
+#if CONFIG_USB_PD_BLOCK_TCPM
 	mutex_init(&pd_port->tcpm_bk_lock);
 	init_waitqueue_head(&pd_port->tcpm_bk_wait_que);
 #endif	/* CONFIG_USB_PD_BLOCK_TCPM */
@@ -581,7 +568,7 @@ int pd_core_init(struct tcpc_device *tcpc)
 
 	pd_dpm_core_init(pd_port);
 
-#ifdef CONFIG_RECV_BAT_ABSENT_NOTIFY
+#if CONFIG_RECV_BAT_ABSENT_NOTIFY
 	INIT_WORK(&pd_port->fg_bat_work, fg_bat_absent_work);
 #endif /* CONFIG_RECV_BAT_ABSENT_NOTIFY */
 
@@ -610,7 +597,7 @@ void pd_extract_rdo_power(uint32_t rdo, uint32_t pdo,
 		*max_curr = max_power / vmin;
 		break;
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SOURCE
+#if CONFIG_USB_PD_REV30_PPS_SOURCE
 	case PDO_TYPE_APDO:
 		*op_curr = RDO_APDO_EXTRACT_OP_MA(rdo);
 		*max_curr = RDO_APDO_EXTRACT_OP_MA(rdo);
@@ -646,7 +633,7 @@ uint32_t pd_reset_pdo_power(struct tcpc_device *tcpc,
 		PD_ERR("No Support\n");
 		break;
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SOURCE
+#if CONFIG_USB_PD_REV30_PPS_SOURCE
 	case PDO_TYPE_APDO:
 		/* TODO: check it later !! */
 		break;
@@ -686,7 +673,7 @@ static inline bool pd_is_cable_communication_available(
 	 * Only the Vconn SRC can communicate with Cable.
 	 */
 
-#ifdef CONFIG_USB_PD_REV30_DISCOVER_CABLE_WITH_VCONN
+#if CONFIG_USB_PD_REV30_DISCOVER_CABLE_WITH_VCONN
 	if (pd_check_rev30(pd_port) && (!pd_port->vconn_role))
 		return false;
 #endif	/* CONFIG_USB_PD_REV30_DISCOVER_CABLE_WITH_VCONN */
@@ -732,7 +719,7 @@ void pd_reset_svid_data(struct pd_port *pd_port)
 
 void pd_free_unexpected_event(struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
+#if CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
 	struct pe_data *pe_data = &pd_port->pe_data;
 
 	if (!pe_data->pd_unexpected_event_pending)
@@ -756,7 +743,7 @@ int pd_reset_protocol_layer(struct pd_port *pd_port, bool sop_only)
 
 	pd_notify_pe_reset_protocol(pd_port);
 
-#ifdef CONFIG_USB_PD_PE_SOURCE
+#if CONFIG_USB_PD_PE_SOURCE
 	pe_data->cap_counter = 0;
 #endif	/* CONFIG_USB_PD_PE_SOURCE */
 
@@ -766,16 +753,16 @@ int pd_reset_protocol_layer(struct pd_port *pd_port, bool sop_only)
 	pe_data->during_swap = 0;
 	pd_port->cap_miss_match = 0;
 
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
+#if CONFIG_USB_PD_REV30_ALERT_REMOTE
 	pe_data->remote_alert = 0;
 #endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
 
-#ifdef CONFIG_USB_PD_DFP_FLOW_DELAY_RESET
+#if CONFIG_USB_PD_DFP_FLOW_DELAY_RESET
 	if (pe_data->pd_prev_connected)
 		dpm_reaction_set(pd_port, DPM_REACTION_DFP_FLOW_DELAY);
 #endif	/* CONFIG_USB_PD_DFP_FLOW_DELAY_RESET */
 
-#ifdef CONFIG_USB_PD_DFP_READY_DISCOVER_ID
+#if CONFIG_USB_PD_DFP_READY_DISCOVER_ID
 	dpm_reaction_clear(pd_port, DPM_REACTION_RETURN_VCONN_SRC);
 #endif	/* CONFIG_USB_PD_DFP_READY_DISCOVER_ID */
 
@@ -789,11 +776,11 @@ int pd_reset_protocol_layer(struct pd_port *pd_port, bool sop_only)
 		PE_RESET_MSG_ID(pd_port, TCPC_TX_SOP_PRIME_PRIME);
 	}
 
-#ifdef CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP
+#if CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP
 	pd_port->msg_id_pr_swap_last = 0xff;
 #endif	/* CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP */
 
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
+#if CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
 	pe_data->pd_sent_ams_init_cmd = true;
 	pd_free_unexpected_event(pd_port);
 #endif	/* CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG */
@@ -849,15 +836,6 @@ int pd_set_data_role(struct pd_port *pd_port, uint8_t dr)
 		return ret;
 
 	pd_port->data_role = dr;
-
-#ifdef CONFIG_DUAL_ROLE_USB_INTF
-	/* dual role usb--> 0:ufp, 1:dfp */
-	pd_port->tcpc->dual_role_mode = pd_port->data_role;
-	/* dual role usb --> 0: Device, 1: Host */
-	pd_port->tcpc->dual_role_dr = !(pd_port->data_role);
-	dual_role_instance_changed(pd_port->tcpc->dr_usb);
-#endif /* CONFIG_DUAL_ROLE_USB_INTF */
-
 	ret = pd_update_msg_header(pd_port);
 	if (ret < 0)
 		return ret;
@@ -880,18 +858,13 @@ int pd_set_power_role(struct pd_port *pd_port, uint8_t pr)
 
 	pd_notify_pe_pr_changed(pd_port);
 
-#ifdef CONFIG_DUAL_ROLE_USB_INTF
-	/* 0:sink, 1: source */
-	pd_port->tcpc->dual_role_pr = !(pd_port->power_role);
-	dual_role_instance_changed(pd_port->tcpc->dr_usb);
-#endif /* CONFIG_DUAL_ROLE_USB_INTF */
 	tcpci_notify_role_swap(pd_port->tcpc, TCP_NOTIFY_PR_SWAP, pr);
 	return ret;
 }
 
 static void pd_init_spec_revision(struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_REV30_SYNC_SPEC_REV
+#if CONFIG_USB_PD_REV30_SYNC_SPEC_REV
 	if (pd_port->tcpc->tcpc_flags & TCPC_FLAGS_PD_REV30) {
 		pd_port->pd_revision[0] = PD_REV30;
 		pd_port->pd_revision[1] = PD_REV30;
@@ -928,7 +901,7 @@ int pd_set_vconn(struct pd_port *pd_port, uint8_t role)
 
 	PE_DBG("%s:%d\n", __func__, role);
 
-#ifdef CONFIG_USB_PD_VCONN_SAFE5V_ONLY
+#if CONFIG_USB_PD_VCONN_SAFE5V_ONLY
 	if (pd_port->pe_data.vconn_highv_prot) {
 		PE_DBG("VC_OVER5V\n");
 		return -EPERM;
@@ -946,7 +919,7 @@ int pd_set_vconn(struct pd_port *pd_port, uint8_t role)
 	if (en_role != en_role_old)
 		tcpci_notify_role_swap(tcpc, TCP_NOTIFY_VCONN_SWAP, en_role);
 out:
-#ifdef CONFIG_USB_PD_VCONN_STABLE_DELAY
+#if CONFIG_USB_PD_VCONN_STABLE_DELAY
 	if (role == PD_ROLE_VCONN_DYNAMIC_ON)
 		pd_restart_timer(pd_port, PD_TIMER_VCONN_STABLE);
 #endif	/* CONFIG_USB_PD_VCONN_STABLE_DELAY */
@@ -990,12 +963,12 @@ int pd_reset_local_hw(struct pd_port *pd_port)
 	pd_port->pe_data.pd_connected  = false;
 	pd_port->pe_data.pe_ready = false;
 
-#ifdef CONFIG_USB_PD_VCONN_SAFE5V_ONLY
+#if CONFIG_USB_PD_VCONN_SAFE5V_ONLY
 	pd_port->pe_data.vconn_highv_prot = false;
 	pd_port->pe_data.vconn_highv_prot_role = PD_ROLE_VCONN_OFF;
 #endif	/* CONFIG_USB_PD_VCONN_SAFE5V_ONLY */
 
-#ifdef CONFIG_USB_PD_RESET_CABLE
+#if CONFIG_USB_PD_RESET_CABLE
 	dpm_reaction_clear(pd_port, DPM_REACTION_CAP_RESET_CABLE);
 #endif	/* CONFIG_USB_PD_RESET_CABLE */
 
@@ -1039,7 +1012,7 @@ int pd_handle_soft_reset(struct pd_port *pd_port)
 
 void pd_handle_first_pd_command(struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	pd_sync_sop_spec_revision(pd_port);
 #endif	/* CONFIG_USB_PD_REV30 */
 
@@ -1053,11 +1026,11 @@ void pd_handle_hard_reset_recovery(struct pd_port *pd_port)
 	pd_port->pe_data.hard_reset_counter = 0;
 	pd_disable_timer(pd_port, PD_TIMER_NO_RESPONSE);
 
-#ifdef CONFIG_USB_PD_RENEGOTIATION_COUNTER
+#if CONFIG_USB_PD_RENEGOTIATION_COUNTER
 	pd_port->pe_data.renegotiation_count++;
 #endif	/* CONFIG_USB_PD_RENEGOTIATION_COUNTER */
 
-#ifdef CONFIG_USB_PD_RECV_HRESET_COUNTER
+#if CONFIG_USB_PD_RECV_HRESET_COUNTER
 	pd_port->pe_data.recv_hard_reset_count = 0;
 #endif	/* CONFIG_USB_PD_RECV_HRESET_COUNTER */
 
@@ -1094,7 +1067,7 @@ int pd_send_message(struct pd_port *pd_port, uint8_t sop_type,
 	else
 		msg_hdr_private = 0;
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	if (pd_rev >= PD_REV30)
 		tcpc->pd_retry_count = PD30_RETRY_COUNT;
 	else
@@ -1161,7 +1134,7 @@ int pd_reply_wait_reject_msg_no_resp(struct pd_port *pd_port)
 	return pd_send_sop_ctrl_msg(pd_port, msg);
 }
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 int pd_send_ext_msg(struct pd_port *pd_port,
 		uint8_t sop_type, uint8_t msg, bool request,
 		uint8_t chunk_nr, uint8_t size, const uint8_t *data)
@@ -1181,7 +1154,7 @@ int pd_send_ext_msg(struct pd_port *pd_port,
 }
 #endif	/* CONFIG_USB_PD_REV30 */
 
-#ifdef CONFIG_USB_PD_RESET_CABLE
+#if CONFIG_USB_PD_RESET_CABLE
 int pd_send_cable_soft_reset(struct pd_port *pd_port)
 {
 	/* reset_protocol_layer */
@@ -1221,7 +1194,7 @@ int pd_send_bist_mode2(struct pd_port *pd_port)
 
 	pd_notify_tcp_event_buf_reset(pd_port, TCP_DPM_RET_DROP_SEND_BIST);
 
-#ifdef CONFIG_USB_PD_TRANSMIT_BIST2
+#if CONFIG_USB_PD_TRANSMIT_BIST2
 	TCPC_DBG("BIST_MODE_2\n");
 	ret = tcpci_transmit(tcpc, TCPC_TX_BIST_MODE_2, 0, NULL);
 #else
@@ -1233,7 +1206,7 @@ int pd_send_bist_mode2(struct pd_port *pd_port)
 
 int pd_disable_bist_mode2(struct pd_port *pd_port)
 {
-#ifndef CONFIG_USB_PD_TRANSMIT_BIST2
+#if !CONFIG_USB_PD_TRANSMIT_BIST2
 	return tcpci_set_bist_carrier_mode(
 		pd_port->tcpc, 0);
 #else
@@ -1248,7 +1221,7 @@ int pd_send_svdm_request(struct pd_port *pd_port,
 		uint8_t obj_pos, uint8_t cnt, uint32_t *data_obj,
 		uint32_t timer_id)
 {
-#ifdef CONFIG_USB_PD_STOP_SEND_VDM_IF_RX_BUSY
+#if CONFIG_USB_PD_STOP_SEND_VDM_IF_RX_BUSY
 	int rv;
 	uint32_t alert_status;
 #endif	/* CONFIG_USB_PD_STOP_SEND_VDM_IF_RX_BUSY */
@@ -1268,7 +1241,7 @@ int pd_send_svdm_request(struct pd_port *pd_port,
 	payload[0] = VDO_S(svid, ver, CMDT_INIT, vdm_cmd, obj_pos);
 	memcpy(&payload[1], data_obj, sizeof(uint32_t) * cnt);
 
-#ifdef CONFIG_USB_PD_STOP_SEND_VDM_IF_RX_BUSY
+#if CONFIG_USB_PD_STOP_SEND_VDM_IF_RX_BUSY
 	rv = tcpci_get_alert_status(pd_port->tcpc, &alert_status);
 	if (rv)
 		return rv;
@@ -1291,7 +1264,7 @@ int pd_send_svdm_request(struct pd_port *pd_port,
 int pd_reply_svdm_request(struct pd_port *pd_port,
 	uint8_t reply, uint8_t cnt, uint32_t *data_obj)
 {
-#ifdef CONFIG_USB_PD_STOP_REPLY_VDM_IF_RX_BUSY
+#if CONFIG_USB_PD_STOP_REPLY_VDM_IF_RX_BUSY
 	int rv;
 	uint32_t alert_status;
 #endif	/* CONFIG_USB_PD_STOP_REPLY_VDM_IF_RX_BUSY */
@@ -1311,7 +1284,7 @@ int pd_reply_svdm_request(struct pd_port *pd_port,
 		memcpy(&payload[1], data_obj, sizeof(uint32_t) * cnt);
 	}
 
-#ifdef CONFIG_USB_PD_STOP_REPLY_VDM_IF_RX_BUSY
+#if CONFIG_USB_PD_STOP_REPLY_VDM_IF_RX_BUSY
 	rv = tcpci_get_alert_status(tcpc, &alert_status);
 	if (rv)
 		return rv;
@@ -1333,7 +1306,7 @@ int pd_reply_svdm_request(struct pd_port *pd_port,
 			PD_DATA_VENDOR_DEF, 1+cnt, payload);
 }
 
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 
 int pd_send_custom_vdm(struct pd_port *pd_port, uint8_t sop_type)
 {
@@ -1357,7 +1330,7 @@ void pd_reset_pe_timer(struct pd_port *pd_port)
 {
 	tcpc_reset_pe_timer(pd_port->tcpc);
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	if (pd_port->request_apdo) {
 		pd_port->request_apdo = false;
 		pd_dpm_start_pps_request_thread(pd_port, false);
@@ -1395,7 +1368,7 @@ int pd_update_connect_state(struct pd_port *pd_port, uint8_t state)
 	return tcpci_notify_pd_state(tcpc, state);
 }
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 
 /*
  * Collision Avoidance : check tx ok
@@ -1407,7 +1380,7 @@ int pd_update_connect_state(struct pd_port *pd_port, uint8_t state)
 
 void pd_set_sink_tx(struct pd_port *pd_port, uint8_t cc)
 {
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (cc == PD30_SINK_TX_OK &&
@@ -1432,7 +1405,7 @@ void pd_set_sink_tx(struct pd_port *pd_port, uint8_t cc)
 
 void pd_sync_sop_spec_revision(struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_REV30_SYNC_SPEC_REV
+#if CONFIG_USB_PD_REV30_SYNC_SPEC_REV
 	uint8_t rev = pd_get_msg_hdr_rev(pd_port);
 	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
@@ -1447,7 +1420,7 @@ void pd_sync_sop_spec_revision(struct pd_port *pd_port)
 
 void pd_sync_sop_prime_spec_revision(struct pd_port *pd_port, uint8_t rev)
 {
-#ifdef CONFIG_USB_PD_REV30_SYNC_SPEC_REV
+#if CONFIG_USB_PD_REV30_SYNC_SPEC_REV
 	struct pe_data *pe_data = &pd_port->pe_data;
 	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
@@ -1478,7 +1451,7 @@ bool pd_is_multi_chunk_msg(struct pd_port *pd_port)
 struct pd_battery_info *pd_get_battery_info(
 	struct pd_port *pd_port, enum pd_battery_reference ref)
 {
-#ifdef CONFIG_USB_PD_REV30_BAT_INFO
+#if CONFIG_USB_PD_REV30_BAT_INFO
 	if (ref < pd_get_fix_battery_nr(pd_port))
 		return &pd_port->fix_bat_info[ref];
 #endif	/* CONFIG_USB_PD_REV30_BAT_INFO */
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_dbg_info.c b/drivers/misc/mediatek/typec/tcpc/pd_dbg_info.c
index d0455cd..9b7adc0 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_dbg_info.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_dbg_info.c
@@ -1,14 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include <linux/kernel.h>
@@ -22,7 +14,7 @@
 #include <linux/kthread.h>
 #include "inc/pd_dbg_info.h"
 
-#ifdef CONFIG_PD_DBG_INFO
+#if IS_ENABLED(CONFIG_PD_DBG_INFO)
 
 #define PD_INFO_BUF_SIZE	(2048*256)
 #define MSG_POLLING_MS		20
@@ -30,30 +22,37 @@
 #define OUT_BUF_MAX (128)
 static struct {
 	int used;
+	int cnt;
 	char buf[PD_INFO_BUF_SIZE + 1 + OUT_BUF_MAX];
 } pd_dbg_buffer[2];
 
+static bool dbg_log_en;
+module_param(dbg_log_en, bool, 0644);
+
 static struct mutex buff_lock;
 static unsigned int using_buf;
-static wait_queue_head_t print_out_wait_que;
-static atomic_t pending_print_out;
+static bool event_loop_thread_stop;
+static wait_queue_head_t event_loop_wait_que;
 static atomic_t busy = ATOMIC_INIT(0);
+static atomic_t pending_event = ATOMIC_INIT(0);
 
 void pd_dbg_info_lock(void)
 {
 	atomic_inc(&busy);
 }
+EXPORT_SYMBOL(pd_dbg_info_lock);
 
 void pd_dbg_info_unlock(void)
 {
 	atomic_dec_if_positive(&busy);
 }
+EXPORT_SYMBOL(pd_dbg_info_unlock);
 
 static inline bool pd_dbg_print_out(void)
 {
-	char temp;
-	int used;
+	int used, cnt;
 	unsigned int index, i;
+	char *str;
 
 	mutex_lock(&buff_lock);
 	index = using_buf;
@@ -62,46 +61,42 @@ static inline bool pd_dbg_print_out(void)
 
 	used = pd_dbg_buffer[index].used;
 
-	if (used <= 0)
+	if (used == 0)
 		return false;
+	cnt = pd_dbg_buffer[index].cnt;
 
-	if (used < (PD_INFO_BUF_SIZE + 1 + OUT_BUF_MAX))
-		pd_dbg_buffer[index].buf[used] = '\0';
-
-	pr_info("///PD dbg info %ud\n", used);
-
-	for (i = 0; i < used; i += OUT_BUF_MAX) {
-		temp = pd_dbg_buffer[index].buf[OUT_BUF_MAX + i];
-		pd_dbg_buffer[index].buf[OUT_BUF_MAX + i] = '\0';
+	pr_info("///PD dbg info %d %d\n", used, cnt);
 
+	str = pd_dbg_buffer[index].buf;
+	for (i = 0; i < cnt; i++) {
 		while (atomic_read(&busy))
 			usleep_range(1000, 2000);
 
-		pr_notice("%s", pd_dbg_buffer[index].buf + i);
-		pd_dbg_buffer[index].buf[OUT_BUF_MAX + i] = temp;
+		pr_info("%s", str);
+		str += strlen(str) + 1;
 	}
 
 	/* pr_info("PD dbg info///\n"); */
 	pd_dbg_buffer[index].used = 0;
+	pd_dbg_buffer[index].cnt = 0;
 	msleep(MSG_POLLING_MS);
 	return true;
 }
 
-static int print_out_thread_fn(void *data)
+static int print_out_thread_fn(void *arg)
 {
 	int ret = 0;
-
 	while (true) {
-		ret = wait_event_interruptible(print_out_wait_que,
-				atomic_read(&pending_print_out) ||
-				kthread_should_stop());
-		if (kthread_should_stop() || ret) {
+		ret = wait_event_interruptible(event_loop_wait_que,
+					       atomic_read(&pending_event) |
+					       event_loop_thread_stop);
+		if (kthread_should_stop() || event_loop_thread_stop || ret) {
 			pr_notice("%s exits(%d)\n", __func__, ret);
 			break;
 		}
 		do {
-			atomic_dec_if_positive(&pending_print_out);
-		} while (pd_dbg_print_out() && !kthread_should_stop());
+			atomic_dec_if_positive(&pending_event);
+		} while (pd_dbg_print_out());
 	}
 
 	return 0;
@@ -111,54 +106,63 @@ int pd_dbg_info(const char *fmt, ...)
 {
 	unsigned int index;
 	va_list args;
-	int r;
-	int used;
+	int r1, r2 = 0, used, left_size;
 	u64 ts;
 	unsigned long rem_usec;
 
+	if (!dbg_log_en)
+		return 0;
+
 	ts = local_clock();
 	rem_usec = do_div(ts, 1000000000) / 1000 / 1000;
 	va_start(args, fmt);
 	mutex_lock(&buff_lock);
 	index = using_buf;
 	used = pd_dbg_buffer[index].used;
-	r = snprintf(pd_dbg_buffer[index].buf + used,
-		PD_INFO_BUF_SIZE - used, "<%5lu.%03lu>",
+	left_size = PD_INFO_BUF_SIZE - used;
+	r1 = snprintf(pd_dbg_buffer[index].buf + used, left_size, "<%5lu.%03lu>",
 		(unsigned long)ts, rem_usec);
-	if (r > 0)
-		used += r;
-	r = vsnprintf(pd_dbg_buffer[index].buf + used,
-			PD_INFO_BUF_SIZE - used, fmt, args);
-	if (r > 0)
-		used += r;
+	if (r1 <= 0 || r1 == left_size)
+		goto out;
+	left_size = PD_INFO_BUF_SIZE - (used + r1);
+	r2 = vsnprintf(pd_dbg_buffer[index].buf + used + r1, left_size, fmt, args);
+	if (r2 <= 0 || r2 == left_size)
+		goto out;
+	used += r1 + r2 + 1;
 
 	if (pd_dbg_buffer[index].used == 0) {
-		atomic_inc(&pending_print_out);
-		wake_up(&print_out_wait_que);
+		atomic_inc(&pending_event);
+		wake_up_interruptible(&event_loop_wait_que);
 	}
 
 	pd_dbg_buffer[index].used = used;
+	pd_dbg_buffer[index].cnt++;
+out:
 	mutex_unlock(&buff_lock);
 	va_end(args);
-	return r;
+	return r2;
 }
+EXPORT_SYMBOL(pd_dbg_info);
 
-static struct task_struct *print_out_task;
+static struct task_struct *print_out_tsk;
 
 int pd_dbg_info_init(void)
 {
 	pr_info("%s\n", __func__);
 	mutex_init(&buff_lock);
-	init_waitqueue_head(&print_out_wait_que);
-	atomic_set(&pending_print_out, 0);
-	print_out_task = kthread_run(print_out_thread_fn, NULL, "pd_dbg_info");
-
+	print_out_tsk = kthread_create(
+			print_out_thread_fn, NULL, "pd_dbg_info");
+	init_waitqueue_head(&event_loop_wait_que);
+	atomic_set(&pending_event, 0);
+	wake_up_process(print_out_tsk);
 	return 0;
 }
 
 void pd_dbg_info_exit(void)
 {
-	kthread_stop(print_out_task);
+	event_loop_thread_stop = true;
+	wake_up_interruptible(&event_loop_wait_que);
+	kthread_stop(print_out_tsk);
 	mutex_destroy(&buff_lock);
 }
 
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_dpm_alt_mode_dc.c b/drivers/misc/mediatek/typec/tcpc/pd_dpm_alt_mode_dc.c
index 3f33271..94375a6 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_dpm_alt_mode_dc.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_dpm_alt_mode_dc.c
@@ -1,27 +1,16 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * PD Device Policy Manager for Direct Charge
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 #include <linux/random.h>
 #include "inc/tcpci.h"
 #include "inc/pd_policy_engine.h"
 #include "inc/pd_dpm_core.h"
 #include "pd_dpm_prv.h"
 
-#ifdef CONFIG_USB_POWER_DELIVERY
-#ifdef CONFIG_USB_PD_ALT_MODE_RTDC
-
+#if CONFIG_USB_PD_ALT_MODE_RTDC
 #define RTDC_UVDM_EN_UNLOCK		0x2024
 #define RTDC_UVDM_RECV_EN_UNLOCK	0x4024
 #define RTDC_SVDM_PPS_AUTHORIZATION	0x10
@@ -29,6 +18,8 @@
 #define RTDC_VALID_MODE				0x01
 #define RTDC_UVDM_EN_UNLOCK_SUCCESS		0x01
 
+#define RTDC_TA_EMULATE	0
+
 void crcbits(uint32_t data, uint32_t *crc, uint32_t *ppolynomial)
 {
 	uint32_t i, newbit, newword, rl_crc;
@@ -85,7 +76,7 @@ static inline bool dc_dfp_send_en_unlock(struct pd_port *pd_port,
 	pd_port->uvdm_data[1] = data0;
 	pd_port->uvdm_data[2] = data1;
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	if (pd_port->pe_data.dc_pps_mode) {
 		pd_port->uvdm_data[0] = VDO_S(
 			USB_VID_DIRECTCHARGE,
@@ -109,7 +100,7 @@ enum pd_dc_dfp_state {
 	DC_DFP_EN_UNLOCK2,
 	DC_DFP_OPERATION,
 
-#ifdef RTDC_TA_EMULATE
+#if RTDC_TA_EMULATE
 	DC_UFP_T0,
 	DC_UFP_T1,
 	DC_UFP_T2,
@@ -157,7 +148,7 @@ static const char * const dc_dfp_state_name[] = {
 	"dc_dfp_en_unlock2",
 	"dc_dfp_operation",
 
-#ifdef RTDC_TA_EMULATE
+#if RTDC_TA_EMULATE
 	"dc1",
 	"dc2",
 	"dc3",
@@ -210,7 +201,7 @@ bool dc_dfp_verify_en_unlock1(struct pd_port *pd_port)
 	expect_resp = RTDC_UVDM_RECV_EN_UNLOCK;
 	resp_cmd = PD_UVDM_HDR_CMD(pd_port->uvdm_data[0]);
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	if (pd_port->pe_data.dc_pps_mode) {
 		resp_cmd = SVDM_CMD_STATE_MASK(pd_port->uvdm_data[0]);
 		expect_resp = SVDM_CMD_STATE(
@@ -261,7 +252,7 @@ bool dc_dfp_verify_en_unlock2(struct pd_port *pd_port)
 	expect_resp = RTDC_UVDM_RECV_EN_UNLOCK;
 	resp_cmd = PD_UVDM_HDR_CMD(pd_port->uvdm_data[0]);
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	if (pd_port->pe_data.dc_pps_mode) {
 		resp_cmd = SVDM_CMD_STATE_MASK(pd_port->uvdm_data[0]);
 		expect_resp = SVDM_CMD_STATE(
@@ -290,10 +281,10 @@ bool dc_dfp_notify_pe_startup(
 	if (!(pd_port->id_vdos[0] & PD_IDH_MODAL_SUPPORT))
 		return false;
 
-	if (pd_port->dpm_caps & DPM_CAP_ATTEMP_ENTER_DC_MODE)
+	if (pd_port->dpm_caps & DPM_CAP_ATTEMPT_ENTER_DC_MODE)
 		dc_dfp_set_state(pd_port, DC_DFP_DISCOVER_ID);
 
-#ifdef RTDC_TA_EMULATE
+#if RTDC_TA_EMULATE
 	dc_dfp_set_state(pd_port, DC_UFP_T0);
 #endif
 
@@ -303,11 +294,11 @@ bool dc_dfp_notify_pe_startup(
 int dc_dfp_notify_pe_ready(struct pd_port *pd_port,
 		struct svdm_svid_data *svid_data)
 {
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 
-#ifdef RTDC_TA_EMULATE
+#if RTDC_TA_EMULATE
 	if (pd_port->data_role == PD_ROLE_DFP && svid_data->exist) {
 		pd_put_tcp_pd_event(pd_port, TCP_DPM_EVT_DR_SWAP_AS_UFP);
 		return 1;
@@ -322,7 +313,7 @@ int dc_dfp_notify_pe_ready(struct pd_port *pd_port,
 	if (pd_port->dc_dfp_state != DC_DFP_DISCOVER_MODES)
 		return 0;
 
-#ifdef CONFIG_USB_PD_RTDC_CHECK_CABLE
+#if CONFIG_USB_PD_RTDC_CHECK_CABLE
 	if (!pd_port->pe_data.power_cable_present) {
 		dc_dfp_set_state(pd_port, DC_DFP_ERR_DISCOVER_CABLE);
 		return 0;
@@ -334,7 +325,7 @@ int dc_dfp_notify_pe_ready(struct pd_port *pd_port,
 	}
 #endif	/* CONFIG_USB_PD_RTDC_CHECK_CABLE */
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	/* If TA support pd revision30, using standard PPS flow */
 	if (pd_check_rev30(pd_port)) {
 		dc_dfp_set_state(pd_port, DC_DFP_ERR_PD_REV30);
@@ -482,8 +473,8 @@ static inline bool dc_dfp_notify_en_unlock2(struct pd_port *pd_port,
 	if (!dc_dfp_verify_en_unlock2(pd_port))
 		return false;
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
-#ifdef CONFIG_USB_PD_REV30_SYNC_SPEC_REV
+#if CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_SYNC_SPEC_REV
 	if (pd_port->pe_data.dc_pps_mode)
 		pd_port->pd_revision[0] = PD_REV30;
 #endif	/* CONFIG_USB_PD_REV30_SYNC_SPEC_REV */
@@ -491,7 +482,7 @@ static inline bool dc_dfp_notify_en_unlock2(struct pd_port *pd_port,
 
 	dc_dfp_set_state(pd_port, DC_DFP_OPERATION);
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	/* PPS shoult not use en_unlock to notify system */
 	if (pd_port->pe_data.dc_pps_mode)
 		return true;
@@ -520,7 +511,7 @@ bool dc_dfp_notify_uvdm(struct pd_port *pd_port,
 bool dc_ufp_notify_uvdm(struct pd_port *pd_port,
 				struct svdm_svid_data *svid_data)
 {
-#ifdef RTDC_TA_EMULATE
+#if RTDC_TA_EMULATE
 	uint32_t reply_cmd[3];
 	uint32_t recv_code[2], rn_code, pass_code;
 
@@ -596,7 +587,7 @@ bool dc_parse_svid_data(struct pd_port *pd_port,
 {
 	svid_data->local_mode.mode_cnt = 1;
 	svid_data->local_mode.mode_vdo[0] = 0x00;
-	pd_port->dpm_caps |= DPM_CAP_ATTEMP_ENTER_DC_MODE;
+	pd_port->dpm_caps |= DPM_CAP_ATTEMPT_ENTER_DC_MODE;
 	return true;
 }
 #endif	/* CONFIG_USB_PD_ALT_MODE_RTDC */
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_dpm_alt_mode_dp.c b/drivers/misc/mediatek/typec/tcpc/pd_dpm_alt_mode_dp.c
index ffac605..bdd7413 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_dpm_alt_mode_dp.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_dpm_alt_mode_dp.c
@@ -1,18 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * PD Device Policy Manager for DisplayPort
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 #include <linux/delay.h>
 
 #include "inc/tcpci.h"
@@ -20,9 +11,7 @@
 #include "inc/pd_dpm_core.h"
 #include "pd_dpm_prv.h"
 
-#ifdef CONFIG_USB_POWER_DELIVERY
-#ifdef CONFIG_USB_PD_ALT_MODE
-
+#if CONFIG_USB_PD_ALT_MODE
 /* Display Port DFP_U / UFP_U */
 
 
@@ -82,7 +71,7 @@ static inline bool dp_update_dp_connected_both(struct pd_port *pd_port,
 }
 
 /* DP : DFP_U */
-#ifdef CONFIG_USB_PD_ALT_MODE_DFP
+#if CONFIG_USB_PD_ALT_MODE_DFP
 #if DP_DBG_ENABLE
 static const char * const dp_dfp_u_state_name[] = {
 	"dp_dfp_u_none",
@@ -116,7 +105,7 @@ bool dp_dfp_u_notify_pe_startup(
 	if (!(pd_port->id_vdos[0] & PD_IDH_MODAL_SUPPORT))
 		return true;
 
-	if (pd_port->dpm_caps & DPM_CAP_ATTEMP_ENTER_DP_MODE)
+	if (pd_port->dpm_caps & DPM_CAP_ATTEMPT_ENTER_DP_MODE)
 		dp_dfp_u_set_state(pd_port, DP_DFP_U_DISCOVER_ID);
 
 	return true;
@@ -450,7 +439,7 @@ bool dp_dfp_u_notify_enter_mode(struct pd_port *pd_port,
 	dp_data->local_status = pd_port->dp_first_connected;
 	dp_dfp_u_set_state(pd_port, DP_DFP_U_STATUS_UPDATE);
 
-#ifdef CONFIG_USB_PD_DBG_DP_DFP_D_AUTO_UPDATE
+#if CONFIG_USB_PD_DBG_DP_DFP_D_AUTO_UPDATE
 	/*
 	 * For Real Product,
 	 * DFP_U should not send status_update until USB status is changed
@@ -663,7 +652,7 @@ bool dp_dfp_u_notify_dp_status_update(struct pd_port *pd_port, bool ack)
 
 static inline void dp_ufp_u_auto_update(struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_DBG_DP_UFP_U_AUTO_UPDATE
+#if CONFIG_USB_PD_DBG_DP_UFP_U_AUTO_UPDATE
 	struct dp_data *dp_data = pd_get_dp_data(pd_port);
 
 	if (dp_data->dfp_u_state == DP_DFP_U_OPERATION)
@@ -876,7 +865,7 @@ bool dp_ufp_u_is_valid_dp_config(struct pd_port *pd_port, uint32_t dp_config)
 
 static inline void dp_ufp_u_auto_attention(struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_DBG_DP_UFP_U_AUTO_ATTENTION
+#if CONFIG_USB_PD_DBG_DP_UFP_U_AUTO_ATTENTION
 	struct dp_data *dp_data = pd_get_dp_data(pd_port);
 
 	pd_port->mode_svid = USB_SID_DISPLAYPORT;
@@ -959,7 +948,7 @@ void pd_dpm_ufp_send_dp_attention(struct pd_port *pd_port)
 
 /* ---- DFP : DP Only ---- */
 
-#ifdef CONFIG_USB_PD_ALT_MODE_DFP
+#if CONFIG_USB_PD_ALT_MODE_DFP
 
 void pd_dpm_dfp_send_dp_status_update(struct pd_port *pd_port)
 {
@@ -1005,7 +994,7 @@ bool dp_reset_state(struct pd_port *pd_port, struct svdm_svid_data *svid_data)
 #define DEFAULT_DP_FIRST_CONNECTED		(DPSTS_DFP_D_CONNECTED)
 #define DEFAULT_DP_SECOND_CONNECTED		(DPSTS_DFP_D_CONNECTED)
 
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 static const struct {
 	const char *prop_name;
 	uint32_t mode;
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_dpm_core.c b/drivers/misc/mediatek/typec/tcpc/pd_dpm_core.c
index b95a885..be7cce9 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_dpm_core.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_dpm_core.c
@@ -1,16 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * PD Device Policy Manager Core Driver
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include <linux/delay.h>
@@ -24,17 +14,18 @@
 #include "inc/pd_core.h"
 #include "pd_dpm_prv.h"
 
+#define NEVER 0
 struct pd_device_policy_manager {
 	uint8_t temp;
 };
 
 static const struct svdm_svid_ops svdm_svid_ops[] = {
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 	{
 		.name = "DisplayPort",
 		.svid = USB_SID_DISPLAYPORT,
 
-#ifdef CONFIG_USB_PD_ALT_MODE_DFP
+#if CONFIG_USB_PD_ALT_MODE_DFP
 		.dfp_inform_id = dp_dfp_u_notify_discover_id,
 		.dfp_inform_svids = dp_dfp_u_notify_discover_svid,
 		.dfp_inform_modes = dp_dfp_u_notify_discover_modes,
@@ -48,17 +39,17 @@ static const struct svdm_svid_ops svdm_svid_ops[] = {
 		.ufp_request_enter_mode = dp_ufp_u_request_enter_mode,
 		.ufp_request_exit_mode = dp_ufp_u_request_exit_mode,
 
-#ifdef CONFIG_USB_PD_ALT_MODE_DFP
+#if CONFIG_USB_PD_ALT_MODE_DFP
 		.notify_pe_startup = dp_dfp_u_notify_pe_startup,
 		.notify_pe_ready = dp_dfp_u_notify_pe_ready,
-#endif	/* #ifdef CONFIG_USB_PD_ALT_MODE_DFP */
+#endif	/* CONFIG_USB_PD_ALT_MODE_DFP */
 
 		.reset_state = dp_reset_state,
 		.parse_svid_data = dp_parse_svid_data,
 	},
 #endif	/* CONFIG_USB_PD_ALT_MODE */
 
-#ifdef CONFIG_USB_PD_RICHTEK_UVDM
+#if CONFIG_USB_PD_RICHTEK_UVDM
 	{
 		.name = "Richtek",
 		.svid = USB_VID_RICHTEK,
@@ -71,7 +62,7 @@ static const struct svdm_svid_ops svdm_svid_ops[] = {
 	},
 #endif	/* CONFIG_USB_PD_RICHTEK_UVDM */
 
-#ifdef CONFIG_USB_PD_ALT_MODE_RTDC
+#if CONFIG_USB_PD_ALT_MODE_RTDC
 	{
 		.name = "Direct Charge",
 		.svid = USB_VID_DIRECTCHARGE,
@@ -151,7 +142,7 @@ int pd_dpm_send_sink_caps(struct pd_port *pd_port)
 {
 	struct pd_port_power_caps *snk_cap = &pd_port->local_snk_cap;
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	if (pd_check_rev30(pd_port))
 		snk_cap->nr = pd_port->local_snk_cap_nr_pd30;
 	else
@@ -188,7 +179,7 @@ int pd_dpm_send_source_caps(struct pd_port *pd_port)
 
 void pd_dpm_inform_cable_id(struct pd_port *pd_port, bool src_startup)
 {
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	struct pe_data *pe_data = &pd_port->pe_data;
 #endif /* CONFIG_USB_PD_REV30 */
 	uint32_t *payload = pd_get_msg_vdm_data_payload(pd_port);
@@ -203,7 +194,7 @@ void pd_dpm_inform_cable_id(struct pd_port *pd_port, bool src_startup)
 
 		dpm_reaction_clear(pd_port, DPM_REACTION_DISCOVER_CABLE);
 	} else {
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 		if (pe_data->discover_id_counter >= PD_DISCOVER_ID30_COUNT)
 			pd_sync_sop_prime_spec_revision(pd_port, PD_REV20);
 #endif	/* CONFIG_USB_PD_REV30 */
@@ -230,7 +221,7 @@ static void dpm_build_sink_pdo_info(struct dpm_pdo_info_t *sink_pdo_info,
 {
 	sink_pdo_info->type = type;
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	if (type == DPM_PDO_TYPE_APDO) {
 		request_v = (request_v / 20) * 20;
 		request_i = (request_i / 50) * 50;
@@ -243,7 +234,8 @@ static void dpm_build_sink_pdo_info(struct dpm_pdo_info_t *sink_pdo_info,
 	sink_pdo_info->uw = request_v * request_i;
 }
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+
+#if CONFIG_USB_PD_REV30_PPS_SINK
 static int pps_request_thread_fn(void *data)
 {
 	struct tcpc_device *tcpc = data;
@@ -268,7 +260,6 @@ static int pps_request_thread_fn(void *data)
 			pd_put_deferred_tcp_event(tcpc, &tcp_event);
 		}
 	}
-
 	return 0;
 }
 
@@ -303,6 +294,7 @@ static bool dpm_build_request_info_apdo(
 }
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 
+
 static bool dpm_build_request_info_pdo(
 		struct pd_port *pd_port, struct dpm_rdo_info_t *req_info,
 		struct pd_port_power_caps *src_cap, uint8_t charging_policy)
@@ -352,7 +344,7 @@ static bool dpm_build_request_info(
 	for (i = 0; i < src_cap->nr; i++)
 		DPM_DBG("SrcCap%d: 0x%08x\n", i+1, src_cap->pdos[i]);
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	if ((charging_policy & DPM_CHARGING_POLICY_MASK)
 		== DPM_CHARGING_POLICY_PPS) {
 		return dpm_build_request_info_apdo(
@@ -428,7 +420,7 @@ static inline void dpm_update_request_not_bat(struct pd_port *pd_port,
 
 	dpm_update_request_i_new(pd_port, req_info);
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	if (req_info->type == DPM_PDO_TYPE_APDO) {
 		pd_port->request_apdo_new = true;
 		pd_port->last_rdo = RDO_APDO(
@@ -458,7 +450,7 @@ static inline void dpm_update_request(
 	uint32_t flags = 0;
 	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	pd_port->request_apdo_new = false;
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 
@@ -484,7 +476,7 @@ static inline void dpm_update_request(
 	else
 		dpm_update_request_not_bat(pd_port, req_info, flags);
 
-#ifdef CONFIG_USB_PD_DIRECT_CHARGE
+#if CONFIG_USB_PD_DIRECT_CHARGE
 	pd_notify_pe_direct_charge(pd_port,
 			req_info->vmin < TCPC_VBUS_SINK_5V);
 #endif	/* CONFIG_USB_PD_DIRECT_CHARGE */
@@ -505,7 +497,7 @@ int pd_dpm_update_tcp_request(struct pd_port *pd_port,
 
 	DPM_DBG("charging_policy=0x%X\n", charging_policy);
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	if ((charging_policy & DPM_CHARGING_POLICY_MASK)
 		== DPM_CHARGING_POLICY_PPS)
 		type = DPM_PDO_TYPE_APDO;
@@ -513,7 +505,7 @@ int pd_dpm_update_tcp_request(struct pd_port *pd_port,
 
 	dpm_build_sink_pdo_info(&sink_pdo_info, type, pd_req->mv, pd_req->ma);
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	if (pd_port->request_apdo &&
 		(sink_pdo_info.vmin == pd_port->request_v) &&
 		(sink_pdo_info.ma == pd_port->request_i))
@@ -529,7 +521,7 @@ int pd_dpm_update_tcp_request(struct pd_port *pd_port,
 		return TCP_DPM_RET_DENIED_INVALID_REQUEST;
 	}
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	if ((charging_policy & DPM_CHARGING_POLICY_MASK)
 		== DPM_CHARGING_POLICY_PPS) {
 		pd_port->request_v_apdo = sink_pdo_info.vmin;
@@ -552,7 +544,7 @@ int pd_dpm_update_tcp_request_ex(struct pd_port *pd_port,
 	if (pd_req->pos > src_cap->nr)
 		return false;
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	if (pd_port->dpm_charging_policy == DPM_CHARGING_POLICY_PPS) {
 		DPM_INFO("Reject tcp_rqeuest_ex if charging_policy=pps\n");
 		return TCP_DPM_RET_DENIED_INVALID_REQUEST;
@@ -647,7 +639,7 @@ void pd_dpm_snk_evaluate_caps(struct pd_port *pd_port)
 
 void pd_dpm_snk_standby_power(struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_SNK_STANDBY_POWER
+#if CONFIG_USB_PD_SNK_STANDBY_POWER
 	/*
 	 * pSnkStdby :
 	 *   Maximum power consumption while in Sink Standby. (2.5W)
@@ -664,7 +656,7 @@ void pd_dpm_snk_standby_power(struct pd_port *pd_port)
 	int standby_curr = 2500000 / max(pd_port->request_v,
 					 pd_port->request_v_new);
 
-#ifdef CONFIG_USB_PD_VCONN_SAFE5V_ONLY
+#if CONFIG_USB_PD_VCONN_SAFE5V_ONLY
 	struct tcpc_device *tcpc = pd_port->tcpc;
 	struct pe_data *pe_data = &pd_port->pe_data;
 	bool vconn_highv_prot = pd_port->request_v_new > 5000;
@@ -678,7 +670,7 @@ void pd_dpm_snk_standby_power(struct pd_port *pd_port)
 	}
 #endif	/* CONFIG_USB_PD_VCONN_SAFE5V_ONLY */
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	/*
 	 * A Sink is not required to transition to Sink Standby
 	 *	when operating with a Programmable Power Supply
@@ -711,7 +703,7 @@ void pd_dpm_snk_standby_power(struct pd_port *pd_port)
 			pd_port->tcpc, type, pd_port->request_v_new, ma);
 	}
 #else
-#ifdef CONFIG_USB_PD_SNK_GOTOMIN
+#if CONFIG_USB_PD_SNK_GOTOMIN
 	tcpci_sink_vbus(pd_port->tcpc, TCP_VBUS_CTRL_REQUEST,
 		pd_port->request_v, pd_port->request_i_new);
 #endif	/* CONFIG_USB_PD_SNK_GOTOMIN */
@@ -726,7 +718,7 @@ void pd_dpm_snk_transition_power(struct pd_port *pd_port)
 	pd_port->request_v = pd_port->request_v_new;
 	pd_port->request_i = pd_port->request_i_new;
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	if (pd_port->request_apdo != pd_port->request_apdo_new) {
 		pd_port->request_apdo = pd_port->request_apdo_new;
 		pd_dpm_start_pps_request_thread(
@@ -746,9 +738,9 @@ void pd_dpm_snk_hard_reset(struct pd_port *pd_port)
 	int mv = 0, ma = 0;
 	bool ignore_hreset = false;
 
-#ifdef CONFIG_USB_PD_SNK_HRESET_KEEP_DRAW
+#if CONFIG_USB_PD_SNK_HRESET_KEEP_DRAW
 	if (!pd_port->pe_data.pd_prev_connected) {
-#ifdef CONFIG_USB_PD_SNK_IGNORE_HRESET_IF_TYPEC_ONLY
+#if CONFIG_USB_PD_SNK_IGNORE_HRESET_IF_TYPEC_ONLY
 		ignore_hreset = true;
 #else
 		ma = -1;
@@ -805,7 +797,7 @@ static inline bool dpm_evaluate_request(
 
 	sink_v = src_info.vmin;
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SOURCE
+#if CONFIG_USB_PD_REV30_PPS_SOURCE
 	if ((pdo & PDO_TYPE_MASK) == PDO_TYPE_APDO) {
 		sink_v = RDO_APDO_EXTRACT_OP_MV(rdo);
 
@@ -871,7 +863,7 @@ void pd_dpm_src_transition_power(struct pd_port *pd_port)
 {
 	pd_enable_vbus_stable_detection(pd_port);
 
-#ifdef CONFIG_USB_PD_SRC_HIGHCAP_POWER
+#if CONFIG_USB_PD_SRC_HIGHCAP_POWER
 	if (pd_port->request_v > pd_port->request_v_new) {
 		mutex_lock(&pd_port->tcpc->access_lock);
 		tcpci_enable_force_discharge(
@@ -1094,7 +1086,7 @@ void pd_dpm_ufp_request_exit_mode(struct pd_port *pd_port)
 static inline void dpm_dfp_update_partner_id(
 			struct pd_port *pd_port, uint32_t *payload)
 {
-#ifdef CONFIG_USB_PD_KEEP_PARTNER_ID
+#if CONFIG_USB_PD_KEEP_PARTNER_ID
 	uint8_t cnt = pd_get_msg_vdm_data_count(pd_port);
 	uint32_t size = sizeof(uint32_t) * (cnt);
 
@@ -1108,7 +1100,7 @@ static inline void dpm_dfp_update_svid_data_exist(
 	uint8_t k;
 	struct svdm_svid_data *svid_data;
 	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-#ifdef CONFIG_USB_PD_KEEP_SVIDS
+#if CONFIG_USB_PD_KEEP_SVIDS
 	struct svdm_svid_list *list = &pd_port->pe_data.remote_svid_list;
 
 	if (list->cnt < VDO_MAX_SVID_NR)
@@ -1389,7 +1381,7 @@ void pd_dpm_dfp_inform_attention(struct pd_port *pd_port)
 
 /* ---- Unstructured VDM ---- */
 
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 
 void pd_dpm_ufp_recv_uvdm(struct pd_port *pd_port)
 {
@@ -1401,6 +1393,7 @@ void pd_dpm_ufp_recv_uvdm(struct pd_port *pd_port)
 	pd_port->uvdm_svid = svid;
 	pd_port->uvdm_cnt = pd_get_msg_data_count(pd_port);
 
+    DPM_INFO("pd_dpm_ufp_recv_uvdm\r\n");
 	memcpy(pd_port->uvdm_data,
 		pd_get_msg_data_payload(pd_port),
 		pd_get_msg_data_size(pd_port));
@@ -1437,7 +1430,7 @@ void pd_dpm_dfp_inform_uvdm(struct pd_port *pd_port, bool ack)
 
 	if (ack && pd_port->uvdm_wait_resp) {
 		svid = dpm_vdm_get_svid(pd_port);
-
+        DPM_INFO("pd_dpm_dfp_inform_uvdm get svid = 0x%04x\r\n", svid);
 		if (svid != expected_svid) {
 			ack = false;
 			DPM_INFO("Not expected SVID (0x%04x, 0x%04x)\n",
@@ -1451,11 +1444,13 @@ void pd_dpm_dfp_inform_uvdm(struct pd_port *pd_port, bool ack)
 	}
 
 	if (svid_data) {
+		DPM_INFO("pd_dpm_dfp_inform_uvdm svid_data is not null\r\n");
 		if (svid_data->ops->dfp_notify_uvdm)
 			svid_data->ops->dfp_notify_uvdm(
 				pd_port, svid_data, ack);
 	}
 
+    DPM_INFO("pd_dpm_dfp_inform_uvdm\r\n");
 	tcpci_notify_uvdm(tcpc, ack);
 	pd_notify_tcp_vdm_event_2nd_result(pd_port,
 		ack ? TCP_DPM_RET_VDM_ACK : TCP_DPM_RET_VDM_NAK);
@@ -1522,7 +1517,7 @@ void pd_dpm_dr_inform_source_cap(struct pd_port *pd_port)
  * DRP : Data Role Swap
  */
 
-#ifdef CONFIG_USB_PD_DR_SWAP
+#if CONFIG_USB_PD_DR_SWAP
 
 void pd_dpm_drs_evaluate_swap(struct pd_port *pd_port, uint8_t role)
 {
@@ -1535,11 +1530,11 @@ void pd_dpm_drs_change_role(struct pd_port *pd_port, uint8_t role)
 
 	pd_port->pe_data.pe_ready = false;
 
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	pd_port->pe_data.pd_traffic_idle = false;
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
 
-#ifdef CONFIG_USB_PD_DFP_FLOW_DELAY_DRSWAP
+#if CONFIG_USB_PD_DFP_FLOW_DELAY_DRSWAP
 	dpm_reaction_set(pd_port, DPM_REACTION_DFP_FLOW_DELAY);
 #else
 	dpm_reaction_clear(pd_port, DPM_REACTION_DFP_FLOW_DELAY);
@@ -1554,9 +1549,9 @@ void pd_dpm_drs_change_role(struct pd_port *pd_port, uint8_t role)
  * DRP : Power Role Swap
  */
 
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 
-#if 0
+#if NEVER
 static bool pd_dpm_evaluate_source_cap_match(pd_port_t *pd_port)
 {
 	int i, j;
@@ -1581,7 +1576,7 @@ static bool pd_dpm_evaluate_source_cap_match(pd_port_t *pd_port)
 
 	return find_cap;
 }
-#endif
+#endif /* NEVER */
 
 /*
  * Rules:
@@ -1625,7 +1620,7 @@ void pd_dpm_prs_evaluate_swap(struct pd_port *pd_port, uint8_t role)
 	bool check_snk = (pd_port->dpm_caps & DPM_CAP_PR_SWAP_CHECK_GP_SNK) ?
 		true : false;
 
-#ifdef CONFIG_USB_PD_SRC_REJECT_PR_SWAP_IF_GOOD_PW
+#if CONFIG_USB_PD_SRC_REJECT_PR_SWAP_IF_GOOD_PW
 	bool check_ext =
 		(pd_port->dpm_caps & DPM_CAP_CHECK_EXT_POWER) ? true : false;
 
@@ -1679,7 +1674,7 @@ void pd_dpm_prs_enable_power_source(struct pd_port *pd_port, bool en)
 
 void pd_dpm_prs_change_role(struct pd_port *pd_port, uint8_t role)
 {
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	pd_port->pe_data.pd_traffic_idle = false;
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
 
@@ -1694,13 +1689,13 @@ void pd_dpm_prs_change_role(struct pd_port *pd_port, uint8_t role)
  * DRP : Vconn Swap
  */
 
-#ifdef CONFIG_USB_PD_VCONN_SWAP
+#if CONFIG_USB_PD_VCONN_SWAP
 
 void pd_dpm_vcs_evaluate_swap(struct pd_port *pd_port)
 {
 	bool accept = true;
 
-#ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
+#if CONFIG_TCPC_VCONN_SUPPLY_MODE
 	struct tcpc_device *tcpc = pd_port->tcpc;
 
 	/* Reject it if we don't want supply vconn */
@@ -1737,9 +1732,9 @@ void pd_dpm_vcs_enable_vconn(struct pd_port *pd_port, uint8_t role)
  * PE : PD3.0
  */
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
 void pd_dpm_inform_source_cap_ext(struct pd_port *pd_port)
 {
 	struct pd_source_cap_ext *scedb;
@@ -1757,7 +1752,7 @@ void pd_dpm_inform_source_cap_ext(struct pd_port *pd_port)
 }
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
 int pd_dpm_send_source_cap_ext(struct pd_port *pd_port)
 {
 	return pd_send_sop_ext_msg(pd_port, PD_EXT_SOURCE_CAP_EXT,
@@ -1765,7 +1760,7 @@ int pd_dpm_send_source_cap_ext(struct pd_port *pd_port)
 }
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_BAT_CAP_LOCAL
+#if CONFIG_USB_PD_REV30_BAT_CAP_LOCAL
 
 static const struct pd_battery_capabilities c_invalid_bcdb = {
 	0, 0, 0, 0, PD_BCDB_BAT_TYPE_INVALID
@@ -1795,7 +1790,7 @@ int pd_dpm_send_battery_cap(struct pd_port *pd_port)
 }
 #endif	/* CONFIG_USB_PD_REV30_BAT_CAP_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
+#if CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
 void pd_dpm_inform_battery_cap(struct pd_port *pd_port)
 {
 	struct pd_battery_capabilities *bcdb;
@@ -1809,7 +1804,7 @@ void pd_dpm_inform_battery_cap(struct pd_port *pd_port)
 }
 #endif	/* CONFIG_USB_PD_REV30_BAT_CAP_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL
 
 static const uint32_t c_invalid_bsdo =
 	BSDO(0xffff, BSDO_BAT_INFO_INVALID_REF);
@@ -1833,7 +1828,7 @@ int pd_dpm_send_battery_status(struct pd_port *pd_port)
 	} else
 		bsdo = &c_invalid_bsdo;
 
-#ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
+#if CONFIG_USB_PD_REV30_ALERT_LOCAL
 	pd_port->pe_data.get_status_once = true;
 #endif	/* CONFIG_USB_PD_REV30_ALERT_LOCAL */
 
@@ -1843,7 +1838,7 @@ int pd_dpm_send_battery_status(struct pd_port *pd_port)
 #endif	/* CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL */
 
 
-#ifdef CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
 void pd_dpm_inform_battery_status(struct pd_port *pd_port)
 {
 	uint32_t *payload;
@@ -1856,11 +1851,12 @@ void pd_dpm_inform_battery_status(struct pd_port *pd_port)
 }
 #endif	/* CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE */
 
+
 static const struct pd_manufacturer_info c_invalid_mfrs = {
 	.vid = 0xFFFF, .pid = 0, .mfrs_string = "Not Supported",
 };
 
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
 int pd_dpm_send_mfrs_info(struct pd_port *pd_port)
 {
 	uint8_t len = 0;
@@ -1890,7 +1886,7 @@ int pd_dpm_send_mfrs_info(struct pd_port *pd_port)
 }
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
+#if CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
 void pd_dpm_inform_mfrs_info(struct pd_port *pd_port)
 {
 	struct pd_manufacturer_info *midb;
@@ -1904,7 +1900,7 @@ void pd_dpm_inform_mfrs_info(struct pd_port *pd_port)
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE */
 
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
+#if CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
 void pd_dpm_inform_country_codes(struct pd_port *pd_port)
 {
 	struct pd_country_codes *ccdb;
@@ -1919,7 +1915,7 @@ void pd_dpm_inform_country_codes(struct pd_port *pd_port)
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE */
 
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
+#if CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
 int pd_dpm_send_country_codes(struct pd_port *pd_port)
 {
 	uint8_t i;
@@ -1936,7 +1932,7 @@ int pd_dpm_send_country_codes(struct pd_port *pd_port)
 }
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
+#if CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
 void pd_dpm_inform_country_info(struct pd_port *pd_port)
 {
 	struct pd_country_info *cidb;
@@ -1950,7 +1946,7 @@ void pd_dpm_inform_country_info(struct pd_port *pd_port)
 }
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL
 int pd_dpm_send_country_info(struct pd_port *pd_port)
 {
 	uint8_t i, cidb_size;
@@ -1978,7 +1974,7 @@ int pd_dpm_send_country_info(struct pd_port *pd_port)
 }
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
+#if CONFIG_USB_PD_REV30_ALERT_REMOTE
 void pd_dpm_inform_alert(struct pd_port *pd_port)
 {
 	uint32_t *data = pd_get_msg_data_payload(pd_port);
@@ -1992,7 +1988,7 @@ void pd_dpm_inform_alert(struct pd_port *pd_port)
 }
 #endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
+#if CONFIG_USB_PD_REV30_ALERT_LOCAL
 int pd_dpm_send_alert(struct pd_port *pd_port)
 {
 	uint32_t ado = pd_port->pe_data.local_alert;
@@ -2006,7 +2002,7 @@ int pd_dpm_send_alert(struct pd_port *pd_port)
 }
 #endif	/* CONFIG_USB_PD_REV30_ALERT_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_STATUS_REMOTE
 void pd_dpm_inform_status(struct pd_port *pd_port)
 {
 	struct pd_status *sdb;
@@ -2024,7 +2020,7 @@ void pd_dpm_inform_status(struct pd_port *pd_port)
 }
 #endif /* CONFIG_USB_PD_REV30_STATUS_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
 int pd_dpm_send_status(struct pd_port *pd_port)
 {
 	struct pd_status sdb;
@@ -2034,7 +2030,7 @@ int pd_dpm_send_status(struct pd_port *pd_port)
 
 	sdb.present_input = pd_port->pd_status_present_in;
 
-#ifdef CONFIG_USB_PD_REV30_BAT_INFO
+#if CONFIG_USB_PD_REV30_BAT_INFO
 	if (sdb.present_input &
 		PD_STATUS_INPUT_INT_POWER_BAT) {
 		sdb.present_battery_input = pd_port->pd_status_bat_in;
@@ -2044,7 +2040,7 @@ int pd_dpm_send_status(struct pd_port *pd_port)
 	sdb.event_flags = pe_data->pd_status_event;
 	pe_data->pd_status_event &= ~PD_STASUS_EVENT_READ_CLEAR;
 
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL_TEMP
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL_TEMP
 	sdb.internal_temp = pd_port->pd_status_temp;
 	sdb.temp_status = pd_port->pd_status_temp_status;
 #else
@@ -2058,7 +2054,7 @@ int pd_dpm_send_status(struct pd_port *pd_port)
 	if (pd_port->power_role !=  PD_ROLE_SINK)
 		sdb.event_flags &= ~PD_STATUS_EVENT_OVP;
 
-#ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
+#if CONFIG_USB_PD_REV30_ALERT_LOCAL
 	pe_data->get_status_once = true;
 #endif	/* CONFIG_USB_PD_REV30_ALERT_LOCAL */
 
@@ -2068,7 +2064,7 @@ int pd_dpm_send_status(struct pd_port *pd_port)
 #endif	/* CONFIG_USB_PD_REV30_STATUS_LOCAL */
 
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 void pd_dpm_inform_pps_status(struct pd_port *pd_port)
 {
 	struct pd_pps_status_raw *ppssdb;
@@ -2096,7 +2092,7 @@ void pd_dpm_inform_not_support(struct pd_port *pd_port)
 
 void pd_dpm_dynamic_enable_vconn(struct pd_port *pd_port)
 {
-#ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
+#if CONFIG_TCPC_VCONN_SUPPLY_MODE
 	struct tcpc_device *tcpc = pd_port->tcpc;
 
 	if (tcpc->tcpc_vconn_supply <= TCPC_VCONN_SUPPLY_ALWAYS)
@@ -2111,7 +2107,7 @@ void pd_dpm_dynamic_enable_vconn(struct pd_port *pd_port)
 
 void pd_dpm_dynamic_disable_vconn(struct pd_port *pd_port)
 {
-#ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
+#if CONFIG_TCPC_VCONN_SUPPLY_MODE
 	bool keep_vconn;
 	struct tcpc_device *tcpc = pd_port->tcpc;
 
@@ -2151,15 +2147,15 @@ int pd_dpm_notify_pe_startup(struct pd_port *pd_port)
 {
 	uint32_t reactions = DPM_REACTION_CAP_ALWAYS;
 
-#ifdef CONFIG_USB_PD_DFP_FLOW_DELAY_STARTUP
+#if CONFIG_USB_PD_DFP_FLOW_DELAY_STARTUP
 	reactions |= DPM_REACTION_DFP_FLOW_DELAY;
 #endif	/* CONFIG_USB_PD_DFP_FLOW_DELAY_STARTUP */
 
-#ifdef CONFIG_USB_PD_UFP_FLOW_DELAY
+#if CONFIG_USB_PD_UFP_FLOW_DELAY
 	reactions |= DPM_REACTION_UFP_FLOW_DELAY;
 #endif	/* CONFIG_USB_PD_UFP_FLOW_DELAY */
 
-#ifdef CONFIG_USB_PD_SRC_TRY_PR_SWAP_IF_BAD_PW
+#if CONFIG_USB_PD_SRC_TRY_PR_SWAP_IF_BAD_PW
 	reactions |= DPM_REACTION_ATTEMPT_GET_FLAG |
 		DPM_REACTION_REQUEST_PR_SWAP;
 #else
@@ -2181,24 +2177,24 @@ int pd_dpm_notify_pe_startup(struct pd_port *pd_port)
 			reactions |= DPM_REACTION_ATTEMPT_GET_FLAG;
 	}
 
-	if (pd_port->dpm_caps & DPM_CAP_ATTEMP_DISCOVER_CABLE)
+	if (pd_port->dpm_caps & DPM_CAP_ATTEMPT_DISCOVER_CABLE)
 		reactions |= DPM_REACTION_CAP_DISCOVER_CABLE;
 
-	if (pd_port->dpm_caps & DPM_CAP_ATTEMP_DISCOVER_CABLE_DFP)
+	if (pd_port->dpm_caps & DPM_CAP_ATTEMPT_DISCOVER_CABLE_DFP)
 		reactions |= DPM_REACTION_DISCOVER_CABLE_FLOW;
 
-#ifdef CONFIG_USB_PD_ATTEMP_ENTER_MODE
+#if CONFIG_USB_PD_ATTEMPT_ENTER_MODE
 	reactions |= DPM_REACTION_DISCOVER_ID |
 		DPM_REACTION_DISCOVER_SVID;
 #else
-	if (pd_port->dpm_caps & DPM_CAP_ATTEMP_DISCOVER_ID)
+	if (pd_port->dpm_caps & DPM_CAP_ATTEMPT_DISCOVER_ID)
 		reactions |= DPM_REACTION_DISCOVER_ID;
-	if (pd_port->dpm_caps & DPM_CAP_ATTEMP_DISCOVER_SVID)
+	if (pd_port->dpm_caps & DPM_CAP_ATTEMPT_DISCOVER_SVID)
 		reactions |= DPM_REACTION_DISCOVER_SVID;
-#endif	/* CONFIG_USB_PD_ATTEMP_ENTER_MODE */
+#endif	/* CONFIG_USB_PD_ATTEMPT_ENTER_MODE */
 
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
 	reactions |= DPM_REACTION_GET_SOURCE_CAP_EXT;
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE */
 #endif	/* CONFIG_USB_PD_REV30 */
@@ -2219,7 +2215,7 @@ int pd_dpm_notify_pe_hardreset(struct pd_port *pd_port)
 
 	pe_data->pe_ready = false;
 
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	pe_data->pd_traffic_idle = false;
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
 
@@ -2228,10 +2224,10 @@ int pd_dpm_notify_pe_hardreset(struct pd_port *pd_port)
 
 	pe_data->dpm_svdm_retry_cnt++;
 
-#ifdef CONFIG_USB_PD_ATTEMP_ENTER_MODE
+#if CONFIG_USB_PD_ATTEMPT_ENTER_MODE
 	dpm_reaction_set(pd_port, DPM_REACTION_DISCOVER_ID |
 		DPM_REACTION_DISCOVER_SVID);
-#endif	/* CONFIG_USB_PD_ATTEMP_ENTER_MODE */
+#endif	/* CONFIG_USB_PD_ATTEMPT_ENTER_MODE */
 
 	svdm_notify_pe_startup(pd_port);
 	return 0;
@@ -2274,6 +2270,7 @@ struct svdm_svid_data *dpm_get_svdm_svid_data(
 	return NULL;
 }
 
+
 bool svdm_reset_state(struct pd_port *pd_port)
 {
 	int i;
@@ -2331,7 +2328,8 @@ int pd_dpm_core_init(struct pd_port *pd_port)
 
 	pd_port->svid_data_cnt = j;
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	pd_port->pps_request_wake_lock =
 		wakeup_source_register(&tcpc->dev, "pd_pps_request_wake_lock");
 	init_waitqueue_head(&pd_port->pps_request_wait_que);
@@ -2339,6 +2337,7 @@ int pd_dpm_core_init(struct pd_port *pd_port)
 	pd_port->pps_request_task = kthread_run(pps_request_thread_fn, tcpc,
 						"pps_request_%s",
 						tcpc->desc.name);
+#endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 #endif /* CONFIG_USB_PD_REV30 */
 
 	return 0;
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_dpm_pdo_select.c b/drivers/misc/mediatek/typec/tcpc/pd_dpm_pdo_select.c
index aa5ce10..b16141d 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_dpm_pdo_select.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_dpm_pdo_select.c
@@ -1,22 +1,11 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * Power Delivery Core Driver
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 #include "inc/pd_dpm_pdo_select.h"
 
-#ifdef CONFIG_USB_POWER_DELIVERY
-
 struct dpm_select_info_t {
 	uint8_t pos;
 	int max_uw;
@@ -27,7 +16,7 @@ struct dpm_select_info_t {
 static inline void dpm_extract_apdo_info(
 		uint32_t pdo, struct dpm_pdo_info_t *info)
 {
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	switch (APDO_TYPE(pdo)) {
 	case APDO_TYPE_PPS:
 		info->apdo_type = DPM_APDO_TYPE_PPS;
@@ -74,7 +63,7 @@ void dpm_extract_pdo_info(
 		info->ma = info->uw / info->vmin;
 		break;
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	case PDO_TYPE_APDO:
 		dpm_extract_apdo_info(pdo, info);
 		break;
@@ -138,7 +127,7 @@ static bool dpm_select_pdo_from_vsafe5v(
  * Select PDO from Direct Charge
  */
 
-#ifdef CONFIG_USB_PD_ALT_MODE_RTDC
+#if CONFIG_USB_PD_ALT_MODE_RTDC
 static bool dpm_select_pdo_from_direct_charge(
 	struct dpm_select_info_t *select_info,
 	struct dpm_pdo_info_t *sink, struct dpm_pdo_info_t *source)
@@ -207,13 +196,13 @@ static bool dpm_select_pdo_from_max_power(
 	bool overload;
 	int uw;
 
-#ifdef CONFIG_USB_PD_ALT_MODE_RTDC
+#if CONFIG_USB_PD_ALT_MODE_RTDC
 	/* Variable for direct charge only */
 	if ((sink->type == DPM_PDO_TYPE_VAR) && (sink->vmin < 5000))
 		return false;
 #endif	/* CONFIG_USB_PD_ALT_MODE_RTDC */
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	if (sink->type == DPM_PDO_TYPE_APDO)
 		return false;
 #endif	/* CONFIG_USB_PD_REV30 */
@@ -247,7 +236,7 @@ static bool dpm_select_pdo_from_max_power(
  * Select PDO from PPS
  */
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 static bool dpm_select_pdo_from_pps(
 		struct dpm_select_info_t *select_info,
 		struct dpm_pdo_info_t *sink, struct dpm_pdo_info_t *source)
@@ -329,13 +318,13 @@ bool dpm_find_match_req_info(struct dpm_rdo_info_t *req_info,
 		select_pdo_fun = dpm_select_pdo_from_custom;
 		break;
 
-#ifdef CONFIG_USB_PD_ALT_MODE_RTDC
+#if CONFIG_USB_PD_ALT_MODE_RTDC
 	case DPM_CHARGING_POLICY_DIRECT_CHARGE:
 		select_pdo_fun = dpm_select_pdo_from_direct_charge;
 		break;
 #endif	/* CONFIG_USB_PD_ALT_MODE_RTDC */
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	case DPM_CHARGING_POLICY_PPS:
 		select_pdo_fun = dpm_select_pdo_from_pps;
 		break;
@@ -374,16 +363,25 @@ bool dpm_find_match_req_info(struct dpm_rdo_info_t *req_info,
 			req_info->oper_ma = MIN(sink->ma, source.ma);
 		}
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 		if (source.type == DPM_PDO_TYPE_APDO) {
 			req_info->vmax = sink->vmax;
 			req_info->vmin = sink->vmin;
 		}
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 
-		return true;
+//		return true;
+	} else {
+		dpm_extract_pdo_info(src_pdos[0], &source);
+		req_info->pos = 1;
+		req_info->type = source.type;
+		req_info->vmax = source.vmax;
+		req_info->vmin = source.vmin;
+		req_info->mismatch = false;
+		req_info->max_ma = source.ma;
+		req_info->oper_ma = source.ma;
 	}
 
-	return false;
+	return true;
 }
 #endif	/* CONFIG_USB_POWER_DELIVERY */
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_dpm_prv.h b/drivers/misc/mediatek/typec/tcpc/pd_dpm_prv.h
index ef5bbd4..63b68fb 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_dpm_prv.h
+++ b/drivers/misc/mediatek/typec/tcpc/pd_dpm_prv.h
@@ -1,14 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #ifndef PD_DPM_PRV_H_INCLUDED
@@ -62,7 +54,7 @@ struct svdm_svid_ops {
 	bool (*notify_pe_shutdown)(struct pd_port *pd_port,
 		struct svdm_svid_data *svid_data);
 
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 	bool (*dfp_notify_uvdm)(struct pd_port *pd_port,
 		struct svdm_svid_data *svid_data, bool ack);
 
@@ -84,7 +76,7 @@ static inline bool dpm_check_data_msg_event(
 		pd_get_curr_pd_event(pd_port), msg);
 }
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 static inline bool dpm_check_ext_msg_event(
 	struct pd_port *pd_port, uint8_t msg)
 {
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_dpm_reaction.c b/drivers/misc/mediatek/typec/tcpc/pd_dpm_reaction.c
index 77b35cb..afae14b 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_dpm_reaction.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_dpm_reaction.c
@@ -1,16 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * PD Device Policy Manager Ready State reactions
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include "inc/tcpci.h"
@@ -38,7 +28,7 @@
  * DPM flow delay reactions
  */
 
-#ifdef CONFIG_USB_PD_UFP_FLOW_DELAY
+#if CONFIG_USB_PD_UFP_FLOW_DELAY
 static uint8_t dpm_reaction_ufp_flow_delay(struct pd_port *pd_port)
 {
 	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
@@ -49,7 +39,7 @@ static uint8_t dpm_reaction_ufp_flow_delay(struct pd_port *pd_port)
 }
 #endif	/* CONFIG_USB_PD_UFP_FLOW_DELAY */
 
-#ifdef CONFIG_USB_PD_DFP_FLOW_DELAY
+#if CONFIG_USB_PD_DFP_FLOW_DELAY
 static uint8_t dpm_reaction_dfp_flow_delay(struct pd_port *pd_port)
 {
 	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
@@ -60,7 +50,7 @@ static uint8_t dpm_reaction_dfp_flow_delay(struct pd_port *pd_port)
 }
 #endif	/* CONFIG_USB_PD_DFP_FLOW_DELAY */
 
-#ifdef CONFIG_USB_PD_VCONN_STABLE_DELAY
+#if CONFIG_USB_PD_VCONN_STABLE_DELAY
 static uint8_t dpm_reaction_vconn_stable_delay(struct pd_port *pd_port)
 {
 	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
@@ -78,7 +68,7 @@ static uint8_t dpm_reaction_vconn_stable_delay(struct pd_port *pd_port)
  * DPM get cap reaction
  */
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 static uint8_t dpm_reaction_get_source_cap_ext(struct pd_port *pd_port)
 {
 	if (pd_port->power_role == PD_ROLE_SINK)
@@ -98,7 +88,7 @@ static uint8_t dpm_reaction_get_source_cap(struct pd_port *pd_port)
 	return TCP_DPM_EVT_GET_SOURCE_CAP;
 }
 
-static uint8_t dpm_reaction_attemp_get_flag(struct pd_port *pd_port)
+static uint8_t dpm_reaction_attempt_get_flag(struct pd_port *pd_port)
 {
 	return TCP_DPM_EVT_GET_SINK_CAP;
 }
@@ -107,7 +97,7 @@ static uint8_t dpm_reaction_attemp_get_flag(struct pd_port *pd_port)
  * DPM swap reaction
  */
 
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 static uint8_t dpm_reaction_request_pr_swap(struct pd_port *pd_port)
 {
 	uint32_t prefer_role =
@@ -120,7 +110,7 @@ static uint8_t dpm_reaction_request_pr_swap(struct pd_port *pd_port)
 		if (prefer_role == DPM_CAP_PR_CHECK_PREFER_SRC)
 			return TCP_DPM_EVT_PR_SWAP_AS_SRC;
 	} else {
-#ifdef CONFIG_USB_PD_SRC_TRY_PR_SWAP_IF_BAD_PW
+#if CONFIG_USB_PD_SRC_TRY_PR_SWAP_IF_BAD_PW
 		if (dpm_check_good_power(pd_port) == GOOD_PW_PARTNER)
 			return TCP_DPM_EVT_PR_SWAP_AS_SNK;
 #endif	/* CONFIG_USB_PD_SRC_TRY_PR_SWAP_IF_BAD_PW */
@@ -133,7 +123,7 @@ static uint8_t dpm_reaction_request_pr_swap(struct pd_port *pd_port)
 }
 #endif	/* CONFIG_USB_PD_PR_SWAP */
 
-#ifdef CONFIG_USB_PD_DR_SWAP
+#if CONFIG_USB_PD_DR_SWAP
 static uint8_t dpm_reaction_request_dr_swap(struct pd_port *pd_port)
 {
 	uint32_t prefer_role =
@@ -152,14 +142,14 @@ static uint8_t dpm_reaction_request_dr_swap(struct pd_port *pd_port)
 
 	return 0;
 }
-#endif	/* #ifdef CONFIG_USB_PD_DR_SWAP */
+#endif	/* CONFIG_USB_PD_DR_SWAP */
 
 
 /*
  * DPM DiscoverCable reaction
  */
 
-#ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
+#if CONFIG_TCPC_VCONN_SUPPLY_MODE
 static uint8_t dpm_reaction_dynamic_vconn(struct pd_port *pd_port)
 {
 	pd_dpm_dynamic_enable_vconn(pd_port);
@@ -167,7 +157,7 @@ static uint8_t dpm_reaction_dynamic_vconn(struct pd_port *pd_port)
 }
 #endif	/* CONFIG_TCPC_VCONN_SUPPLY_MODE */
 
-#ifdef CONFIG_USB_PD_DISCOVER_CABLE_REQUEST_VCONN
+#if CONFIG_USB_PD_DISCOVER_CABLE_REQUEST_VCONN
 static uint8_t dpm_reaction_request_vconn_source(struct pd_port *pd_port)
 {
 	bool return_vconn = true;
@@ -178,7 +168,7 @@ static uint8_t dpm_reaction_request_vconn_source(struct pd_port *pd_port)
 	if (pd_port->vconn_role)
 		return 0;
 
-#ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
+#if CONFIG_TCPC_VCONN_SUPPLY_MODE
 	if (pd_port->tcpc->tcpc_vconn_supply == TCPC_VCONN_SUPPLY_STARTUP)
 		return_vconn = false;
 #endif	/* CONFIG_TCPC_VCONN_SUPPLY_MODE */
@@ -193,10 +183,10 @@ static uint8_t dpm_reaction_request_vconn_source(struct pd_port *pd_port)
 }
 #endif	/* CONFIG_USB_PD_DISCOVER_CABLE_REQUEST_VCONN */
 
-#ifdef CONFIG_USB_PD_DFP_READY_DISCOVER_ID
+#if CONFIG_USB_PD_DFP_READY_DISCOVER_ID
 static uint8_t pd_dpm_reaction_discover_cable(struct pd_port *pd_port)
 {
-#ifdef CONFIG_PD_DFP_RESET_CABLE
+#if CONFIG_PD_DFP_RESET_CABLE
 	if (pd_is_reset_cable(pd_port))
 		return TCP_DPM_EVT_CABLE_SOFTRESET;
 #endif	/* CONFIG_PD_DFP_RESET_CABLE */
@@ -210,7 +200,7 @@ static uint8_t pd_dpm_reaction_discover_cable(struct pd_port *pd_port)
 }
 #endif	/* CONFIG_USB_PD_DFP_READY_DISCOVER_ID */
 
-#ifdef CONFIG_USB_PD_DISCOVER_CABLE_RETURN_VCONN
+#if CONFIG_USB_PD_DISCOVER_CABLE_RETURN_VCONN
 static uint8_t dpm_reaction_return_vconn_source(struct pd_port *pd_port)
 {
 	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
@@ -228,21 +218,21 @@ static uint8_t dpm_reaction_return_vconn_source(struct pd_port *pd_port)
  * DPM EnterMode reaction
  */
 
-#ifdef CONFIG_USB_PD_ATTEMP_DISCOVER_ID
+#if CONFIG_USB_PD_ATTEMPT_DISCOVER_ID
 static uint8_t dpm_reaction_discover_id(struct pd_port *pd_port)
 {
 	return TCP_DPM_EVT_DISCOVER_ID;
 }
-#endif	/* CONFIG_USB_PD_ATTEMP_DISCOVER_ID */
+#endif	/* CONFIG_USB_PD_ATTEMPT_DISCOVER_ID */
 
-#ifdef CONFIG_USB_PD_ATTEMP_DISCOVER_SVID
+#if CONFIG_USB_PD_ATTEMPT_DISCOVER_SVID
 static uint8_t dpm_reaction_discover_svid(struct pd_port *pd_port)
 {
 	return TCP_DPM_EVT_DISCOVER_SVIDS;
 }
-#endif	/* CONFIG_USB_PD_ATTEMP_DISCOVER_SVID */
+#endif	/* CONFIG_USB_PD_ATTEMPT_DISCOVER_SVID */
 
-#ifdef CONFIG_USB_PD_MODE_OPERATION
+#if CONFIG_USB_PD_MODE_OPERATION
 static uint8_t dpm_reaction_mode_operation(struct pd_port *pd_port)
 {
 	if (svdm_notify_pe_ready(pd_port))
@@ -256,9 +246,9 @@ static uint8_t dpm_reaction_mode_operation(struct pd_port *pd_port)
  * DPM Local/Remote Alert reaction
  */
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 
-#ifdef CONFIG_USB_PD_DPM_AUTO_SEND_ALERT
+#if CONFIG_USB_PD_DPM_AUTO_SEND_ALERT
 
 static uint8_t dpm_reaction_send_alert(struct pd_port *pd_port)
 {
@@ -282,7 +272,7 @@ static uint8_t dpm_reaction_send_alert(struct pd_port *pd_port)
 
 #endif	/* CONFIG_USB_PD_DPM_AUTO_SEND_ALERT */
 
-#ifdef CONFIG_USB_PD_DPM_AUTO_GET_STATUS
+#if CONFIG_USB_PD_DPM_AUTO_GET_STATUS
 
 const uint32_t c_get_status_alert_type = ADO_ALERT_OCP|
 	ADO_ALERT_OTP|ADO_ALERT_OVP|ADO_ALERT_OPER_CHANGED|
@@ -383,7 +373,7 @@ static inline uint8_t dpm_get_pd_connect_state(struct pd_port *pd_port)
 
 static inline void dpm_check_vconn_highv_prot(struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_VCONN_SAFE5V_ONLY
+#if CONFIG_USB_PD_VCONN_SAFE5V_ONLY
 	struct tcpc_device *tcpc = pd_port->tcpc;
 	struct pe_data *pe_data = &pd_port->pe_data;
 	bool vconn_highv_prot = pd_port->request_v_new > 5000;
@@ -405,9 +395,6 @@ static uint8_t dpm_reaction_update_pe_ready(struct pd_port *pd_port)
 	if (!pd_port->pe_data.pe_ready) {
 		DPM_INFO("PE_READY\n");
 		pd_port->pe_data.pe_ready = true;
-#ifdef CONFIG_DUAL_ROLE_USB_INTF
-		dual_role_instance_changed(pd_port->tcpc->dr_usb);
-#endif /* CONFIG_DUAL_ROLE_USB_INTF */
 	}
 
 	state = dpm_get_pd_connect_state(pd_port);
@@ -416,7 +403,7 @@ static uint8_t dpm_reaction_update_pe_ready(struct pd_port *pd_port)
 	dpm_check_vconn_highv_prot(pd_port);
 	pd_dpm_dynamic_disable_vconn(pd_port);
 
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	pd_port->pe_data.pd_traffic_idle = true;
 	if (pd_check_rev30(pd_port) &&
 		(pd_port->power_role == PD_ROLE_SOURCE))
@@ -525,26 +512,26 @@ struct dpm_ready_reaction {
 
 static const struct dpm_ready_reaction dpm_reactions[] = {
 
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_DPM_AUTO_SEND_ALERT
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_DPM_AUTO_SEND_ALERT
 	DECL_DPM_REACTION_PD30(
 		DPM_REACTION_CAP_ALWAYS,
 		dpm_reaction_send_alert),
 #endif	/* CONFIG_USB_PD_DPM_AUTO_SEND_ALERT */
-#ifdef CONFIG_USB_PD_DPM_AUTO_GET_STATUS
+#if CONFIG_USB_PD_DPM_AUTO_GET_STATUS
 	DECL_DPM_REACTION_PD30(
 		DPM_REACTION_CAP_ALWAYS,
 		dpm_reaction_handle_alert),
 #endif	/* CONFIG_USB_PD_DPM_AUTO_GET_STATUS */
 #endif	/* CONFIG_USB_PD_REV30 */
 
-#ifdef CONFIG_USB_PD_DFP_FLOW_DELAY
+#if CONFIG_USB_PD_DFP_FLOW_DELAY
 	DECL_DPM_REACTION_DFP(
 		DPM_REACTION_DFP_FLOW_DELAY,
 		dpm_reaction_dfp_flow_delay),
 #endif	/* CONFIG_USB_PD_DFP_FLOW_DELAY */
 
-#ifdef CONFIG_USB_PD_UFP_FLOW_DELAY
+#if CONFIG_USB_PD_UFP_FLOW_DELAY
 	DECL_DPM_REACTION_UFP(
 		DPM_REACTION_UFP_FLOW_DELAY,
 		dpm_reaction_ufp_flow_delay),
@@ -560,69 +547,69 @@ static const struct dpm_ready_reaction dpm_reactions[] = {
 
 	DECL_DPM_REACTION_LIMITED_RETRIES(
 		DPM_REACTION_ATTEMPT_GET_FLAG,
-		dpm_reaction_attemp_get_flag),
+		dpm_reaction_attempt_get_flag),
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	DECL_DPM_REACTION_PD30_ONE_SHOT(
 		DPM_REACTION_GET_SOURCE_CAP_EXT,
 		dpm_reaction_get_source_cap_ext),
 #endif	/* CONFIG_USB_PD_REV30 */
 
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 	DECL_DPM_REACTION_CHECK_ONCE(
 		DPM_REACTION_REQUEST_PR_SWAP,
 		dpm_reaction_request_pr_swap),
 #endif	/* CONFIG_USB_PD_PR_SWAP */
 
-#ifdef CONFIG_USB_PD_DR_SWAP
+#if CONFIG_USB_PD_DR_SWAP
 	DECL_DPM_REACTION_CHECK_ONCE(
 		DPM_REACTION_REQUEST_DR_SWAP,
 		dpm_reaction_request_dr_swap),
 #endif	/* CONFIG_USB_PD_DR_SWAP */
 
-#ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
+#if CONFIG_TCPC_VCONN_SUPPLY_MODE
 	DECL_DPM_REACTION_DFP_PD30_CHECK_ONCE(
 		DPM_REACTION_DYNAMIC_VCONN,
 		dpm_reaction_dynamic_vconn),
 #endif	/* CONFIG_TCPC_VCONN_SUPPLY_MODE */
 
-#ifdef CONFIG_USB_PD_DISCOVER_CABLE_REQUEST_VCONN
+#if CONFIG_USB_PD_DISCOVER_CABLE_REQUEST_VCONN
 	DECL_DPM_REACTION_DFP_PD30_RUN_ONCE(
 		DPM_REACTION_REQUEST_VCONN_SRC,
 		dpm_reaction_request_vconn_source),
 #endif	/* CONFIG_USB_PD_DISCOVER_CABLE_REQUEST_VCONN */
 
-#ifdef CONFIG_USB_PD_VCONN_STABLE_DELAY
+#if CONFIG_USB_PD_VCONN_STABLE_DELAY
 	DECL_DPM_REACTION_DFP_PD30_CHECK_ONCE(
 		DPM_REACTION_VCONN_STABLE_DELAY,
 		dpm_reaction_vconn_stable_delay),
 #endif	/* CONFIG_USB_PD_VCONN_STABLE_DELAY */
 
-#ifdef CONFIG_USB_PD_DFP_READY_DISCOVER_ID
+#if CONFIG_USB_PD_DFP_READY_DISCOVER_ID
 	DECL_DPM_REACTION_DFP_PD30_CHECK_ONCE(
 		DPM_REACTION_DISCOVER_CABLE,
 		pd_dpm_reaction_discover_cable),
 #endif	/* CONFIG_USB_PD_DFP_READY_DISCOVER_ID */
 
-#ifdef CONFIG_USB_PD_DISCOVER_CABLE_RETURN_VCONN
+#if CONFIG_USB_PD_DISCOVER_CABLE_RETURN_VCONN
 	DECL_DPM_REACTION_DFP_PD30_RUN_ONCE(
 		DPM_REACTION_RETURN_VCONN_SRC,
 		dpm_reaction_return_vconn_source),
 #endif	/* CONFIG_USB_PD_DISCOVER_CABLE_RETURN_VCONN */
 
-#ifdef CONFIG_USB_PD_ATTEMP_DISCOVER_ID
+#if CONFIG_USB_PD_ATTEMPT_DISCOVER_ID
 	DECL_DPM_REACTION_DFP_PD30_LIMITED_RETRIES(
 		DPM_REACTION_DISCOVER_ID,
 		dpm_reaction_discover_id),
-#endif	/* CONFIG_USB_PD_ATTEMP_DISCOVER_ID */
+#endif	/* CONFIG_USB_PD_ATTEMPT_DISCOVER_ID */
 
-#ifdef CONFIG_USB_PD_ATTEMP_DISCOVER_SVID
+#if CONFIG_USB_PD_ATTEMPT_DISCOVER_SVID
 	DECL_DPM_REACTION_DFP_PD30_LIMITED_RETRIES(
 		DPM_REACTION_DISCOVER_SVID,
 		dpm_reaction_discover_svid),
-#endif	/* CONFIG_USB_PD_ATTEMP_DISCOVER_SVID */
+#endif	/* CONFIG_USB_PD_ATTEMPT_DISCOVER_SVID */
 
-#ifdef CONFIG_USB_PD_MODE_OPERATION
+#if CONFIG_USB_PD_MODE_OPERATION
 	DECL_DPM_REACTION_ALWAYS(
 		dpm_reaction_mode_operation),
 #endif	/* CONFIG_USB_PD_MODE_OPERATION */
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_dpm_uvdm.c b/drivers/misc/mediatek/typec/tcpc/pd_dpm_uvdm.c
index af67e52..81146b2 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_dpm_uvdm.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_dpm_uvdm.c
@@ -1,25 +1,17 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * PD Device Policy Manager for UVDM
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
+
 #include "inc/tcpci.h"
 #include "inc/pd_policy_engine.h"
 #include "inc/pd_dpm_core.h"
 #include "pd_dpm_prv.h"
 
-#ifdef CONFIG_USB_PD_RICHTEK_UVDM
+#if CONFIG_USB_PD_RICHTEK_UVDM
 
+#define NEVER 0
 bool richtek_dfp_notify_pe_startup(
 		struct pd_port *pd_port, struct svdm_svid_data *svid_data)
 {
@@ -40,7 +32,7 @@ int richtek_dfp_notify_pe_ready(
 	pd_port->richtek_init_done = true;
 	UVDM_INFO("%s\n", __func__);
 
-#if 0
+#if NEVER
 	pd_port->uvdm_cnt = 3;
 	pd_port->uvdm_wait_resp = true;
 
@@ -49,7 +41,7 @@ int richtek_dfp_notify_pe_ready(
 	pd_port->uvdm_data[2] = 0x44332211;
 
 	pd_put_tcp_vdm_event(pd_port, TCP_DPM_EVT_UVDM);
-#endif
+#endif /* NEVER */
 
 	return 1;
 }
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine.c b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine.c
old mode 100644
new mode 100755
index f738361..4ea7e62
--- a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine.c
@@ -1,16 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * Power Delivery Policy Engine Driver
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include "inc/pd_core.h"
@@ -27,7 +17,7 @@
 static const char *const pe_state_name[] = {
 
 /******************* Source *******************/
-#ifdef CONFIG_USB_PD_PE_SOURCE
+#if CONFIG_USB_PD_PE_SOURCE
 	"PE_SRC_STARTUP",
 	"PE_SRC_DISCOVERY",
 	"PE_SRC_SEND_CAPABILITIES",
@@ -45,8 +35,8 @@ static const char *const pe_state_name[] = {
 	"PE_SRC_SEND_SOFT_RESET",
 	"PE_SRC_SOFT_RESET",
 /* Source Startup Discover Cable */
-#ifdef CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
-#ifdef CONFIG_PD_SRC_RESET_CABLE
+#if CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
+#if CONFIG_PD_SRC_RESET_CABLE
 	"PE_SRC_CBL_SEND_SOFT_RESET",
 #endif	/* CONFIG_PD_SRC_RESET_CABLE */
 	"PE_SRC_VDM_IDENTITY_REQUEST",
@@ -54,32 +44,32 @@ static const char *const pe_state_name[] = {
 	"PE_SRC_VDM_IDENTITY_NAKED",
 #endif	/* PD_CAP_PE_SRC_STARTUP_DISCOVER_ID */
 /* Source for PD30 */
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	"PE_SRC_SEND_NOT_SUPPORTED",
 	"PE_SRC_NOT_SUPPORTED_RECEIVED",
 	"PE_SRC_CHUNK_RECEIVED",
-#ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
+#if CONFIG_USB_PD_REV30_ALERT_LOCAL
 	"PE_SRC_SEND_SOURCE_ALERT",
 #endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
+#if CONFIG_USB_PD_REV30_ALERT_REMOTE
 	"PE_SRC_SINK_ALERT_RECEIVED",
 #endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
 	"PE_SRC_GIVE_SOURCE_CAP_EXT",
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
 	"PE_SRC_GIVE_SOURCE_STATUS",
 #endif	/* CONFIG_USB_PD_REV30_STATUS_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_STATUS_REMOTE
 	"PE_SRC_GET_SINK_STATUS",
 #endif	/* CONFIG_USB_PD_REV30_STATUS_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_PPS_SOURCE
+#if CONFIG_USB_PD_REV30_PPS_SOURCE
 	"PE_SRC_GIVE_PPS_STATUS",
 #endif	/* CONFIG_USB_PD_REV30_PPS_SOURCE */
 #endif	/* CONFIG_USB_PD_REV30 */
 #endif	/* CONFIG_USB_PD_PE_SOURCE */
 /******************* Sink *******************/
-#ifdef CONFIG_USB_PD_PE_SINK
+#if CONFIG_USB_PD_PE_SINK
 	"PE_SNK_STARTUP",
 	"PE_SNK_DISCOVERY",
 	"PE_SNK_WAIT_FOR_CAPABILITIES",
@@ -94,32 +84,32 @@ static const char *const pe_state_name[] = {
 	"PE_SNK_SEND_SOFT_RESET",
 	"PE_SNK_SOFT_RESET",
 /* Sink for PD30 */
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	"PE_SNK_SEND_NOT_SUPPORTED",
 	"PE_SNK_NOT_SUPPORTED_RECEIVED",
 	"PE_SNK_CHUNK_RECEIVED",
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
+#if CONFIG_USB_PD_REV30_ALERT_REMOTE
 	"PE_SNK_SOURCE_ALERT_RECEIVED",
 #endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
+#if CONFIG_USB_PD_REV30_ALERT_LOCAL
 	"PE_SNK_SEND_SINK_ALERT",
 #endif	/* CONFIG_USB_PD_REV30_ALERT_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
 	"PE_SNK_GET_SOURCE_CAP_EXT",
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_STATUS_REMOTE
 	"PE_SNK_GET_SOURCE_STATUS",
 #endif	/* CONFIG_USB_PD_REV30_STATUS_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
 	"PE_SNK_GIVE_SINK_STATUS",
 #endif	/* CONFIG_USB_PD_REV30_STATUS_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	"PE_SNK_GET_PPS_STATUS",
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 #endif	/* CONFIG_USB_PD_REV30 */
 #endif	/* CONFIG_USB_PD_PE_SINK */
 /******************* DR_SWAP *******************/
-#ifdef CONFIG_USB_PD_DR_SWAP
+#if CONFIG_USB_PD_DR_SWAP
 /* DR_SWAP_DFP */
 	"PE_DRS_DFP_UFP_EVALUATE_DR_SWAP",
 	"PE_DRS_DFP_UFP_ACCEPT_DR_SWAP",
@@ -134,7 +124,7 @@ static const char *const pe_state_name[] = {
 	"PE_DRS_UFP_DFP_REJECT_DR_SWAP",
 #endif	/* CONFIG_USB_PD_DR_SWAP */
 /******************* PR_SWAP *******************/
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 /* PR_SWAP_SRC */
 	"PE_PRS_SRC_SNK_EVALUATE_PR_SWAP",
 	"PE_PRS_SRC_SNK_ACCEPT_PR_SWAP",
@@ -157,17 +147,17 @@ static const char *const pe_state_name[] = {
 	"PE_DR_SNK_GET_SINK_CAP",
 	"PE_DR_SNK_GIVE_SOURCE_CAP",
 /* get same role cap for PD30 */
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
 	"PE_DR_SNK_GIVE_SOURCE_CAP_EXT",
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
 	"PE_DR_SRC_GET_SOURCE_CAP_EXT",
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE */
 #endif	/* CONFIG_USB_PD_REV30 */
 #endif	/* CONFIG_USB_PD_PR_SWAP */
 /******************* VCONN_SWAP *******************/
-#ifdef CONFIG_USB_PD_VCONN_SWAP
+#if CONFIG_USB_PD_VCONN_SWAP
 	"PE_VCS_SEND_SWAP",
 	"PE_VCS_EVALUATE_SWAP",
 	"PE_VCS_ACCEPT_SWAP",
@@ -184,7 +174,7 @@ static const char *const pe_state_name[] = {
 	"PE_UFP_VDM_EVALUATE_MODE_ENTRY",
 	"PE_UFP_VDM_MODE_EXIT",
 	"PE_UFP_VDM_ATTENTION_REQUEST",
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 	"PE_UFP_VDM_DP_STATUS_UPDATE",
 	"PE_UFP_VDM_DP_CONFIGURE",
 #endif/* CONFIG_USB_PD_ALT_MODE */
@@ -207,11 +197,11 @@ static const char *const pe_state_name[] = {
 	"PE_DFP_VDM_MODE_EXIT_REQUEST",
 	"PE_DFP_VDM_MODE_EXIT_ACKED",
 	"PE_DFP_VDM_ATTENTION_REQUEST",
-#ifdef CONFIG_PD_DFP_RESET_CABLE
+#if CONFIG_PD_DFP_RESET_CABLE
 	"PE_DFP_CBL_SEND_SOFT_RESET",
 	"PE_DFP_CBL_SEND_CABLE_RESET",
 #endif	/* CONFIG_PD_DFP_RESET_CABLE */
-#ifdef CONFIG_USB_PD_ALT_MODE_DFP
+#if CONFIG_USB_PD_ALT_MODE_DFP
 	"PE_DFP_VDM_DP_STATUS_UPDATE_REQUEST",
 	"PE_DFP_VDM_DP_STATUS_UPDATE_ACKED",
 	"PE_DFP_VDM_DP_STATUS_UPDATE_NAKED",
@@ -220,7 +210,7 @@ static const char *const pe_state_name[] = {
 	"PE_DFP_VDM_DP_CONFIGURATION_NAKED",
 #endif/* CONFIG_USB_PD_ALT_MODE_DFP */
 /******************* UVDM & SVDM *******************/
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 	"PE_UFP_UVDM_RECV",
 	"PE_DFP_UVDM_SEND",
 	"PE_DFP_UVDM_ACKED",
@@ -228,56 +218,56 @@ static const char *const pe_state_name[] = {
 #endif/* CONFIG_USB_PD_CUSTOM_VDM */
 	"PE_UFP_VDM_SEND_NAK",
 /******************* PD30 Common *******************/
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
 	"PE_GET_BATTERY_CAP",
 #endif	/* CONFIG_USB_PD_REV30_BAT_CAP_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_BAT_CAP_LOCAL
+#if CONFIG_USB_PD_REV30_BAT_CAP_LOCAL
 	"PE_GIVE_BATTERY_CAP",
 #endif	/* CONFIG_USB_PD_REV30_BAT_CAP_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
 	"PE_GET_BATTERY_STATUS",
 #endif	/* CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL
 	"PE_GIVE_BATTERY_STATUS",
 #endif	/* CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
+#if CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
 	"PE_GET_MANUFACTURER_INFO",
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
 	"PE_GIVE_MANUFACTURER_INFO",
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
+#if CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
 	"PE_GET_COUNTRY_CODES",
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
+#if CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
 	"PE_GIVE_COUNTRY_CODES",
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
+#if CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
 	"PE_GET_COUNTRY_INFO",
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL
 	"PE_GIVE_COUNTRY_INFO",
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL */
 
 	"PE_VDM_NOT_SUPPORTED",
 #endif /* CONFIG_USB_PD_REV30 */
 /******************* Others *******************/
-#ifdef CONFIG_USB_PD_CUSTOM_DBGACC
+#if CONFIG_USB_PD_CUSTOM_DBGACC
 	"PE_DBG_READY",
 #endif/* CONFIG_USB_PD_CUSTOM_DBGACC */
-#ifdef CONFIG_USB_PD_RECV_HRESET_COUNTER
+#if CONFIG_USB_PD_RECV_HRESET_COUNTER
 	"PE_OVER_RECV_HRESET_LIMIT",
 #endif/* CONFIG_USB_PD_RECV_HRESET_COUNTER */
 	"PE_REJECT",
 	"PE_ERROR_RECOVERY",
-#ifdef CONFIG_USB_PD_ERROR_RECOVERY_ONCE
+#if CONFIG_USB_PD_ERROR_RECOVERY_ONCE
 	"PE_ERROR_RECOVERY_ONCE",
 #endif	/* CONFIG_USB_PD_ERROR_RECOVERY_ONCE */
 	"PE_BIST_TEST_DATA",
 	"PE_BIST_CARRIER_MODE_2",
 
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
+#if CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
 	"PE_UNEXPECTED_TX_WAIT",
 	"PE_SEND_SOFT_RESET_TX_WAIT",
 	"PE_RECV_SOFT_RESET_TX_WAIT",
@@ -293,7 +283,7 @@ static const char *const pe_state_name[] = {
 
 static const char *const pe_state_name[] = {
 /******************* Source *******************/
-#ifdef CONFIG_USB_PD_PE_SOURCE
+#if CONFIG_USB_PD_PE_SOURCE
 	"SRC_START",
 	"SRC_DISC",
 	"SRC_SEND_CAP",
@@ -311,8 +301,8 @@ static const char *const pe_state_name[] = {
 	"SRC_SEND_SRESET",
 	"SRC_SRESET",
 /* Source Startup Discover Cable */
-#ifdef CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
-#ifdef CONFIG_PD_SRC_RESET_CABLE
+#if CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
+#if CONFIG_PD_SRC_RESET_CABLE
 	"SRC_CBL_SEND_SRESET",
 #endif	/* CONFIG_PD_SRC_RESET_CABLE */
 	"SRC_VDM_ID_REQ",
@@ -320,32 +310,32 @@ static const char *const pe_state_name[] = {
 	"SRC_VDM_ID_NAK",
 #endif	/* PD_CAP_PE_SRC_STARTUP_DISCOVER_ID */
 /* Source for PD30 */
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	"SRC_NO_SUPP",
 	"SRC_NO_SUPP_RECV",
 	"SRC_CK_RECV",
-#ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
+#if CONFIG_USB_PD_REV30_ALERT_LOCAL
 	"SRC_ALERT",
 #endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
+#if CONFIG_USB_PD_REV30_ALERT_REMOTE
 	"SRC_RECV_ALERT",
 #endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
 	"SRC_GIVE_CAP_EXT",
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
 	"SRC_GIVE_STATUS",
 #endif	/* CONFIG_USB_PD_REV30_STATUS_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_STATUS_REMOTE
 	"SRC_GET_STATUS",
 #endif	/* CONFIG_USB_PD_REV30_STATUS_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_PPS_SOURCE
+#if CONFIG_USB_PD_REV30_PPS_SOURCE
 	"SRC_GIVE_PPS",
 #endif	/* CONFIG_USB_PD_REV30_PPS_SOURCE */
 #endif	/* CONFIG_USB_PD_REV30 */
 #endif	/* CONFIG_USB_PD_PE_SOURCE */
 /******************* Sink *******************/
-#ifdef CONFIG_USB_PD_PE_SINK
+#if CONFIG_USB_PD_PE_SINK
 /* Sink Init */
 	"SNK_START",
 	"SNK_DISC",
@@ -361,32 +351,32 @@ static const char *const pe_state_name[] = {
 	"SNK_SEND_SRESET",
 	"SNK_SRESET",
 /* Sink for PD30 */
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	"SNK_NO_SUPP",
 	"SNK_NO_SUPP_RECV",
 	"SNK_CK_RECV",
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
+#if CONFIG_USB_PD_REV30_ALERT_REMOTE
 	"SNK_RECV_ALERT",
 #endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
+#if CONFIG_USB_PD_REV30_ALERT_LOCAL
 	"SNK_ALERT",
 #endif	/* CONFIG_USB_PD_REV30_ALERT_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
 	"SNK_GET_CAP_EX",
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_STATUS_REMOTE
 	"SNK_GET_STATUS",
 #endif	/* CONFIG_USB_PD_REV30_STATUS_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
 	"SNK_GIVE_STATUS",
 #endif	/* CONFIG_USB_PD_REV30_STATUS_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	"SNK_GET_PPS",
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 #endif	/* CONFIG_USB_PD_REV30 */
 #endif	/* CONFIG_USB_PD_PE_SINK */
 /******************* DR_SWAP *******************/
-#ifdef CONFIG_USB_PD_DR_SWAP
+#if CONFIG_USB_PD_DR_SWAP
 /* DR_SWAP_DFP */
 	"D_DFP_EVA",
 	"D_DFP_ACCEPT",
@@ -401,7 +391,7 @@ static const char *const pe_state_name[] = {
 	"D_UFP_REJECT",
 #endif	/* CONFIG_USB_PD_DR_SWAP */
 /******************* PR_SWAP *******************/
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 /* PR_SWAP_SRC */
 	"P_SRC_EVA",
 	"P_SRC_ACCEPT",
@@ -425,17 +415,17 @@ static const char *const pe_state_name[] = {
 	"DR_SNK_GET_CAP",
 	"DR_SNK_GIVE_CAP",
 /* get same role cap for PD30 */
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
 	"DR_SNK_GIVE_CAP_EXT",
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
 	"DR_SRC_GET_CAP_EXT",
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE */
 #endif	/* CONFIG_USB_PD_REV30 */
 #endif	/* CONFIG_USB_PD_PR_SWAP */
 /******************* VCONN_SWAP *******************/
-#ifdef CONFIG_USB_PD_VCONN_SWAP
+#if CONFIG_USB_PD_VCONN_SWAP
 	"V_SEND",
 	"V_EVA",
 	"V_ACCEPT",
@@ -452,7 +442,7 @@ static const char *const pe_state_name[] = {
 	"U_EVA_MODE",
 	"U_MODE_EX",
 	"U_ATTENTION",
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 	"U_D_STATUS",
 	"U_D_CONFIG",
 #endif/* CONFIG_USB_PD_ALT_MODE */
@@ -475,11 +465,11 @@ static const char *const pe_state_name[] = {
 	"D_MODE_EX_REQ",
 	"D_MODE_EX_ACK",
 	"D_ATTENTION",
-#ifdef CONFIG_PD_DFP_RESET_CABLE
+#if CONFIG_PD_DFP_RESET_CABLE
 	"D_C_SRESET",
 	"D_C_CRESET",
 #endif	/* CONFIG_PD_DFP_RESET_CABLE */
-#ifdef CONFIG_USB_PD_ALT_MODE_DFP
+#if CONFIG_USB_PD_ALT_MODE_DFP
 	"D_DP_STATUS_REQ",
 	"D_DP_STATUS_ACK",
 	"D_DP_STATUS_NAK",
@@ -488,7 +478,7 @@ static const char *const pe_state_name[] = {
 	"D_DP_CONFIG_NAK",
 #endif/* CONFIG_USB_PD_ALT_MODE_DFP */
 /******************* UVDM & SVDM *******************/
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 	"U_UVDM_RECV",
 	"D_UVDM_SEND",
 	"D_UVDM_ACKED",
@@ -496,56 +486,56 @@ static const char *const pe_state_name[] = {
 #endif/* CONFIG_USB_PD_CUSTOM_VDM */
 	"U_SEND_NAK",
 /******************* PD30 Common *******************/
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
 	"GET_BAT_CAP",
 #endif	/* CONFIG_USB_PD_REV30_BAT_CAP_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_BAT_CAP_LOCAL
+#if CONFIG_USB_PD_REV30_BAT_CAP_LOCAL
 	"GIVE_BAT_CAP",
 #endif	/* CONFIG_USB_PD_REV30_BAT_CAP_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
 	"GET_BAT_STATUS",
 #endif	/* CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL
 	"GIVE_BAT_STATUS",
 #endif	/* CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
+#if CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
 	"GET_MFRS_INFO",
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
 	"GIVE_MFRS_INFO",
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
+#if CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
 	"GET_CC",
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
+#if CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
 	"GIVE_CC",
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
+#if CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
 	"GET_CI",
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL
 	"GIVE_CI",
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL */
 
 	"VDM_NO_SUPP",
 #endif /* CONFIG_USB_PD_REV30 */
 /******************* Others *******************/
-#ifdef CONFIG_USB_PD_CUSTOM_DBGACC
+#if CONFIG_USB_PD_CUSTOM_DBGACC
 	"DBG_READY",
 #endif/* CONFIG_USB_PD_CUSTOM_DBGACC */
-#ifdef CONFIG_USB_PD_RECV_HRESET_COUNTER
+#if CONFIG_USB_PD_RECV_HRESET_COUNTER
 	"OVER_HRESET_LIMIT",
 #endif/* CONFIG_USB_PD_RECV_HRESET_COUNTER */
 	"REJECT",
 	"ERR_RECOVERY",
-#ifdef CONFIG_USB_PD_ERROR_RECOVERY_ONCE
+#if CONFIG_USB_PD_ERROR_RECOVERY_ONCE
 	"ERR_RECOVERY1",
 #endif	/* CONFIG_USB_PD_ERROR_RECOVERY_ONCE */
 	"BIST_TD",
 	"BIST_C2",
 
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
+#if CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
 	"UNEXPECTED_TX",
 	"SEND_SRESET_TX",
 	"RECV_SRESET_TX",
@@ -571,7 +561,7 @@ struct pe_state_actions {
 
 static const struct pe_state_actions pe_state_actions[] = {
 /******************* Source *******************/
-#ifdef CONFIG_USB_PD_PE_SOURCE
+#if CONFIG_USB_PD_PE_SOURCE
 	PE_STATE_ACTIONS(pe_src_startup),
 	PE_STATE_ACTIONS(pe_src_discovery),
 	PE_STATE_ACTIONS(pe_src_send_capabilities),
@@ -589,8 +579,8 @@ static const struct pe_state_actions pe_state_actions[] = {
 	PE_STATE_ACTIONS(pe_src_send_soft_reset),
 	PE_STATE_ACTIONS(pe_src_soft_reset),
 /* Source Startup Discover Cable */
-#ifdef CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
-#ifdef CONFIG_PD_SRC_RESET_CABLE
+#if CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
+#if CONFIG_PD_SRC_RESET_CABLE
 	PE_STATE_ACTIONS(pe_src_cbl_send_soft_reset),
 #endif	/* CONFIG_PD_SRC_RESET_CABLE */
 	PE_STATE_ACTIONS(pe_src_vdm_identity_request),
@@ -598,32 +588,32 @@ static const struct pe_state_actions pe_state_actions[] = {
 	PE_STATE_ACTIONS(pe_src_vdm_identity_naked),
 #endif	/* PD_CAP_PE_SRC_STARTUP_DISCOVER_ID */
 /* Source for PD30 */
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	PE_STATE_ACTIONS(pe_src_send_not_supported),
 	PE_STATE_ACTIONS(pe_src_not_supported_received),
 	PE_STATE_ACTIONS(pe_src_chunk_received),
-#ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
+#if CONFIG_USB_PD_REV30_ALERT_LOCAL
 	PE_STATE_ACTIONS(pe_src_send_source_alert),
 #endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
+#if CONFIG_USB_PD_REV30_ALERT_REMOTE
 	PE_STATE_ACTIONS(pe_src_sink_alert_received),
 #endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
 	PE_STATE_ACTIONS(pe_src_give_source_cap_ext),
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
 	PE_STATE_ACTIONS(pe_src_give_source_status),
 #endif	/* CONFIG_USB_PD_REV30_STATUS_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_STATUS_REMOTE
 	PE_STATE_ACTIONS(pe_src_get_sink_status),
 #endif	/* CONFIG_USB_PD_REV30_STATUS_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_PPS_SOURCE
+#if CONFIG_USB_PD_REV30_PPS_SOURCE
 	PE_STATE_ACTIONS(pe_src_give_pps_status),
 #endif	/* CONFIG_USB_PD_REV30_PPS_SOURCE */
 #endif	/* CONFIG_USB_PD_REV30 */
 #endif	/* CONFIG_USB_PD_PE_SOURCE */
 /******************* Sink *******************/
-#ifdef CONFIG_USB_PD_PE_SINK
+#if CONFIG_USB_PD_PE_SINK
 /* Sink Init */
 	PE_STATE_ACTIONS(pe_snk_startup),
 	PE_STATE_ACTIONS(pe_snk_discovery),
@@ -639,32 +629,32 @@ static const struct pe_state_actions pe_state_actions[] = {
 	PE_STATE_ACTIONS(pe_snk_send_soft_reset),
 	PE_STATE_ACTIONS(pe_snk_soft_reset),
 /* Sink for PD30 */
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	PE_STATE_ACTIONS(pe_snk_send_not_supported),
 	PE_STATE_ACTIONS(pe_snk_not_supported_received),
 	PE_STATE_ACTIONS(pe_snk_chunk_received),
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
+#if CONFIG_USB_PD_REV30_ALERT_REMOTE
 	PE_STATE_ACTIONS(pe_snk_source_alert_received),
 #endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
+#if CONFIG_USB_PD_REV30_ALERT_LOCAL
 	PE_STATE_ACTIONS(pe_snk_send_sink_alert),
 #endif	/* CONFIG_USB_PD_REV30_ALERT_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
 	PE_STATE_ACTIONS(pe_snk_get_source_cap_ext),
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_STATUS_REMOTE
 	PE_STATE_ACTIONS(pe_snk_get_source_status),
 #endif	/* CONFIG_USB_PD_REV30_STATUS_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
 	PE_STATE_ACTIONS(pe_snk_give_sink_status),
 #endif	/* CONFIG_USB_PD_REV30_STATUS_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	PE_STATE_ACTIONS(pe_snk_get_pps_status),
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 #endif	/* CONFIG_USB_PD_REV30 */
 #endif	/* CONFIG_USB_PD_PE_SINK */
 /******************* DR_SWAP *******************/
-#ifdef CONFIG_USB_PD_DR_SWAP
+#if CONFIG_USB_PD_DR_SWAP
 /* DR_SWAP_DFP */
 	PE_STATE_ACTIONS(pe_drs_dfp_ufp_evaluate_dr_swap),
 	PE_STATE_ACTIONS(pe_drs_dfp_ufp_accept_dr_swap),
@@ -679,7 +669,7 @@ static const struct pe_state_actions pe_state_actions[] = {
 	PE_STATE_ACTIONS(pe_drs_ufp_dfp_reject_dr_swap),
 #endif	/* CONFIG_USB_PD_DR_SWAP */
 /******************* PR_SWAP *******************/
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 /* PR_SWAP_SRC */
 	PE_STATE_ACTIONS(pe_prs_src_snk_evaluate_pr_swap),
 	PE_STATE_ACTIONS(pe_prs_src_snk_accept_pr_swap),
@@ -703,17 +693,17 @@ static const struct pe_state_actions pe_state_actions[] = {
 	PE_STATE_ACTIONS(pe_dr_snk_get_sink_cap),
 	PE_STATE_ACTIONS(pe_dr_snk_give_source_cap),
 /* get same role cap for PD30 */
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
 	PE_STATE_ACTIONS(pe_dr_snk_give_source_cap_ext),
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
 	PE_STATE_ACTIONS(pe_dr_src_get_source_cap_ext),
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE */
 #endif	/* CONFIG_USB_PD_REV30 */
 #endif	/* CONFIG_USB_PD_PR_SWAP */
 /******************* VCONN_SWAP *******************/
-#ifdef CONFIG_USB_PD_VCONN_SWAP
+#if CONFIG_USB_PD_VCONN_SWAP
 	PE_STATE_ACTIONS(pe_vcs_send_swap),
 	PE_STATE_ACTIONS(pe_vcs_evaluate_swap),
 	PE_STATE_ACTIONS(pe_vcs_accept_swap),
@@ -730,7 +720,7 @@ static const struct pe_state_actions pe_state_actions[] = {
 	PE_STATE_ACTIONS(pe_ufp_vdm_evaluate_mode_entry),
 	PE_STATE_ACTIONS(pe_ufp_vdm_mode_exit),
 	PE_STATE_ACTIONS(pe_ufp_vdm_attention_request),
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 	PE_STATE_ACTIONS(pe_ufp_vdm_dp_status_update),
 	PE_STATE_ACTIONS(pe_ufp_vdm_dp_configure),
 #endif/* CONFIG_USB_PD_ALT_MODE */
@@ -753,11 +743,11 @@ static const struct pe_state_actions pe_state_actions[] = {
 	PE_STATE_ACTIONS(pe_dfp_vdm_mode_exit_request),
 	PE_STATE_ACTIONS(pe_dfp_vdm_mode_exit_acked),
 	PE_STATE_ACTIONS(pe_dfp_vdm_attention_request),
-#ifdef CONFIG_PD_DFP_RESET_CABLE
+#if CONFIG_PD_DFP_RESET_CABLE
 	PE_STATE_ACTIONS(pe_dfp_cbl_send_soft_reset),
 	PE_STATE_ACTIONS(pe_dfp_cbl_send_cable_reset),
 #endif	/* CONFIG_PD_DFP_RESET_CABLE */
-#ifdef CONFIG_USB_PD_ALT_MODE_DFP
+#if CONFIG_USB_PD_ALT_MODE_DFP
 	PE_STATE_ACTIONS(pe_dfp_vdm_dp_status_update_request),
 	PE_STATE_ACTIONS(pe_dfp_vdm_dp_status_update_acked),
 	PE_STATE_ACTIONS(pe_dfp_vdm_dp_status_update_naked),
@@ -766,7 +756,7 @@ static const struct pe_state_actions pe_state_actions[] = {
 	PE_STATE_ACTIONS(pe_dfp_vdm_dp_configuration_naked),
 #endif/* CONFIG_USB_PD_ALT_MODE_DFP */
 /******************* UVDM & SVDM *******************/
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 	PE_STATE_ACTIONS(pe_ufp_uvdm_recv),
 	PE_STATE_ACTIONS(pe_dfp_uvdm_send),
 	PE_STATE_ACTIONS(pe_dfp_uvdm_acked),
@@ -774,55 +764,55 @@ static const struct pe_state_actions pe_state_actions[] = {
 #endif/* CONFIG_USB_PD_CUSTOM_VDM */
 	PE_STATE_ACTIONS(pe_ufp_vdm_send_nak),
 /******************* PD30 Common *******************/
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
 	PE_STATE_ACTIONS(pe_get_battery_cap),
 #endif	/* CONFIG_USB_PD_REV30_BAT_CAP_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_BAT_CAP_LOCAL
+#if CONFIG_USB_PD_REV30_BAT_CAP_LOCAL
 	PE_STATE_ACTIONS(pe_give_battery_cap),
 #endif	/* CONFIG_USB_PD_REV30_BAT_CAP_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
 	PE_STATE_ACTIONS(pe_get_battery_status),
 #endif	/* CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL
 	PE_STATE_ACTIONS(pe_give_battery_status),
 #endif	/* CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
+#if CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
 	PE_STATE_ACTIONS(pe_get_manufacturer_info),
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
 	PE_STATE_ACTIONS(pe_give_manufacturer_info),
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
+#if CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
 	PE_STATE_ACTIONS(pe_get_country_codes),
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
+#if CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
 	PE_STATE_ACTIONS(pe_give_country_codes),
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL */
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
+#if CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
 	PE_STATE_ACTIONS(pe_get_country_info),
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE */
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL
 	PE_STATE_ACTIONS(pe_give_country_info),
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL */
 	PE_STATE_ACTIONS(pe_vdm_not_supported),
 #endif /* CONFIG_USB_PD_REV30 */
 /******************* Others *******************/
-#ifdef CONFIG_USB_PD_CUSTOM_DBGACC
+#if CONFIG_USB_PD_CUSTOM_DBGACC
 	PE_STATE_ACTIONS(pe_dbg_ready),
 #endif/* CONFIG_USB_PD_CUSTOM_DBGACC */
-#ifdef CONFIG_USB_PD_RECV_HRESET_COUNTER
+#if CONFIG_USB_PD_RECV_HRESET_COUNTER
 	PE_STATE_ACTIONS(pe_over_recv_hreset_limit),
 #endif/* CONFIG_USB_PD_RECV_HRESET_COUNTER */
 	PE_STATE_ACTIONS(pe_reject),
 	PE_STATE_ACTIONS(pe_error_recovery),
-#ifdef CONFIG_USB_PD_ERROR_RECOVERY_ONCE
+#if CONFIG_USB_PD_ERROR_RECOVERY_ONCE
 	PE_STATE_ACTIONS(pe_error_recovery_once),
 #endif	/* CONFIG_USB_PD_ERROR_RECOVERY_ONCE */
 	PE_STATE_ACTIONS(pe_bist_test_data),
 	PE_STATE_ACTIONS(pe_bist_carrier_mode_2),
 
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
+#if CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
 	PE_STATE_ACTIONS(pe_unexpected_tx_wait),
 	PE_STATE_ACTIONS(pe_send_soft_reset_tx_wait),
 	PE_STATE_ACTIONS(pe_recv_soft_reset_tx_wait),
@@ -842,15 +832,15 @@ void (*pe_get_exit_action(uint8_t pe_state))
 
 	switch (pe_state) {
 /******************* Source *******************/
-#ifdef CONFIG_USB_PD_PE_SOURCE
+#if CONFIG_USB_PD_PE_SOURCE
 	case PE_SRC_TRANSITION_TO_DEFAULT:
 		retval = pe_src_transition_to_default_exit;
 		break;
 	case PE_SRC_GET_SINK_CAP:
 		retval = pe_src_get_sink_cap_exit;
 		break;
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_STATUS_REMOTE
 	case PE_SRC_GET_SINK_STATUS:
 		retval = pe_src_get_sink_status_exit;
 		break;
@@ -859,25 +849,25 @@ void (*pe_get_exit_action(uint8_t pe_state))
 #endif	/* CONFIG_USB_PD_PE_SOURCE */
 
 /******************* Sink *******************/
-#ifdef CONFIG_USB_PD_PE_SINK
+#if CONFIG_USB_PD_PE_SINK
 	case PE_SNK_SELECT_CAPABILITY:
 		retval = pe_snk_select_capability_exit;
 		break;
 
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
 	case PE_SNK_GET_SOURCE_CAP_EXT:
 		retval = pe_snk_get_source_cap_ext_exit;
 		break;
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_STATUS_REMOTE
 	case PE_SNK_GET_SOURCE_STATUS:
 		retval = pe_snk_get_source_status_exit;
 		break;
 #endif	/* CONFIG_USB_PD_REV30_STATUS_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	case PE_SNK_GET_PPS_STATUS:
 		retval = pe_snk_get_pps_status_exit;
 		break;
@@ -887,7 +877,7 @@ void (*pe_get_exit_action(uint8_t pe_state))
 #endif	/* CONFIG_USB_PD_PE_SINK */
 
 /******************* PR_SWAP *******************/
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 	case PE_DR_SRC_GET_SOURCE_CAP:
 		retval = pe_dr_src_get_source_cap_exit;
 		break;
@@ -897,8 +887,8 @@ void (*pe_get_exit_action(uint8_t pe_state))
 		break;
 
 /* get same role cap for PD30 */
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
 	case PE_DR_SRC_GET_SOURCE_CAP_EXT:
 		retval = pe_dr_src_get_source_cap_ext_exit;
 		break;
@@ -907,33 +897,33 @@ void (*pe_get_exit_action(uint8_t pe_state))
 #endif	/* CONFIG_USB_PD_PR_SWAP */
 
 /******************* PD30 Common *******************/
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
 	case PE_GET_BATTERY_CAP:
 		retval = pe_get_battery_cap_exit;
 		break;
 #endif	/* CONFIG_USB_PD_REV30_BAT_CAP_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
 	case PE_GET_BATTERY_STATUS:
 		retval = pe_get_battery_status_exit;
 		break;
 #endif	/* CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
+#if CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
 	case PE_GET_MANUFACTURER_INFO:
 		retval = pe_get_manufacturer_info_exit;
 		break;
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE */
 
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
+#if CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
 	case PE_GET_COUNTRY_CODES:
 		retval = pe_get_country_codes_exit;
 		break;
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
+#if CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
 	case PE_GET_COUNTRY_INFO:
 		retval = pe_get_country_info_exit;
 		break;
@@ -952,7 +942,12 @@ void (*pe_get_exit_action(uint8_t pe_state))
 
 	return retval;
 }
-
+int pd_usb_connected = 0;
+int get_pd_usb_connected(void)
+{
+	return pd_usb_connected;
+}
+EXPORT_SYMBOL(get_pd_usb_connected);
 static inline void print_state(
 	struct pd_port *pd_port, uint8_t state)
 {
@@ -1000,6 +995,12 @@ static inline void pd_pe_state_change(
 		PD_BUG_ON(1);
 		return;
 	}
+	if (new_state >= PE_IDLE1)
+		pd_usb_connected = 0;
+	else if (new_state == PE_SNK_READY)
+		pd_usb_connected = 1;
+	else if (new_state == PE_SRC_READY)
+		pd_usb_connected = 2;
 
 	if (new_state < PE_IDLE1)
 		prev_exit_action = pe_get_exit_action(old_state);
@@ -1038,7 +1039,7 @@ static inline void pd_pe_state_change(
 		pd_port->pe_vdm_state = new_state;
 	else
 		pd_port->pe_pd_state = new_state;
-
+    PE_DBG("get ps current state %s\r\n", pe_state_name[new_state]);
 	pd_port->pe_state_curr = new_state;
 
 	/* Change RX cap first for compliance */
@@ -1091,13 +1092,13 @@ static inline bool pd_try_get_vdm_event(
 	struct pd_port *pd_port = &tcpc->pd_port;
 
 	switch (pd_port->pe_pd_state) {
-#ifdef CONFIG_USB_PD_PE_SINK
+#if CONFIG_USB_PD_PE_SINK
 	case PE_SNK_READY:
 		ret = pd_get_vdm_event(tcpc, pd_event);
 		break;
 #endif	/* CONFIG_USB_PD_PE_SINK */
 
-#ifdef CONFIG_USB_PD_PE_SOURCE
+#if CONFIG_USB_PD_PE_SOURCE
 	case PE_SRC_READY:
 		ret = pd_get_vdm_event(tcpc, pd_event);
 		break;
@@ -1108,14 +1109,14 @@ static inline bool pd_try_get_vdm_event(
 		ret = pd_get_vdm_event(tcpc, pd_event);
 		break;
 
-#ifdef CONFIG_PD_SRC_RESET_CABLE
+#if CONFIG_PD_SRC_RESET_CABLE
 	case PE_SRC_CBL_SEND_SOFT_RESET:
 		ret = pd_get_vdm_event(tcpc, pd_event);
 		break;
 #endif	/* CONFIG_PD_SRC_RESET_CABLE */
 #endif	/* CONFIG_USB_PD_PE_SOURCE */
 
-#ifdef CONFIG_USB_PD_CUSTOM_DBGACC
+#if CONFIG_USB_PD_CUSTOM_DBGACC
 	case PE_DBG_READY:
 		ret = pd_get_vdm_event(tcpc, pd_event);
 		break;
@@ -1130,11 +1131,11 @@ static inline bool pd_try_get_vdm_event(
 	return ret;
 }
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 
 static inline bool pd_check_sink_tx_ok(struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	if (pd_check_rev30(pd_port) &&
 		(pd_port->pe_data.pd_traffic_control != PD_SINK_TX_OK))
 		return false;
@@ -1145,7 +1146,7 @@ static inline bool pd_check_sink_tx_ok(struct pd_port *pd_port)
 
 static inline bool pd_check_source_tx_ok(struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	if (!pd_check_rev30(pd_port))
 		return true;
 
@@ -1163,17 +1164,17 @@ static inline bool pd_check_source_tx_ok(struct pd_port *pd_port)
 
 static inline bool pd_check_pd30_tx_ready(struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_PE_SINK
+#if CONFIG_USB_PD_PE_SINK
 	if (pd_port->pe_pd_state == PE_SNK_READY)
 		return pd_check_sink_tx_ok(pd_port);
 #endif	/* CONFIG_USB_PD_PE_SINK */
 
-#ifdef CONFIG_USB_PD_PE_SOURCE
+#if CONFIG_USB_PD_PE_SOURCE
 	if (pd_port->pe_pd_state == PE_SRC_READY)
 		return pd_check_source_tx_ok(pd_port);
 #endif	/* CONFIG_USB_PD_PE_SOURCE */
 
-#ifdef CONFIG_USB_PD_CUSTOM_DBGACC
+#if CONFIG_USB_PD_CUSTOM_DBGACC
 	if (pd_port->pe_pd_state == PE_DBG_READY)
 		return true;
 #endif	/* CONFIG_USB_PD_CUSTOM_DBGACC */
@@ -1184,17 +1185,17 @@ static inline bool pd_check_pd30_tx_ready(struct pd_port *pd_port)
 static inline bool pd_check_pd20_tx_ready(struct pd_port *pd_port)
 {
 	switch (pd_port->pe_pd_state) {
-#ifdef CONFIG_USB_PD_PE_SINK
+#if CONFIG_USB_PD_PE_SINK
 	case PE_SNK_READY:
 		return true;
 #endif	/* CONFIG_USB_PD_PE_SINK */
 
-#ifdef CONFIG_USB_PD_PE_SOURCE
+#if CONFIG_USB_PD_PE_SOURCE
 	case PE_SRC_READY:
 		return true;
 #endif	/* CONFIG_USB_PD_PE_SOURCE */
 
-#ifdef CONFIG_USB_PD_CUSTOM_DBGACC
+#if CONFIG_USB_PD_CUSTOM_DBGACC
 	case PE_DBG_READY:
 		return true;
 #endif	/* CONFIG_USB_PD_CUSTOM_DBGACC */
@@ -1224,7 +1225,7 @@ static inline bool pd_check_tx_ready(struct pd_port *pd_port)
 	if (pd_port->pe_data.vdm_state_timer)
 		return false;
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	return pd_check_pd30_tx_ready(pd_port);
 #else
 	return pd_check_pd20_tx_ready(pd_port);
@@ -1246,7 +1247,7 @@ static inline uint8_t pd_try_get_deferred_tcp_event(struct pd_port *pd_port)
 		pd_port->tcpc, &pd_port->tcp_event))
 		return DPM_READY_REACTION_BUSY;
 
-#ifdef CONFIG_USB_PD_TCPM_CB_2ND
+#if CONFIG_USB_PD_TCPM_CB_2ND
 	pd_port->tcp_event_drop_reset_once = true;
 #endif	/* CONFIG_USB_PD_TCPM_CB_2ND */
 
@@ -1275,7 +1276,7 @@ static inline uint8_t pd_try_get_active_event(
 	if (!pd_check_tx_ready(pd_port))
 		return PE_NEW_EVT_NULL;
 
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
+#if CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
 	if (pd_port->pe_data.pd_unexpected_event_pending) {
 		pd_port->pe_data.pd_unexpected_event_pending = false;
 		*pd_event = pd_port->pe_data.pd_unexpected_event;
@@ -1311,7 +1312,7 @@ static inline uint8_t pd_try_get_active_event(
 	if (ret >= TCP_DPM_EVT_VDM_COMMAND)
 		return PE_NEW_EVT_VDM;
 
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
+#if CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
 	pd_port->pe_data.pd_sent_ams_init_cmd = false;
 #endif	/* CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG */
 
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_com.c b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_com.c
index 4954cc9..00e3267 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_com.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_com.c
@@ -1,18 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * Power Delivery Policy Engine for Common
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 #include "inc/pd_core.h"
 #include "inc/pd_dpm_core.h"
 #include "inc/tcpci.h"
@@ -37,7 +28,7 @@ static void pe_idle_reset_data(struct pd_port *pd_port)
 
 	pd_enable_bist_test_mode(pd_port, false);
 
-#ifndef CONFIG_USB_PD_TRANSMIT_BIST2
+#if !CONFIG_USB_PD_TRANSMIT_BIST2
 	pd_disable_bist_mode2(pd_port);
 #endif	/* CONFIG_USB_PD_TRANSMIT_BIST2 */
 
@@ -48,7 +39,7 @@ static void pe_idle_reset_data(struct pd_port *pd_port)
 
 void pe_idle1_entry(struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_ERROR_RECOVERY_ONCE
+#if CONFIG_USB_PD_ERROR_RECOVERY_ONCE
 	pd_port->error_recovery_once = 0;
 #endif	/* CONFIG_USB_PD_ERROR_RECOVERY_ONCE */
 
@@ -74,7 +65,7 @@ void pe_reject_entry(struct pd_port *pd_port)
 
 void pe_error_recovery_entry(struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_ERROR_RECOVERY_ONCE
+#if CONFIG_USB_PD_ERROR_RECOVERY_ONCE
 	pd_port->error_recovery_once++;
 #endif	/* CONFIG_USB_PD_ERROR_RECOVERY_ONCE */
 
@@ -83,7 +74,7 @@ void pe_error_recovery_entry(struct pd_port *pd_port)
 	pd_try_put_pe_idle_event(pd_port);
 }
 
-#ifdef CONFIG_USB_PD_ERROR_RECOVERY_ONCE
+#if CONFIG_USB_PD_ERROR_RECOVERY_ONCE
 void pe_error_recovery_once_entry(struct pd_port *pd_port)
 {
 	uint8_t state = PD_CONNECT_TYPEC_ONLY_SNK_DFT;
@@ -100,7 +91,7 @@ void pe_error_recovery_once_entry(struct pd_port *pd_port)
 }
 #endif	/* CONFIG_USB_PD_ERROR_RECOVERY_ONCE */
 
-#ifdef CONFIG_USB_PD_RECV_HRESET_COUNTER
+#if CONFIG_USB_PD_RECV_HRESET_COUNTER
 void pe_over_recv_hreset_limit_entry(struct pd_port *pd_port)
 {
 	PE_INFO("OverHResetLimit++\n");
@@ -133,7 +124,7 @@ void pe_bist_carrier_mode_2_exit(struct pd_port *pd_port)
 	pd_disable_bist_mode2(pd_port);
 }
 
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
+#if CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
 void pe_unexpected_tx_wait_entry(struct pd_port *pd_port)
 {
 	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
@@ -182,7 +173,7 @@ static inline uint8_t pe30_power_ready_entry(struct pd_port *pd_port)
 	if (pd_port->vconn_role)
 		rx_cap = PD_RX_CAP_PE_READY_DFP;
 
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	dpm_reaction_clear(pd_port,
 		DPM_REACTION_DFP_FLOW_DELAY |
 		DPM_REACTION_UFP_FLOW_DELAY);
@@ -210,11 +201,11 @@ void pe_power_ready_entry(struct pd_port *pd_port)
 	pd_port->pe_data.during_swap = false;
 	pd_port->pe_data.explicit_contract = true;
 
-#ifdef CONFIG_USB_PD_RENEGOTIATION_COUNTER
+#if CONFIG_USB_PD_RENEGOTIATION_COUNTER
 	pd_port->pe_data.renegotiation_count = 0;
 #endif	/* CONFIG_USB_PD_RENEGOTIATION_COUNTER */
 
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
+#if CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
 	pd_port->pe_data.pd_sent_ams_init_cmd = true;
 #endif /* CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG */
 
@@ -229,13 +220,13 @@ void pe_power_ready_entry(struct pd_port *pd_port)
 	pd_notify_tcp_event_2nd_result(pd_port, TCP_DPM_RET_SUCCESS);
 }
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 
 /*
  * [PD3.0] Figure 8-85 Get Battery Capabilities State Diagram
  */
 
-#ifdef CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
+#if CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
 void pe_get_battery_cap_entry(struct pd_port *pd_port)
 {
 	struct pd_get_battery_capabilities *gbcdb =
@@ -256,7 +247,7 @@ void pe_get_battery_cap_exit(struct pd_port *pd_port)
  * [PD3.0] Figure 8-86 Give Battery Capabilities State Diagram
  */
 
-#ifdef CONFIG_USB_PD_REV30_BAT_CAP_LOCAL
+#if CONFIG_USB_PD_REV30_BAT_CAP_LOCAL
 void pe_give_battery_cap_entry(struct pd_port *pd_port)
 {
 	PE_STATE_WAIT_TX_SUCCESS(pd_port);
@@ -269,7 +260,7 @@ void pe_give_battery_cap_entry(struct pd_port *pd_port)
  * [PD3.0] Figure 8-87 Get Battery Status State Diagram
  */
 
-#ifdef CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
 void pe_get_battery_status_entry(struct pd_port *pd_port)
 {
 	struct pd_get_battery_status *gbsdb =
@@ -290,7 +281,7 @@ void pe_get_battery_status_exit(struct pd_port *pd_port)
  * [PD3.0] Figure 8-88 Give Battery Status State Diagram
  */
 
-#ifdef CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL
 void pe_give_battery_status_entry(struct pd_port *pd_port)
 {
 	PE_STATE_WAIT_TX_SUCCESS(pd_port);
@@ -303,7 +294,7 @@ void pe_give_battery_status_entry(struct pd_port *pd_port)
  * [PD3.0] Figure 8-89 Get Manufacturer Information State Diagram
  */
 
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
+#if CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
 
 void pe_get_manufacturer_info_entry(struct pd_port *pd_port)
 {
@@ -326,7 +317,7 @@ void pe_get_manufacturer_info_exit(struct pd_port *pd_port)
  * [PD3.0] Figure 8-90 Give Manufacturer Information State Diagram
  */
 
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
 
 void pe_give_manufacturer_info_entry(struct pd_port *pd_port)
 {
@@ -341,7 +332,7 @@ void pe_give_manufacturer_info_entry(struct pd_port *pd_port)
  * [PD3.0] Figure 8-91 Get Country Codes State Diagram
  */
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
+#if CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
 void pe_get_country_codes_entry(struct pd_port *pd_port)
 {
 	PE_STATE_WAIT_MSG(pd_port);
@@ -359,7 +350,7 @@ void pe_get_country_codes_exit(struct pd_port *pd_port)
  * [PD3.0] Figure 8-92 Give Country Codes State Diagram
  */
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
+#if CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
 void pe_give_country_codes_entry(struct pd_port *pd_port)
 {
 	PE_STATE_WAIT_TX_SUCCESS(pd_port);
@@ -372,7 +363,7 @@ void pe_give_country_codes_entry(struct pd_port *pd_port)
  * [PD3.0] Figure 8-93 Get Country Information State Diagram
  */
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
+#if CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
 void pe_get_country_info_entry(struct pd_port *pd_port)
 {
 	uint32_t *ccdo =
@@ -393,7 +384,7 @@ void pe_get_country_info_exit(struct pd_port *pd_port)
  * [PD3.0] Figure 8-94 Give Country Information State Diagram
  */
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_COUNTRY_INFO_LOCAL
 void pe_give_country_info_entry(struct pd_port *pd_port)
 {
 	PE_STATE_WAIT_TX_SUCCESS(pd_port);
@@ -414,3 +405,4 @@ void pe_vdm_not_supported_entry(struct pd_port *pd_port)
 }
 
 #endif	/* CONFIG_USB_PD_REV30 */
+#endif /* CONFIG_USB_POWER_DELIVERY */
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_dbg.c b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_dbg.c
index 768599b..e00131f 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_dbg.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_dbg.c
@@ -1,16 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * Power Delivery Policy Engine for DBGACC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include "inc/pd_core.h"
@@ -18,7 +8,7 @@
 #include "inc/tcpci.h"
 #include "inc/pd_policy_engine.h"
 
-#ifdef CONFIG_USB_PD_CUSTOM_DBGACC
+#if CONFIG_USB_PD_CUSTOM_DBGACC
 
 void pe_dbg_ready_entry(struct pd_port *pd_port)
 {
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_dfp.c b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_dfp.c
index 32b0d31..1d82dac 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_dfp.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_dfp.c
@@ -1,16 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * Power Delivery Policy Engine for DFP
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include "inc/pd_core.h"
@@ -143,7 +133,7 @@ void pe_dfp_vdm_attention_request_entry(struct pd_port *pd_port)
  * [PD2.0] Figure 8-83 DFP Cable Soft Reset or Cable Reset State Diagram
  */
 
-#ifdef CONFIG_PD_DFP_RESET_CABLE
+#if CONFIG_PD_DFP_RESET_CABLE
 
 void pe_dfp_cbl_send_soft_reset_entry(struct pd_port *pd_port)
 {
@@ -163,7 +153,7 @@ void pe_dfp_cbl_send_cable_reset_entry(struct pd_port *pd_port)
  * [PD2.0] Display Port
  */
 
-#ifdef CONFIG_USB_PD_ALT_MODE_DFP
+#if CONFIG_USB_PD_ALT_MODE_DFP
 
 void pe_dfp_vdm_dp_status_update_request_entry(struct pd_port *pd_port)
 {
@@ -201,7 +191,7 @@ void pe_dfp_vdm_dp_configuration_naked_entry(struct pd_port *pd_port)
  * UVDM
  */
 
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 
 void pe_dfp_uvdm_send_entry(struct pd_port *pd_port)
 {
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_dr.c b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_dr.c
index e4eb8bb..8431207 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_dr.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_dr.c
@@ -1,16 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * Power Delivery Policy Engine for DR
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include "inc/pd_core.h"
@@ -64,7 +54,7 @@ void pe_dr_snk_give_source_cap_entry(struct pd_port *pd_port)
 	pd_dpm_send_source_caps(pd_port);
 }
 
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
 void pe_dr_snk_give_source_cap_ext_entry(struct pd_port *pd_port)
 {
 	PE_STATE_WAIT_TX_SUCCESS(pd_port);
@@ -73,7 +63,7 @@ void pe_dr_snk_give_source_cap_ext_entry(struct pd_port *pd_port)
 }
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
 void pe_dr_src_get_source_cap_ext_entry(struct pd_port *pd_port)
 {
 	PE_STATE_WAIT_MSG(pd_port);
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_drs.c b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_drs.c
index ec22756..5586ad3 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_drs.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_drs.c
@@ -1,16 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * Power Delivery Policy Engine for DRS
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include "inc/pd_core.h"
@@ -63,7 +53,7 @@ void pe_drs_ufp_dfp_accept_dr_swap_entry(struct pd_port *pd_port)
 
 void pe_drs_ufp_dfp_change_to_dfp_entry(struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_RESET_CABLE
+#if CONFIG_USB_PD_RESET_CABLE
 	dpm_reaction_set(pd_port, DPM_REACTION_CAP_RESET_CABLE);
 #endif	/* CONFIG_USB_PD_RESET_CABLE */
 
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_prs.c b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_prs.c
index a888d68..0bdc249 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_prs.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_prs.c
@@ -1,16 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * Power Delivery Policy Engine for PRS
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include "inc/pd_core.h"
@@ -100,7 +90,7 @@ void pe_prs_snk_src_assert_rp_entry(struct pd_port *pd_port)
 
 void pe_prs_snk_src_source_on_entry(struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_RESET_CABLE
+#if CONFIG_USB_PD_RESET_CABLE
 	dpm_reaction_set(pd_port, DPM_REACTION_CAP_RESET_CABLE);
 #endif	/* CONFIG_USB_PD_RESET_CABLE */
 
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_snk.c b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_snk.c
index cab1839..3ff3f80 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_snk.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_snk.c
@@ -1,16 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * Power Delivery Policy Engine for SNK
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include "inc/pd_core.h"
@@ -27,7 +17,7 @@ void pe_snk_startup_entry(struct pd_port *pd_port)
 	uint8_t rx_cap = PD_RX_CAP_PE_STARTUP;
 	bool pr_swap = pd_port->state_machine == PE_STATE_MACHINE_PR_SWAP;
 
-#ifdef CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP
+#if CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP
 	uint8_t msg_id_last = pd_port->pe_data.msg_id_rx[TCPC_TX_SOP];
 #endif	/* CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP */
 
@@ -40,7 +30,7 @@ void pe_snk_startup_entry(struct pd_port *pd_port)
 		 */
 		rx_cap = PD_RX_CAP_PE_SEND_WAIT_CAP;
 
-#ifdef CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP
+#if CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP
 		pd_port->msg_id_pr_swap_last = msg_id_last;
 #endif	/* CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP */
 	}
@@ -63,7 +53,7 @@ void pe_snk_discovery_entry(struct pd_port *pd_port)
 void pe_snk_wait_for_capabilities_entry(
 				struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_SNK_HRESET_KEEP_DRAW
+#if CONFIG_USB_PD_SNK_HRESET_KEEP_DRAW
 	/* Default current draw after HardReset */
 	if (pd_check_pe_during_hard_reset(pd_port))
 		pd_dpm_sink_vbus(pd_port, true);
@@ -112,7 +102,7 @@ void pe_snk_select_capability_entry(struct pd_port *pd_port)
 
 void pe_snk_select_capability_exit(struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_RENEGOTIATION_COUNTER
+#if CONFIG_USB_PD_RENEGOTIATION_COUNTER
 	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 #endif /* CONFIG_USB_PD_RENEGOTIATION_COUNTER */
 
@@ -121,7 +111,7 @@ void pe_snk_select_capability_exit(struct pd_port *pd_port)
 					RDO_POS(pd_port->last_rdo);
 		pd_port->cap_miss_match = 0;
 	} else if (pd_check_ctrl_msg_event(pd_port, PD_CTRL_REJECT)) {
-#ifdef CONFIG_USB_PD_RENEGOTIATION_COUNTER
+#if CONFIG_USB_PD_RENEGOTIATION_COUNTER
 		if (pd_port->cap_miss_match == 0x01) {
 			PE_INFO("reset renegotiation cnt by cap mismatch\n");
 			pd_port->pe_data.renegotiation_count = 0;
@@ -140,7 +130,7 @@ void pe_snk_transition_sink_entry(struct pd_port *pd_port)
 {
 	pd_enable_pe_state_timer(pd_port, PD_TIMER_PS_TRANSITION);
 
-#ifdef CONFIG_USB_PD_SNK_GOTOMIN
+#if CONFIG_USB_PD_SNK_GOTOMIN
 	if (pd_check_ctrl_msg_event(pd_port, PD_CTRL_GOTO_MIN)) {
 		if (pd_port->dpm_caps & DPM_CAP_LOCAL_GIVE_BACK)
 			pd_port->request_i_new = pd_port->request_i_op;
@@ -179,7 +169,7 @@ void pe_snk_give_sink_cap_entry(struct pd_port *pd_port)
 
 void pe_snk_get_source_cap_entry(struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_TCPM_CB_2ND
+#if CONFIG_USB_PD_TCPM_CB_2ND
 	PE_STATE_WAIT_MSG(pd_port);
 #else
 	PE_STATE_WAIT_TX_SUCCESS(pd_port);
@@ -200,7 +190,7 @@ void pe_snk_soft_reset_entry(struct pd_port *pd_port)
 
 /* ---- Policy Engine (PD30) ---- */
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 
 /*
  * [PD3.0] Figure 8-71 Sink Port Not Supported Message State Diagram
@@ -229,7 +219,7 @@ void pe_snk_chunk_received_entry(struct pd_port *pd_port)
  * [PD3.0] Figure 8-74 Sink Port Source Alert State Diagram
  */
 
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
+#if CONFIG_USB_PD_REV30_ALERT_REMOTE
 void pe_snk_source_alert_received_entry(struct pd_port *pd_port)
 {
 	PE_STATE_DPM_INFORMED(pd_port);
@@ -242,7 +232,7 @@ void pe_snk_source_alert_received_entry(struct pd_port *pd_port)
  * [PD3.0] Figure 8-75 Sink Port Sink Alert State Diagram
  */
 
-#ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
+#if CONFIG_USB_PD_REV30_ALERT_LOCAL
 void pe_snk_send_sink_alert_entry(struct pd_port *pd_port)
 {
 	PE_STATE_WAIT_TX_SUCCESS(pd_port);
@@ -254,7 +244,7 @@ void pe_snk_send_sink_alert_entry(struct pd_port *pd_port)
  * [PD3.0] Figure 8-77 Sink Port Get Source Capabilities Extended State Diagram
  */
 
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
 void pe_snk_get_source_cap_ext_entry(struct pd_port *pd_port)
 {
 	PE_STATE_WAIT_MSG(pd_port);
@@ -272,7 +262,7 @@ void pe_snk_get_source_cap_ext_exit(struct pd_port *pd_port)
  * [PD3.0] Figure 8-79 Sink Port Get Source Status State Diagram
  */
 
-#ifdef CONFIG_USB_PD_REV30_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_STATUS_REMOTE
 void pe_snk_get_source_status_entry(struct pd_port *pd_port)
 {
 	PE_STATE_WAIT_MSG(pd_port);
@@ -290,7 +280,7 @@ void pe_snk_get_source_status_exit(struct pd_port *pd_port)
  * [PD3.0] Figure 8-82 Sink Give Sink Status State Diagram
  */
 
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
 void pe_snk_give_sink_status_entry(struct pd_port *pd_port)
 {
 	PE_STATE_WAIT_TX_SUCCESS(pd_port);
@@ -303,7 +293,7 @@ void pe_snk_give_sink_status_entry(struct pd_port *pd_port)
  * [PD3.0] Figure 8-83 Sink Port Get Source PPS Status State Diagram
  */
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 void pe_snk_get_pps_status_entry(struct pd_port *pd_port)
 {
 	PE_STATE_WAIT_MSG(pd_port);
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_src.c b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_src.c
index 2e1157d..27080d7 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_src.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_src.c
@@ -1,16 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * Power Delivery Policy Engine for SRC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include <linux/delay.h>
@@ -47,7 +37,7 @@ void pe_src_discovery_entry(struct pd_port *pd_port)
 
 	pd_enable_timer(pd_port, PD_TIMER_SOURCE_CAPABILITY);
 
-#ifdef CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
+#if CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
 	if (pd_is_discover_cable(pd_port))
 		pd_enable_timer(pd_port, PD_TIMER_DISCOVER_ID);
 #endif
@@ -168,9 +158,9 @@ void pe_src_soft_reset_entry(struct pd_port *pd_port)
  Source Startup Structured VDM Discover Identity State Diagram (TODO)
  */
 
-#ifdef CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
+#if CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
 
-#ifdef CONFIG_PD_SRC_RESET_CABLE
+#if CONFIG_PD_SRC_RESET_CABLE
 void pe_src_cbl_send_soft_reset_entry(struct pd_port *pd_port)
 {
 	PE_STATE_WAIT_RESPONSE(pd_port);
@@ -202,7 +192,7 @@ void pe_src_vdm_identity_naked_entry(struct pd_port *pd_port)
 #endif	/* CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID */
 
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 
 /*
  * [PD3.0] Source Port Not Supported Message State Diagram
@@ -231,7 +221,7 @@ void pe_src_chunk_received_entry(struct pd_port *pd_port)
  * [PD3.0] Figure 8-73 Source Port Source Alert State Diagram
  */
 
-#ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
+#if CONFIG_USB_PD_REV30_ALERT_LOCAL
 void pe_src_send_source_alert_entry(struct pd_port *pd_port)
 {
 	PE_STATE_WAIT_TX_SUCCESS(pd_port);
@@ -243,7 +233,7 @@ void pe_src_send_source_alert_entry(struct pd_port *pd_port)
  * [PD3.0] Figure 8-76 Source Port Sink Alert State Diagram
  */
 
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
+#if CONFIG_USB_PD_REV30_ALERT_REMOTE
 void pe_src_sink_alert_received_entry(struct pd_port *pd_port)
 {
 	PE_STATE_DPM_INFORMED(pd_port);
@@ -256,7 +246,7 @@ void pe_src_sink_alert_received_entry(struct pd_port *pd_port)
  * [PD3.0] Figure 8-78 Source Give Source Capabilities Extended State Diagram
  */
 
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
 void pe_src_give_source_cap_ext_entry(struct pd_port *pd_port)
 {
 	PE_STATE_WAIT_TX_SUCCESS(pd_port);
@@ -269,7 +259,7 @@ void pe_src_give_source_cap_ext_entry(struct pd_port *pd_port)
  * [PD3.0] Figure 8-80 Source Give Source Status State Diagram
  */
 
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
 void pe_src_give_source_status_entry(struct pd_port *pd_port)
 {
 	PE_STATE_WAIT_TX_SUCCESS(pd_port);
@@ -282,7 +272,7 @@ void pe_src_give_source_status_entry(struct pd_port *pd_port)
  * [PD3.0] Figure 8-81 Source Port Get Sink Status State Diagram
  */
 
-#ifdef CONFIG_USB_PD_REV30_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_STATUS_REMOTE
 void pe_src_get_sink_status_entry(struct pd_port *pd_port)
 {
 	PE_STATE_WAIT_MSG(pd_port);
@@ -299,7 +289,7 @@ void pe_src_get_sink_status_exit(struct pd_port *pd_port)
  * [PD3.0] Figure 8-84 Source Give Source PPS Status State Diagram
  */
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SOURCE
+#if CONFIG_USB_PD_REV30_PPS_SOURCE
 void pe_src_give_pps_status_entry(struct pd_port *pd_port)
 {
 	PE_STATE_WAIT_TX_SUCCESS(pd_port);
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_ufp.c b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_ufp.c
index d1699ba..d42ffed 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_ufp.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_ufp.c
@@ -1,16 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * Power Delivery Policy Engine for UFP
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include "inc/pd_core.h"
@@ -74,7 +64,7 @@ void pe_ufp_vdm_attention_request_entry(
 	VDM_STATE_NORESP_CMD(pd_port);
 
 	switch (pd_port->mode_svid) {
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 	case USB_SID_DISPLAYPORT:
 		pd_dpm_ufp_send_dp_attention(pd_port);
 		break;
@@ -90,7 +80,7 @@ void pe_ufp_vdm_attention_request_entry(
  * ALT Mode
  */
 
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 
 void pe_ufp_vdm_dp_status_update_entry(struct pd_port *pd_port)
 {
@@ -108,7 +98,7 @@ void pe_ufp_vdm_dp_configure_entry(struct pd_port *pd_port)
  * SVMD/UVDM
  */
 
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 
 void pe_ufp_uvdm_recv_entry(struct pd_port *pd_port)
 {
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_vcs.c b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_vcs.c
index a0a91cb..70017b2 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_vcs.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_vcs.c
@@ -1,18 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * Power Delivery Policy Engine for VCS
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
-
 #include "inc/pd_core.h"
 #include "inc/pd_dpm_core.h"
 #include "inc/tcpci.h"
@@ -55,8 +44,8 @@ void pe_vcs_turn_off_vconn_entry(struct pd_port *pd_port)
 
 void pe_vcs_turn_on_vconn_entry(struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_RESET_CABLE
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_RESET_CABLE
 	dpm_reaction_set(pd_port, DPM_REACTION_CAP_RESET_CABLE);
 #endif	/* CONFIG_USB_PD_RESET_CABLE */
 #endif	/* CONFIG_USB_PD_REV30 */
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_process_evt.c b/drivers/misc/mediatek/typec/tcpc/pd_process_evt.c
index fccad95..f0bc626 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_process_evt.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_process_evt.c
@@ -1,16 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * Power Delivery Process Event
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include "inc/pd_core.h"
@@ -40,7 +30,7 @@ static const char * const pd_ctrl_msg_name[] = {
 	"soft_reset",
 	"ctrlE",
 	"ctrlF",
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	"no_support",
 	"get_src_cap_ex",
 	"get_status",
@@ -62,7 +52,7 @@ static const char * const pd_data_msg_name[] = {
 	"request",
 	"bist",
 	"sink_cap",
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	"bat_status",
 	"alert",
 	"get_ci",
@@ -87,7 +77,7 @@ static inline void print_data_msg_event(struct tcpc_device *tcpc, uint8_t msg)
 		PE_EVT_INFO("%s\n", pd_data_msg_name[msg]);
 }
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 
 static const char *const pd_ext_msg_name[] = {
 	"ext0",
@@ -127,7 +117,7 @@ static const char *const pd_hw_msg_name[] = {
 	"discard",
 	"retry_vdm",
 
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	"sink_tx_change",
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
 };
@@ -188,7 +178,7 @@ static const char *const tcp_dpm_evt_name[] = {
 	"bist_cm2",
 	"dummy",
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	"get_src_cap_ext",
 	"get_status",
 	"fr_swap_snk",
@@ -212,15 +202,15 @@ static const char *const tcp_dpm_evt_name[] = {
 	"exit_mode",
 	"attention",
 
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 	"dp_atten",
-#ifdef CONFIG_USB_PD_ALT_MODE_DFP
+#if CONFIG_USB_PD_ALT_MODE_DFP
 	"dp_status",
 	"dp_config",
 #endif	/* CONFIG_USB_PD_ALT_MODE_DFP */
 #endif	/* CONFIG_USB_PD_ALT_MODE */
 
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 	"uvdm",
 #endif	/* CONFIG_USB_PD_CUSTOM_VDM */
 
@@ -253,7 +243,7 @@ static inline void print_event(
 		print_data_msg_event(tcpc, pd_event->msg);
 		break;
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	case PD_EVT_EXT_MSG:
 		print_ext_msg_event(tcpc, pd_event->msg);
 		break;
@@ -306,7 +296,7 @@ bool pd_make_pe_state_transit(struct pd_port *pd_port,
 
 static inline bool pd_process_ready_protocol_error(struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	bool multi_chunk;
 #endif	/* CONFIG_USB_PD_REV30 */
 
@@ -320,7 +310,7 @@ static inline bool pd_process_ready_protocol_error(struct pd_port *pd_port)
 		return true;
 	}
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	multi_chunk = pd_is_multi_chunk_msg(pd_port);
 
 	if (pd_port->power_role == PD_ROLE_SINK) {
@@ -337,12 +327,12 @@ static inline bool pd_process_ready_protocol_error(struct pd_port *pd_port)
 #endif	/* CONFIG_USB_PD_REV30 */
 }
 
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
+#if CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
 
 static inline bool pd_process_unexpected_alert(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
+#if CONFIG_USB_PD_REV30_ALERT_REMOTE
 	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (pd_event->event_type == PD_EVT_DATA_MSG ||
@@ -424,9 +414,9 @@ bool pd_process_protocol_error(
 
 	switch (pd_port->pe_state_curr) {
 	case PE_SNK_TRANSITION_SINK:
-		/* fall through */
+		fallthrough;
 	case PE_SRC_TRANSITION_SUPPLY:	/* never recv ping for Source =.=*/
-		/* fall through */
+		fallthrough;
 	case PE_SRC_TRANSITION_SUPPLY2:
 		power_change = true;
 		if (pd_event_msg_match(pd_event,
@@ -436,7 +426,7 @@ bool pd_process_protocol_error(
 		}
 		break;
 
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 	case PE_PRS_SRC_SNK_WAIT_SOURCE_ON:
 #endif	/* CONFIG_USB_PD_PR_SWAP */
 		if (pd_event_msg_match(pd_event,
@@ -458,7 +448,7 @@ bool pd_process_protocol_error(
 	ret = true;
 
 	if (pd_port->pe_data.during_swap) {
-#ifdef CONFIG_USB_PD_PR_SWAP_ERROR_RECOVERY
+#if CONFIG_USB_PD_PR_SWAP_ERROR_RECOVERY
 		PE_TRANSIT_STATE(pd_port, PE_ERROR_RECOVERY);
 #else
 		pe_transit_hard_reset_state(pd_port);
@@ -466,7 +456,7 @@ bool pd_process_protocol_error(
 	} else if (power_change)
 		pe_transit_hard_reset_state(pd_port);
 	else {
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
+#if CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
 		if (!pd_process_unexpected_message(pd_port, pd_event))
 			return false;
 #else
@@ -493,7 +483,7 @@ bool pd_process_tx_failed_discard(struct pd_port *pd_port, uint8_t msg)
 		return false;
 	}
 
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
+#if CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
 	if (msg == PD_HW_TX_DISCARD &&
 		(tcpc->tcpc_flags & TCPC_FLAGS_RETRY_CRC_DISCARD)) {
 
@@ -515,18 +505,18 @@ bool pd_process_tx_failed_discard(struct pd_port *pd_port, uint8_t msg)
 
 /*---------------------------------------------------------------------------*/
 
-#ifdef CONFIG_USB_PD_RESET_CABLE
+#if CONFIG_USB_PD_RESET_CABLE
 static inline bool pd_process_cable_ctrl_msg_accept(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
 	switch (pd_port->pe_state_curr) {
-#ifdef CONFIG_PD_SRC_RESET_CABLE
+#if CONFIG_PD_SRC_RESET_CABLE
 	case PE_SRC_CBL_SEND_SOFT_RESET:
 		vdm_put_dpm_discover_cable_event(pd_port);
 		return false;
 #endif	/* CONFIG_PD_SRC_RESET_CABLE */
 
-#ifdef CONFIG_PD_DFP_RESET_CABLE
+#if CONFIG_PD_DFP_RESET_CABLE
 	case PE_DFP_CBL_SEND_SOFT_RESET:
 		pe_transit_ready_state(pd_port);
 		return true;
@@ -543,7 +533,7 @@ static inline bool pd_process_event_cable(
 	bool ret = false;
 	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
-#ifdef CONFIG_USB_PD_RESET_CABLE
+#if CONFIG_USB_PD_RESET_CABLE
 	if (pd_event->msg == PD_CTRL_ACCEPT)
 		ret = pd_process_cable_ctrl_msg_accept(pd_port, pd_event);
 #endif	/* CONFIG_USB_PD_RESET_CABLE */
@@ -564,7 +554,7 @@ static void pd_copy_msg_data(struct pd_port *pd_port,
 	pd_port->pd_msg_data_payload = payload;
 }
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 static inline void pd_copy_msg_data_from_ext_evt(
 	struct pd_port *pd_port, struct pd_msg *pd_msg)
 {
@@ -591,7 +581,7 @@ static inline void pd_copy_msg_data_from_evt(
 			pd_get_msg_hdr_cnt(pd_port), sizeof(uint32_t));
 		break;
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	case PD_EVT_EXT_MSG:
 		PD_BUG_ON(pd_msg == NULL);
 		pd_copy_msg_data_from_ext_evt(pd_port, pd_msg);
@@ -636,7 +626,7 @@ static inline bool pe_is_valid_pd_msg_id(struct pd_port *pd_port,
 			PE_DBG("Discard_CRC\n");
 			return true;
 
-#ifdef CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP
+#if CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP
 		case PD_CTRL_PS_RDY:
 			if (pd_port->msg_id_pr_swap_last == msg_id) {
 				PE_INFO("Repeat ps_rdy\n");
@@ -692,7 +682,7 @@ static inline bool pe_is_valid_pd_msg_role(struct pd_port *pd_port,
 	 */
 
 	if (msg_dr == pd_port->data_role) {
-#ifdef CONFIG_USB_PD_CHECK_DATA_ROLE
+#if CONFIG_USB_PD_CHECK_DATA_ROLE
 		ret = false;
 #endif
 		PE_INFO("Wrong DR:%d\n", msg_dr);
@@ -717,7 +707,7 @@ static inline void pe_translate_pd_msg_event(struct pd_port *pd_port,
 	else
 		pd_event->event_type = PD_EVT_CTRL_MSG;
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	if (PD_HEADER_EXT(msg_hdr))
 		pd_event->event_type = PD_EVT_EXT_MSG;
 
@@ -734,13 +724,13 @@ static inline uint8_t pe_get_startup_state(
 	bool act_as_sink = true;
 	uint8_t startup_state = 0xff;
 
-#ifdef CONFIG_USB_PD_CUSTOM_DBGACC
+#if CONFIG_USB_PD_CUSTOM_DBGACC
 	pd_port->custom_dbgacc = false;
 #endif	/* CONFIG_USB_PD_CUSTOM_DBGACC */
 
 	switch (pd_event->msg_sec) {
 	case TYPEC_ATTACHED_DBGACC_SNK:
-#ifdef CONFIG_USB_PD_CUSTOM_DBGACC
+#if CONFIG_USB_PD_CUSTOM_DBGACC
 		pd_port->custom_dbgacc = true;
 		startup_state = PE_DBG_READY;
 		break;
@@ -756,7 +746,7 @@ static inline uint8_t pe_get_startup_state(
 	}
 
 	/* At least > 4 for Ellisys VNDI PR_SWAP */
-#ifdef CONFIG_USB_PD_ERROR_RECOVERY_ONCE
+#if CONFIG_USB_PD_ERROR_RECOVERY_ONCE
 	if (pd_port->error_recovery_once > 4)
 		startup_state = PE_ERROR_RECOVERY_ONCE;
 #endif	/* CONFIG_USB_PD_ERROR_RECOVERY_ONCE */
@@ -840,7 +830,7 @@ static inline void pe_init_curr_state(struct pd_port *pd_port)
 
 	pd_port->curr_unsupported_msg = false;
 
-#ifdef CONFIG_USB_PD_CUSTOM_DBGACC
+#if CONFIG_USB_PD_CUSTOM_DBGACC
 	if (pd_port->custom_dbgacc)
 		pd_port->curr_ready_state = PE_DBG_READY;
 #endif	/* CONFIG_USB_PD_CUSTOM_DBGACC */
@@ -885,7 +875,7 @@ bool pd_process_event(
 	if (pd_event->event_type == PD_EVT_TCP_MSG)
 		return pd_process_event_tcp(pd_port, pd_event);
 
-#ifdef CONFIG_USB_PD_CUSTOM_DBGACC
+#if CONFIG_USB_PD_CUSTOM_DBGACC
 	if (pd_port->custom_dbgacc)
 		return pd_process_event_dbg(pd_port, pd_event);
 #endif	/* CONFIG_USB_PD_CUSTOM_DBGACC */
@@ -899,19 +889,19 @@ bool pd_process_event(
 		return true;
 
 	switch (pd_port->state_machine) {
-#ifdef CONFIG_USB_PD_DR_SWAP
+#if CONFIG_USB_PD_DR_SWAP
 	case PE_STATE_MACHINE_DR_SWAP:
 		ret = pd_process_event_drs(pd_port, pd_event);
 		break;
 #endif	/* CONFIG_USB_PD_DR_SWAP */
 
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 	case PE_STATE_MACHINE_PR_SWAP:
 		ret = pd_process_event_prs(pd_port, pd_event);
 		break;
 #endif	/* CONFIG_USB_PD_PR_SWAP */
 
-#ifdef CONFIG_USB_PD_VCONN_SWAP
+#if CONFIG_USB_PD_VCONN_SWAP
 	case PE_STATE_MACHINE_VCONN_SWAP:
 		ret = pd_process_event_vcs(pd_port, pd_event);
 		break;
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_com.c b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_com.c
index ea70dea..88c0c55 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_com.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_com.c
@@ -1,28 +1,20 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * Power Delivery Policy Engine for Common
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 #include "inc/pd_core.h"
 #include "inc/tcpci_event.h"
 #include "inc/pd_process_evt.h"
 #include "inc/pd_dpm_core.h"
 
+#define NEVER 0
 /*
  * [BLOCK] DRP (dr_swap, pr_swap, vconn_swap)
  */
 
-#ifdef CONFIG_USB_PD_DR_SWAP
+#if CONFIG_USB_PD_DR_SWAP
 static inline bool pd_evaluate_reject_dr_swap(struct pd_port *pd_port)
 {
 	if (pd_port->dpm_caps & DPM_CAP_LOCAL_DR_DATA) {
@@ -36,7 +28,7 @@ static inline bool pd_evaluate_reject_dr_swap(struct pd_port *pd_port)
 }
 #endif	/* CONFIG_USB_PD_DR_SWAP */
 
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 static inline bool pd_evaluate_reject_pr_swap(struct pd_port *pd_port)
 {
 	if (pd_port->dpm_caps & DPM_CAP_LOCAL_DR_POWER) {
@@ -50,7 +42,7 @@ static inline bool pd_evaluate_reject_pr_swap(struct pd_port *pd_port)
 }
 #endif	/* CONFIG_USB_PD_PR_SWAP */
 
-#ifdef CONFIG_USB_PD_VCONN_SWAP
+#if CONFIG_USB_PD_VCONN_SWAP
 static inline bool pd_evaluate_accept_vconn_swap(struct pd_port *pd_port)
 {
 	if (pd_port->dpm_caps & DPM_CAP_LOCAL_VCONN_SUPPLY)
@@ -68,7 +60,7 @@ static inline bool pd_process_ctrl_msg_dr_swap(
 		return true;
 	}
 
-#ifdef CONFIG_USB_PD_DR_SWAP
+#if CONFIG_USB_PD_DR_SWAP
 	if (!pd_check_pe_state_ready(pd_port))
 		return false;
 
@@ -90,7 +82,7 @@ static inline bool pd_process_ctrl_msg_dr_swap(
 static inline bool pd_process_ctrl_msg_pr_swap(
 		struct pd_port *pd_port, struct pd_event *pd_event)
 {
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 	if (!pd_evaluate_reject_pr_swap(pd_port)) {
 		pd_port->pe_data.during_swap = false;
 		pd_port->state_machine = PE_STATE_MACHINE_PR_SWAP;
@@ -106,7 +98,7 @@ static inline bool pd_process_ctrl_msg_pr_swap(
 static inline bool pd_process_ctrl_msg_vconn_swap(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
-#ifdef CONFIG_USB_PD_VCONN_SWAP
+#if CONFIG_USB_PD_VCONN_SWAP
 	if (!pd_check_pe_state_ready(pd_port))
 		return false;
 
@@ -153,7 +145,7 @@ static inline bool pd_process_data_msg_bist(
 		return true;
 
 	default:
-#if 0
+#if NEVER
 	case BDO_MODE_RECV:
 	case BDO_MODE_TRANSMIT:
 	case BDO_MODE_COUNTERS:
@@ -161,7 +153,7 @@ static inline bool pd_process_data_msg_bist(
 	case BDO_MODE_CARRIER1:
 	case BDO_MODE_CARRIER3:
 	case BDO_MODE_EYE:
-#endif
+#endif /* NEVER */
 		PE_DBG("Unsupport BIST\n");
 		pd_noitfy_pe_bist_mode(pd_port, PD_BIST_MODE_DISABLE);
 		return false;
@@ -199,7 +191,7 @@ static inline bool pd_process_ctrl_msg_wait(struct pd_port *pd_port)
 
 static bool pd_process_tx_msg(struct pd_port *pd_port, uint8_t msg)
 {
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
+#if CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
 	if (msg != PD_HW_TX_DISCARD)
 		pd_port->pe_data.pd_sent_ams_init_cmd = true;
 
@@ -245,7 +237,7 @@ static inline bool pd_process_ctrl_msg(
 {
 	bool ret = false;
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	if (!pd_check_rev30(pd_port) &&
 		pd_event->msg >= PD_CTRL_PD30_START) {
 		pd_event->msg = PD_CTRL_MSG_NR;
@@ -279,7 +271,7 @@ static inline bool pd_process_ctrl_msg(
 		if (!pd_port->pe_data.during_swap &&
 			!pd_check_pe_during_hard_reset(pd_port)) {
 
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
+#if CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
 			if (pd_is_pe_wait_pd_transmit_done(pd_port)) {
 				PE_TRANSIT_STATE(pd_port,
 						 PE_RECV_SOFT_RESET_TX_WAIT);
@@ -305,9 +297,9 @@ static inline bool pd_process_ctrl_msg(
 		ret = pd_process_ctrl_msg_vconn_swap(pd_port, pd_event);
 		break;
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
+#if CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
 	case PD_CTRL_GET_COUNTRY_CODE:
 		if (pd_port->country_nr) {
 			ret = PE_MAKE_STATE_TRANSIT_SINGLE(
@@ -347,7 +339,7 @@ static inline bool pd_process_data_msg(
 	bool ret = false;
 	uint8_t ready_state = pe_get_curr_ready_state(pd_port);
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	if (!pd_check_rev30(pd_port) &&
 		pd_event->msg >= PD_DATA_PD30_START) {
 		pd_event->msg = PD_DATA_MSG_NR;
@@ -361,15 +353,15 @@ static inline bool pd_process_data_msg(
 			ret = pd_process_data_msg_bist(pd_port, pd_event);
 		break;
 
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
 	case PD_DATA_BAT_STATUS:
 		ret = PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_GET_BATTERY_STATUS, ready_state);
 		break;
 #endif	/* CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
+#if CONFIG_USB_PD_REV30_COUNTRY_CODE_LOCAL
 	case PD_DATA_GET_COUNTRY_INFO:
 		if (pd_port->country_nr) {
 			ret = PE_MAKE_STATE_TRANSIT_SINGLE(
@@ -387,7 +379,7 @@ static inline bool pd_process_data_msg(
  * [BLOCK] Porcess Extend MSG
  */
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 static inline bool pd_process_ext_msg(
 		struct pd_port *pd_port, struct pd_event *pd_event)
 {
@@ -399,7 +391,7 @@ static inline bool pd_process_ext_msg(
 		return false;
 	}
 
-#ifndef CONFIG_USB_PD_REV30_CHUNKING_BY_PE
+#if !CONFIG_USB_PD_REV30_CHUNKING_BY_PE
 	if (pd_port->pe_state_curr == ready_state &&
 		pd_is_multi_chunk_msg(pd_port)) {
 		pd_port->curr_unsupported_msg = true;
@@ -409,7 +401,7 @@ static inline bool pd_process_ext_msg(
 
 	switch (pd_event->msg) {
 
-#ifdef CONFIG_USB_PD_REV30_BAT_CAP_LOCAL
+#if CONFIG_USB_PD_REV30_BAT_CAP_LOCAL
 	case PD_EXT_GET_BAT_CAP:
 		if (pd_port->bat_nr) {
 			ret = PE_MAKE_STATE_TRANSIT_SINGLE(
@@ -418,7 +410,7 @@ static inline bool pd_process_ext_msg(
 		break;
 #endif	/* CONFIG_USB_PD_REV30_BAT_CAP_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL
 	case PD_EXT_GET_BAT_STATUS:
 		if (pd_port->bat_nr) {
 			ret = PE_MAKE_STATE_TRANSIT_SINGLE(
@@ -427,35 +419,35 @@ static inline bool pd_process_ext_msg(
 		break;
 #endif	/* CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
+#if CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
 	case PD_EXT_BAT_CAP:
 		ret = PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_GET_BATTERY_CAP, ready_state);
 		break;
 #endif	/* CONFIG_USB_PD_REV30_BAT_CAP_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
+#if CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
 	case PD_EXT_GET_MFR_INFO:
 		ret = PE_MAKE_STATE_TRANSIT_SINGLE(
 			ready_state, PE_GIVE_MANUFACTURER_INFO);
 		break;
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
+#if CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
 	case PD_EXT_MFR_INFO:
 		ret = PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_GET_MANUFACTURER_INFO, ready_state);
 		break;
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
+#if CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
 	case PD_EXT_COUNTRY_INFO:
 		ret = PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_GET_COUNTRY_INFO, ready_state);
 		break;
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
+#if CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
 	case PD_EXT_COUNTRY_CODES:
 		ret = PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_GET_COUNTRY_CODES, ready_state);
@@ -478,7 +470,7 @@ static inline bool pd_process_dpm_msg(
 
 	switch (pd_event->msg) {
 	case PD_DPM_ACK:
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
+#if CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
 		if (pd_port->pe_state_curr == PE_SEND_SOFT_RESET_STANDBY) {
 			pe_transit_soft_reset_state(pd_port);
 			return true;
@@ -492,7 +484,7 @@ static inline bool pd_process_dpm_msg(
 		}
 		break;
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	case PD_DPM_NOT_SUPPORT:
 		if (pd_check_rev30(pd_port)) {
 			PE_TRANSIT_STATE(pd_port, PE_VDM_NOT_SUPPORTED);
@@ -512,7 +504,7 @@ static inline bool pd_process_dpm_msg(
 static inline bool pd_process_recv_hard_reset(
 		struct pd_port *pd_port, struct pd_event *pd_event)
 {
-#ifdef CONFIG_USB_PD_RECV_HRESET_COUNTER
+#if CONFIG_USB_PD_RECV_HRESET_COUNTER
 	if (pd_port->pe_data.recv_hard_reset_count > PD_HARD_RESET_COUNT) {
 		PE_TRANSIT_STATE(pd_port, PE_OVER_RECV_HRESET_LIMIT);
 		return true;
@@ -521,7 +513,7 @@ static inline bool pd_process_recv_hard_reset(
 	pd_port->pe_data.recv_hard_reset_count++;
 #endif	/* CONFIG_USB_PD_RECV_HRESET_COUNTER */
 
-#ifdef CONFIG_USB_PD_RENEGOTIATION_COUNTER
+#if CONFIG_USB_PD_RENEGOTIATION_COUNTER
 	if (pd_check_pe_during_hard_reset(pd_port))
 		pd_port->pe_data.renegotiation_count++;
 #endif	/* CONFIG_USB_PD_RENEGOTIATION_COUNTER */
@@ -533,7 +525,7 @@ static inline bool pd_process_recv_hard_reset(
 static bool pd_process_hw_msg_tx_failed_discard(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
-#ifdef CONFIG_USB_PD_RENEGOTIATION_COUNTER
+#if CONFIG_USB_PD_RENEGOTIATION_COUNTER
 	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (pd_port->pe_data.renegotiation_count > PD_HARD_RESET_COUNT) {
@@ -583,10 +575,10 @@ static inline bool pd_process_hw_msg(
 static inline bool pd_check_rx_pending(struct pd_port *pd_port)
 {
 	bool pending = false;
+	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
-#ifdef CONFIG_USB_PD_CHECK_RX_PENDING_IF_SRTOUT
 	uint32_t alert;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
+	int timeout = -1;
 
 	if (tcpci_get_alert_status(tcpc, &alert))
 		return false;
@@ -597,13 +589,31 @@ static inline bool pd_check_rx_pending(struct pd_port *pd_port)
 	} else if (!pd_is_msg_empty(tcpc)) {
 		PE_INFO("rx_pending2\n");
 		pending = true;
+	} else if (!tcpc->alert_done.done) {
+		pending = true;
+		/* alert thread is handling, but not sure is TXRX event
+		 * just for not block TXRX event ASAP
+		 */
+		PE_INFO("alert_pending3\n");
+		timeout =
+		wait_for_completion_interruptible_timeout(&tcpc->alert_done,
+			usecs_to_jiffies(CONFIG_USB_PD_TRY_TIMEDELAY_IF_SRTOUT));
+		PE_INFO("timeout = %d\n", timeout);
+		/* if really timeout,
+		 * timer need to handle without waiting for alert event
+		 */
+		if (timeout <= 0)
+			pending = false;
 	}
 
-#ifndef CONFIG_USB_PD_ONLY_PRINT_SYSTEM_BUSY
-	if (pending)
-		pd_enable_timer(pd_port, PD_TIMER_SENDER_RESPONSE);
+	if (pending) {
+#if CONFIG_USB_PD_ONLY_PRINT_SYSTEM_BUSY
+		if (tcpc->alert_max_access_time >
+				CONFIG_USB_PD_TRY_TIMEDELAY_MAX)
+			/*if alert may prcess long, restart timer*/
+			pd_enable_timer(pd_port, PD_TIMER_SENDER_RESPONSE);
 #endif /* CONFIG_USB_PD_ONLY_PRINT_SYSTEM_BUSY */
-#endif	/* CONFIG_USB_PD_CHECK_RX_PENDING_IF_SRTOUT */
+	}
 
 	return pending;
 }
@@ -614,18 +624,11 @@ static inline bool pd_process_timer_msg(
 	uint8_t ready_state = pe_get_curr_ready_state(pd_port);
 
 	switch (pd_event->msg) {
-#ifndef CONFIG_USB_PD_DBG_IGRONE_TIMEOUT
+#if !CONFIG_USB_PD_DBG_IGRONE_TIMEOUT
 	case PD_TIMER_SENDER_RESPONSE:
 
-#ifdef CONFIG_USB_PD_CHECK_RX_PENDING_IF_SRTOUT
-#ifndef CONFIG_USB_PD_ONLY_PRINT_SYSTEM_BUSY
 		if (pd_check_rx_pending(pd_port))
 			return false;
-#else
-		pd_check_rx_pending(pd_port);
-#endif	/* CONFIG_USB_PD_PRINT_SYSTEM_BUSY */
-#endif	/* CONFIG_USB_PD_CHECK_RX_PENDING_IF_SRTOUT */
-
 
 		pd_cancel_dpm_reaction(pd_port);
 		pd_notify_pe_cancel_pr_swap(pd_port);
@@ -649,7 +652,7 @@ static inline bool pd_process_timer_msg(
 			return true;
 		break;
 
-#ifdef CONFIG_USB_PD_DFP_FLOW_DELAY
+#if CONFIG_USB_PD_DFP_FLOW_DELAY
 	case PD_TIMER_DFP_FLOW_DELAY:
 		if (pd_port->pe_state_curr == ready_state &&
 			pd_port->data_role == PD_ROLE_DFP) {
@@ -660,7 +663,7 @@ static inline bool pd_process_timer_msg(
 		break;
 #endif	/* CONFIG_USB_PD_DFP_FLOW_DELAY */
 
-#ifdef CONFIG_USB_PD_UFP_FLOW_DELAY
+#if CONFIG_USB_PD_UFP_FLOW_DELAY
 	case PD_TIMER_UFP_FLOW_DELAY:
 		if (pd_port->pe_state_curr == ready_state &&
 			pd_port->data_role == PD_ROLE_UFP) {
@@ -671,7 +674,7 @@ static inline bool pd_process_timer_msg(
 		break;
 #endif	/* CONFIG_USB_PD_UFP_FLOW_DELAY */
 
-#ifdef CONFIG_USB_PD_VCONN_STABLE_DELAY
+#if CONFIG_USB_PD_VCONN_STABLE_DELAY
 	case PD_TIMER_VCONN_STABLE:
 		if (pd_port->vconn_role == PD_ROLE_VCONN_DYNAMIC_ON) {
 			pd_set_vconn(pd_port, PD_ROLE_VCONN_ON);
@@ -682,13 +685,14 @@ static inline bool pd_process_timer_msg(
 		break;
 #endif	/* CONFIG_USB_PD_VCONN_STABLE_DELAY */
 
-#if defined(CONFIG_USB_PD_REV30) && defined(CONFIG_USB_PD_REV30_COLLISION_AVOID)
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	case PD_TIMER_DEFERRED_EVT:
 		pd_notify_tcp_event_buf_reset(
 			pd_port, TCP_DPM_RET_DROP_PE_BUSY);
 		break;
-#endif
-
+#endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
+#endif	/* CONFIG_USB_PD_REV30 */
 	default:
 		break;
 	}
@@ -706,7 +710,7 @@ bool pd_process_event_com(
 	case PD_EVT_DATA_MSG:
 		return pd_process_data_msg(pd_port, pd_event);
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	case PD_EVT_EXT_MSG:
 		return pd_process_ext_msg(pd_port, pd_event);
 #endif	/* CONFIG_USB_PD_REV30 */
@@ -724,3 +728,4 @@ bool pd_process_event_com(
 		return false;
 	}
 }
+#endif /* CONFIG_USB_POWER_DELIVERY */
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_dbg.c b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_dbg.c
index 7f0ee5e..67924ab 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_dbg.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_dbg.c
@@ -1,23 +1,13 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * Power Delivery Process Event For DBGACC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include "inc/pd_core.h"
 #include "inc/tcpci_event.h"
 #include "inc/pd_process_evt.h"
 
-#ifdef CONFIG_USB_PD_CUSTOM_DBGACC
+#if CONFIG_USB_PD_CUSTOM_DBGACC
 
 bool pd_process_event_dbg(struct pd_port *pd_port, struct pd_event *pd_event)
 {
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_drs.c b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_drs.c
index d502ac0..d0a043a 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_drs.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_drs.c
@@ -1,22 +1,13 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * Power Delivery Process Event For DRS
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
-
 #include "inc/pd_core.h"
 #include "inc/tcpci_event.h"
 #include "inc/pd_process_evt.h"
 
+#if CONFIG_USB_PD_DR_SWAP
+
 /* PD Control MSG reactions */
 
 DECL_PE_STATE_TRANSITION(PD_CTRL_MSG_GOOD_CRC) = {
@@ -100,3 +91,4 @@ bool pd_process_event_drs(struct pd_port *pd_port, struct pd_event *pd_event)
 		return false;
 	}
 }
+#endif	/* CONFIG_USB_PD_DR_SWAP */
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_prs.c b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_prs.c
index 23e34de..fb62c69 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_prs.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_prs.c
@@ -1,16 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * Power Delivery Process Event For PRS
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include "inc/pd_core.h"
@@ -18,7 +8,9 @@
 #include "inc/pd_process_evt.h"
 #include "inc/pd_dpm_core.h"
 
-#ifdef CONFIG_USB_PD_PR_SWAP_ERROR_RECOVERY
+#if CONFIG_USB_PD_PR_SWAP
+
+#if CONFIG_USB_PD_PR_SWAP_ERROR_RECOVERY
 #define PE_PRS_SNK_HARD_RESET	PE_ERROR_RECOVERY
 #define PE_PRS_SRC_HARD_RESET	PE_ERROR_RECOVERY
 #else
@@ -69,7 +61,7 @@ DECL_PE_STATE_REACTION(PD_DPM_MSG_NAK);
 /* HW Event reactions */
 
 DECL_PE_STATE_TRANSITION(PD_HW_VBUS_PRESENT) = {
-#ifdef CONFIG_USB_PD_VBUS_DETECTION_DURING_PR_SWAP
+#if CONFIG_USB_PD_VBUS_DETECTION_DURING_PR_SWAP
 	{ PE_PRS_SRC_SNK_WAIT_SOURCE_ON, PE_SNK_STARTUP },
 #endif /* CONFIG_USB_PD_VBUS_DETECTION_DURING_PR_SWAP */
 };
@@ -83,7 +75,7 @@ DECL_PE_STATE_REACTION(PD_HW_TX_FAILED);
 
 DECL_PE_STATE_TRANSITION(PD_HW_VBUS_SAFE0V) = {
 	{ PE_PRS_SRC_SNK_TRANSITION_TO_OFF, PE_PRS_SRC_SNK_ASSERT_RD },
-#ifdef CONFIG_USB_PD_VBUS_DETECTION_DURING_PR_SWAP
+#if CONFIG_USB_PD_VBUS_DETECTION_DURING_PR_SWAP
 	{ PE_PRS_SNK_SRC_TRANSITION_TO_OFF, PE_PRS_SNK_SRC_ASSERT_RP },
 #endif /* CONFIG_USB_PD_VBUS_DETECTION_DURING_PR_SWAP */
 };
@@ -111,7 +103,7 @@ static inline bool pd_process_ctrl_msg_ps_rdy(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
 	switch (pd_port->pe_state_curr) {
-#ifdef CONFIG_USB_PD_VBUS_DETECTION_DURING_PR_SWAP
+#if CONFIG_USB_PD_VBUS_DETECTION_DURING_PR_SWAP
 	case PE_PRS_SRC_SNK_WAIT_SOURCE_ON:
 		pd_enable_vbus_valid_detection(pd_port, true);
 		return false;
@@ -177,7 +169,6 @@ static inline bool pd_process_hw_msg(
 		return PE_MAKE_STATE_TRANSIT(PD_HW_VBUS_PRESENT);
 
 	case PD_HW_TX_FAILED:
-	/* fallthrough */
 	case PD_HW_TX_DISCARD:
 		return PE_MAKE_STATE_TRANSIT(PD_HW_TX_FAILED);
 
@@ -238,3 +229,5 @@ bool pd_process_event_prs(struct pd_port *pd_port, struct pd_event *pd_event)
 		return false;
 	}
 }
+#endif	/* CONFIG_USB_PD_PR_SWAP */
+
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_snk.c b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_snk.c
old mode 100644
new mode 100755
index 4547af6..8e2069e
--- a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_snk.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_snk.c
@@ -1,16 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * Power Delivery Process Event For SNK
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include "inc/pd_core.h"
@@ -37,7 +27,7 @@ DECL_PE_STATE_TRANSITION(PD_DATA_MSG_SOURCE_CAP) = {
 	{ PE_SNK_STARTUP, PE_SNK_EVALUATE_CAPABILITY },
 	{ PE_SNK_DISCOVERY, PE_SNK_EVALUATE_CAPABILITY },
 
-#ifdef CONFIG_USB_PD_TCPM_CB_2ND
+#if CONFIG_USB_PD_TCPM_CB_2ND
 	{ PE_SNK_GET_SOURCE_CAP, PE_SNK_EVALUATE_CAPABILITY },
 #endif	/* CONFIG_USB_PD_TCPM_CB_2ND */
 };
@@ -53,7 +43,7 @@ static bool pd_process_ctrl_msg_get_source_cap(
 	if (pd_port->pe_state_curr != PE_SNK_READY)
 		return false;
 
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 	if (pd_port->dpm_caps & DPM_CAP_LOCAL_DR_POWER) {
 		PE_TRANSIT_STATE(pd_port, next);
 		return true;
@@ -68,13 +58,13 @@ static bool pd_process_ctrl_msg_get_source_cap(
 static inline bool pd_process_ctrl_msg(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
-#ifdef CONFIG_USB_PD_PARTNER_CTRL_MSG_FIRST
+#if CONFIG_USB_PD_PARTNER_CTRL_MSG_FIRST
 	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	switch (pd_port->pe_state_curr) {
 	case PE_SNK_GET_SOURCE_CAP:
 
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 	case PE_DR_SNK_GET_SINK_CAP:
 #endif	/* CONFIG_USB_PD_PR_SWAP */
 		if (pd_event->msg >= PD_CTRL_GET_SOURCE_CAP &&
@@ -111,7 +101,7 @@ static inline bool pd_process_ctrl_msg(
 			PE_TRANSIT_STATE(pd_port, PE_SNK_READY);
 			return true;
 
-#ifdef CONFIG_USB_PD_VBUS_DETECTION_DURING_PR_SWAP
+#if CONFIG_USB_PD_VBUS_DETECTION_DURING_PR_SWAP
 		case PE_PRS_SRC_SNK_WAIT_SOURCE_ON:
 		case PE_PRS_SNK_SRC_TRANSITION_TO_OFF:
 			return false;
@@ -146,14 +136,14 @@ static inline bool pd_process_ctrl_msg(
 		}
 		break;
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	case PD_CTRL_NOT_SUPPORTED:
 		if (PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_SNK_READY, PE_SNK_NOT_SUPPORTED_RECEIVED))
 			return true;
 		break;
 
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
 	case PD_CTRL_GET_SOURCE_CAP_EXT:
 		if (pd_process_ctrl_msg_get_source_cap(
 			pd_port, PE_DR_SNK_GIVE_SOURCE_CAP_EXT))
@@ -161,7 +151,7 @@ static inline bool pd_process_ctrl_msg(
 		break;
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
 	case PD_CTRL_GET_STATUS:
 		if (PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_SNK_READY, PE_SNK_GIVE_SINK_STATUS))
@@ -187,14 +177,14 @@ static inline bool pd_process_data_msg(
 {
 	switch (pd_event->msg) {
 	case PD_DATA_SOURCE_CAP:
-#ifdef CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP
+#if CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP
 		pd_port->msg_id_pr_swap_last = 0xff;
 #endif	/* CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP */
 		if (PE_MAKE_STATE_TRANSIT(PD_DATA_MSG_SOURCE_CAP))
 			return true;
 		break;
 
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 	case PD_DATA_SINK_CAP:
 		if (PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_DR_SNK_GET_SINK_CAP, PE_SNK_READY))
@@ -202,8 +192,8 @@ static inline bool pd_process_data_msg(
 		break;
 #endif	/* CONFIG_USB_PD_PR_SWAP */
 
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_ALERT_REMOTE
 	case PD_DATA_ALERT:
 		if (PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_SNK_READY, PE_SNK_SOURCE_ALERT_RECEIVED))
@@ -222,13 +212,13 @@ static inline bool pd_process_data_msg(
 /*
  * [BLOCK] Porcess Extend MSG
  */
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 static inline bool pd_process_ext_msg(
 		struct pd_port *pd_port, struct pd_event *pd_event)
 {
 	switch (pd_event->msg) {
 
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
 	case PD_EXT_SOURCE_CAP_EXT:
 		if (PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_SNK_GET_SOURCE_CAP_EXT, PE_SNK_READY))
@@ -236,15 +226,15 @@ static inline bool pd_process_ext_msg(
 		break;
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_REMOTE
 	case PD_EXT_STATUS:
 		if (PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_SNK_GET_SOURCE_STATUS, PE_SNK_READY))
 			return true;
 		break;
-#endif	/* CONFIG_USB_PD_REV30_STATUS_LOCAL */
+#endif	/* CONFIG_USB_PD_REV30_STATUS_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	case PD_EXT_PPS_STATUS:
 		if (PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_SNK_GET_PPS_STATUS, PE_SNK_READY))
@@ -285,11 +275,11 @@ static inline bool pd_process_dpm_msg(
 static inline bool pd_process_hw_msg_sink_tx_change(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	struct pe_data *pe_data = &pd_port->pe_data;
 	uint8_t pd_traffic;
 
-#ifdef CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
+#if CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
 	if (pe_data->pd_traffic_control == PD_SINK_TX_START)
 		return false;
 #endif	/* CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP */
@@ -314,7 +304,7 @@ static inline bool pd_process_vbus_absent(struct pd_port *pd_port)
 {
 	if (pd_port->pe_state_curr != PE_SNK_DISCOVERY)
 		return false;
-#ifdef CONFIG_USB_PD_SNK_HRESET_KEEP_DRAW
+#if CONFIG_USB_PD_SNK_HRESET_KEEP_DRAW
 	/* iSafe0mA: Maximum current a Sink
 	 * is allowed to draw when VBUS is driven to vSafe0V
 	 */
@@ -340,7 +330,7 @@ static inline bool pd_process_hw_msg(
 	case PD_HW_TX_DISCARD:
 		return pd_process_tx_failed_discard(pd_port, pd_event->msg);
 
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	case PD_HW_SINK_TX_CHANGE:
 		return pd_process_hw_msg_sink_tx_change(pd_port, pd_event);
 #endif /* CONFIG_USB_PD_REV30_COLLISION_AVOID */
@@ -399,7 +389,7 @@ static inline void pd_report_typec_only_charger(struct pd_port *pd_port)
 static inline bool pd_process_timer_msg(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
-#ifndef CONFIG_USB_PD_DBG_IGRONE_TIMEOUT
+#if !CONFIG_USB_PD_DBG_IGRONE_TIMEOUT
 	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 #endif	/* CONFIG_USB_PD_DBG_IGRONE_TIMEOUT */
 	struct pe_data __maybe_unused *pe_data = &pd_port->pe_data;
@@ -408,12 +398,10 @@ static inline bool pd_process_timer_msg(
 	case PD_TIMER_SINK_REQUEST:
 		return PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_SNK_READY, PE_SNK_SELECT_CAPABILITY);
-
-#ifndef CONFIG_USB_PD_DBG_IGRONE_TIMEOUT
+#if !CONFIG_USB_PD_DBG_IGRONE_TIMEOUT
 	case PD_TIMER_SINK_WAIT_CAP:
 	case PD_TIMER_PS_TRANSITION:
-		if ((pd_port->pe_state_curr != PE_SNK_DISCOVERY) &&
-			(pe_data->hard_reset_counter <= PD_HARD_RESET_COUNT)) {
+		if (pe_data->hard_reset_counter <= PD_HARD_RESET_COUNT) {
 			PE_TRANSIT_STATE(pd_port, PE_SNK_HARD_RESET);
 			return true;
 		}
@@ -428,20 +416,20 @@ static inline bool pd_process_timer_msg(
 		break;
 #endif	/* CONFIG_USB_PD_DBG_IGRONE_TIMEOUT */
 
-#ifdef CONFIG_USB_PD_DFP_READY_DISCOVER_ID
+#if CONFIG_USB_PD_DFP_READY_DISCOVER_ID
 	case PD_TIMER_DISCOVER_ID:
 		vdm_put_dpm_discover_cable_event(pd_port);
 		break;
 #endif	/* CONFIG_USB_PD_DFP_READY_DISCOVER_ID */
-		/* fall through */
-#ifdef CONFIG_USB_PD_REV30
+		fallthrough;
+#if CONFIG_USB_PD_REV30
 	case PD_TIMER_CK_NOT_SUPPORTED:
 		if (PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_SNK_CHUNK_RECEIVED, PE_SNK_SEND_NOT_SUPPORTED))
 			return true;
-		/* fall through */
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
-#ifdef CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
+		fallthrough;
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
 	case PD_TIMER_SNK_FLOW_DELAY:
 		if (pe_data->pd_traffic_control == PD_SINK_TX_START) {
 			if (typec_get_cc_res() == TYPEC_CC_VOLT_SNK_3_0)
@@ -473,7 +461,7 @@ bool pd_process_event_snk(struct pd_port *pd_port, struct pd_event *pd_event)
 	case PD_EVT_DATA_MSG:
 		return pd_process_data_msg(pd_port, pd_event);
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	case PD_EVT_EXT_MSG:
 		return pd_process_ext_msg(pd_port, pd_event);
 #endif	/* CONFIG_USB_PD_REV30 */
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_src.c b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_src.c
index bfdb65f..5701db8 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_src.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_src.c
@@ -1,18 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * Power Delivery Process Event For SRC
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 #include "inc/pd_core.h"
 #include "inc/tcpci_event.h"
 #include "inc/pd_process_evt.h"
@@ -90,7 +81,7 @@ static inline bool pd_process_ctrl_msg_get_sink_cap(
 	if (pd_port->pe_state_curr != PE_SRC_READY)
 		return false;
 
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 	if (pd_port->dpm_caps & DPM_CAP_LOCAL_DR_POWER) {
 		PE_TRANSIT_STATE(pd_port, PE_DR_SRC_GIVE_SINK_CAP);
 		return true;
@@ -106,13 +97,13 @@ static inline bool pd_process_ctrl_msg(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 
 {
-#ifdef CONFIG_USB_PD_PARTNER_CTRL_MSG_FIRST
+#if CONFIG_USB_PD_PARTNER_CTRL_MSG_FIRST
 	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	switch (pd_port->pe_state_curr) {
 	case PE_SRC_GET_SINK_CAP:
 
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 	case PE_DR_SRC_GET_SOURCE_CAP:
 #endif	/* CONFIG_USB_PD_PR_SWAP */
 		if (pd_event->msg >= PD_CTRL_GET_SOURCE_CAP &&
@@ -147,14 +138,14 @@ static inline bool pd_process_ctrl_msg(
 			return true;
 		break;
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	case PD_CTRL_NOT_SUPPORTED:
 		if (PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_SRC_READY, PE_SRC_NOT_SUPPORTED_RECEIVED))
 			return true;
 		break;
 
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
 	case PD_CTRL_GET_SOURCE_CAP_EXT:
 		if (PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_SRC_READY, PE_SRC_GIVE_SOURCE_CAP_EXT))
@@ -162,7 +153,7 @@ static inline bool pd_process_ctrl_msg(
 		break;
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
 	case PD_CTRL_GET_STATUS:
 		if (PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_SRC_READY, PE_SRC_GIVE_SOURCE_STATUS))
@@ -170,7 +161,7 @@ static inline bool pd_process_ctrl_msg(
 		break;
 #endif	/* CONFIG_USB_PD_REV30_STATUS_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SOURCE
+#if CONFIG_USB_PD_REV30_PPS_SOURCE
 	case PD_CTRL_GET_PPS_STATUS:
 		if (PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_SRC_READY, PE_SRC_GIVE_PPS_STATUS))
@@ -196,7 +187,7 @@ static inline bool pd_process_data_msg(
 
 {
 	switch (pd_event->msg) {
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 	case PD_DATA_SOURCE_CAP:
 		if (PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_DR_SRC_GET_SOURCE_CAP, PE_SRC_READY))
@@ -215,8 +206,8 @@ static inline bool pd_process_data_msg(
 			return true;
 		break;
 
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_ALERT_REMOTE
 	case PD_DATA_ALERT:
 		if (PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_SRC_READY, PE_SRC_SINK_ALERT_RECEIVED))
@@ -236,14 +227,14 @@ static inline bool pd_process_data_msg(
 /*
  * [BLOCK] Porcess Extend MSG
  */
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 
 static inline bool pd_process_ext_msg(
 		struct pd_port *pd_port, struct pd_event *pd_event)
 {
 	switch (pd_event->msg) {
 
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
 	case PD_EXT_SOURCE_CAP_EXT:
 		if (PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_DR_SRC_GET_SOURCE_CAP_EXT, PE_SRC_READY))
@@ -251,7 +242,7 @@ static inline bool pd_process_ext_msg(
 		break;
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
 	case PD_EXT_STATUS:
 		if (PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_SRC_GET_SINK_STATUS, PE_SRC_READY))
@@ -326,7 +317,7 @@ static inline bool pd_process_hw_msg_tx_failed(
 		}
 	}
 
-#ifdef CONFIG_PD_SRC_RESET_CABLE
+#if CONFIG_PD_SRC_RESET_CABLE
 	if (pd_port->pe_state_curr == PE_SRC_CBL_SEND_SOFT_RESET) {
 		PE_TRANSIT_STATE(pd_port, PE_SRC_SEND_CAPABILITIES);
 		return true;
@@ -352,7 +343,7 @@ static inline bool pd_process_hw_msg(
 			PE_SRC_TRANSITION_SUPPLY, PE_SRC_TRANSITION_SUPPLY2);
 
 	case PD_HW_TX_FAILED:
-	/* fallthrough */
+		fallthrough;
 	case PD_HW_TX_DISCARD:
 		return pd_process_hw_msg_tx_failed(pd_port, pd_event);
 
@@ -388,11 +379,11 @@ static inline bool pd_process_pe_msg(
 static inline bool pd_process_timer_msg_source_start(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
-#ifdef CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
+#if CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
 	if (pd_is_discover_cable(pd_port) &&
 		pd_port->pe_data.msg_id_tx[TCPC_TX_SOP_PRIME] == 0) {
 
-#ifdef CONFIG_PD_SRC_RESET_CABLE
+#if CONFIG_PD_SRC_RESET_CABLE
 		if (pd_is_reset_cable(pd_port)) {
 			PE_TRANSIT_STATE(pd_port, PE_SRC_CBL_SEND_SOFT_RESET);
 			return true;
@@ -406,7 +397,7 @@ static inline bool pd_process_timer_msg_source_start(
 
 	switch (pd_port->pe_state_curr) {
 	case PE_SRC_STARTUP:
-#ifdef CONFIG_PD_SRC_RESET_CABLE
+#if CONFIG_PD_SRC_RESET_CABLE
 	case PE_SRC_CBL_SEND_SOFT_RESET:
 #endif	/* CONFIG_PD_SRC_RESET_CABLE */
 		PE_TRANSIT_STATE(pd_port, PE_SRC_SEND_CAPABILITIES);
@@ -450,8 +441,8 @@ static inline bool pd_process_timer_msg(
 	case PD_TIMER_SOURCE_CAPABILITY:
 		return pd_process_timer_msg_source_cap(pd_port, pd_event);
 
-#ifndef CONFIG_USB_PD_DBG_IGRONE_TIMEOUT
-#ifdef CONFIG_PD_SRC_RESET_CABLE
+#if !CONFIG_USB_PD_DBG_IGRONE_TIMEOUT
+#if CONFIG_PD_SRC_RESET_CABLE
 	case PD_TIMER_SENDER_RESPONSE:
 		return PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_SRC_CBL_SEND_SOFT_RESET, PE_SRC_SEND_CAPABILITIES);
@@ -464,7 +455,7 @@ static inline bool pd_process_timer_msg(
 	case PD_TIMER_SOURCE_START:
 		return pd_process_timer_msg_source_start(pd_port, pd_event);
 
-#ifndef CONFIG_USB_PD_DBG_IGRONE_TIMEOUT
+#if !CONFIG_USB_PD_DBG_IGRONE_TIMEOUT
 	case PD_TIMER_NO_RESPONSE:
 		return pd_process_timer_msg_no_response(pd_port, pd_event);
 #endif
@@ -474,7 +465,7 @@ static inline bool pd_process_timer_msg(
 			pd_dpm_src_transition_power(pd_port);
 		break;
 
-#ifdef CONFIG_PD_DISCOVER_CABLE_ID
+#if CONFIG_PD_DISCOVER_CABLE_ID
 	case PD_TIMER_DISCOVER_ID:
 		vdm_put_dpm_discover_cable_event(pd_port);
 		break;
@@ -485,20 +476,20 @@ static inline bool pd_process_timer_msg(
 		pd_enable_vbus_valid_detection(pd_port, true);
 		break;
 
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	case PD_TIMER_SINK_TX:
 		if (pd_port->pe_data.pd_traffic_control == PD_SINK_TX_NG)
 			pd_port->pe_data.pd_traffic_control = PD_SOURCE_TX_OK;
 
-#ifdef CONFIG_USB_PD_REV30_SRC_FLOW_DELAY_STARTUP
+#if CONFIG_USB_PD_REV30_SRC_FLOW_DELAY_STARTUP
 		if (pd_port->pe_data.pd_traffic_control == PD_SOURCE_TX_START)
 			pd_port->pe_data.pd_traffic_control = PD_SINK_TX_OK;
 #endif	/* CONFIG_USB_PD_REV30_SRC_FLOW_DELAY_STARTUP */
 
 		break;
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
-		/* fall through */
-#ifdef CONFIG_USB_PD_REV30
+		fallthrough;
+#if CONFIG_USB_PD_REV30
 	case PD_TIMER_CK_NOT_SUPPORTED:
 		return PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_SRC_CHUNK_RECEIVED, PE_SRC_SEND_NOT_SUPPORTED);
@@ -521,7 +512,7 @@ bool pd_process_event_src(struct pd_port *pd_port, struct pd_event *pd_event)
 	case PD_EVT_DATA_MSG:
 		return pd_process_data_msg(pd_port, pd_event);
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	case PD_EVT_EXT_MSG:
 		return pd_process_ext_msg(pd_port, pd_event);
 #endif	/* CONFIG_USB_PD_REV30 */
@@ -542,3 +533,4 @@ bool pd_process_event_src(struct pd_port *pd_port, struct pd_event *pd_event)
 		return false;
 	}
 }
+#endif /* CONFIG_USB_POWER_DELIVERY */
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_tcp.c b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_tcp.c
index a863c5d..ef7802c 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_tcp.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_tcp.c
@@ -1,16 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * Power Delivery Process Event for TCP
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include "inc/pd_core.h"
@@ -18,7 +8,7 @@
 #include "inc/pd_process_evt.h"
 #include "inc/pd_dpm_core.h"
 
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 static inline int pd_handle_tcp_event_pr_swap(
 	struct pd_port *pd_port, uint8_t new_role)
 {
@@ -39,7 +29,7 @@ static inline int pd_handle_tcp_event_pr_swap(
 }
 #endif	/* CONFIG_USB_PD_PR_SWAP */
 
-#ifdef CONFIG_USB_PD_DR_SWAP
+#if CONFIG_USB_PD_DR_SWAP
 static inline int pd_handle_tcp_event_dr_swap(
 	struct pd_port *pd_port, uint8_t new_role)
 {
@@ -63,7 +53,7 @@ static inline int pd_handle_tcp_event_dr_swap(
 }
 #endif	/* CONFIG_USB_PD_DR_SWAP */
 
-#ifdef CONFIG_USB_PD_VCONN_SWAP
+#if CONFIG_USB_PD_VCONN_SWAP
 static inline int pd_handle_tcp_event_vconn_swap(
 	struct pd_port *pd_port, uint8_t new_role)
 {
@@ -85,7 +75,7 @@ static inline int pd_handle_tcp_event_vconn_swap(
 }
 #endif	/* CONFIG_USB_PD_VCONN_SWAP */
 
-#ifdef CONFIG_USB_PD_PE_SOURCE
+#if CONFIG_USB_PD_PE_SOURCE
 static inline int pd_handle_tcp_event_gotomin(struct pd_port *pd_port)
 {
 	if (pd_port->pe_state_curr != PE_SRC_READY)
@@ -108,7 +98,7 @@ static inline int pd_handle_tcp_event_softreset(struct pd_port *pd_port)
 	return TCP_DPM_RET_SENT;
 }
 
-#ifdef CONFIG_PD_DFP_RESET_CABLE
+#if CONFIG_PD_DFP_RESET_CABLE
 static inline int pd_handle_tcp_event_cable_softreset(struct pd_port *pd_port)
 {
 	bool role_check;
@@ -136,7 +126,7 @@ static inline int pd_handle_tcp_event_get_source_cap(struct pd_port *pd_port)
 		PE_TRANSIT_STATE(pd_port, PE_SNK_GET_SOURCE_CAP);
 		return TCP_DPM_RET_SENT;
 
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 	case PE_SRC_READY:
 		if (pd_port->dpm_caps & DPM_CAP_LOCAL_DR_POWER) {
 			PE_TRANSIT_STATE(pd_port, PE_DR_SRC_GET_SOURCE_CAP);
@@ -157,7 +147,7 @@ static inline int pd_handle_tcp_event_get_sink_cap(struct pd_port *pd_port)
 		PE_TRANSIT_STATE(pd_port, PE_SRC_GET_SINK_CAP);
 		return TCP_DPM_RET_SENT;
 
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 	case PE_SNK_READY:
 		if (pd_port->dpm_caps & DPM_CAP_LOCAL_DR_POWER) {
 			PE_TRANSIT_STATE(pd_port, PE_DR_SNK_GET_SINK_CAP);
@@ -171,7 +161,7 @@ static inline int pd_handle_tcp_event_get_sink_cap(struct pd_port *pd_port)
 	return TCP_DPM_RET_DENIED_NOT_READY;
 }
 
-#ifdef CONFIG_USB_PD_PE_SINK
+#if CONFIG_USB_PD_PE_SINK
 static inline int pd_handle_tcp_event_request(struct pd_port *pd_port)
 {
 	int ret = 0;
@@ -213,9 +203,9 @@ static inline int pd_handle_tcp_event_bist_cm2(struct pd_port *pd_port)
 	return TCP_DPM_RET_SENT;
 }
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
 static inline int pd_handle_tcp_event_get_source_cap_ext(
 					struct pd_port *pd_port)
 {
@@ -224,7 +214,7 @@ static inline int pd_handle_tcp_event_get_source_cap_ext(
 		PE_TRANSIT_STATE(pd_port, PE_SNK_GET_SOURCE_CAP_EXT);
 		return TCP_DPM_RET_SENT;
 
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 	case PE_SRC_READY:
 		if (pd_port->dpm_caps & DPM_CAP_LOCAL_DR_POWER) {
 			PE_TRANSIT_STATE(pd_port,
@@ -239,7 +229,7 @@ static inline int pd_handle_tcp_event_get_source_cap_ext(
 }
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 static inline int pd_handle_tcp_event_get_pps_status(struct pd_port *pd_port)
 {
 	if (pd_port->pe_state_curr != PE_SNK_READY)
@@ -265,13 +255,13 @@ static inline int pd_make_tcp_event_transit_ready2(
 {
 	switch (pd_port->pe_state_curr) {
 
-#ifdef CONFIG_USB_PD_PE_SINK
+#if CONFIG_USB_PD_PE_SINK
 	case PE_SNK_READY:
 		PE_TRANSIT_STATE(pd_port, snk_state);
 		return TCP_DPM_RET_SENT;
 #endif	/* CONFIG_USB_PD_PE_SINK */
 
-#ifdef CONFIG_USB_PD_PE_SOURCE
+#if CONFIG_USB_PD_PE_SOURCE
 	case PE_SRC_READY:
 		PE_TRANSIT_STATE(pd_port, src_state);
 		return TCP_DPM_RET_SENT;
@@ -281,7 +271,7 @@ static inline int pd_make_tcp_event_transit_ready2(
 	return TCP_DPM_RET_DENIED_NOT_READY;
 }
 
-#ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
+#if CONFIG_USB_PD_REV30_ALERT_LOCAL
 static inline int pd_handle_tcp_event_alert(struct pd_port *pd_port)
 {
 	struct tcp_dpm_event *tcp_event = &pd_port->tcp_event;
@@ -313,7 +303,7 @@ static inline int pd_handle_tcp_dpm_event(
 {
 	int ret = TCP_DPM_RET_DENIED_UNKNOWN;
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	if (pd_event->msg >= TCP_DPM_EVT_PD30_COMMAND
 		&& pd_event->msg < TCP_DPM_EVT_VDM_COMMAND) {
 		if (!pd_check_rev30(pd_port))
@@ -326,7 +316,7 @@ static inline int pd_handle_tcp_dpm_event(
 		break;
 	case TCP_DPM_EVT_PR_SWAP_AS_SNK:
 	case TCP_DPM_EVT_PR_SWAP_AS_SRC:
-#ifdef CONFIG_USB_PD_PR_SWAP
+#if CONFIG_USB_PD_PR_SWAP
 		ret = pd_handle_tcp_event_pr_swap(pd_port,
 			pd_event->msg - TCP_DPM_EVT_PR_SWAP_AS_SNK);
 #endif	/* CONFIG_USB_PD_PR_SWAP */
@@ -334,7 +324,7 @@ static inline int pd_handle_tcp_dpm_event(
 
 	case TCP_DPM_EVT_DR_SWAP_AS_UFP:
 	case TCP_DPM_EVT_DR_SWAP_AS_DFP:
-#ifdef CONFIG_USB_PD_DR_SWAP
+#if CONFIG_USB_PD_DR_SWAP
 		ret = pd_handle_tcp_event_dr_swap(pd_port,
 			pd_event->msg - TCP_DPM_EVT_DR_SWAP_AS_UFP);
 #endif	/* CONFIG_USB_PD_DR_SWAP */
@@ -342,14 +332,14 @@ static inline int pd_handle_tcp_dpm_event(
 
 	case TCP_DPM_EVT_VCONN_SWAP_OFF:
 	case TCP_DPM_EVT_VCONN_SWAP_ON:
-#ifdef CONFIG_USB_PD_VCONN_SWAP
+#if CONFIG_USB_PD_VCONN_SWAP
 		ret = pd_handle_tcp_event_vconn_swap(pd_port,
 			pd_event->msg - TCP_DPM_EVT_VCONN_SWAP_OFF);
 #endif	/* CONFIG_USB_PD_VCONN_SWAP */
 		break;
 
 	case TCP_DPM_EVT_GOTOMIN:
-#ifdef CONFIG_USB_PD_PE_SOURCE
+#if CONFIG_USB_PD_PE_SOURCE
 		ret =  pd_handle_tcp_event_gotomin(pd_port);
 #endif	/* CONFIG_USB_PD_PE_SOURCE */
 		break;
@@ -358,7 +348,7 @@ static inline int pd_handle_tcp_dpm_event(
 		break;
 
 	case TCP_DPM_EVT_CABLE_SOFTRESET:
-#ifdef CONFIG_PD_DFP_RESET_CABLE
+#if CONFIG_PD_DFP_RESET_CABLE
 		ret = pd_handle_tcp_event_cable_softreset(pd_port);
 #endif	/* CONFIG_PD_DFP_RESET_CABLE */
 		break;
@@ -371,7 +361,7 @@ static inline int pd_handle_tcp_dpm_event(
 		ret =  pd_handle_tcp_event_get_sink_cap(pd_port);
 		break;
 
-#ifdef CONFIG_USB_PD_PE_SINK
+#if CONFIG_USB_PD_PE_SINK
 	case TCP_DPM_EVT_REQUEST:
 		ret = pd_handle_tcp_event_request(pd_port);
 		break;
@@ -387,61 +377,61 @@ static inline int pd_handle_tcp_dpm_event(
 		ret = pd_handle_tcp_event_bist_cm2(pd_port);
 		break;
 
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
 	case TCP_DPM_EVT_GET_SOURCE_CAP_EXT:
 		ret = pd_handle_tcp_event_get_source_cap_ext(pd_port);
 		break;
 #endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_STATUS_REMOTE
 	case TCP_DPM_EVT_GET_STATUS:
 		ret = pd_make_tcp_event_transit_ready2(pd_port,
 			PE_SNK_GET_SOURCE_STATUS, PE_SRC_GET_SINK_STATUS);
 		break;
 #endif	/* CONFIG_USB_PD_REV30_STATUS_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
+#if CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE
 	case TCP_DPM_EVT_GET_COUNTRY_CODE:
 		ret = pd_make_tcp_event_transit_ready(
 			pd_port, PE_GET_COUNTRY_CODES);
 		break;
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_CODE_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	case TCP_DPM_EVT_GET_PPS_STATUS:
 		ret = pd_handle_tcp_event_get_pps_status(pd_port);
 		break;
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 
-#ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
+#if CONFIG_USB_PD_REV30_ALERT_LOCAL
 	case TCP_DPM_EVT_ALERT:
 		ret = pd_handle_tcp_event_alert(pd_port);
 		break;
 #endif	/* CONFIG_USB_PD_REV30_ALERT_LOCAL */
 
-#ifdef CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
+#if CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE
 	case TCP_DPM_EVT_GET_COUNTRY_INFO:
 		ret = pd_make_tcp_event_transit_ready(
 			pd_port, PE_GET_COUNTRY_INFO);
 		break;
 #endif	/* CONFIG_USB_PD_REV30_COUNTRY_INFO_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
+#if CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
 	case TCP_DPM_EVT_GET_BAT_CAP:
 		ret = pd_make_tcp_event_transit_ready(
 			pd_port, PE_GET_BATTERY_CAP);
 		break;
 #endif	/* CONFIG_USB_PD_REV30_BAT_CAP_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE
 	case TCP_DPM_EVT_GET_BAT_STATUS:
 		ret = pd_make_tcp_event_transit_ready(
 			pd_port, PE_GET_BATTERY_STATUS);
 		break;
 #endif	/* CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
+#if CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE
 	case TCP_DPM_EVT_GET_MFRS_INFO:
 		ret = pd_make_tcp_event_transit_ready(
 			pd_port, PE_GET_MANUFACTURER_INFO);
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_vcs.c b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_vcs.c
index a1971c3..53b8839 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_vcs.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_vcs.c
@@ -1,23 +1,13 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * Power Delivery Process Event For VCS
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include "inc/pd_core.h"
 #include "inc/tcpci_event.h"
 #include "inc/pd_process_evt.h"
 
-#ifdef CONFIG_USB_PD_VCONN_SWAP
+#if CONFIG_USB_PD_VCONN_SWAP
 /* DPM Event reactions */
 
 DECL_PE_STATE_TRANSITION(PD_DPM_MSG_ACK) = {
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_vdm.c b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_vdm.c
index e3e9cf1..cb4435b 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_vdm.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_vdm.c
@@ -1,16 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * Power Delivery Process Event For VDM
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include "inc/pd_core.h"
@@ -97,7 +87,7 @@ static const struct vdm_state_transition pe_vdm_state_reactions[] = {
 		PE_UFP_VDM_ATTENTION_REQUEST
 	),
 
-#ifdef CONFIG_USB_PD_ALT_MODE_DFP
+#if CONFIG_USB_PD_ALT_MODE_DFP
 	VDM_DFP_CMD_REACTION(CMD_DP_STATUS,
 		PE_UFP_VDM_DP_STATUS_UPDATE,
 		PE_DFP_VDM_DP_STATUS_UPDATE_REQUEST
@@ -109,7 +99,7 @@ static const struct vdm_state_transition pe_vdm_state_reactions[] = {
 	),
 #endif	/* CONFIG_USB_PD_ALT_MODE_DFP */
 
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 	/* Only handle Timeout Case */
 	VDM_DFP_CMD_REACTION_PD30(0,
 		PE_UFP_UVDM_RECV,
@@ -117,14 +107,14 @@ static const struct vdm_state_transition pe_vdm_state_reactions[] = {
 	),
 #endif	/* CONFIG_USB_PD_CUSTOM_VDM */
 
-#ifdef CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
+#if CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
 	VDM_CABLE_CMD_REACTION(CMD_DISCOVER_IDENT,
 		0,
 		PE_SRC_VDM_IDENTITY_REQUEST
 	),
 #endif /* CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID */
 
-#ifdef CONFIG_USB_PD_DFP_READY_DISCOVER_ID
+#if CONFIG_USB_PD_DFP_READY_DISCOVER_ID
 	VDM_CABLE_CMD_REACTION(CMD_DISCOVER_IDENT,
 		0,
 		PE_DFP_CBL_VDM_IDENTITY_REQUEST
@@ -335,19 +325,19 @@ static inline bool pd_make_vdm_state_transit_nak(struct pd_port *pd_port)
 
 /* Discover Cable ID */
 
-#ifdef CONFIG_PD_DISCOVER_CABLE_ID
+#if CONFIG_PD_DISCOVER_CABLE_ID
 DECL_PE_STATE_TRANSITION(PD_DPM_MSG_DISCOVER_CABLE) = {
-#ifdef CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
+#if CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
 	{ PE_SRC_STARTUP, PE_SRC_VDM_IDENTITY_REQUEST},
 	{ PE_SRC_DISCOVERY, PE_SRC_VDM_IDENTITY_REQUEST},
 #endif
 
-#ifdef CONFIG_USB_PD_DFP_READY_DISCOVER_ID
+#if CONFIG_USB_PD_DFP_READY_DISCOVER_ID
 	{ PE_SRC_READY, PE_DFP_CBL_VDM_IDENTITY_REQUEST},
 	{ PE_SNK_READY, PE_DFP_CBL_VDM_IDENTITY_REQUEST},
 #endif	/* CONFIG_USB_PD_DFP_READY_DISCOVER_ID */
 
-#ifdef CONFIG_PD_SRC_RESET_CABLE
+#if CONFIG_PD_SRC_RESET_CABLE
 	{ PE_SRC_CBL_SEND_SOFT_RESET, PE_SRC_VDM_IDENTITY_REQUEST},
 #endif	/* CONFIG_PD_SRC_RESET_CABLE */
 };
@@ -358,8 +348,8 @@ DECL_PE_STATE_REACTION(PD_DPM_MSG_DISCOVER_CABLE);
  * [BLOCK] Porcess Ctrl MSG
  */
 
-#ifdef CONFIG_USB_PD_ALT_MODE
-#ifdef CONFIG_USB_PD_DBG_DP_UFP_U_AUTO_ATTENTION
+#if CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_DBG_DP_UFP_U_AUTO_ATTENTION
 static inline bool pd_ufp_u_auto_send_attention(struct pd_port *pd_port)
 {
 	struct dp_data *dp_data = pd_get_dp_data(pd_port);
@@ -390,8 +380,8 @@ static inline bool pd_process_ctrl_msg(
 		pd_enable_timer(pd_port, pe_data->vdm_state_timer);
 
 	switch (pd_port->pe_state_curr) {
-#ifdef CONFIG_USB_PD_ALT_MODE
-#ifdef CONFIG_USB_PD_DBG_DP_UFP_U_AUTO_ATTENTION
+#if CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_DBG_DP_UFP_U_AUTO_ATTENTION
 	case PE_UFP_VDM_DP_CONFIGURE:
 		if (pd_ufp_u_auto_send_attention(pd_port))
 			return true;
@@ -404,19 +394,19 @@ static inline bool pd_process_ctrl_msg(
 		break;
 #endif	/* CONFIG_USB_PD_ALT_MODE */
 
-#ifdef CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
+#if CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
 	case PE_SRC_VDM_IDENTITY_REQUEST:
 		pe_data->power_cable_present = true;
 		return false;
 #endif	/* CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID */
 
-#ifdef CONFIG_USB_PD_DFP_READY_DISCOVER_ID
+#if CONFIG_USB_PD_DFP_READY_DISCOVER_ID
 	case PE_DFP_CBL_VDM_IDENTITY_REQUEST:
 		pe_data->power_cable_present = true;
 		return false;
 #endif	/* CONFIG_USB_PD_DFP_READY_DISCOVER_ID */
 
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 	case PE_DFP_UVDM_SEND:
 		if (!pd_port->uvdm_wait_resp) {
 			PE_TRANSIT_STATE(pd_port, PE_DFP_UVDM_ACKED);
@@ -439,7 +429,7 @@ static inline bool pd_process_ctrl_msg(
  * [BLOCK] Porcess Custom MSG (SVDM/UVDM)
  */
 
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 
 bool pd_process_custom_vdm(struct pd_port *pd_port, bool svdm)
 {
@@ -472,7 +462,7 @@ static inline bool pd_process_uvdm(
 {
 	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
-#ifdef CONFIG_USB_PD_UVDM
+#if CONFIG_USB_PD_UVDM
 	/* support sop only */
 	if (pd_event->pd_msg->frame_type != TCPC_TX_SOP)
 		return false;
@@ -521,7 +511,7 @@ static inline const char *assign_vdm_cmd_name(uint8_t cmd)
 	return NULL;
 }
 
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 static const char *const pe_vdm_dp_cmd_name[] = {
 	"DPStatus",
 	"DPConfig",
@@ -558,7 +548,7 @@ static inline void print_vdm_msg(
 
 	name = assign_vdm_cmd_name(cmd);
 
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 	if (name == NULL && svid == USB_SID_DISPLAYPORT)
 		name = assign_vdm_dp_cmd_name(cmd);
 #endif	/* CONFIG_USB_PD_ALT_MODE */
@@ -584,7 +574,7 @@ static inline bool pd_process_sop_vdm(
 	if (pd_make_vdm_state_transit_sop(pd_port))
 		return true;
 
-#ifdef CONFIG_USB_PD_SVDM
+#if CONFIG_USB_PD_SVDM
 	if (pd_process_custom_vdm(pd_port, true))
 		return true;
 #endif	/* CONFIG_USB_PD_SVDM */
@@ -630,8 +620,7 @@ static inline bool pd_process_data_msg(
 	print_vdm_msg(pd_port, pd_event);
 
 	if (pd_port->curr_vdm_svid != USB_SID_PD &&
-		!dpm_get_svdm_svid_data(pd_port, pd_port->curr_vdm_svid) &&
-		pd_port->curr_vdm_svid != USB_VID_MQP) {
+		!dpm_get_svdm_svid_data(pd_port, pd_port->curr_vdm_svid)) {
 		PE_TRANSIT_STATE(pd_port, PE_UFP_VDM_SEND_NAK);
 		ret = true;
 	} else if (pd_msg->frame_type == TCPC_TX_SOP_PRIME) {
@@ -747,15 +736,15 @@ const uint8_t tcp_vdm_evt_init_state[] = {
 	PE_DFP_VDM_MODE_EXIT_REQUEST, /* TCP_DPM_EVT_EXIT_MODE */
 	PE_UFP_VDM_ATTENTION_REQUEST, /* TCP_DPM_EVT_ATTENTION */
 
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 	PE_UFP_VDM_ATTENTION_REQUEST, /* TCP_DPM_EVT_DP_ATTENTION */
-#ifdef CONFIG_USB_PD_ALT_MODE_DFP
+#if CONFIG_USB_PD_ALT_MODE_DFP
 	PE_DFP_VDM_DP_STATUS_UPDATE_REQUEST, /* TCP_DPM_EVT_DP_STATUS_UPDATE */
 	PE_DFP_VDM_DP_CONFIGURATION_REQUEST, /* TCP_DPM_EVT_DP_CONFIG */
 #endif	/* CONFIG_USB_PD_ALT_MODE_DFP */
 #endif	/* CONFIG_USB_PD_ALT_MODE */
 
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 	PE_DFP_UVDM_SEND, /* TCP_DPM_EVT_UVDM */
 #endif	/* CONFIG_USB_PD_CUSTOM_VDM */
 };
@@ -765,7 +754,7 @@ static inline bool pd_process_tcp_cable_event(
 {
 	bool ret;
 	int tcp_ret;
-#ifdef CONFIG_PD_DISCOVER_CABLE_ID
+#if CONFIG_PD_DISCOVER_CABLE_ID
 	bool role_check = true;
 
 	if (pd_check_rev30(pd_port))
@@ -787,7 +776,7 @@ static inline bool pd_process_tcp_cable_event(
 	return ret;
 }
 
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 
 static inline uint32_t tcpc_update_bits(
 	uint32_t var, uint32_t update, uint32_t mask)
@@ -817,7 +806,7 @@ static inline void pd_parse_tcp_dpm_evt_dp_status(struct pd_port *pd_port)
 		dp_data_tcp->val, dp_data_tcp->mask);
 }
 
-#ifdef CONFIG_USB_PD_ALT_MODE_DFP
+#if CONFIG_USB_PD_ALT_MODE_DFP
 
 static inline void pd_parse_tcp_dpm_evt_dp_config(struct pd_port *pd_port)
 {
@@ -833,7 +822,7 @@ static inline void pd_parse_tcp_dpm_evt_dp_config(struct pd_port *pd_port)
 #endif	/* CONFIG_USB_PD_ALT_MODE_DFP */
 #endif	/* CONFIG_USB_PD_ALT_MODE */
 
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 static inline void pd_parse_tcp_dpm_evt_uvdm(struct pd_port *pd_port)
 {
 	struct tcp_dpm_custom_vdm_data *vdm_data =
@@ -844,7 +833,7 @@ static inline void pd_parse_tcp_dpm_evt_uvdm(struct pd_port *pd_port)
 	memcpy(pd_port->uvdm_data,
 		vdm_data->vdos, sizeof(uint32_t) * vdm_data->cnt);
 
-#ifdef CONFIG_USB_PD_SVDM
+#if CONFIG_USB_PD_SVDM
 	if (pd_check_rev30(pd_port) &&
 		(pd_port->uvdm_data[0] & VDO_SVDM_TYPE))
 		pd_port->uvdm_data[0] |= VDO_SVDM_VERS(SVDM_REV20);
@@ -856,13 +845,13 @@ static inline void pd_parse_tcp_dpm_evt_from_tcpm(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
 	switch (pd_event->msg) {
-#ifdef CONFIG_USB_PD_KEEP_SVIDS
+#if CONFIG_USB_PD_KEEP_SVIDS
 	case TCP_DPM_EVT_DISCOVER_SVIDS:
 		pd_port->pe_data.remote_svid_list.cnt = 0;
 		break;
 #endif	/* CONFIG_USB_PD_KEEP_SVIDS */
 
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 	case TCP_DPM_EVT_DISCOVER_MODES:
 	case TCP_DPM_EVT_ENTER_MODE:
 	case TCP_DPM_EVT_EXIT_MODE:
@@ -874,7 +863,7 @@ static inline void pd_parse_tcp_dpm_evt_from_tcpm(
 		pd_parse_tcp_dpm_evt_dp_status(pd_port);
 		break;
 
-#ifdef CONFIG_USB_PD_ALT_MODE_DFP
+#if CONFIG_USB_PD_ALT_MODE_DFP
 	case TCP_DPM_EVT_DP_STATUS_UPDATE:
 		pd_parse_tcp_dpm_evt_dp_status(pd_port);
 		break;
@@ -884,7 +873,7 @@ static inline void pd_parse_tcp_dpm_evt_from_tcpm(
 #endif	/* CONFIG_USB_PD_ALT_MODE_DFP */
 #endif	/* CONFIG_USB_PD_ALT_MODE */
 
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 	case TCP_DPM_EVT_UVDM:
 		pd_parse_tcp_dpm_evt_uvdm(pd_port);
 		break;
diff --git a/drivers/misc/mediatek/typec/tcpc/rt_pd_manager.c b/drivers/misc/mediatek/typec/tcpc/rt_pd_manager.c
index df5c8f5..2cde7d2 100644
--- a/drivers/misc/mediatek/typec/tcpc/rt_pd_manager.c
+++ b/drivers/misc/mediatek/typec/tcpc/rt_pd_manager.c
@@ -1,40 +1,57 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2021 MediaTek Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
+ * Copyright (c) 2021 MediaTek Inc.
  */
 
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/platform_device.h>
+#include <linux/power_supply.h>
 #include <linux/usb/typec.h>
+#include <linux/usb/typec_mux.h>
 
 #include "inc/tcpci_typec.h"
-#include <mt-plat/charger_class.h>
-#include <mt-plat/mtk_boot.h>
-#include <mt-plat/mtk_charger.h>
-#include "../../accdet/mt6359/accdet.h"
-#include <linux/soc/mediatek/ocp96011-i2c.h>
-
-#define RT_PD_MANAGER_VERSION	"1.0.6_MTK"
-#ifndef CONFIG_CHARGE_MACRO_P530
-extern bool batt_protect_powerpath;
-#endif
+#if IS_ENABLED(CONFIG_MTK_CHARGER)
+#include <charger_class.h>
+#endif /* CONFIG_MTK_CHARGER */
+
+#define RT_PD_MANAGER_VERSION	"1.0.8"
+
+struct typec_port {
+	unsigned int			id;
+	struct device			dev;
+	struct ida			mode_ids;
+
+	int				prefer_role;
+	enum typec_data_role		data_role;
+	enum typec_role			pwr_role;
+	enum typec_role			vconn_role;
+	enum typec_pwr_opmode		pwr_opmode;
+	enum typec_port_type		port_type;
+	struct mutex			port_type_lock;
+
+	enum typec_orientation		orientation;
+	struct typec_switch		*sw;
+	struct typec_mux		*mux;
+
+	const struct typec_capability	*cap;
+	const struct typec_operations   *ops;
+};
+
 struct rt_pd_manager_data {
 	struct device *dev;
+#if IS_ENABLED(CONFIG_MTK_CHARGER)
 	struct charger_device *chg_dev;
-	struct charger_consumer *chg_consumer;
+#if CONFIG_WATER_DETECTION
+	struct power_supply *chg_psy;
+#endif /* CONFIG_WATER_DETECTION */
+#endif /* CONFIG_MTK_CHARGER */
 	struct tcpc_device *tcpc;
 	struct notifier_block pd_nb;
+#if CONFIG_WATER_DETECTION
 	bool tcpc_kpoc;
+#endif /* CONFIG_WATER_DETECTION */
 	int sink_mv_new;
 	int sink_ma_new;
 	int sink_mv_old;
@@ -52,10 +69,6 @@ void __attribute__((weak)) usb_dpdm_pulldown(bool enable)
 	pr_notice("%s is not defined\n", __func__);
 }
 
-#if defined(CONFIG_OCP96011_I2C)
-extern void typec_headphone_irq_handler(int state);
-#endif
-
 static int pd_tcp_notifier_call(struct notifier_block *nb,
 				unsigned long event, void *data)
 {
@@ -66,40 +79,24 @@ static int pd_tcp_notifier_call(struct notifier_block *nb,
 	uint8_t old_state = TYPEC_UNATTACHED, new_state = TYPEC_UNATTACHED;
 	enum typec_pwr_opmode opmode = TYPEC_PWR_MODE_USB;
 	uint32_t partner_vdos[VDO_MAX_NR];
+	struct typec_mux_state state;
+#if CONFIG_WATER_DETECTION
+#if IS_ENABLED(CONFIG_MTK_CHARGER)
+	union power_supply_propval val = {.intval = 0};
+#endif /* CONFIG_MTK_CHARGER */
+#endif /* CONFIG_WATER_DETECTION */
 
 	switch (event) {
 	case TCP_NOTIFY_SINK_VBUS:
-		rpmd->sink_mv_new = noti->vbus_state.mv;
-		rpmd->sink_ma_new = noti->vbus_state.ma;
-		dev_info(rpmd->dev, "%s sink vbus %dmV %dmA type(0x%02X)\n",
-				    __func__, rpmd->sink_mv_new,
-				    rpmd->sink_ma_new, noti->vbus_state.type);
-
-		if ((rpmd->sink_mv_new != rpmd->sink_mv_old) ||
-		    (rpmd->sink_ma_new != rpmd->sink_ma_old)) {
-			rpmd->sink_mv_old = rpmd->sink_mv_new;
-			rpmd->sink_ma_old = rpmd->sink_ma_new;
-			if (rpmd->sink_mv_new && rpmd->sink_ma_new) {
-#ifndef CONFIG_CHARGE_MACRO_P530
-				if (batt_protect_powerpath) {
-#endif
-					charger_manager_enable_power_path(
-						rpmd->chg_consumer, MAIN_CHARGER, true);
-#ifndef CONFIG_CHARGE_MACRO_P530
-				} else {
-					pr_info("%s batt_protect_powerpath=%d\n", __func__,batt_protect_powerpath);
-				}
-#endif
-			} else if (!rpmd->tcpc_kpoc) {
-				charger_manager_enable_power_path(
-					rpmd->chg_consumer, MAIN_CHARGER,
-					false);
-			}
-		}
 		break;
 	case TCP_NOTIFY_TYPEC_STATE:
 		old_state = noti->typec_state.old_state;
 		new_state = noti->typec_state.new_state;
+
+		state.data = noti;
+		state.mode = TCP_NOTIFY_TYPEC_STATE;
+		typec_mux_set(rpmd->typec_port->mux, &state);
+
 		if (old_state == TYPEC_UNATTACHED &&
 		    (new_state == TYPEC_ATTACHED_SNK ||
 		     new_state == TYPEC_ATTACHED_NORP_SRC ||
@@ -119,6 +116,11 @@ static int pd_tcp_notifier_call(struct notifier_block *nb,
 					     noti->typec_state.rp_level -
 					     TYPEC_CC_VOLT_SNK_DFT);
 			typec_set_vconn_role(rpmd->typec_port, TYPEC_SINK);
+			/* set typec switch orientation */
+			typec_set_orientation(rpmd->typec_port,
+					noti->typec_state.polarity ?
+					TYPEC_ORIENTATION_NORMAL :
+					TYPEC_ORIENTATION_REVERSE);
 		} else if ((old_state == TYPEC_ATTACHED_SNK ||
 			    old_state == TYPEC_ATTACHED_NORP_SRC ||
 			    old_state == TYPEC_ATTACHED_CUSTOM_SRC ||
@@ -140,19 +142,24 @@ static int pd_tcp_notifier_call(struct notifier_block *nb,
 			typec_set_data_role(rpmd->typec_port, TYPEC_HOST);
 			typec_set_pwr_role(rpmd->typec_port, TYPEC_SOURCE);
 			switch (noti->typec_state.local_rp_level) {
-			case TYPEC_RP_3_0:
+			case TYPEC_CC_RP_3_0:
 				opmode = TYPEC_PWR_MODE_3_0A;
 				break;
-			case TYPEC_RP_1_5:
+			case TYPEC_CC_RP_1_5:
 				opmode = TYPEC_PWR_MODE_1_5A;
 				break;
-			case TYPEC_RP_DFT:
+			case TYPEC_CC_RP_DFT:
 			default:
 				opmode = TYPEC_PWR_MODE_USB;
 				break;
 			}
 			typec_set_pwr_opmode(rpmd->typec_port, opmode);
 			typec_set_vconn_role(rpmd->typec_port, TYPEC_SOURCE);
+			/* set typec switch orientation */
+			typec_set_orientation(rpmd->typec_port,
+					noti->typec_state.polarity ?
+					TYPEC_ORIENTATION_NORMAL :
+					TYPEC_ORIENTATION_REVERSE);
 		} else if ((old_state == TYPEC_ATTACHED_SRC ||
 			    old_state == TYPEC_ATTACHED_DEBUG) &&
 			    new_state == TYPEC_UNATTACHED) {
@@ -162,23 +169,18 @@ static int pd_tcp_notifier_call(struct notifier_block *nb,
 			   new_state == TYPEC_ATTACHED_AUDIO) {
 			dev_info(rpmd->dev, "%s Audio plug in\n", __func__);
 			/* enable AudioAccessory connection */
-#if defined(CONFIG_OCP96011_I2C)
-			ocp96011_switch_event(0);
-			typec_headphone_irq_handler(1);
-#endif
 		} else if (old_state == TYPEC_ATTACHED_AUDIO &&
 			   new_state == TYPEC_UNATTACHED) {
 			dev_info(rpmd->dev, "%s Audio plug out\n", __func__);
 			/* disable AudioAccessory connection */
-#if defined(CONFIG_OCP96011_I2C)
-			ocp96011_switch_event(1);
-			typec_headphone_irq_handler(0);
-#endif
 		}
 
 		if (new_state == TYPEC_UNATTACHED) {
 			typec_unregister_partner(rpmd->partner);
 			rpmd->partner = NULL;
+			/* set typec switch orientation */
+			typec_set_orientation(rpmd->typec_port,
+					      TYPEC_ORIENTATION_NONE);
 			if (rpmd->typec_caps.prefer_role == TYPEC_SOURCE) {
 				typec_set_data_role(rpmd->typec_port,
 						    TYPEC_HOST);
@@ -220,10 +222,12 @@ static int pd_tcp_notifier_call(struct notifier_block *nb,
 			}
 			rpmd->partner = typec_register_partner(rpmd->typec_port,
 					&rpmd->partner_desc);
-			if (!rpmd->partner)
+			if (IS_ERR(rpmd->partner)) {
+				ret = PTR_ERR(rpmd->partner);
 				dev_notice(rpmd->dev,
-					   "%s typec register partner fail\n",
-					   __func__);
+				"%s typec register partner fail(%d)\n",
+					   __func__, ret);
+			}
 		}
 		break;
 	case TCP_NOTIFY_PR_SWAP:
@@ -285,7 +289,9 @@ static int pd_tcp_notifier_call(struct notifier_block *nb,
 	case TCP_NOTIFY_EXT_DISCHARGE:
 		dev_info(rpmd->dev, "%s ext discharge = %d\n",
 				    __func__, noti->en_state.en);
+#if IS_ENABLED(CONFIG_MTK_CHARGER)
 		charger_dev_enable_discharge(rpmd->chg_dev, noti->en_state.en);
+#endif /* CONFIG_MTK_CHARGER */
 		break;
 	case TCP_NOTIFY_PD_STATE:
 		dev_info(rpmd->dev, "%s pd state = %d\n",
@@ -315,6 +321,7 @@ static int pd_tcp_notifier_call(struct notifier_block *nb,
 			break;
 		};
 		break;
+#if CONFIG_WATER_DETECTION
 	case TCP_NOTIFY_WD_STATUS:
 		dev_info(rpmd->dev, "%s wd status = %d\n",
 				    __func__, noti->wd_status.water_detected);
@@ -325,32 +332,50 @@ static int pd_tcp_notifier_call(struct notifier_block *nb,
 				break;
 			dev_info(rpmd->dev, "%s Water is detected in KPOC\n",
 					    __func__);
-			charger_manager_enable_high_voltage_charging(
-					rpmd->chg_consumer, false);
+#if IS_ENABLED(CONFIG_MTK_CHARGER)
+			val.intval = 0;
+			power_supply_set_property(rpmd->chg_psy,
+						  POWER_SUPPLY_PROP_VOLTAGE_MAX,
+						  &val);
+#endif /* CONFIG_MTK_CHARGER */
 		} else {
 			usb_dpdm_pulldown(true);
 			if (!rpmd->tcpc_kpoc)
 				break;
 			dev_info(rpmd->dev, "%s Water is removed in KPOC\n",
 					    __func__);
-			charger_manager_enable_high_voltage_charging(
-					rpmd->chg_consumer, true);
+#if IS_ENABLED(CONFIG_MTK_CHARGER)
+			val.intval = 1;
+			power_supply_set_property(rpmd->chg_psy,
+						  POWER_SUPPLY_PROP_VOLTAGE_MAX,
+						  &val);
+#endif /* CONFIG_MTK_CHARGER */
 		}
 		break;
+#endif /* CONFIG_WATER_DETECTION */
 	case TCP_NOTIFY_CABLE_TYPE:
 		dev_info(rpmd->dev, "%s cable type = %d\n",
 				    __func__, noti->cable_type.type);
 		break;
+	case TCP_NOTIFY_AMA_DP_HPD_STATE:
+		state.data = noti;
+		state.mode = TCP_NOTIFY_AMA_DP_HPD_STATE;
+		typec_mux_set(rpmd->typec_port->mux, &state);
+		break;
+	case TCP_NOTIFY_AMA_DP_STATE:
+		state.mode = TCP_NOTIFY_AMA_DP_STATE;
+		state.data = noti;
+		typec_mux_set(rpmd->typec_port->mux, &state);
+		break;
 	default:
 		break;
 	};
 	return NOTIFY_OK;
 }
 
-static int tcpc_typec_try_role(const struct typec_capability *cap, int role)
+static int tcpc_typec_try_role(struct typec_port *port, int role)
 {
-	struct rt_pd_manager_data *rpmd =
-		container_of(cap, struct rt_pd_manager_data, typec_caps);
+	struct rt_pd_manager_data *rpmd = dev_get_drvdata(&port->dev);
 	uint8_t typec_role = TYPEC_ROLE_UNKNOWN;
 
 	dev_info(rpmd->dev, "%s role = %d\n", __func__, role);
@@ -372,12 +397,10 @@ static int tcpc_typec_try_role(const struct typec_capability *cap, int role)
 	return tcpm_typec_change_role_postpone(rpmd->tcpc, typec_role, true);
 }
 
-static int tcpc_typec_dr_set(const struct typec_capability *cap,
-			     enum typec_data_role role)
+static int tcpc_typec_dr_set(struct typec_port *port, enum typec_data_role role)
 {
 	int ret = 0;
-	struct rt_pd_manager_data *rpmd =
-		container_of(cap, struct rt_pd_manager_data, typec_caps);
+	struct rt_pd_manager_data *rpmd = dev_get_drvdata(&port->dev);
 	uint8_t data_role = tcpm_inquire_pd_data_role(rpmd->tcpc);
 	bool do_swap = false;
 
@@ -410,12 +433,10 @@ static int tcpc_typec_dr_set(const struct typec_capability *cap,
 	return 0;
 }
 
-static int tcpc_typec_pr_set(const struct typec_capability *cap,
-			     enum typec_role role)
+static int tcpc_typec_pr_set(struct typec_port *port, enum typec_role role)
 {
 	int ret = 0;
-	struct rt_pd_manager_data *rpmd =
-		container_of(cap, struct rt_pd_manager_data, typec_caps);
+	struct rt_pd_manager_data *rpmd = dev_get_drvdata(&port->dev);
 	uint8_t power_role = tcpm_inquire_pd_power_role(rpmd->tcpc);
 	bool do_swap = false;
 
@@ -450,12 +471,10 @@ static int tcpc_typec_pr_set(const struct typec_capability *cap,
 	return 0;
 }
 
-static int tcpc_typec_vconn_set(const struct typec_capability *cap,
-				enum typec_role role)
+static int tcpc_typec_vconn_set(struct typec_port *port, enum typec_role role)
 {
 	int ret = 0;
-	struct rt_pd_manager_data *rpmd =
-		container_of(cap, struct rt_pd_manager_data, typec_caps);
+	struct rt_pd_manager_data *rpmd = dev_get_drvdata(&port->dev);
 	uint8_t vconn_role = tcpm_inquire_pd_vconn_role(rpmd->tcpc);
 	bool do_swap = false;
 
@@ -488,11 +507,9 @@ static int tcpc_typec_vconn_set(const struct typec_capability *cap,
 	return 0;
 }
 
-static int tcpc_typec_port_type_set(const struct typec_capability *cap,
-				    enum typec_port_type type)
+static int tcpc_typec_port_type_set(struct typec_port *port, enum typec_port_type type)
 {
-	struct rt_pd_manager_data *rpmd =
-		container_of(cap, struct rt_pd_manager_data, typec_caps);
+	struct rt_pd_manager_data *rpmd = dev_get_drvdata(&port->dev);
 	bool as_sink = tcpc_typec_is_act_as_sink_role(rpmd->tcpc);
 	uint8_t typec_role = TYPEC_ROLE_UNKNOWN;
 
@@ -500,18 +517,18 @@ static int tcpc_typec_port_type_set(const struct typec_capability *cap,
 			    __func__, type, as_sink);
 
 	switch (type) {
-	case TYPEC_PORT_UFP:
+	case TYPEC_PORT_SNK:
 		if (as_sink)
 			return 0;
 		break;
-	case TYPEC_PORT_DFP:
+	case TYPEC_PORT_SRC:
 		if (!as_sink)
 			return 0;
 		break;
 	case TYPEC_PORT_DRP:
-		if (cap->prefer_role == TYPEC_SOURCE)
+		if (rpmd->typec_caps.prefer_role == TYPEC_SOURCE)
 			typec_role = TYPEC_ROLE_TRY_SRC;
-		else if (cap->prefer_role == TYPEC_SINK)
+		else if (rpmd->typec_caps.prefer_role == TYPEC_SINK)
 			typec_role = TYPEC_ROLE_TRY_SNK;
 		else
 			typec_role = TYPEC_ROLE_DRP;
@@ -523,13 +540,24 @@ static int tcpc_typec_port_type_set(const struct typec_capability *cap,
 	return tcpm_typec_role_swap(rpmd->tcpc);
 }
 
+static const struct typec_operations rt_pd_ops = {
+	.try_role = tcpc_typec_try_role,
+	.dr_set = tcpc_typec_dr_set,
+	.pr_set = tcpc_typec_pr_set,
+	.vconn_set = tcpc_typec_vconn_set,
+	.port_type_set = tcpc_typec_port_type_set
+};
+
 static int typec_init(struct rt_pd_manager_data *rpmd)
 {
 	int ret = 0;
 
 	rpmd->typec_caps.type = TYPEC_PORT_DRP;
+	rpmd->typec_caps.data = TYPEC_PORT_DRD;
 	rpmd->typec_caps.revision = 0x0120;
 	rpmd->typec_caps.pd_revision = 0x0300;
+	rpmd->typec_caps.driver_data = rpmd;
+	rpmd->typec_caps.fwnode = rpmd->tcpc->dev.parent->fwnode;
 	switch (rpmd->tcpc->desc.role_def) {
 	case TYPEC_ROLE_SRC:
 	case TYPEC_ROLE_TRY_SRC:
@@ -543,22 +571,19 @@ static int typec_init(struct rt_pd_manager_data *rpmd)
 		rpmd->typec_caps.prefer_role = TYPEC_NO_PREFERRED_ROLE;
 		break;
 	}
-	rpmd->typec_caps.try_role = tcpc_typec_try_role;
-	rpmd->typec_caps.dr_set = tcpc_typec_dr_set;
-	rpmd->typec_caps.pr_set = tcpc_typec_pr_set;
-	rpmd->typec_caps.vconn_set = tcpc_typec_vconn_set;
-	rpmd->typec_caps.port_type_set = tcpc_typec_port_type_set;
+	rpmd->typec_caps.ops = &rt_pd_ops;
 
 	rpmd->typec_port = typec_register_port(rpmd->dev, &rpmd->typec_caps);
-	if (!rpmd->typec_port) {
-		ret = -ENOMEM;
+
+	ret = PTR_ERR_OR_ZERO(rpmd->typec_port);
+	if (ret) {
 		dev_notice(rpmd->dev, "%s typec register port fail(%d)\n",
 				      __func__, ret);
-		goto out;
+		rpmd->typec_port = NULL;
+		return -EINVAL;
 	}
 
 	rpmd->partner_desc.identity = &rpmd->partner_identity;
-out:
 	return ret;
 }
 
@@ -575,6 +600,7 @@ static int rt_pd_manager_probe(struct platform_device *pdev)
 
 	rpmd->dev = &pdev->dev;
 
+#if IS_ENABLED(CONFIG_MTK_CHARGER)
 	rpmd->chg_dev = get_charger_by_name("primary_chg");
 	if (!rpmd->chg_dev) {
 		dev_notice(rpmd->dev, "%s get chg dev fail\n", __func__);
@@ -582,13 +608,15 @@ static int rt_pd_manager_probe(struct platform_device *pdev)
 		goto err_get_chg_dev;
 	}
 
-	rpmd->chg_consumer = charger_manager_get_by_name(rpmd->dev,
-							 "charger_port1");
-	if (!rpmd->chg_consumer) {
-		dev_notice(rpmd->dev, "%s get chg consumer fail\n", __func__);
+#if CONFIG_WATER_DETECTION
+	rpmd->chg_psy = power_supply_get_by_name("mtk-master-charger");
+	if (!rpmd->chg_psy) {
+		dev_notice(rpmd->dev, "%s get chg psy fail\n", __func__);
 		ret = -ENODEV;
-		goto err_get_chg_consumer;
+		goto err_get_chg_psy;
 	}
+#endif /* CONFIG_WATER_DETECTION */
+#endif /* CONFIG_MTK_CHARGER */
 
 	rpmd->tcpc = tcpc_dev_get_by_name("type_c_port0");
 	if (!rpmd->tcpc) {
@@ -597,13 +625,16 @@ static int rt_pd_manager_probe(struct platform_device *pdev)
 		goto err_get_tcpc_dev;
 	}
 
-	ret = get_boot_mode();
-	if (ret == KERNEL_POWER_OFF_CHARGING_BOOT ||
-	    ret == LOW_POWER_OFF_CHARGING_BOOT)
+#if CONFIG_WATER_DETECTION
+	/* 8 = KERNEL_POWER_OFF_CHARGING_BOOT */
+	/* 9 = LOW_POWER_OFF_CHARGING_BOOT */
+	ret = rpmd->tcpc->bootmode;
+	if (ret == 8 || ret == 9)
 		rpmd->tcpc_kpoc = true;
 	else
 		rpmd->tcpc_kpoc = false;
 	dev_info(rpmd->dev, "%s tcpc_kpoc = %d\n", __func__, rpmd->tcpc_kpoc);
+#endif /* CONFIG_WATER_DETECTION */
 
 	rpmd->sink_mv_old = -1;
 	rpmd->sink_ma_old = -1;
@@ -632,8 +663,13 @@ err_reg_tcpc_notifier:
 	typec_unregister_port(rpmd->typec_port);
 err_init_typec:
 err_get_tcpc_dev:
-err_get_chg_consumer:
+#if IS_ENABLED(CONFIG_MTK_CHARGER)
+#if CONFIG_WATER_DETECTION
+	power_supply_put(rpmd->chg_psy);
+err_get_chg_psy:
+#endif /* CONFIG_WATER_DETECTION */
 err_get_chg_dev:
+#endif /* CONFIG_MTK_CHARGER */
 	return ret;
 }
 
@@ -652,6 +688,11 @@ static int rt_pd_manager_remove(struct platform_device *pdev)
 				      __func__, ret);
 
 	typec_unregister_port(rpmd->typec_port);
+#if IS_ENABLED(CONFIG_MTK_CHARGER)
+#if CONFIG_WATER_DETECTION
+	power_supply_put(rpmd->chg_psy);
+#endif /* CONFIG_WATER_DETECTION */
+#endif /* CONFIG_MTK_CHARGER */
 
 	return ret;
 }
@@ -690,8 +731,15 @@ MODULE_VERSION(RT_PD_MANAGER_VERSION);
 
 /*
  * Release Note
- * 1.0.6
+ * 1.0.8
  * (1) Register typec_port
  * (2) Remove unused parts
  * (3) Add rt_pd_manager_remove()
+ *
+ * 1.0.7
+ * (1) enable power path in sink vbus
+ *
+ * 1.0.6
+ * (1) refactor data struct and remove unuse part
+ * (2) move bc12 relative to charger ic driver
  */
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpc_mt6360.c b/drivers/misc/mediatek/typec/tcpc/tcpc_mt6360.c
index d0d93a0..30187a1 100644
--- a/drivers/misc/mediatek/typec/tcpc/tcpc_mt6360.c
+++ b/drivers/misc/mediatek/typec/tcpc/tcpc_mt6360.c
@@ -1,14 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2018 MediaTek Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include <linux/init.h>
@@ -36,21 +28,18 @@
 #include "inc/mt6360.h"
 #include "inc/tcpci_typec.h"
 
-#ifdef CONFIG_RT_REGMAP
-#include <mt-plat/rt-regmap.h>
+#if IS_ENABLED(CONFIG_RT_REGMAP)
+#include <rt-regmap.h>
 #endif /* CONFIG_RT_REGMAP */
 
-#if 1 /*  #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))*/
 #include <linux/sched/rt.h>
-#endif /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)) */
 
-#if defined(CONFIG_WATER_DETECTION) || defined(CONFIG_CABLE_TYPE_DETECTION)
-#if CONFIG_MTK_GAUGE_VERSION == 30
-#include <mt-plat/charger_class.h>
-#endif /* CONFIG_MTK_GAUGE_VERSION == 30 */
+#if CONFIG_WATER_DETECTION || CONFIG_CABLE_TYPE_DETECTION
+#include <charger_class.h>
 #endif /* CONFIG_WATER_DETECTION || CONFIG_CABLE_TYPE_DETECTION */
 
 /* #define DEBUG_GPIO	66 */
+#define DEBUG_GPIO 0
 
 #define MT6360_DRV_VERSION	"2.0.7_MTK"
 
@@ -65,7 +54,7 @@
 struct mt6360_chip {
 	struct i2c_client *client;
 	struct device *dev;
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	struct rt_regmap_device *m_dev;
 #endif /* CONFIG_RT_REGMAP */
 	struct semaphore io_lock;
@@ -78,25 +67,22 @@ struct mt6360_chip {
 	struct wakeup_source *irq_wake_lock;
 	struct wakeup_source *i2c_wake_lock;
 
-	atomic_t poll_count;
-	struct delayed_work poll_work;
-
 	int irq_gpio;
 	int irq;
 	int chip_id;
 
-#ifdef CONFIG_MTK_TYPEC_WATER_DETECT_BY_PCB
+#if IS_ENABLED(CONFIG_MTK_TYPEC_WATER_DETECT_BY_PCB)
 	int pcb_gpio;
 	int pcb_gpio_polarity;
 #endif /* CONFIG_MTK_TYPEC_WATER_DETECT_BY_PCB */
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 	atomic_t wd_protect_rty;
 	struct wakeup_source *wd_wakeup_src;
 #endif /* CONFIG_WATER_DETECTION */
 
-#ifdef CONFIG_WD_SBU_POLLING
-#ifdef CONFIG_WD_POLLING_ONLY
+#if CONFIG_WD_SBU_POLLING
+#if CONFIG_WD_POLLING_ONLY
 	struct delayed_work usbid_poll_work;
 #endif /* CONFIG_WD_POLLING_ONLY */
 	struct work_struct wd_work;
@@ -104,19 +90,16 @@ struct mt6360_chip {
 	bool usbid_irqen;
 #endif /* CONFIG_WD_SBU_POLLING */
 
-#ifdef CONFIG_CABLE_TYPE_DETECTION
+#if CONFIG_CABLE_TYPE_DETECTION
 	bool handle_init_ctd;
 	enum tcpc_cable_type init_cable_type;
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
 
-#if defined(CONFIG_WATER_DETECTION) || defined(CONFIG_CABLE_TYPE_DETECTION)
-#if CONFIG_MTK_GAUGE_VERSION == 30
+#if CONFIG_WATER_DETECTION || CONFIG_CABLE_TYPE_DETECTION
 	struct charger_device *chgdev;
-#endif /* CONFIG_MTK_GAUGE_VERSION == 30 */
 #endif /* CONFIG_WATER_DETECTION || CONFIG_CABLE_TYPE_DETECTION */
 };
 
-struct mt6360_chip *g_chip = NULL;
 static const u8 mt6360_vend_alert_clearall[MT6360_VEND_INT_MAX] = {
 	0x3F, 0xDF, 0xFF, 0xFF, 0xFF,
 };
@@ -125,7 +108,7 @@ static const u8 mt6360_vend_alert_maskall[MT6360_VEND_INT_MAX] = {
 	0x00, 0x00, 0x00, 0x00, 0x00,
 };
 
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 RT_REG_DECL(TCPC_V10_REG_VID, 2, RT_NORMAL, {});
 RT_REG_DECL(TCPC_V10_REG_PID, 2, RT_NORMAL, {});
 RT_REG_DECL(TCPC_V10_REG_DID, 2, RT_NORMAL, {});
@@ -385,7 +368,7 @@ static int mt6360_reg_read(struct i2c_client *i2c, u8 reg, u8 *data)
 	int ret;
 	struct mt6360_chip *chip = i2c_get_clientdata(i2c);
 
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	ret = rt_regmap_block_read(chip->m_dev, reg, 1, data);
 #else
 	ret = mt6360_read_device(chip->client, reg, 1, data);
@@ -402,7 +385,7 @@ static int mt6360_reg_write(struct i2c_client *i2c, u8 reg, const u8 data)
 	int ret;
 	struct mt6360_chip *chip = i2c_get_clientdata(i2c);
 
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	ret = rt_regmap_block_write(chip->m_dev, reg, 1, &data);
 #else
 	ret = mt6360_write_device(chip->client, reg, 1, &data);
@@ -417,7 +400,7 @@ static int mt6360_block_read(struct i2c_client *i2c, u8 reg, int len, void *dst)
 	int ret;
 	struct mt6360_chip *chip = i2c_get_clientdata(i2c);
 
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	ret = rt_regmap_block_read(chip->m_dev, reg, len, dst);
 #else
 	ret = mt6360_read_device(chip->client, reg, len, dst);
@@ -433,7 +416,7 @@ static int mt6360_block_write(struct i2c_client *i2c, u8 reg, int len,
 	int ret;
 	struct mt6360_chip *chip = i2c_get_clientdata(i2c);
 
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	ret = rt_regmap_block_write(chip->m_dev, reg, len, src);
 #else
 	ret = mt6360_write_device(chip->client, reg, len, src);
@@ -562,7 +545,7 @@ static inline int mt6360_i2c_clr_bit(struct tcpc_device *tcpc, u8 reg, u8 mask)
 	return mt6360_i2c_update_bits(tcpc, reg, 0x00, mask);
 }
 
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 static struct rt_regmap_fops mt6360_regmap_fops = {
 	.read_device = mt6360_read_device,
 	.write_device = mt6360_write_device,
@@ -572,7 +555,7 @@ static int mt6360_regmap_init(struct mt6360_chip *chip)
 {
 	struct rt_regmap_properties *props;
 	char name[32];
-	int len, ret;
+	int len;
 
 	props = devm_kzalloc(chip->dev, sizeof(*props), GFP_KERNEL);
 	if (!props)
@@ -583,8 +566,8 @@ static int mt6360_regmap_init(struct mt6360_chip *chip)
 	props->rt_regmap_mode = RT_MULTI_BYTE |
 				RT_IO_PASS_THROUGH | RT_DBG_SPECIAL;
 
-	ret = snprintf(name, sizeof(name), "mt6360-%02x", chip->client->addr);
-	if (ret < 0)
+	len = snprintf(name, sizeof(name), "mt6360-%02x", chip->client->addr);
+	if (len < 0 || len > 32)
 		return -EINVAL;
 	len = strlen(name);
 	props->name = kzalloc(len + 1, GFP_KERNEL);
@@ -612,14 +595,14 @@ static void mt6360_regmap_deinit(struct mt6360_chip *chip)
 static inline int mt6360_software_reset(struct tcpc_device *tcpc)
 {
 	int ret;
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	struct mt6360_chip *chip = tcpc_get_dev_data(tcpc);
 #endif /* CONFIG_RT_REGMAP */
 
 	ret = mt6360_i2c_write8(tcpc, MT6360_REG_SWRESET, 1);
 	if (ret < 0)
 		return ret;
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	rt_regmap_cache_reload(chip->m_dev);
 #endif /* CONFIG_RT_REGMAP */
 	usleep_range(1000, 2000);
@@ -661,21 +644,21 @@ static int mt6360_init_vend_mask(struct tcpc_device *tcpc)
 				  MT6360_M_VCONN_OV_CC2 |
 				  MT6360_M_VCONN_OCR |
 				  MT6360_M_VCONN_INVALID;
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	mask[MT6360_VEND_INT1] |= MT6360_M_VBUS_SAFE0V;
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 
-#ifdef CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
+#if CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
 	if (tcpc->tcpc_flags & TCPC_FLAGS_LPM_WAKEUP_WATCHDOG)
 		mask[MT6360_VEND_INT1] |= MT6360_M_WAKEUP;
 #endif	/* CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG */
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 	if (tcpc->tcpc_flags & TCPC_FLAGS_WATER_DETECTION)
 		mask[MT6360_VEND_INT2] |= MT6360_M_WD_EVT;
 #endif /* CONFIG_WATER_DETECTION */
 
-#ifdef CONFIG_CABLE_TYPE_DETECTION
+#if CONFIG_CABLE_TYPE_DETECTION
 	if (tcpc->tcpc_flags & TCPC_FLAGS_CABLE_TYPE_DETECTION)
 		mask[MT6360_VEND_INT3] |= MT6360_M_CTD;
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
@@ -690,7 +673,7 @@ static int __mt6360_init_alert_mask(struct tcpc_device *tcpc)
 		   TCPC_V10_REG_ALERT_POWER_STATUS |
 		   TCPC_V10_REG_ALERT_VENDOR_DEFINED;
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	mask |= TCPC_V10_REG_ALERT_TX_SUCCESS |
 		TCPC_V10_REG_ALERT_TX_DISCARDED |
 		TCPC_V10_REG_ALERT_TX_FAILED |
@@ -715,7 +698,7 @@ static int mt6360_init_alert_mask(struct tcpc_device *tcpc)
 	mt6360_init_ext_mask(tcpc);
 	mt6360_init_vend_mask(tcpc);
 
-#ifdef CONFIG_CABLE_TYPE_DETECTION
+#if CONFIG_CABLE_TYPE_DETECTION
 	if (chip->handle_init_ctd) {
 		chip->handle_init_ctd = false;
 		tcpc_typec_handle_ctd(tcpc, chip->init_cable_type);
@@ -725,28 +708,15 @@ static int mt6360_init_alert_mask(struct tcpc_device *tcpc)
 	return 0;
 }
 
-static inline void mt6360_poll_ctrl(struct mt6360_chip *chip)
-{
-	cancel_delayed_work_sync(&chip->poll_work);
-
-	if (atomic_read(&chip->poll_count) == 0) {
-		atomic_inc(&chip->poll_count);
-		cpu_idle_poll_ctrl(true);
-	}
-
-	schedule_delayed_work(&chip->poll_work, msecs_to_jiffies(40));
-}
-
 static void mt6360_irq_work_handler(struct kthread_work *work)
 {
 	int regval, gpio_val;
 	struct mt6360_chip *chip = container_of(work, struct mt6360_chip,
 						irq_work);
 
-	mt6360_poll_ctrl(chip);
 	tcpci_lock_typec(chip->tcpc);
 
-#ifdef DEBUG_GPIO
+#if DEBUG_GPIO
 	gpio_set_value(DEBUG_GPIO, 1);
 #endif /* DEBUG_GPIO */
 
@@ -759,35 +729,22 @@ static void mt6360_irq_work_handler(struct kthread_work *work)
 
 	tcpci_unlock_typec(chip->tcpc);
 
-#ifdef DEBUG_GPIO
+#if DEBUG_GPIO
 	gpio_set_value(DEBUG_GPIO, 1);
 #endif /* DEBUG_GPIO */
 }
 
-static void mt6360_poll_work(struct work_struct *work)
-{
-	struct mt6360_chip *chip = container_of(work, struct mt6360_chip,
-						poll_work.work);
-
-	if (atomic_dec_and_test(&chip->poll_count))
-		cpu_idle_poll_ctrl(false);
-}
-
 static irqreturn_t mt6360_intr_handler(int irq, void *data)
 {
 	struct mt6360_chip *chip = data;
 
 	__pm_wakeup_event(chip->irq_wake_lock, MT6360_IRQ_WAKE_TIME);
 
-#ifdef DEBUG_GPIO
+#if DEBUG_GPIO
 	gpio_set_value(DEBUG_GPIO, 0);
 #endif
 
-#if 1 /* (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)) */
 	kthread_queue_work(&chip->irq_worker, &chip->irq_work);
-#else
-	queue_kthread_work(&chip->irq_worker, &chip->irq_work);
-#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0) */
 	return IRQ_HANDLED;
 }
 
@@ -817,7 +774,7 @@ static inline int mt6360_enable_auto_rpconnect(struct tcpc_device *tcpc,
 		(tcpc, MT6360_REG_CTD_CTRL2, MT6360_DIS_RPDET);
 }
 
-#ifdef CONFIG_WD_SBU_POLLING
+#if CONFIG_WD_SBU_POLLING
 static int mt6360_get_cc(struct tcpc_device *tcpc, int *cc1, int *cc2);
 static void mt6360_enable_usbid_irq(struct mt6360_chip *chip, bool en);
 
@@ -866,12 +823,14 @@ static void mt6360_wd_work(struct work_struct *work)
 	if (cc1 != TYPEC_CC_DRP_TOGGLING || cc2 != TYPEC_CC_DRP_TOGGLING)
 		goto out;
 
+#if CONFIG_WATER_DETECTION
 	ret = tcpci_is_water_detected(chip->tcpc);
 	if (ret <= 0) {
 		mt6360_enable_usbid_polling(chip, true);
 		goto out;
 	}
 	tcpc_typec_handle_wd(chip->tcpc, true);
+#endif
 out:
 	tcpci_unlock_typec(chip->tcpc);
 }
@@ -903,12 +862,12 @@ struct mt6360_pmu_irq_desc {
 #define MT6360_PMU_IRQDESC(name) {#name, mt6360_pmu_##name##_handler, -1}
 
 static struct mt6360_pmu_irq_desc mt6360_pmu_tcpc_irq_desc[] = {
-#ifdef CONFIG_WD_SBU_POLLING
+#if CONFIG_WD_SBU_POLLING
 	MT6360_PMU_IRQDESC(usbid_evt),
 #endif /* CONFIG_WD_SBU_POLLING */
 };
 
-#ifdef CONFIG_WD_SBU_POLLING
+#if CONFIG_WD_SBU_POLLING
 static void mt6360_enable_usbid_irq(struct mt6360_chip *chip, bool en)
 {
 	struct mt6360_pmu_irq_desc *irq_desc;
@@ -973,7 +932,8 @@ static int mt6360_pmu_tcpc_irq_register(struct tcpc_device *tcpc)
 		irq_desc->irq = r->start;
 		ret = devm_request_threaded_irq(chip->dev, irq_desc->irq, NULL,
 						irq_desc->irq_handler,
-						IRQF_TRIGGER_FALLING,
+						IRQF_TRIGGER_FALLING |
+						IRQF_ONESHOT,
 						irq_desc->name,
 						chip);
 		if (ret < 0)
@@ -1001,12 +961,12 @@ static int mt6360_init_alert(struct tcpc_device *tcpc)
 	if (!name)
 		return -ENOMEM;
 	ret = snprintf(name, PAGE_SIZE, "%s-IRQ", chip->tcpc_desc->name);
-	if ((ret < 0) || (ret >= PAGE_SIZE - 1))
+	if (ret < 0)
 		return -EINVAL;
 	dev_info(chip->dev, "%s name = %s, gpio = %d\n", __func__,
 		 chip->tcpc_desc->name, chip->irq_gpio);
 	ret = devm_gpio_request(chip->dev, chip->irq_gpio, name);
-#ifdef DEBUG_GPIO
+#if DEBUG_GPIO
 	gpio_request(DEBUG_GPIO, "debug_latency_pin");
 	gpio_direction_output(DEBUG_GPIO, 1);
 #endif /* DEBUG_GPIO */
@@ -1031,11 +991,7 @@ static int mt6360_init_alert(struct tcpc_device *tcpc)
 	}
 	dev_info(chip->dev, "%s IRQ number = %d\n", __func__, chip->irq);
 
-#if 1 /* (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)) */
 	kthread_init_worker(&chip->irq_worker);
-#else
-	init_kthread_worker(&chip->irq_worker);
-#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0) */
 
 	chip->irq_worker_task = kthread_run(kthread_worker_fn,
 					    &chip->irq_worker, "%s",
@@ -1046,11 +1002,7 @@ static int mt6360_init_alert(struct tcpc_device *tcpc)
 	}
 
 	sched_setscheduler(chip->irq_worker_task, SCHED_FIFO, &param);
-#if 1 /* (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)) */
 	kthread_init_work(&chip->irq_work, mt6360_irq_work_handler);
-#else
-	init_kthread_work(&chip->irq_work, mt6360_irq_work_handler);
-#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0) */
 
 	ret = request_irq(chip->irq, mt6360_intr_handler, IRQF_TRIGGER_FALLING |
 			  IRQF_NO_THREAD, name, chip);
@@ -1088,7 +1040,7 @@ static int mt6360_set_clock_gating(struct tcpc_device *tcpc, bool en)
 {
 	int ret = 0;
 
-#ifdef CONFIG_TCPC_CLOCK_GATING
+#if CONFIG_TCPC_CLOCK_GATING
 	int i = 0;
 	u8 clk1 = MT6360_CLK_DIV_600K_EN | MT6360_CLK_DIV_300K_EN;
 	u8 clk2 = MT6360_CLK_DIV_2P4M_EN;
@@ -1226,7 +1178,7 @@ static int mt6360_get_power_status(struct tcpc_device *tcpc, u16 *status)
 	 * Vsafe0v only triggers when vbus falls under 0.8V,
 	 * also update parameter if vbus present triggers
 	 */
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	ret = tcpci_is_vsafe0v(tcpc);
 	if (ret >= 0)
 		tcpc->vbus_safe0v = ret ? true : false;
@@ -1268,10 +1220,7 @@ static int mt6360_get_cc(struct tcpc_device *tcpc, int *cc1, int *cc2)
 	if (act_as_drp)
 		act_as_sink = TCPC_V10_REG_CC_STATUS_DRP_RESULT(status);
 	else {
-		if (tcpc->typec_polarity)
-			cc_role = TCPC_V10_REG_CC_STATUS_CC2(role_ctrl);
-		else
-			cc_role = TCPC_V10_REG_CC_STATUS_CC1(role_ctrl);
+		cc_role = TCPC_V10_REG_CC_STATUS_CC1(role_ctrl);
 		if (cc_role == TYPEC_CC_RP)
 			act_as_sink = false;
 		else
@@ -1292,7 +1241,7 @@ static int mt6360_get_cc(struct tcpc_device *tcpc, int *cc1, int *cc2)
 	return 0;
 }
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 static int mt6360_enable_vsafe0v_detect(struct tcpc_device *tcpc, bool en)
 {
 	return (en ? mt6360_i2c_set_bit : mt6360_i2c_clr_bit)
@@ -1305,7 +1254,7 @@ static int mt6360_set_cc(struct tcpc_device *tcpc, int pull)
 	int ret;
 	u8 data;
 	int rp_lvl = TYPEC_CC_PULL_GET_RP_LVL(pull), pull1, pull2;
-#ifdef CONFIG_WD_SBU_POLLING
+#if CONFIG_WD_SBU_POLLING
 	struct mt6360_chip *chip = tcpc_get_dev_data(tcpc);
 #endif /* CONFIG_WD_SBU_POLLING */
 
@@ -1318,19 +1267,19 @@ static int mt6360_set_cc(struct tcpc_device *tcpc, int pull)
 		if (ret < 0)
 			return ret;
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 		mt6360_enable_vsafe0v_detect(tcpc, false);
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 
 		mt6360_enable_auto_rpconnect(tcpc, true);
 		mt6360_enable_oneshot_rpconnect(tcpc, true);
 
-#ifdef CONFIG_TCPC_LOW_POWER_MODE
+#if CONFIG_TCPC_LOW_POWER_MODE
 		tcpci_set_low_power_mode(tcpc, true, pull);
 #endif /* CONFIG_TCPC_LOW_POWER_MODE */
 		ret = mt6360_command(tcpc, TCPM_CMD_LOOK_CONNECTION);
-#ifdef CONFIG_WD_SBU_POLLING
-#ifdef CONFIG_WD_POLLING_ONLY
+#if CONFIG_WD_SBU_POLLING
+#if CONFIG_WD_POLLING_ONLY
 		schedule_delayed_work(&chip->usbid_poll_work,
 					msecs_to_jiffies(500));
 #else
@@ -1338,14 +1287,16 @@ static int mt6360_set_cc(struct tcpc_device *tcpc, int pull)
 #endif /* CONFIG_WD_POLLING_ONLY */
 #endif /* CONFIG_WD_SBU_POLLING */
 	} else {
-#ifdef CONFIG_WD_POLLING_ONLY
+#if CONFIG_WD_POLLING_ONLY
 		cancel_delayed_work(&chip->usbid_poll_work);
 		mt6360_enable_usbid_polling(chip, false);
 #endif /* CONFIG_WD_POLLING_ONLY */
 
 		pull1 = pull2 = pull;
 
-		if (pull == TYPEC_CC_RP && tcpc->typec_is_attached_src) {
+		if ((pull == TYPEC_CC_RP_DFT || pull == TYPEC_CC_RP_1_5 ||
+			pull == TYPEC_CC_RP_3_0) &&
+			tcpc->typec_is_attached_src) {
 			if (tcpc->typec_polarity)
 				pull1 = TYPEC_CC_RD;
 			else
@@ -1427,7 +1378,7 @@ static int mt6360_set_vconn(struct tcpc_device *tcpc, int en)
 	return ret;
 }
 
-#ifdef CONFIG_TCPC_LOW_POWER_MODE
+#if CONFIG_TCPC_LOW_POWER_MODE
 static int mt6360_is_low_power_mode(struct tcpc_device *tcpc)
 {
 	int ret;
@@ -1450,13 +1401,13 @@ static int mt6360_set_low_power_mode(struct tcpc_device *tcpc, bool en,
 		(tcpc, MT6360_REG_MODE_CTRL2, MT6360_AUTOIDLE_EN);
 	if (ret < 0)
 		return ret;
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	mt6360_enable_vsafe0v_detect(tcpc, !en);
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 	if (en) {
 		data = MT6360_LPWR_EN | MT6360_LPWR_LDO_EN;
 
-#ifdef CONFIG_TYPEC_CAP_NORP_SRC
+#if CONFIG_TYPEC_CAP_NORP_SRC
 		data |= MT6360_VBUS_DET_EN | MT6360_PD_BG_EN |
 			MT6360_PD_IREF_EN;
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
@@ -1477,11 +1428,11 @@ static int mt6360_set_watchdog(struct tcpc_device *tcpc, bool en)
 
 static int mt6360_tcpc_deinit(struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	struct mt6360_chip *chip = tcpc_get_dev_data(tcpc);
 #endif /* CONFIG_RT_REGMAP */
 
-#ifdef CONFIG_TCPC_SHUTDOWN_CC_DETACH
+#if CONFIG_TCPC_SHUTDOWN_CC_DETACH
 	mt6360_set_cc(tcpc, TYPEC_CC_DRP);
 	mt6360_set_cc(tcpc, TYPEC_CC_OPEN);
 
@@ -1490,14 +1441,14 @@ static int mt6360_tcpc_deinit(struct tcpc_device *tcpc)
 #else
 	mt6360_i2c_write8(tcpc, MT6360_REG_SWRESET, 1);
 #endif	/* CONFIG_TCPC_SHUTDOWN_CC_DETACH */
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	rt_regmap_cache_reload(chip->m_dev);
 #endif /* CONFIG_RT_REGMAP */
 
 	return 0;
 }
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 static int mt6360_is_vsafe0v(struct tcpc_device *tcpc)
 {
 	int ret;
@@ -1522,7 +1473,7 @@ static int mt6360_vsafe0v_irq_handler(struct tcpc_device *tcpc)
 }
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 static int mt6360_wd_irq_handler(struct tcpc_device *tcpc)
 {
 	int ret;
@@ -1559,7 +1510,7 @@ retry:
 	return 0;
 }
 
-#ifdef CONFIG_WD_POLLING_ONLY
+#if CONFIG_WD_POLLING_ONLY
 static void mt6360_usbid_poll_work(struct work_struct *work)
 {
 	int ret, cc1, cc2;
@@ -1582,7 +1533,7 @@ out:
 #endif /* CONFIG_WD_POLLING_ONLY */
 #endif /* CONFIG_WATER_DETECTION */
 
-#ifdef CONFIG_CABLE_TYPE_DETECTION
+#if CONFIG_CABLE_TYPE_DETECTION
 static inline int mt6360_get_cable_type(struct tcpc_device *tcpc,
 					enum tcpc_cable_type *type)
 {
@@ -1677,15 +1628,15 @@ struct irq_mapping_tbl {
 	{ .num = _num, .name = #_name, .hdlr = mt6360_##_name##_irq_handler }
 
 static struct irq_mapping_tbl mt6360_vend_irq_mapping_tbl[] = {
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	MT6360_IRQ_MAPPING(1, vsafe0v),
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 	MT6360_IRQ_MAPPING(14, wd),
 #endif /* CONFIG_WATER_DETECTION */
 
-#ifdef CONFIG_CABLE_TYPE_DETECTION
+#if CONFIG_CABLE_TYPE_DETECTION
 	MT6360_IRQ_MAPPING(20, ctd),
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
 
@@ -1698,7 +1649,8 @@ static struct irq_mapping_tbl mt6360_vend_irq_mapping_tbl[] = {
 
 static int mt6360_alert_vendor_defined_handler(struct tcpc_device *tcpc)
 {
-	int ret, i, irqnum, irqbit;
+	int ret, i, irqbit;
+	unsigned int irqnum;
 	u8 alert[MT6360_VEND_INT_MAX];
 	u8 mask[MT6360_VEND_INT_MAX];
 
@@ -1734,7 +1686,7 @@ static int mt6360_alert_vendor_defined_handler(struct tcpc_device *tcpc)
 	return 0;
 }
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 static inline int mt6360_init_water_detection(struct tcpc_device *tcpc)
 {
 	/*
@@ -1743,7 +1695,8 @@ static inline int mt6360_init_water_detection(struct tcpc_device *tcpc)
 	 * 0xc1[1:0] -> Rust exiting counts during rust protection flow
 	 * (when RUST_PROTECT_EN is "1"), set as 4
 	 */
-	mt6360_i2c_write8(tcpc, MT6360_REG_WD_DET_CTRL2, 0x02);
+	/* TODO: Modify PINS_SEL to CC1/CC2/DP/DM if USB setting is ready */
+	mt6360_i2c_write8(tcpc, MT6360_REG_WD_DET_CTRL2, 0x82);
 
 	/* DPDM Pull up capability, 220u */
 	mt6360_i2c_write8(tcpc, MT6360_REG_WD_DET_CTRL3, 0xFF);
@@ -1814,14 +1767,14 @@ static int mt6360_is_water_detected(struct tcpc_device *tcpc)
 	int ret, usbid;
 	u32 ub, lb;
 	struct mt6360_chip *chip = tcpc_get_dev_data(tcpc);
-#ifdef CONFIG_CABLE_TYPE_DETECTION
+#if CONFIG_CABLE_TYPE_DETECTION
 	u8 ctd_evt;
 	enum tcpc_cable_type cable_type;
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
 
 	__pm_stay_awake(chip->wd_wakeup_src);
 
-#ifdef CONFIG_WD_SBU_POLLING
+#if CONFIG_WD_SBU_POLLING
 	ret = mt6360_enable_usbid_polling(chip, false);
 #else
 	ret = charger_dev_enable_usbid(chip->chgdev, false);
@@ -1912,7 +1865,7 @@ static int mt6360_is_water_detected(struct tcpc_device *tcpc)
 		}
 	} else
 		dev_info(chip->dev, "%s get usbid adc fail\n", __func__);
-#ifdef CONFIG_CABLE_TYPE_DETECTION
+#if CONFIG_CABLE_TYPE_DETECTION
 	cable_type = tcpc->typec_cable_type;
 	if (cable_type == TCPC_CABLE_TYPE_NONE) {
 		ret = mt6360_i2c_read8(chip->tcpc, MT6360_REG_MT_INT3,
@@ -1997,7 +1950,7 @@ static int mt6360_tcpc_init(struct tcpc_device *tcpc, bool sw_reset)
 			return ret;
 	}
 
-#ifdef CONFIG_TCPC_I2CRST_EN
+#if CONFIG_TCPC_I2CRST_EN
 	mt6360_i2c_write8(tcpc, MT6360_REG_I2CRST_CTRL,
 			  MT6360_REG_I2CRST_SET(true, 0x0f));
 #endif	/* CONFIG_TCPC_I2CRST_EN */
@@ -2039,7 +1992,7 @@ static int mt6360_tcpc_init(struct tcpc_device *tcpc, bool sw_reset)
 	/* Enable Rp connect oneshot */
 	mt6360_enable_oneshot_rpconnect(tcpc, true);
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 	mt6360_init_water_detection(tcpc);
 #endif /* CONFIG_WATER_DETECTION */
 
@@ -2059,7 +2012,7 @@ static int mt6360_tcpc_init(struct tcpc_device *tcpc, bool sw_reset)
 	return 0;
 }
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 static int mt6360_set_msg_header(
 	struct tcpc_device *tcpc, u8 power_role, u8 data_role)
 {
@@ -2132,7 +2085,7 @@ static int mt6360_set_bist_carrier_mode(struct tcpc_device *tcpc, u8 pattern)
 #define MT6360_TRANSMIT_MAX_SIZE \
 	(sizeof(u16) + sizeof(u32) * 7)
 
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 static int mt6360_retransmit(struct tcpc_device *tcpc)
 {
 	return mt6360_i2c_write8(tcpc, TCPC_V10_REG_TRANSMIT,
@@ -2193,18 +2146,18 @@ static struct tcpc_ops mt6360_tcpc_ops = {
 	.deinit = mt6360_tcpc_deinit,
 	.alert_vendor_defined_handler = mt6360_alert_vendor_defined_handler,
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	.is_vsafe0v = mt6360_is_vsafe0v,
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 
-#ifdef CONFIG_TCPC_LOW_POWER_MODE
+#if CONFIG_TCPC_LOW_POWER_MODE
 	.is_low_power_mode = mt6360_is_low_power_mode,
 	.set_low_power_mode = mt6360_set_low_power_mode,
 #endif	/* CONFIG_TCPC_LOW_POWER_MODE */
 
 	.set_watchdog = mt6360_set_watchdog,
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	.set_msg_header = mt6360_set_msg_header,
 	.set_rx_enable = mt6360_set_rx_enable,
 	.protocol_reset = mt6360_protocol_reset,
@@ -2214,11 +2167,11 @@ static struct tcpc_ops mt6360_tcpc_ops = {
 	.set_bist_carrier_mode = mt6360_set_bist_carrier_mode,
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 	.retransmit = mt6360_retransmit,
 #endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 	.is_water_detected = mt6360_is_water_detected,
 	.set_water_protection = mt6360_set_water_protection,
 	.set_usbid_polling = mt6360_set_usbid_polling,
@@ -2230,11 +2183,9 @@ static int mt6360_init_ctd(struct mt6360_chip *chip)
 {
 	int ret = 0;
 
-#ifdef CONFIG_CABLE_TYPE_DETECTION
+#if CONFIG_CABLE_TYPE_DETECTION
 	u8 ctd_evt;
-#if CONFIG_MTK_GAUGE_VERSION == 30
 	u8 status;
-#endif
 
 	chip->tcpc->typec_cable_type = TCPC_CABLE_TYPE_NONE;
 	chip->handle_init_ctd = true;
@@ -2243,14 +2194,12 @@ static int mt6360_init_ctd(struct mt6360_chip *chip)
 		return ret;
 	if (ctd_evt & MT6360_M_CTD) {
 		mt6360_get_cable_type(chip->tcpc, &chip->init_cable_type);
-#if CONFIG_MTK_GAUGE_VERSION == 30
 		if (chip->init_cable_type == TCPC_CABLE_TYPE_C2C) {
 			ret = charger_dev_get_ctd_dischg_status(chip->chgdev,
 								&status);
 			if (ret >= 0 && (status & 0x82))
 				chip->init_cable_type = TCPC_CABLE_TYPE_A2C;
 		}
-#endif
 	}
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
 
@@ -2260,20 +2209,13 @@ static int mt6360_init_ctd(struct mt6360_chip *chip)
 static int mt6360_parse_dt(struct mt6360_chip *chip, struct device *dev,
 			   struct mt6360_tcpc_platform_data *pdata)
 {
-	struct device_node *np = NULL;
+	struct device_node *np = dev->of_node;
 	struct resource *res;
-	int res_cnt, ret;
+	int res_cnt = 0, ret;
+	struct of_phandle_args irq;
 
 	pr_info("%s\n", __func__);
-
-	np = of_find_node_by_name(NULL, "type_c_port0");
-	if (!np) {
-		dev_err(dev, "%s find node fail\n", __func__);
-		return -ENODEV;
-	}
-	dev->of_node = np;
-
-#if (!defined(CONFIG_MTK_GPIO) || defined(CONFIG_MTK_GPIOLIB_STAND))
+#if IS_ENABLED(CONFIG_MTK_GPIO) || IS_ENABLED(CONFIG_MTK_GPIOLIB_STAND)
 	ret = of_get_named_gpio(np, "mt6360pd,intr_gpio", 0);
 	if (ret < 0) {
 		dev_err(dev, "%s no intr_gpio info(gpiolib)\n", __func__);
@@ -2289,8 +2231,8 @@ static int mt6360_parse_dt(struct mt6360_chip *chip, struct device *dev,
 	}
 #endif /* !CONFIG_MTK_GPIO || CONFIG_MTK_GPIOLIB_STAND */
 
-#ifdef CONFIG_MTK_TYPEC_WATER_DETECT_BY_PCB
-#if (!defined(CONFIG_MTK_GPIO) || defined(CONFIG_MTK_GPIOLIB_STAND))
+#if IS_ENABLED(CONFIG_MTK_TYPEC_WATER_DETECT_BY_PCB)
+#if IS_ENABLED(CONFIG_MTK_GPIO) || IS_ENABLED(CONFIG_MTK_GPIOLIB_STAND)
 	ret = of_get_named_gpio(np, "mt6360pd,pcb_gpio", 0);
 	if (ret < 0) {
 		dev_info(dev, "%s no pcb_gpio info(gpiolib)\n", __func__);
@@ -2326,7 +2268,8 @@ static int mt6360_parse_dt(struct mt6360_chip *chip, struct device *dev,
 	}
 #endif /* CONFIG_MTK_TYPEC_WATER_DETECT_BY_PCB */
 
-	res_cnt = of_irq_count(np);
+	while (of_irq_parse_one(np, res_cnt, &irq) == 0)
+		res_cnt++;
 	if (!res_cnt) {
 		dev_info(dev, "%s no irqs specified\n", __func__);
 		return 0;
@@ -2353,7 +2296,7 @@ static void check_printk_performance(void)
 	u64 t1, t2;
 	u32 nsrem;
 
-#ifdef CONFIG_PD_DBG_INFO
+#if IS_ENABLED(CONFIG_PD_DBG_INFO)
 	for (i = 0; i < 10; i++) {
 		t1 = local_clock();
 		pd_dbg_info("%d\n", i);
@@ -2389,8 +2332,15 @@ static int mt6360_tcpcdev_init(struct mt6360_chip *chip, struct device *dev)
 {
 	struct tcpc_desc *desc;
 	struct device_node *np = dev->of_node;
-	u32 val = -EINVAL, len;
+	struct device_node *boot_np = NULL;
+	u32 val, len;
 	const char *name = "default";
+	const struct {
+		u32 size;
+		u32 tag;
+		u32 bootmode;
+		u32 boottype;
+	} *tag;
 
 	desc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);
 	if (!desc)
@@ -2430,7 +2380,7 @@ static int mt6360_tcpcdev_init(struct mt6360_chip *chip, struct device *dev)
 		}
 	}
 
-#ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
+#if CONFIG_TCPC_VCONN_SUPPLY_MODE
 	if (of_property_read_u32(np, "mt-tcpc,vconn_supply", &val) >= 0) {
 		if (val >= TCPC_VCONN_SUPPLY_NR)
 			desc->vconn_supply = TCPC_VCONN_SUPPLY_ALWAYS;
@@ -2451,21 +2401,16 @@ static int mt6360_tcpcdev_init(struct mt6360_chip *chip, struct device *dev)
 
 	chip->tcpc_desc = desc;
 	chip->tcpc = tcpc_device_register(dev, desc, &mt6360_tcpc_ops, chip);
-	if (IS_ERR_OR_NULL(chip->tcpc))
+	if (IS_ERR(chip->tcpc) || !chip->tcpc)
 		return -EINVAL;
 
-#ifdef CONFIG_USB_PD_DISABLE_PE
-	chip->tcpc->disable_pe = of_property_read_bool(np,
-						       "mt-tcpc,disable_pe");
-#endif	/* CONFIG_USB_PD_DISABLE_PE */
-
 	/* Init tcpc_flags */
 	chip->tcpc->tcpc_flags = TCPC_FLAGS_LPM_WAKEUP_WATCHDOG |
 				 TCPC_FLAGS_RETRY_CRC_DISCARD;
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 	chip->tcpc->tcpc_flags |= TCPC_FLAGS_RETRY_CRC_DISCARD;
 #endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	chip->tcpc->tcpc_flags |= TCPC_FLAGS_PD_REV30;
 #endif	/* CONFIG_USB_PD_REV30 */
 
@@ -2476,36 +2421,34 @@ static int mt6360_tcpcdev_init(struct mt6360_chip *chip, struct device *dev)
 
 	chip->tcpc->tcpc_flags |= TCPC_FLAGS_DISABLE_LEGACY;
 	chip->tcpc->tcpc_flags |= TCPC_FLAGS_WATCHDOG_EN;
-#ifdef CONFIG_MTK_TYPEC_WATER_DETECT_BY_PCB
+#if IS_ENABLED(CONFIG_MTK_TYPEC_WATER_DETECT_BY_PCB)
 	if (gpio_get_value(chip->pcb_gpio) == chip->pcb_gpio_polarity)
 		chip->tcpc->tcpc_flags |= TCPC_FLAGS_WATER_DETECTION;
 #else
 	chip->tcpc->tcpc_flags |= TCPC_FLAGS_WATER_DETECTION;
 #endif /* CONFIG_MTK_TYPEC_WATER_DETECT_BY_PCB */
+#if CONFIG_WD_POLLING_ONLY
+	chip->tcpc->tcpc_flags |= TCPC_FLAGS_WD_POLLING_ONLY;
+#endif
 	chip->tcpc->tcpc_flags |= TCPC_FLAGS_CABLE_TYPE_DETECTION;
-	return 0;
-}
-
-int power_supply_get_cc(void)
-{
-	int cc1, cc2;
 
-	if (g_chip == NULL) {
-		pr_err("%s null address\n",__func__);
-		return ERR_STATUS;
+	/* mediatek boot mode */
+	boot_np = of_parse_phandle(np, "bootmode", 0);
+	if (!boot_np) {
+		dev_notice(dev, "failed to get bootmode phandle\n");
+		return -ENODEV;
 	}
+	tag = of_get_property(boot_np, "atag,boot", NULL);
+	if (!tag) {
+		dev_notice(dev, "failed to get atag,boot\n");
+		return -EINVAL;
+	}
+	dev_info(dev, "sz:0x%x tag:0x%x mode:0x%x type:0x%x\n",
+		 tag->size, tag->tag, tag->bootmode, tag->boottype);
+	chip->tcpc->bootmode = tag->bootmode;
 
-	tcpci_lock_typec(g_chip->tcpc);
-	mt6360_get_cc(g_chip->tcpc, &cc1, &cc2);
-	tcpci_unlock_typec(g_chip->tcpc);
-
-	pr_err("%s %d %d\n",__func__, cc1, cc2);
-	if (cc1 == cc2)
-		return ERR_STATUS;
-
-	return (cc1 > cc2) ? POSITIVE : NEGATIVE;
+	return 0;
 }
-EXPORT_SYMBOL_GPL(power_supply_get_cc);
 
 static inline int mt6360_check_revision(struct i2c_client *client)
 {
@@ -2592,21 +2535,20 @@ static int mt6360_i2c_probe(struct i2c_client *client,
 	sema_init(&chip->io_lock, 1);
 	sema_init(&chip->suspend_lock, 1);
 	i2c_set_clientdata(client, chip);
-	INIT_DELAYED_WORK(&chip->poll_work, mt6360_poll_work);
 	chip->irq_wake_lock =
 		wakeup_source_register(chip->dev, "mt6360_irq_wake_lock");
 	chip->i2c_wake_lock =
 		wakeup_source_register(chip->dev, "mt6360_i2c_wake_lock");
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 	chip->wd_wakeup_src =
 		wakeup_source_register(chip->dev, "mt6360_wd_wakeup_src");
 	atomic_set(&chip->wd_protect_rty, CONFIG_WD_PROTECT_RETRY_COUNT);
-#ifdef CONFIG_WD_POLLING_ONLY
+#if CONFIG_WD_POLLING_ONLY
 	INIT_DELAYED_WORK(&chip->usbid_poll_work, mt6360_usbid_poll_work);
 #endif /* CONFIG_WD_POLLING_ONLY */
 #endif /* CONFIG_WATER_DETECTION */
-#ifdef CONFIG_WD_SBU_POLLING
+#if CONFIG_WD_SBU_POLLING
 	mutex_init(&chip->usbid_irq_lock);
 	chip->usbid_irqen = true;
 	INIT_WORK(&chip->wd_work, mt6360_wd_work);
@@ -2614,7 +2556,7 @@ static int mt6360_i2c_probe(struct i2c_client *client,
 
 	dev_info(chip->dev, "%s chipID = 0x%0X\n", __func__, chip->chip_id);
 
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	ret = mt6360_regmap_init(chip);
 	if (ret < 0) {
 		dev_err(chip->dev, "%s regmap init fail(%d)\n", __func__, ret);
@@ -2622,18 +2564,17 @@ static int mt6360_i2c_probe(struct i2c_client *client,
 	}
 #endif /* CONIFG_RT_REGMAP */
 
-#if defined(CONFIG_WATER_DETECTION) || defined(CONFIG_CABLE_TYPE_DETECTION)
-#if CONFIG_MTK_GAUGE_VERSION == 30
+#if CONFIG_WATER_DETECTION || CONFIG_CABLE_TYPE_DETECTION
+#if IS_ENABLED(CONFIG_MTK_CHARGER)
 	chip->chgdev = get_charger_by_name("primary_chg");
 	if (!chip->chgdev) {
 		dev_err(chip->dev, "%s get charger device fail\n", __func__);
 		ret = -EPROBE_DEFER;
 		goto err_tcpc_reg;
 	}
-#endif /* CONFIG_MTK_GAUGE_VERSION == 30 */
+#endif /* CONFIG_MTK_CHARGER */
 #endif /* CONFIG_WATER_DETECTION || CONFIG_CABLE_TYPE_DETECTION */
 
-	g_chip = chip;
 	ret = mt6360_tcpcdev_init(chip, &client->dev);
 	if (ret < 0) {
 		dev_err(chip->dev, "%s tcpc dev init fail\n", __func__);
@@ -2660,7 +2601,7 @@ static int mt6360_i2c_probe(struct i2c_client *client,
 	}
 
 	tcpc_schedule_init_work(chip->tcpc);
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 	mt6360_water_calibration(chip->tcpc);
 #endif /* CONFIG_WATER_DETECTION */
 	dev_info(chip->dev, "%s successfully!\n", __func__);
@@ -2669,10 +2610,9 @@ static int mt6360_i2c_probe(struct i2c_client *client,
 err_sw_reset:
 	tcpc_device_unregister(chip->dev, chip->tcpc);
 err_tcpc_reg:
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	mt6360_regmap_deinit(chip);
 #endif /* CONFIG_RT_REGMAP */
-	g_chip = NULL;
 	return ret;
 }
 
@@ -2681,24 +2621,22 @@ static int mt6360_i2c_remove(struct i2c_client *client)
 	struct mt6360_chip *chip = i2c_get_clientdata(client);
 
 	if (chip) {
-		cancel_delayed_work_sync(&chip->poll_work);
-#ifdef CONFIG_WD_SBU_POLLING
+#if CONFIG_WD_SBU_POLLING
 		cancel_work_sync(&chip->wd_work);
-#ifdef CONFIG_WD_POLLING_ONLY
+#if CONFIG_WD_POLLING_ONLY
 		cancel_delayed_work_sync(&chip->usbid_poll_work);
 #endif /* CONFIG_WD_POLLING_ONLY */
 #endif /* CONFIG_WD_SBU_POLLING */
 		tcpc_device_unregister(chip->dev, chip->tcpc);
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 		mt6360_regmap_deinit(chip);
 #endif /* CONFIG_RT_REGMAP */
 	}
-	g_chip = NULL;
 
 	return 0;
 }
 
-#ifdef CONFIG_PM
+#if CONFIG_PM
 static int mt6360_i2c_suspend(struct device *dev)
 {
 	struct mt6360_chip *chip;
@@ -2740,7 +2678,7 @@ static void mt6360_shutdown(struct i2c_client *client)
 		i2c_smbus_write_byte_data(client, MT6360_REG_SWRESET, 0x01);
 }
 
-#ifdef CONFIG_PM_RUNTIME
+#if IS_ENABLED(CONFIG_PM_RUNTIME)
 static int mt6360_pm_suspend_runtime(struct device *device)
 {
 	dev_dbg(device, "pm_runtime: suspending...\n");
@@ -2756,7 +2694,7 @@ static int mt6360_pm_resume_runtime(struct device *device)
 
 static const struct dev_pm_ops mt6360_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(mt6360_i2c_suspend, mt6360_i2c_resume)
-#ifdef CONFIG_PM_RUNTIME
+#if IS_ENABLED(CONFIG_PM_RUNTIME)
 	SET_RUNTIME_PM_OPS(mt6360_pm_suspend_runtime, mt6360_pm_resume_runtime,
 			   NULL)
 #endif /* CONFIG_PM_RUNTIME */
@@ -2826,11 +2764,6 @@ MODULE_VERSION(MT6360_DRV_VERSION);
  *	(2) AUTOIDLE enable
  *	(3) Reset Protocol FSM and clear RX alerts twice before clock gating
  *
- * 2.0.4_MTK
- *	(1) support mt6360 pd discard retry
- *	(2) fix system busy when rx pending2
- *	(3) handle mask alert event when unmask irq
- *
  * 2.0.3_MTK
  *	(1) Single Rp as Attatched.SRC for Ellisys TD.4.9.4
  *
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpc_mt6362.c b/drivers/misc/mediatek/typec/tcpc/tcpc_mt6362.c
index a85abde..107911d 100644
--- a/drivers/misc/mediatek/typec/tcpc/tcpc_mt6362.c
+++ b/drivers/misc/mediatek/typec/tcpc/tcpc_mt6362.c
@@ -1,18 +1,21 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (c) 2019 MediaTek Inc.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
+#include <linux/cpu.h>
+#include <linux/iio/consumer.h>
+#include <linux/interrupt.h>
 #include <linux/kernel.h>
+#include <linux/kthread.h>
 #include <linux/module.h>
 #include <linux/of.h>
-#include <linux/regmap.h>
+#include <linux/of_irq.h>
 #include <linux/platform_device.h>
-#include <linux/kthread.h>
-#include <linux/cpu.h>
-#include <linux/iio/consumer.h>
-#include <uapi/linux/sched/types.h>
+#include <linux/regmap.h>
+#include <linux/sched/clock.h>
 #include <dt-bindings/mfd/mt6362.h>
+#include <uapi/linux/sched/types.h>
 
 #include "inc/tcpci.h"
 #include "inc/tcpci_typec.h"
@@ -20,7 +23,7 @@
 #include "inc/std_tcpci_v10.h"
 
 #define MT6362_INFO_EN	1
-#define MT6362_DBGINFO_EN	1
+#define MT6362_DBGINFO_EN	0
 #define MT6362_WD1_EN	1
 #define MT6362_WD2_EN	1
 
@@ -119,9 +122,6 @@
 	(MT6362_MSK_VCON_OVCC1 | MT6362_MSK_VCON_OVCC2 | MT6362_MSK_VCON_RVP | \
 	 MT6362_MSK_VCON_UVP | MT6362_MSK_VCON_SHTGND)
 #define MT6362_MSK_CTD		BIT(4)
-#define MT6362_MSK_FOD_DONE	BIT(0)
-#define MT6362_MSK_FOD_OV	BIT(1)
-#define MT6362_MSK_FOD_DISCHGF	BIT(7)
 #define MT6362_MSK_RPDET_AUTO	BIT(7)
 #define MT6362_MSK_RPDET_MANUAL	BIT(6)
 #define MT6362_MSK_CTD_EN	BIT(1)
@@ -143,14 +143,6 @@
 #define MT6362_MSK_HIDET_CC2_CMPEN	BIT(4)
 #define MT6362_MSK_HIDET_CC_CMPEN \
 	(MT6362_MSK_HIDET_CC1_CMPEN | MT6362_MSK_HIDET_CC2_CMPEN)
-#define MT6362_MSK_FOD_DONE	BIT(0)
-#define MT6362_MSK_FOD_OV	BIT(1)
-#define MT6362_MSK_FOD_LR	BIT(5)
-#define MT6362_MSK_FOD_HR	BIT(6)
-#define MT6362_MSK_FOD_DISCHGF	BIT(7)
-#define MT6362_MSK_FOD_ALL \
-	(MT6362_MSK_FOD_DONE | MT6362_MSK_FOD_OV | MT6362_MSK_FOD_LR | \
-	 MT6362_MSK_FOD_HR | MT6362_MSK_FOD_DISCHGF)
 #define MT6362_MSK_CABLE_TYPEC	BIT(4)
 #define MT6362_MSK_CABLE_TYPEA	BIT(5)
 #define MT6362_MSK_SHIPPING_OFF	BIT(5)
@@ -254,7 +246,7 @@ static const u8 mt6362_vend_alert_maskall[MT6362_VEND_INT_NUM] = {
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 };
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 /* reg0x20 ~ reg0x2D */
 static const u8 mt6362_rt2_wd_init_setting[] = {
 	0x50, 0x34, 0x44, 0xCA, 0x68, 0x02, 0x20, 0x03,
@@ -303,11 +295,11 @@ static const u8 mt6362_wd_polling_path[MT6362_WD_CHAN_NUM] = {
 
 static const u8 mt6362_wd_protection_path[MT6362_WD_CHAN_NUM] = {
 	MT6362_MSK_WDSBU1_EN | MT6362_MSK_WDSBU2_EN |
-	MT6362_MSK_WDCC1_EN | MT6362_MSK_WDCC2_EN,
-//	MT6362_MSK_WDDP_EN | MT6362_MSK_WDDM_EN,
+	MT6362_MSK_WDCC1_EN | MT6362_MSK_WDCC2_EN |
+	MT6362_MSK_WDDP_EN | MT6362_MSK_WDDM_EN,
 	MT6362_MSK_WDSBU1_EN | MT6362_MSK_WDSBU2_EN |
-	MT6362_MSK_WDCC1_EN | MT6362_MSK_WDCC2_EN,
-//	MT6362_MSK_WDDP_EN | MT6362_MSK_WDDM_EN,
+	MT6362_MSK_WDCC1_EN | MT6362_MSK_WDCC2_EN |
+	MT6362_MSK_WDDP_EN | MT6362_MSK_WDDM_EN,
 };
 #endif /* CONFIG_WATER_DETECTION */
 
@@ -323,18 +315,15 @@ struct mt6362_tcpc_data {
 	int irq;
 	u16 did;
 
-	atomic_t cpu_poll_count;
-	struct delayed_work cpu_poll_dwork;
-
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 	atomic_t wd_protect_rty;
 #endif /* CONFIG_WATER_DETECTION */
 
-#ifdef CONFIG_WD_POLLING_ONLY
+#if CONFIG_WD_POLLING_ONLY
 	struct delayed_work wd_poll_dwork;
 #endif /* CONFIG_WD_POLLING_ONLY */
 
-#ifdef CONFIG_CABLE_TYPE_DETECTION
+#if CONFIG_CABLE_TYPE_DETECTION
 	bool handle_init_ctd;
 	enum tcpc_cable_type init_cable_type;
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
@@ -470,7 +459,7 @@ static int mt6362_init_vend_mask(struct mt6362_tcpc_data *tdata)
 {
 	u8 mask[MT6362_VEND_INT_NUM] = {0};
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	mask[MT6362_VEND_INT1] |= MT6362_MSK_VBUS80;
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 	if (tdata->tcpc->tcpc_flags & TCPC_FLAGS_LPM_WAKEUP_WATCHDOG)
@@ -500,7 +489,7 @@ static int mt6362_init_alert_mask(struct mt6362_tcpc_data *tdata)
 		   TCPC_V10_REG_ALERT_POWER_STATUS |
 		   TCPC_V10_REG_ALERT_VENDOR_DEFINED;
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	mask |= TCPC_V10_REG_ALERT_TX_SUCCESS |
 		TCPC_V10_REG_ALERT_TX_DISCARDED |
 		TCPC_V10_REG_ALERT_TX_FAILED |
@@ -527,7 +516,7 @@ static int mt6362_enable_force_discharge(struct mt6362_tcpc_data *tdata,
 		(tdata, TCPC_V10_REG_POWER_CTRL, TCPC_V10_REG_FORCE_DISC_EN);
 }
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 static int mt6362_enable_vsafe0v_detect(struct mt6362_tcpc_data *tdata, bool en)
 {
 	return (en ? mt6362_set_bits : mt6362_clr_bits)
@@ -569,7 +558,7 @@ static int mt6362_vend_alert_status_clear(struct mt6362_tcpc_data *tdata,
 			      TCPC_V10_REG_ALERT_VENDOR_DEFINED);
 }
 
-#ifdef CONFIG_CABLE_TYPE_DETECTION
+#if CONFIG_CABLE_TYPE_DETECTION
 static int mt6362_get_cable_type(struct mt6362_tcpc_data *tdata,
 				 enum tcpc_cable_type *type)
 {
@@ -589,10 +578,10 @@ static int mt6362_get_cable_type(struct mt6362_tcpc_data *tdata,
 }
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
 
-static int mt6362_init_fod_ctd(struct mt6362_tcpc_data *tdata)
+static int mt6362_init_ctd(struct mt6362_tcpc_data *tdata)
 {
 	int ret = 0;
-#ifdef CONFIG_CABLE_TYPE_DETECTION
+#if CONFIG_CABLE_TYPE_DETECTION
 	u8 ctd_evt;
 
 	tdata->tcpc->typec_cable_type = TCPC_CABLE_TYPE_NONE;
@@ -606,7 +595,7 @@ static int mt6362_init_fod_ctd(struct mt6362_tcpc_data *tdata)
 	return ret;
 }
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 static int mt6362_set_wd_ldo(struct mt6362_tcpc_data *tdata,
 			     enum mt6362_wd_ldo ldo)
 {
@@ -615,7 +604,7 @@ static int mt6362_set_wd_ldo(struct mt6362_tcpc_data *tdata,
 }
 #endif /* CONFIG_WATER_DETECTION */
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 static int mt6362_get_cc(struct tcpc_device *tcpc, int *cc1, int *cc2);
 static int mt6362_is_cc_toggling(struct mt6362_tcpc_data *tdata, bool *toggling)
 {
@@ -870,7 +859,7 @@ static int __mt6362_is_water_detected(struct mt6362_tcpc_data *tdata,
 	struct tcpc_desc *desc = tdata->desc;
 	u32 lb = desc->wd_sbu_ph_lbound;
 	u32 ub = desc->wd_sbu_calib_init * 110 / 100;
-#ifdef CONFIG_CABLE_TYPE_DETECTION
+#if CONFIG_CABLE_TYPE_DETECTION
 	enum tcpc_cable_type cable_type;
 	u8 ctd_evt;
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
@@ -927,7 +916,7 @@ static int __mt6362_is_water_detected(struct mt6362_tcpc_data *tdata,
 		msleep(20);
 	}
 
-#ifdef CONFIG_CABLE_TYPE_DETECTION
+#if CONFIG_CABLE_TYPE_DETECTION
 	cable_type = tdata->tcpc->typec_cable_type;
 	if (cable_type == TCPC_CABLE_TYPE_NONE) {
 		ret = mt6362_read8(tdata, MT6362_REG_MTINT3, &ctd_evt);
@@ -1081,7 +1070,7 @@ out:
 	return 0;
 }
 
-#ifdef CONFIG_WD_POLLING_ONLY
+#if CONFIG_WD_POLLING_ONLY
 static void mt6362_wd_poll_dwork_handler(struct work_struct *work)
 {
 	int ret;
@@ -1110,7 +1099,7 @@ static int mt6362_set_cc_toggling(struct mt6362_tcpc_data *tdata, int pull)
 	ret = mt6362_write8(tdata, TCPC_V10_REG_ROLE_CTRL, data);
 	if (ret < 0)
 		return ret;
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	ret = mt6362_enable_vsafe0v_detect(tdata, false);
 	if (ret < 0)
 		return ret;
@@ -1119,7 +1108,7 @@ static int mt6362_set_cc_toggling(struct mt6362_tcpc_data *tdata, int pull)
 	ret = mt6362_write8(tdata, MT6362_REG_LPWRCTRL3, 0xD9);
 	if (ret < 0)
 		return ret;
-#ifdef CONFIG_TCPC_LOW_POWER_MODE
+#if CONFIG_TCPC_LOW_POWER_MODE
 	tcpci_set_low_power_mode(tdata->tcpc, true, pull);
 #endif /* CONFIG_TCPC_LOW_POWER_MODE */
 	udelay(30);
@@ -1127,8 +1116,8 @@ static int mt6362_set_cc_toggling(struct mt6362_tcpc_data *tdata, int pull)
 			    TCPM_CMD_LOOK_CONNECTION);
 	if (ret < 0)
 		return ret;
-#ifdef CONFIG_WD_SBU_POLLING
-#ifdef CONFIG_WD_POLLING_ONLY
+#if CONFIG_WD_SBU_POLLING
+#if CONFIG_WD_POLLING_ONLY
 	schedule_delayed_work(&tdata->wd_poll_dwork,
 			msecs_to_jiffies(500));
 #else
@@ -1208,7 +1197,7 @@ static int mt6362_tcpc_init(struct tcpc_device *tcpc, bool sw_reset)
 	mt6362_set_bits(tdata, TCPC_V10_REG_TCPC_CTRL,
 			TCPC_V10_REG_TCPC_CTRL_EN_LOOK4CONNECTION_ALERT);
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 	mt6362_init_wd(tdata);
 #endif /* CONFIG_WATER_DETECTION */
 
@@ -1239,8 +1228,7 @@ static int mt6362_init_mask(struct tcpc_device *tcpc)
 	mt6362_init_ext_mask(tdata);
 	mt6362_init_vend_mask(tdata);
 
-#ifdef CONFIG_CABLE_TYPE_DETECTION
-	/* Init cable type must be done after fod */
+#if CONFIG_CABLE_TYPE_DETECTION
 	if (tdata->handle_init_ctd) {
 		/*
 		 * wait 3ms for exit low power mode and
@@ -1328,7 +1316,7 @@ static int mt6362_get_power_status(struct tcpc_device *tcpc, u16 *status)
 	 * Vsafe0v only triggers when vbus falls under 0.8V,
 	 * also update parameter if vbus present triggers
 	 */
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	ret = tcpci_is_vsafe0v(tcpc);
 	if (ret < 0)
 		goto out;
@@ -1400,7 +1388,7 @@ static int mt6362_set_cc(struct tcpc_device *tcpc, int pull)
 	if (pull == TYPEC_CC_DRP) {
 		ret = mt6362_set_cc_toggling(tdata, pull);
 	} else {
-#ifdef CONFIG_WD_POLLING_ONLY
+#if CONFIG_WD_POLLING_ONLY
 		cancel_delayed_work_sync(&tdata->wd_poll_dwork);
 		mt6362_enable_wd_polling(tdata, false);
 #endif /* CONFIG_WD_POLLING_ONLY */
@@ -1454,7 +1442,7 @@ static int mt6362_set_vconn(struct tcpc_device *tcpc, int en)
 
 static int mt6362_tcpc_deinit(struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_TCPC_SHUTDOWN_CC_DETACH
+#if CONFIG_TCPC_SHUTDOWN_CC_DETACH
 	mt6362_set_cc(tcpc, TYPEC_CC_DRP);
 	mt6362_set_cc(tcpc, TYPEC_CC_OPEN);
 #else
@@ -1473,7 +1461,7 @@ static int mt6362_set_watchdog(struct tcpc_device *tcpc, bool en)
 		(tdata, TCPC_V10_REG_TCPC_CTRL, TCPC_V10_REG_TCPC_CTRL_EN_WDT);
 }
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 static int mt6362_is_vsafe0v(struct tcpc_device *tcpc)
 {
 	int ret;
@@ -1487,7 +1475,7 @@ static int mt6362_is_vsafe0v(struct tcpc_device *tcpc)
 }
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 
-#ifdef CONFIG_TCPC_LOW_POWER_MODE
+#if CONFIG_TCPC_LOW_POWER_MODE
 static int mt6362_is_low_power_mode(struct tcpc_device *tcpc)
 {
 	int ret;
@@ -1508,12 +1496,12 @@ static int mt6362_set_low_power_mode(struct tcpc_device *tcpc, bool en,
 
 	if (en) {
 		data = MT6362_MSK_LPWR_EN;
-#ifdef CONFIG_TYPEC_CAP_NORP_SRC
+#if CONFIG_TYPEC_CAP_NORP_SRC
 		data |= MT6362_MSK_VBUSDET_EN;
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
 	} else {
 		data = MT6362_MSK_VBUSDET_EN | MT6362_MSK_BMCIOOSC_EN;
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 		mt6362_enable_vsafe0v_detect(tdata, true);
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 	}
@@ -1521,7 +1509,7 @@ static int mt6362_set_low_power_mode(struct tcpc_device *tcpc, bool en,
 }
 #endif	/* CONFIG_TCPC_LOW_POWER_MODE */
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 static int mt6362_set_msg_header(struct tcpc_device *tcpc, u8 power_role,
 				 u8 data_role)
 {
@@ -1623,7 +1611,7 @@ static int mt6362_set_bist_carrier_mode(struct tcpc_device *tcpc, u8 pattern)
 }
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 static int mt6362_retransmit(struct tcpc_device *tcpc)
 {
 	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
@@ -1634,7 +1622,7 @@ static int mt6362_retransmit(struct tcpc_device *tcpc)
 }
 #endif /* CONFIG_USB_PD_RETRY_CRC_DISCARD */
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 static int mt6362_is_water_detected(struct tcpc_device *tcpc)
 {
 	int ret, i;
@@ -1667,7 +1655,7 @@ static int mt6362_set_wd_polling(struct tcpc_device *tcpc, bool en)
 {
 	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
 
-#ifdef CONFIG_WD_POLLING_ONLY
+#if CONFIG_WD_POLLING_ONLY
 	if (!en)
 		cancel_delayed_work_sync(&tdata->wd_poll_dwork);
 #endif /* CONFIG_WD_POLLING_ONLY */
@@ -1681,7 +1669,7 @@ static int mt6362_set_wd_polling(struct tcpc_device *tcpc, bool en)
  * ==================================================================
  */
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 static int mt6362_vsafe0v_irq_handler(struct mt6362_tcpc_data *tdata)
 {
 	int ret;
@@ -1694,7 +1682,7 @@ static int mt6362_vsafe0v_irq_handler(struct mt6362_tcpc_data *tdata)
 }
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 static int mt6362_wd12_strise_irq_handler(struct mt6362_tcpc_data *tdata)
 {
 	/* Pull or discharge status from 0 to 1 in normal polling mode */
@@ -1709,7 +1697,7 @@ static int mt6362_wd12_done_irq_handler(struct mt6362_tcpc_data *tdata)
 }
 #endif /* CONFIG_WATER_DETECTION */
 
-#ifdef CONFIG_CABLE_TYPE_DETECTION
+#if CONFIG_CABLE_TYPE_DETECTION
 static int mt6362_ctd_irq_handler(struct mt6362_tcpc_data *tdata)
 {
 	int ret;
@@ -1735,16 +1723,16 @@ struct irq_mapping_tbl {
 	{ .num = _num, .name = #_name, .hdlr = mt6362_##_name##_irq_handler }
 
 static struct irq_mapping_tbl mt6362_vend_irq_mapping_tbl[] = {
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	MT6362_IRQ_MAPPING(1, vsafe0v),
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 	MT6362_IRQ_MAPPING(49, wd12_strise),
 	MT6362_IRQ_MAPPING(50, wd12_done),
 #endif /* CONFIG_WATER_DETECTION */
 
-#ifdef CONFIG_CABLE_TYPE_DETECTION
+#if CONFIG_CABLE_TYPE_DETECTION
 	MT6362_IRQ_MAPPING(20, ctd),
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
 };
@@ -1806,16 +1794,16 @@ static struct tcpc_ops mt6362_tcpc_ops = {
 	.set_watchdog = mt6362_set_watchdog,
 	.alert_vendor_defined_handler = mt6362_alert_vendor_defined_handler,
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	.is_vsafe0v = mt6362_is_vsafe0v,
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 
-#ifdef CONFIG_TCPC_LOW_POWER_MODE
+#if CONFIG_TCPC_LOW_POWER_MODE
 	.is_low_power_mode = mt6362_is_low_power_mode,
 	.set_low_power_mode = mt6362_set_low_power_mode,
 #endif	/* CONFIG_TCPC_LOW_POWER_MODE */
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	.set_msg_header = mt6362_set_msg_header,
 	.set_rx_enable = mt6362_set_rx_enable,
 	.protocol_reset = mt6362_protocol_reset,
@@ -1825,40 +1813,17 @@ static struct tcpc_ops mt6362_tcpc_ops = {
 	.set_bist_carrier_mode = mt6362_set_bist_carrier_mode,
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 	.retransmit = mt6362_retransmit,
 #endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 	.is_water_detected = mt6362_is_water_detected,
 	.set_water_protection = mt6362_set_water_protection,
 	.set_usbid_polling = mt6362_set_wd_polling,
 #endif /* CONFIG_WATER_DETECTION */
 };
 
-static void mt6362_cpu_poll_ctrl(struct mt6362_tcpc_data *tdata)
-{
-	cancel_delayed_work_sync(&tdata->cpu_poll_dwork);
-
-	if (atomic_read(&tdata->cpu_poll_count) == 0) {
-		atomic_inc(&tdata->cpu_poll_count);
-		cpu_idle_poll_ctrl(true);
-	}
-
-	schedule_delayed_work(&tdata->cpu_poll_dwork, msecs_to_jiffies(40));
-}
-
-static void mt6362_cpu_poll_dwork_handler(struct work_struct *work)
-{
-	struct delayed_work *dwork = to_delayed_work(work);
-	struct mt6362_tcpc_data *tdata = container_of(dwork,
-						      struct mt6362_tcpc_data,
-						      cpu_poll_dwork);
-
-	if (atomic_dec_and_test(&tdata->cpu_poll_count))
-		cpu_idle_poll_ctrl(false);
-}
-
 static void mt6362_irq_work_handler(struct kthread_work *work)
 {
 	struct mt6362_tcpc_data *tdata = container_of(work,
@@ -1866,7 +1831,6 @@ static void mt6362_irq_work_handler(struct kthread_work *work)
 						      irq_work);
 
 	MT6362_DBGINFO("++\n");
-	mt6362_cpu_poll_ctrl(tdata);
 	tcpci_lock_typec(tdata->tcpc);
 	tcpci_alert(tdata->tcpc);
 	tcpci_unlock_typec(tdata->tcpc);
@@ -1927,31 +1891,28 @@ static int mt6362_init_irq(struct mt6362_tcpc_data *tdata,
 
 static int mt6362_register_tcpcdev(struct mt6362_tcpc_data *tdata)
 {
-	struct device_node *np = tdata->dev->of_node;
-
 	tdata->tcpc = tcpc_device_register(tdata->dev, tdata->desc,
 					  &mt6362_tcpc_ops, tdata);
-	if (IS_ERR_OR_NULL(tdata->tcpc))
+	if (IS_ERR(tdata->tcpc))
 		return -EINVAL;
 
-#ifdef CONFIG_USB_PD_DISABLE_PE
-	tdata->tcpc->disable_pe = of_property_read_bool(np, "tcpc,disable_pe");
-#endif	/* CONFIG_USB_PD_DISABLE_PE */
-
 	/* Init tcpc_flags */
-#ifdef CONFIG_CABLE_TYPE_DETECTION
+#if CONFIG_CABLE_TYPE_DETECTION
 	tdata->tcpc->tcpc_flags |= TCPC_FLAGS_CABLE_TYPE_DETECTION;
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WD_POLLING_ONLY
+	chip->tcpc->tcpc_flags |= TCPC_FLAGS_WD_POLLING_ONLY;
+#endif
+#if CONFIG_WATER_DETECTION
 	tdata->tcpc->tcpc_flags |= TCPC_FLAGS_WATER_DETECTION;
 #endif /* CONFIG_WATER_DETECTION */
-#ifdef CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
+#if CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
 	tdata->tcpc->tcpc_flags |= TCPC_FLAGS_LPM_WAKEUP_WATCHDOG;
 #endif	/* CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG */
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 	tdata->tcpc->tcpc_flags |= TCPC_FLAGS_RETRY_CRC_DISCARD;
 #endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	tdata->tcpc->tcpc_flags |= TCPC_FLAGS_PD_REV30;
 #endif	/* CONFIG_USB_PD_REV30 */
 	if (tdata->tcpc->tcpc_flags & TCPC_FLAGS_PD_REV30)
@@ -1976,7 +1937,7 @@ static int mt6362_parse_dt(struct mt6362_tcpc_data *tdata)
 	/* default setting */
 	desc->role_def = TYPEC_ROLE_DRP;
 	desc->notifier_supply_num = 0;
-	desc->rp_lvl = TYPEC_RP_DFT;
+	desc->rp_lvl = TYPEC_CC_RP_DFT;
 	desc->vconn_supply = TCPC_VCONN_SUPPLY_ALWAYS;
 
 	if (of_property_read_u32(np, "tcpc,role_def", &val) >= 0) {
@@ -1995,17 +1956,21 @@ static int mt6362_parse_dt(struct mt6362_tcpc_data *tdata)
 
 	if (of_property_read_u32(np, "tcpc,rp_level", &val) >= 0) {
 		switch (val) {
-		case TYPEC_RP_DFT:
-		case TYPEC_RP_1_5:
-		case TYPEC_RP_3_0:
-			desc->rp_lvl = val;
+		case 0: /* RP Default */
+			desc->rp_lvl = TYPEC_CC_RP_DFT;
+			break;
+		case 1: /* RP 1.5V */
+			desc->rp_lvl = TYPEC_CC_RP_1_5;
+			break;
+		case 2: /* RP 3.0V */
+			desc->rp_lvl = TYPEC_CC_RP_3_0;
 			break;
 		default:
 			break;
 		}
 	}
 
-#ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
+#if CONFIG_TCPC_VCONN_SUPPLY_MODE
 	if (of_property_read_u32(np, "tcpc,vconn_supply", &val) >= 0) {
 		if (val >= TCPC_VCONN_SUPPLY_NR)
 			desc->vconn_supply = TCPC_VCONN_SUPPLY_ALWAYS;
@@ -2014,7 +1979,7 @@ static int mt6362_parse_dt(struct mt6362_tcpc_data *tdata)
 	}
 #endif	/* CONFIG_TCPC_VCONN_SUPPLY_MODE */
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 	if (of_property_read_u32(np, "wd,sbu_calib_init", &val) < 0)
 		desc->wd_sbu_calib_init = CONFIG_WD_SBU_CALIB_INIT;
 	else
@@ -2110,7 +2075,7 @@ static void check_printk_performance(void)
 	u64 t1, t2;
 	u32 nsrem;
 
-#ifdef CONFIG_PD_DBG_INFO
+#if IS_ENABLED(CONFIG_PD_DBG_INFO)
 	for (i = 0; i < 10; i++) {
 		t1 = local_clock();
 		pd_dbg_info("%d\n", i);
@@ -2173,12 +2138,10 @@ static int mt6362_tcpc_probe(struct platform_device *pdev)
 #if TCPC_ENABLE_ANYMSG
 	check_printk_performance();
 #endif /* TCPC_ENABLE_ANYMSG */
-	INIT_DELAYED_WORK(&tdata->cpu_poll_dwork,
-			  mt6362_cpu_poll_dwork_handler);
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 	atomic_set(&tdata->wd_protect_rty, CONFIG_WD_PROTECT_RETRY_COUNT);
-#ifdef CONFIG_WD_POLLING_ONLY
+#if CONFIG_WD_POLLING_ONLY
 	INIT_DELAYED_WORK(&tdata->wd_poll_dwork, mt6362_wd_poll_dwork_handler);
 #endif /* CONFIG_WD_POLLING_ONLY */
 #endif /* CONFIG_WATER_DETECTION */
@@ -2204,9 +2167,9 @@ static int mt6362_tcpc_probe(struct platform_device *pdev)
 	}
 
 	/* Must init before sw reset */
-	ret = mt6362_init_fod_ctd(tdata);
+	ret = mt6362_init_ctd(tdata);
 	if (ret < 0) {
-		dev_err(tdata->dev, "%s init fod ctd fail(%d)\n", __func__,
+		dev_err(tdata->dev, "%s init ctd fail(%d)\n", __func__,
 			ret);
 		goto err;
 	}
@@ -2237,10 +2200,9 @@ static int mt6362_tcpc_remove(struct platform_device *pdev)
 
 	if (!tdata)
 		return 0;
-#ifdef CONFIG_WD_POLLING_ONLY
+#if CONFIG_WD_POLLING_ONLY
 	cancel_delayed_work_sync(&tdata->wd_poll_dwork);
 #endif /* CONFIG_WD_POLLING_ONLY */
-	cancel_delayed_work_sync(&tdata->cpu_poll_dwork);
 	if (tdata->tcpc)
 		tcpc_device_unregister(tdata->dev, tdata->tcpc);
 	return 0;
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpc_mt6370.c b/drivers/misc/mediatek/typec/tcpc/tcpc_mt6370.c
index c138f98..72cd91f 100644
--- a/drivers/misc/mediatek/typec/tcpc/tcpc_mt6370.c
+++ b/drivers/misc/mediatek/typec/tcpc/tcpc_mt6370.c
@@ -1,16 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * Mediatek MT6370 Type-C Port Control Driver
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include <linux/init.h>
@@ -36,15 +26,14 @@
 #include "inc/tcpci.h"
 #include "inc/mt6370.h"
 
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 #include <mt-plat/rt-regmap.h>
 #endif /* CONFIG_RT_REGMAP */
 
-#if 1 /*  #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))*/
 #include <linux/sched/rt.h>
-#endif /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)) */
 
 /* #define DEBUG_GPIO	66 */
+#define DEBUG_GPIO 0
 
 #define MT6370_DRV_VERSION	"2.0.6_MTK"
 
@@ -53,7 +42,7 @@
 struct mt6370_chip {
 	struct i2c_client *client;
 	struct device *dev;
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	struct rt_regmap_device *m_dev;
 #endif /* CONFIG_RT_REGMAP */
 	struct semaphore io_lock;
@@ -74,7 +63,7 @@ struct mt6370_chip {
 	int chip_id;
 };
 
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 RT_REG_DECL(TCPC_V10_REG_VID, 2, RT_NORMAL_WR_ONCE, {});
 RT_REG_DECL(TCPC_V10_REG_PID, 2, RT_NORMAL_WR_ONCE, {});
 RT_REG_DECL(TCPC_V10_REG_DID, 2, RT_NORMAL_WR_ONCE, {});
@@ -255,7 +244,7 @@ static int mt6370_reg_read(struct i2c_client *i2c, u8 reg)
 	u8 val = 0;
 	int ret = 0;
 
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	ret = rt_regmap_block_read(chip->m_dev, reg, 1, &val);
 #else
 	ret = mt6370_read_device(chip->client, reg, 1, &val);
@@ -272,7 +261,7 @@ static int mt6370_reg_write(struct i2c_client *i2c, u8 reg, const u8 data)
 	struct mt6370_chip *chip = i2c_get_clientdata(i2c);
 	int ret = 0;
 
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	ret = rt_regmap_block_write(chip->m_dev, reg, 1, &data);
 #else
 	ret = mt6370_write_device(chip->client, reg, 1, &data);
@@ -287,11 +276,11 @@ static int mt6370_block_read(struct i2c_client *i2c,
 {
 	struct mt6370_chip *chip = i2c_get_clientdata(i2c);
 	int ret = 0;
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	ret = rt_regmap_block_read(chip->m_dev, reg, len, dst);
 #else
 	ret = mt6370_read_device(chip->client, reg, len, dst);
-#endif /* #ifdef CONFIG_RT_REGMAP */
+#endif /* #if IS_ENABLED(CONFIG_RT_REGMAP) */
 	if (ret < 0)
 		dev_err(chip->dev, "mt6370 block read fail\n");
 	return ret;
@@ -302,11 +291,11 @@ static int mt6370_block_write(struct i2c_client *i2c,
 {
 	struct mt6370_chip *chip = i2c_get_clientdata(i2c);
 	int ret = 0;
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	ret = rt_regmap_block_write(chip->m_dev, reg, len, src);
 #else
 	ret = mt6370_write_device(chip->client, reg, len, src);
-#endif /* #ifdef CONFIG_RT_REGMAP */
+#endif /* #if IS_ENABLED(CONFIG_RT_REGMAP) */
 	if (ret < 0)
 		dev_err(chip->dev, "mt6370 block write fail\n");
 	return ret;
@@ -368,7 +357,7 @@ static inline int mt6370_i2c_read16(
 	return data;
 }
 
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 static struct rt_regmap_fops mt6370_regmap_fops = {
 	.read_device = mt6370_read_device,
 	.write_device = mt6370_write_device,
@@ -377,7 +366,7 @@ static struct rt_regmap_fops mt6370_regmap_fops = {
 
 static int mt6370_regmap_init(struct mt6370_chip *chip)
 {
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	struct rt_regmap_properties *props;
 	char name[32];
 	int len;
@@ -422,7 +411,7 @@ static int mt6370_regmap_init(struct mt6370_chip *chip)
 
 static int mt6370_regmap_deinit(struct mt6370_chip *chip)
 {
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	rt_regmap_device_unregister(chip->m_dev);
 #endif
 	return 0;
@@ -431,13 +420,13 @@ static int mt6370_regmap_deinit(struct mt6370_chip *chip)
 static inline int mt6370_software_reset(struct tcpc_device *tcpc)
 {
 	int ret = mt6370_i2c_write8(tcpc, MT6370_REG_SWRESET, 1);
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	struct mt6370_chip *chip = tcpc_get_dev_data(tcpc);
 #endif /* CONFIG_RT_REGMAP */
 
 	if (ret < 0)
 		return ret;
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	rt_regmap_cache_reload(chip->m_dev);
 #endif /* CONFIG_RT_REGMAP */
 	usleep_range(1000, 2000);
@@ -456,7 +445,7 @@ static int mt6370_init_alert_mask(struct tcpc_device *tcpc)
 
 	mask = TCPC_V10_REG_ALERT_CC_STATUS | TCPC_V10_REG_ALERT_POWER_STATUS;
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	/* Need to handle RX overflow */
 	mask |= TCPC_V10_REG_ALERT_TX_SUCCESS | TCPC_V10_REG_ALERT_TX_DISCARDED
 			| TCPC_V10_REG_ALERT_TX_FAILED
@@ -491,19 +480,19 @@ static int mt6370_init_fault_mask(struct tcpc_device *tcpc)
 static int mt6370_init_mt_mask(struct tcpc_device *tcpc)
 {
 	uint8_t mt_mask = 0;
-#ifdef CONFIG_TCPC_WATCHDOG_EN
+#if CONFIG_TCPC_WATCHDOG_EN
 	mt_mask |= MT6370_REG_M_WATCHDOG;
 #endif /* CONFIG_TCPC_WATCHDOG_EN */
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	mt_mask |= MT6370_REG_M_VBUS_80;
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 
-#ifdef CONFIG_TYPEC_CAP_RA_DETACH
+#if CONFIG_TYPEC_CAP_RA_DETACH
 	if (tcpc->tcpc_flags & TCPC_FLAGS_CHECK_RA_DETACHE)
 		mt_mask |= MT6370_REG_M_RA_DETACH;
 #endif /* CONFIG_TYPEC_CAP_RA_DETACH */
 
-#ifdef CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
+#if CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
 	if (tcpc->tcpc_flags & TCPC_FLAGS_LPM_WAKEUP_WATCHDOG)
 		mt_mask |= MT6370_REG_M_WAKEUP;
 #endif	/* CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG */
@@ -535,7 +524,7 @@ static void mt6370_irq_work_handler(struct kthread_work *work)
 	/* make sure I2C bus had resumed */
 	tcpci_lock_typec(chip->tcpc);
 
-#ifdef DEBUG_GPIO
+#if DEBUG_GPIO
 	gpio_set_value(DEBUG_GPIO, 1);
 #endif
 
@@ -548,7 +537,7 @@ static void mt6370_irq_work_handler(struct kthread_work *work)
 
 	tcpci_unlock_typec(chip->tcpc);
 
-#ifdef DEBUG_GPIO
+#if DEBUG_GPIO
 	gpio_set_value(DEBUG_GPIO, 1);
 #endif
 }
@@ -568,7 +557,7 @@ static irqreturn_t mt6370_intr_handler(int irq, void *data)
 
 	__pm_wakeup_event(chip->irq_wake_lock, MT6370_IRQ_WAKE_TIME);
 
-#ifdef DEBUG_GPIO
+#if DEBUG_GPIO
 	gpio_set_value(DEBUG_GPIO, 0);
 #endif
 	kthread_queue_work(&chip->irq_worker, &chip->irq_work);
@@ -594,14 +583,13 @@ static int mt6370_init_alert(struct tcpc_device *tcpc)
 
 	ret = snprintf(name, PAGE_SIZE, "%s-IRQ", chip->tcpc_desc->name);
 	if (ret < 0 || ret >= PAGE_SIZE)
-		pr_info("%s-%d, snprintf fail, ret=%d\n",
-			__func__, __LINE__, ret);
+		pr_info("%s-%d, snprintf fail\n", __func__, __LINE__);
 
 	pr_info("%s name = %s, gpio = %d\n", __func__,
 				chip->tcpc_desc->name, chip->irq_gpio);
 
 	ret = devm_gpio_request(chip->dev, chip->irq_gpio, name);
-#ifdef DEBUG_GPIO
+#if DEBUG_GPIO
 	gpio_request(DEBUG_GPIO, "debug_latency_pin");
 	gpio_direction_output(DEBUG_GPIO, 1);
 #endif
@@ -658,7 +646,7 @@ int mt6370_alert_status_clear(struct tcpc_device *tcpc, uint32_t mask)
 	int ret;
 	uint16_t mask_t1;
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	uint8_t mask_t2;
 #endif
 
@@ -670,7 +658,7 @@ int mt6370_alert_status_clear(struct tcpc_device *tcpc, uint32_t mask)
 			return ret;
 	}
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	mask_t2 = mask >> 16;
 	if (mask_t2) {
 		ret = mt6370_i2c_write8(tcpc, MT6370_REG_MT_INT, mask_t2);
@@ -687,7 +675,7 @@ static int mt6370_set_clock_gating(struct tcpc_device *tcpc,
 {
 	int ret = 0;
 
-#ifdef CONFIG_TCPC_CLOCK_GATING
+#if CONFIG_TCPC_CLOCK_GATING
 	int i = 0;
 	uint8_t clk2 = MT6370_REG_CLK_DIV_600K_EN
 		| MT6370_REG_CLK_DIV_300K_EN | MT6370_REG_CLK_CK_300K_EN;
@@ -720,8 +708,8 @@ static inline int mt6370_init_cc_params(
 {
 	int rv = 0;
 
-#ifdef CONFIG_USB_POWER_DELIVERY
-#ifdef CONFIG_USB_PD_SNK_DFT_NO_GOOD_CRC
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
+#if CONFIG_USB_PD_SNK_DFT_NO_GOOD_CRC
 	uint8_t en, sel;
 
 	if (cc_res == TYPEC_CC_VOLT_SNK_DFT) { /* 0.55 */
@@ -761,7 +749,7 @@ static int mt6370_tcpc_init(struct tcpc_device *tcpc, bool sw_reset)
 	mt6370_i2c_write8(tcpc, MT6370_REG_PHY_CTRL11, 0xfc);
 	mt6370_i2c_write8(tcpc, MT6370_REG_PHY_CTRL12, 0x50);
 
-#ifdef CONFIG_TCPC_I2CRST_EN
+#if CONFIG_TCPC_I2CRST_EN
 	mt6370_i2c_write8(tcpc,
 		MT6370_REG_I2CRST_CTRL,
 		MT6370_REG_I2CRST_SET(true, 0x0f));
@@ -854,7 +842,7 @@ int mt6370_fault_status_clear(struct tcpc_device *tcpc, uint8_t status)
 int mt6370_get_alert_mask(struct tcpc_device *tcpc, uint32_t *mask)
 {
 	int ret;
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	uint8_t v2;
 #endif
 
@@ -863,7 +851,7 @@ int mt6370_get_alert_mask(struct tcpc_device *tcpc, uint32_t *mask)
 		return ret;
 	*mask = (uint16_t) ret;
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	ret = mt6370_i2c_read8(tcpc, MT6370_REG_MT_MASK);
 	if (ret < 0)
 		return ret;
@@ -877,7 +865,7 @@ int mt6370_get_alert_mask(struct tcpc_device *tcpc, uint32_t *mask)
 int mt6370_get_alert_status(struct tcpc_device *tcpc, uint32_t *alert)
 {
 	int ret;
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	uint8_t v2;
 #endif
 
@@ -887,7 +875,7 @@ int mt6370_get_alert_status(struct tcpc_device *tcpc, uint32_t *alert)
 
 	*alert = (uint16_t) ret;
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	ret = mt6370_i2c_read8(tcpc, MT6370_REG_MT_INT);
 	if (ret < 0)
 		return ret;
@@ -913,7 +901,7 @@ static int mt6370_get_power_status(
 	if (ret & TCPC_V10_REG_POWER_STATUS_VBUS_PRES)
 		*pwr_status |= TCPC_REG_POWER_STATUS_VBUS_PRES;
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	ret = mt6370_i2c_read8(tcpc, MT6370_REG_MT_STATUS);
 	if (ret < 0)
 		return ret;
@@ -962,10 +950,7 @@ static int mt6370_get_cc(struct tcpc_device *tcpc, int *cc1, int *cc2)
 	if (act_as_drp) {
 		act_as_sink = TCPC_V10_REG_CC_STATUS_DRP_RESULT(status);
 	} else {
-		if (tcpc->typec_polarity)
-			cc_role = TCPC_V10_REG_CC_STATUS_CC2(role_ctrl);
-		else
-			cc_role = TCPC_V10_REG_CC_STATUS_CC1(role_ctrl);
+		cc_role =  TCPC_V10_REG_CC_STATUS_CC1(role_ctrl);
 		if (cc_role == TYPEC_CC_RP)
 			act_as_sink = false;
 		else
@@ -989,7 +974,7 @@ static int mt6370_get_cc(struct tcpc_device *tcpc, int *cc1, int *cc2)
 	return 0;
 }
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 static int mt6370_enable_vsafe0v_detect(
 	struct tcpc_device *tcpc, bool enable)
 {
@@ -1013,7 +998,7 @@ static int mt6370_set_cc(struct tcpc_device *tcpc, int pull)
 	uint8_t data;
 	int rp_lvl = TYPEC_CC_PULL_GET_RP_LVL(pull), pull1, pull2;
 
-	MT6370_INFO("pull = 0x%02X\n", pull);
+	MT6370_INFO("\n");
 	pull = TYPEC_CC_PULL_GET_RES(pull);
 	if (pull == TYPEC_CC_DRP) {
 		data = TCPC_V10_REG_ROLE_CTRL_RES_SET(
@@ -1023,20 +1008,22 @@ static int mt6370_set_cc(struct tcpc_device *tcpc, int pull)
 			tcpc, TCPC_V10_REG_ROLE_CTRL, data);
 
 		if (ret == 0) {
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 			mt6370_enable_vsafe0v_detect(tcpc, false);
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 			ret = mt6370_command(tcpc, TCPM_CMD_LOOK_CONNECTION);
 		}
 	} else {
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 		if (pull == TYPEC_CC_RD && tcpc->pd_wait_pr_swap_complete)
 			mt6370_init_cc_params(tcpc, TYPEC_CC_VOLT_SNK_DFT);
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
 		pull1 = pull2 = pull;
 
-		if (pull == TYPEC_CC_RP && tcpc->typec_is_attached_src) {
+		if ((pull == TYPEC_CC_RP_DFT || pull == TYPEC_CC_RP_1_5 ||
+			pull == TYPEC_CC_RP_3_0) &&
+			tcpc->typec_is_attached_src) {
 			if (tcpc->typec_polarity)
 				pull1 = TYPEC_CC_OPEN;
 			else
@@ -1053,13 +1040,12 @@ static int mt6370_set_polarity(struct tcpc_device *tcpc, int polarity)
 {
 	int data;
 
-	if (polarity < 0 || polarity > 1)
-		return -EOVERFLOW;
-
-	data = mt6370_init_cc_params(tcpc,
-		tcpc->typec_remote_cc[polarity]);
-	if (data)
-		return data;
+	if (polarity >= 0 && polarity < ARRAY_SIZE(tcpc->typec_remote_cc)) {
+		data = mt6370_init_cc_params(tcpc,
+			tcpc->typec_remote_cc[polarity]);
+		if (data)
+			return data;
+	}
 
 	data = mt6370_i2c_read8(tcpc, TCPC_V10_REG_TCPC_CTRL);
 	if (data < 0)
@@ -1100,7 +1086,7 @@ static int mt6370_set_vconn(struct tcpc_device *tcpc, int enable)
 	return rv;
 }
 
-#ifdef CONFIG_TCPC_LOW_POWER_MODE
+#if CONFIG_TCPC_LOW_POWER_MODE
 static int mt6370_is_low_power_mode(struct tcpc_device *tcpc)
 {
 	int rv = mt6370_i2c_read8(tcpc, MT6370_REG_BMC_CTRL);
@@ -1121,7 +1107,7 @@ static int mt6370_set_low_power_mode(
 		MT6370_REG_IDLE_SET(0, 1, en ? 0 : 1, 0));
 	if (ret < 0)
 		return ret;
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	mt6370_enable_vsafe0v_detect(tcpc, !en);
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 	if (en) {
@@ -1130,7 +1116,7 @@ static int mt6370_set_low_power_mode(
 		if (pull & TYPEC_CC_RP)
 			data |= MT6370_REG_BMCIO_LPRPRD;
 
-#ifdef CONFIG_TYPEC_CAP_NORP_SRC
+#if CONFIG_TYPEC_CAP_NORP_SRC
 		data |= MT6370_REG_BMCIO_BG_EN | MT6370_REG_VBUS_DET_EN;
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
 	} else {
@@ -1142,7 +1128,7 @@ static int mt6370_set_low_power_mode(
 }
 #endif	/* CONFIG_TCPC_LOW_POWER_MODE */
 
-#ifdef CONFIG_TCPC_WATCHDOG_EN
+#if CONFIG_TCPC_WATCHDOG_EN
 int mt6370_set_watchdog(struct tcpc_device *tcpc, bool en)
 {
 	uint8_t data = MT6370_REG_WATCHDOG_CTRL_SET(en, 7);
@@ -1152,7 +1138,7 @@ int mt6370_set_watchdog(struct tcpc_device *tcpc, bool en)
 }
 #endif	/* CONFIG_TCPC_WATCHDOG_EN */
 
-#ifdef CONFIG_TCPC_INTRST_EN
+#if CONFIG_TCPC_INTRST_EN
 int mt6370_set_intrst(struct tcpc_device *tcpc, bool en)
 {
 	return mt6370_i2c_write8(tcpc,
@@ -1162,11 +1148,11 @@ int mt6370_set_intrst(struct tcpc_device *tcpc, bool en)
 
 static int mt6370_tcpc_deinit(struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	struct mt6370_chip *chip = tcpc_get_dev_data(tcpc);
 #endif /* CONFIG_RT_REGMAP */
 
-#ifdef CONFIG_TCPC_SHUTDOWN_CC_DETACH
+#if CONFIG_TCPC_SHUTDOWN_CC_DETACH
 	mt6370_set_cc(tcpc, TYPEC_CC_DRP);
 	mt6370_set_cc(tcpc, TYPEC_CC_OPEN);
 
@@ -1180,14 +1166,14 @@ static int mt6370_tcpc_deinit(struct tcpc_device *tcpc)
 #else
 	mt6370_i2c_write8(tcpc, MT6370_REG_SWRESET, 1);
 #endif	/* CONFIG_TCPC_SHUTDOWN_CC_DETACH */
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	rt_regmap_cache_reload(chip->m_dev);
 #endif /* CONFIG_RT_REGMAP */
 
 	return 0;
 }
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 static int mt6370_set_msg_header(
 	struct tcpc_device *tcpc, uint8_t power_role, uint8_t data_role)
 {
@@ -1266,7 +1252,7 @@ static int mt6370_set_bist_carrier_mode(
 /* transmit count (1byte) + message header (2byte) + data object (7*4) */
 #define MT6370_TRANSMIT_MAX_SIZE (1+sizeof(uint16_t) + sizeof(uint32_t)*7)
 
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 static int mt6370_retransmit(struct tcpc_device *tcpc)
 {
 	return mt6370_i2c_write8(tcpc, TCPC_V10_REG_TRANSMIT,
@@ -1335,20 +1321,20 @@ static struct tcpc_ops mt6370_tcpc_ops = {
 	.set_vconn = mt6370_set_vconn,
 	.deinit = mt6370_tcpc_deinit,
 
-#ifdef CONFIG_TCPC_LOW_POWER_MODE
+#if CONFIG_TCPC_LOW_POWER_MODE
 	.is_low_power_mode = mt6370_is_low_power_mode,
 	.set_low_power_mode = mt6370_set_low_power_mode,
 #endif	/* CONFIG_TCPC_LOW_POWER_MODE */
 
-#ifdef CONFIG_TCPC_WATCHDOG_EN
+#if CONFIG_TCPC_WATCHDOG_EN
 	.set_watchdog = mt6370_set_watchdog,
 #endif	/* CONFIG_TCPC_WATCHDOG_EN */
 
-#ifdef CONFIG_TCPC_INTRST_EN
+#if CONFIG_TCPC_INTRST_EN
 	.set_intrst = mt6370_set_intrst,
 #endif	/* CONFIG_TCPC_INTRST_EN */
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	.set_msg_header = mt6370_set_msg_header,
 	.set_rx_enable = mt6370_set_rx_enable,
 	.protocol_reset = mt6370_protocol_reset,
@@ -1358,7 +1344,7 @@ static struct tcpc_ops mt6370_tcpc_ops = {
 	.set_bist_carrier_mode = mt6370_set_bist_carrier_mode,
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 	.retransmit = mt6370_retransmit,
 #endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
 };
@@ -1377,7 +1363,7 @@ static int mt_parse_dt(struct mt6370_chip *chip, struct device *dev)
 	}
 	dev->of_node = np;
 
-#if (!defined(CONFIG_MTK_GPIO) || defined(CONFIG_MTK_GPIOLIB_STAND))
+#if IS_ENABLED(CONFIG_MTK_GPIO) || IS_ENABLED(CONFIG_MTK_GPIOLIB_STAND)
 	ret = of_get_named_gpio(np, "mt6370pd,intr_gpio", 0);
 	if (ret < 0)
 		pr_err("%s no intr_gpio info\n", __func__);
@@ -1404,7 +1390,7 @@ static void check_printk_performance(void)
 	u64 t1, t2;
 	u32 nsrem;
 
-#ifdef CONFIG_PD_DBG_INFO
+#if IS_ENABLED(CONFIG_PD_DBG_INFO)
 	for (i = 0; i < 10; i++) {
 		t1 = local_clock();
 		pd_dbg_info("%d\n", i);
@@ -1471,17 +1457,21 @@ static int mt6370_tcpcdev_init(struct mt6370_chip *chip, struct device *dev)
 
 	if (of_property_read_u32(np, "mt-tcpc,rp_level", &val) >= 0) {
 		switch (val) {
-		case TYPEC_RP_DFT:
-		case TYPEC_RP_1_5:
-		case TYPEC_RP_3_0:
-			desc->rp_lvl = val;
+		case 0: /* RP Default */
+			desc->rp_lvl = TYPEC_CC_RP_DFT;
+			break;
+		case 1: /* RP 1.5V */
+			desc->rp_lvl = TYPEC_CC_RP_1_5;
+			break;
+		case 2: /* RP 3.0V */
+			desc->rp_lvl = TYPEC_CC_RP_3_0;
 			break;
 		default:
 			break;
 		}
 	}
 
-#ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
+#if CONFIG_TCPC_VCONN_SUPPLY_MODE
 	if (of_property_read_u32(np, "mt-tcpc,vconn_supply", &val) >= 0) {
 		if (val >= TCPC_VCONN_SUPPLY_NR)
 			desc->vconn_supply = TCPC_VCONN_SUPPLY_ALWAYS;
@@ -1509,23 +1499,18 @@ static int mt6370_tcpcdev_init(struct mt6370_chip *chip, struct device *dev)
 
 	chip->tcpc = tcpc_device_register(dev,
 			desc, &mt6370_tcpc_ops, chip);
-	if (IS_ERR_OR_NULL(chip->tcpc))
+	if (IS_ERR(chip->tcpc))
 		return -EINVAL;
 
-#ifdef CONFIG_USB_PD_DISABLE_PE
-	chip->tcpc->disable_pe =
-			of_property_read_bool(np, "mt-tcpc,disable_pe");
-#endif	/* CONFIG_USB_PD_DISABLE_PE */
-
 	chip->tcpc->tcpc_flags =
 		TCPC_FLAGS_LPM_WAKEUP_WATCHDOG |
 		TCPC_FLAGS_RETRY_CRC_DISCARD;
 
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 	chip->tcpc->tcpc_flags |= TCPC_FLAGS_RETRY_CRC_DISCARD;
 #endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	chip->tcpc->tcpc_flags |= TCPC_FLAGS_PD_REV30;
 
 	if (chip->tcpc->tcpc_flags & TCPC_FLAGS_PD_REV30)
@@ -1682,7 +1667,7 @@ static int mt6370_i2c_remove(struct i2c_client *client)
 	return 0;
 }
 
-#ifdef CONFIG_PM
+#if CONFIG_PM
 static int mt6370_i2c_suspend(struct device *dev)
 {
 	struct mt6370_chip *chip;
@@ -1691,7 +1676,7 @@ static int mt6370_i2c_suspend(struct device *dev)
 	if (client) {
 		chip = i2c_get_clientdata(client);
 		if (chip) {
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 			if (chip->tcpc->pd_wait_hard_reset_complete) {
 				pr_info("%s WAITING HRESET(%d) - NO SUSPEND\n",
 				    __func__,
@@ -1738,7 +1723,7 @@ static void mt6370_shutdown(struct i2c_client *client)
 	}
 }
 
-#ifdef CONFIG_PM_RUNTIME
+#if IS_ENABLED(CONFIG_PM_RUNTIME)
 static int mt6370_pm_suspend_runtime(struct device *device)
 {
 	dev_dbg(device, "pm_runtime: suspending...\n");
@@ -1757,7 +1742,7 @@ static const struct dev_pm_ops mt6370_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(
 			mt6370_i2c_suspend,
 			mt6370_i2c_resume)
-#ifdef CONFIG_PM_RUNTIME
+#if IS_ENABLED(CONFIG_PM_RUNTIME)
 	SET_RUNTIME_PM_OPS(
 		mt6370_pm_suspend_runtime,
 		mt6370_pm_resume_runtime,
diff --git a/./tcpc_mt6375.c b/drivers/misc/mediatek/typec/tcpc/tcpc_mt6375.c
new file mode 100644
index 0000000..6e8d6c8
--- /dev/null
+++ b/drivers/misc/mediatek/typec/tcpc/tcpc_mt6375.c
@@ -0,0 +1,2732 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+#include <linux/platform_device.h>
+#include <linux/kthread.h>
+#include <linux/cpu.h>
+#include <linux/iio/consumer.h>
+#include <uapi/linux/sched/types.h>
+#include <dt-bindings/mfd/mt6375.h>
+#include <linux/sched/clock.h>
+
+#include "inc/tcpci.h"
+#include "inc/tcpci_typec.h"
+#include "inc/tcpci_core.h"
+#include "inc/std_tcpci_v10.h"
+
+#define MT6375_INFO_EN	1
+#define MT6375_DBGINFO_EN	1
+#define MT6375_WD1_EN	1
+#define MT6375_WD2_EN	1
+
+#define MT6375_INFO(fmt, ...) \
+	do { \
+		if (MT6375_INFO_EN) \
+			pd_dbg_info("%s " fmt, __func__, ##__VA_ARGS__); \
+	} while (0)
+
+#define MT6375_DBGINFO(fmt, ...) \
+	do { \
+		if (MT6375_DBGINFO_EN) \
+			pd_dbg_info("%s " fmt, __func__, ##__VA_ARGS__); \
+	} while (0)
+
+#define MT6375_VID	0x29CF
+#define MT6375_PID	0x6375
+
+#define MT6375_IRQ_WAKE_TIME	(500) /* ms */
+
+/* Vendor Register Define */
+#define MT6375_REG_PHYCTRL1	(0x80)
+#define MT6375_REG_PHYCTRL2	(0x81)
+#define MT6375_REG_PHYCTRL3	(0x82)
+#define MT6375_REG_PHYCTRL7	(0x86)
+#define MT6375_REG_PHYCTRL8	(0x89)
+#define MT6375_REG_VCONCTRL2	(0x8B)
+#define MT6375_REG_VCONCTRL3	(0x8C)
+#define MT6375_REG_SYSCTRL1	(0x8F)
+#define MT6375_REG_SYSCTRL2	(0x90)
+#define MT6375_REG_MTMASK1	(0x91)
+#define MT6375_REG_MTMASK2	(0x92)
+#define MT6375_REG_MTMASK3	(0x93)
+#define MT6375_REG_MTMASK4	(0x94)
+#define MT6375_REG_MTMASK5	(0x95)
+#define MT6375_REG_MTMASK6	(0x96)
+#define MT6375_REG_MTMASK7	(0x97)
+#define MT6375_REG_MTINT1	(0x98)
+#define MT6375_REG_MTINT2	(0x99)
+#define MT6375_REG_MTINT3	(0x9A)
+#define MT6375_REG_MTINT4	(0x9B)
+#define MT6375_REG_MTINT5	(0x9C)
+#define MT6375_REG_MTINT6	(0x9D)
+#define MT6375_REG_MTINT7	(0x9E)
+#define MT6375_REG_MTST1	(0x9F)
+#define MT6375_REG_MTST2	(0xA0)
+#define MT6375_REG_MTST3	(0xA1)
+#define MT6375_REG_MTST4	(0xA2)
+#define MT6375_REG_MTST5	(0xA3)
+#define MT6375_REG_MTST6	(0xA4)
+#define MT6375_REG_MTST7	(0xA5)
+#define MT6375_REG_PHYCTRL9	(0xAC)
+#define MT6375_REG_SYSCTRL3	(0xB0)
+#define MT6375_REG_TCPCCTRL1	(0xB1)
+#define MT6375_REG_TCPCCTRL2	(0xB2)
+#define MT6375_REG_TCPCCTRL3	(0xB3)
+#define MT6375_REG_LPWRCTRL3	(0xBB)
+#define MT6375_REG_WATCHDOGCTRL	(0xBE)
+#define MT6375_REG_I2CTORSTCTRL	(0xBF)
+#define MT6375_REG_HILOCTRL9	(0xC8)
+#define MT6375_REG_HILOCTRL10	(0xC9)
+#define MT6375_REG_SHIELDCTRL1	(0xCA)
+#define MT6375_REG_TYPECOTPCTRL	(0xCD)
+#define MT6375_REG_WD12MODECTRL	(0xD0)
+#define MT6375_REG_WD1PATHEN	(0xD1)
+#define MT6375_REG_WD1MISCCTRL	(0xD2)
+#define MT6375_REG_WD2PATHEN	(0xD3)
+#define MT6375_REG_WD2MISCCTRL	(0xD4)
+#define MT6375_REG_WD1PULLST	(0xD5)
+#define MT6375_REG_WD1DISCHGST	(0xD6)
+#define MT6375_REG_WD2PULLST	(0xD7)
+#define MT6375_REG_WD2DISCHGST	(0xD8)
+#define MT6375_REG_WD0MODECTRL	(0xD9)
+#define MT6375_REG_WD0SET	(0xDA)
+#define MT6375_REG_WDSET	(0xDB)
+#define MT6375_REG_WDSET1	(0xDC)
+
+/* RT2 */
+#define MT6375_REG_RT2BASEADDR	(0xF200)
+#define MT6375_REG_WDSET2	(0x20)
+#define MT6375_REG_WDSET3	(0x21)
+#define MT6375_REG_WD1MISCSET	(0x22)
+#define MT6375_REG_WD1VOLCMP	(0x23)
+#define MT6375_REG_WD2MISCSET	(0x28)
+#define MT6375_REG_WD2VOLCMP	(0x29)
+
+/* PMU */
+#define MT6375_REG_DPDM_CTRL1	(0x153)
+
+/* Mask & Shift */
+/* MT6375_REG_PHYCTRL8: 0x89 */
+#define MT6375_MSK_PRLRSTB	BIT(1)
+/* MT6375_REG_VCONCTRL2: 0x8B */
+#define MT6375_MSK_VCON_RVPEN	BIT(3)
+#define MT6375_MSK_VCON_OVCCEN	BIT(7)
+#define MT6375_MSK_VCON_PROTEN	\
+	(MT6375_MSK_VCON_RVPEN | MT6375_MSK_VCON_OVCCEN)
+/* MT6375_REG_SYSCTRL1: 0x8F */
+#define MT6375_MSK_AUTOIDLE_EN	BIT(3)
+#define MT6375_MSK_SHIPPING_OFF	BIT(5)
+/* MT6375_REG_SYSCTRL2: 0x90 */
+#define MT6375_MSK_BMCIOOSC_EN	BIT(0)
+#define MT6375_MSK_VBUSDET_EN	BIT(1)
+#define MT6375_MSK_LPWR_EN	BIT(3)
+/* MT6375_REG_MTINT1: 0x98 */
+#define MT6375_MSK_WAKEUP	BIT(0)
+#define MT6375_MSK_VBUS80	BIT(1)
+#define MT6375_MSK_TYPECOTP	BIT(2)
+/* MT6375_REG_MTINT2: 0x99 */
+#define MT6375_MSK_VCON_OVCC1	BIT(0)
+#define MT6375_MSK_VCON_OVCC2	BIT(1)
+#define MT6375_MSK_VCON_RVP	BIT(2)
+#define MT6375_MSK_VCON_UVP	BIT(4)
+#define MT6375_MSK_VCON_SHTGND	BIT(5)
+#define MT6375_MSK_VCON_FAULT \
+	(MT6375_MSK_VCON_OVCC1 | MT6375_MSK_VCON_OVCC2 | MT6375_MSK_VCON_RVP | \
+	 MT6375_MSK_VCON_UVP | MT6375_MSK_VCON_SHTGND)
+/* MT6375_REG_MTINT3: 0x9A */
+#define MT6375_MSK_CTD		BIT(4)
+/* MT6375_REG_MTINT4: 0x9B */
+#define MT6375_MSK_FOD_DONE	BIT(0)
+#define MT6375_MSK_FOD_OV	BIT(1)
+#define MT6375_MSK_FOD_LR	BIT(5)
+#define MT6375_MSK_FOD_HR	BIT(6)
+#define MT6375_MSK_FOD_DISCHGF	BIT(7)
+#define MT6375_MSK_FOD_ALL \
+	(MT6375_MSK_FOD_DONE | MT6375_MSK_FOD_OV | MT6375_MSK_FOD_LR | \
+	 MT6375_MSK_FOD_HR | MT6375_MSK_FOD_DISCHGF)
+/* MT6375_REG_MTINT5: 0x9C */
+#define MT6375_MSK_HIDET_CC1	BIT(4)
+#define MT6375_MSK_HIDET_CC2	BIT(5)
+#define MT6375_MSK_HIDET_CC	(MT6375_MSK_HIDET_CC1 | MT6375_MSK_HIDET_CC2)
+/* MT6375_REG_MTINT7: 0x9E */
+#define MT6375_MSK_WD12_STFALL	BIT(0)
+#define MT6375_MSK_WD12_STRISE	BIT(1)
+#define MT6375_MSK_WD12_DONE	BIT(2)
+#define MT6375_MSK_WD0_STFALL	BIT(3)
+#define MT6375_MSK_WD0_STRISE	BIT(4)
+/* MT6375_REG_MTST3: 0xA1 */
+#define MT6375_MSK_CABLE_TYPEC	BIT(4)
+#define MT6375_MSK_CABLE_TYPEA	BIT(5)
+/* MT6375_REG_HILOCTRL10: 0xC9 */
+#define MT6375_MSK_HIDET_CC1_CMPEN	BIT(1)
+#define MT6375_MSK_HIDET_CC2_CMPEN	BIT(4)
+#define MT6375_MSK_HIDET_CC_CMPEN \
+	(MT6375_MSK_HIDET_CC1_CMPEN | MT6375_MSK_HIDET_CC2_CMPEN)
+/* MT6375_REG_SHIELDCTRL1: 0xCA */
+#define MT6375_MSK_CTD_EN	BIT(1)
+#define MT6375_MSK_OPEN40MS_EN	BIT(4)
+#define MT6375_MSK_RPDET_MANUAL	BIT(6)
+#define MT6375_MSK_RPDET_AUTO	BIT(7)
+/* MT6375_REG_TYPECOTPCTRL: 0xCD */
+#define MT6375_MSK_TYPECOTP_FWEN	BIT(2)
+/* MT6375_REG_WD12MODECTRL: 0xD0 */
+#define MT6375_MSK_WD12MODE_EN	BIT(4)
+#define MT6375_MSK_WD12PROT	BIT(6)
+/* MT6375_REG_WD1PATHEN: 0xD1 */
+#define MT6375_MSK_WDSBU1_EN	BIT(0)
+#define MT6375_MSK_WDSBU2_EN	BIT(1)
+#define MT6375_MSK_WDCC1_EN	BIT(2)
+#define MT6375_MSK_WDCC2_EN	BIT(3)
+#define MT6375_MSK_WDDP_EN	BIT(4)
+#define MT6375_MSK_WDDM_EN	BIT(5)
+/* MT6375_REG_WD1MISCCTRL: 0xD2 */
+#define MT6375_MSK_WDFWMODE_EN	BIT(0)
+#define MT6375_MSK_WDDISCHG_EN	BIT(1)
+#define MT6375_MSK_WDRPULL_EN	BIT(2)
+#define MT6375_MSK_WDIPULL_EN	BIT(3)
+/* MT6375_REG_WD0MODECTRL: 0xD9 */
+#define MT6375_MSK_WD0MODE_EN	BIT(4)
+/* MT6375_REG_WD0SET: 0xDA */
+#define MT6375_MSK_WD0PULL_STS	BIT(7)
+/* MT6375_REG_WDSET: 0xDB */
+#define MT6375_MSK_WDLDO_SEL	GENMASK(7, 6)
+#define MT6375_SFT_WDLDO_SEL	(6)
+/* RT2 MT6375_REG_WDSET3: 0x21 */
+#define MT6375_MASK_WD_TDET	GENMASK(2, 0)
+#define MT6375_SHFT_WD_TDET	(0)
+/* RT2 MT6375_REG_WD1MISCSET: 0x22 */
+#define MT6375_MSK_WDIPULL_SEL	GENMASK(6, 4)
+#define MT6375_SFT_WDIPULL_SEL	(4)
+#define MT6375_MSK_WDRPULL_SEL	GENMASK(3, 1)
+#define MT6375_SFT_WDRPULL_SEL	(1)
+/* RT2 MT6375_REG_WD1VOLCMP: 0x23 */
+#define MT6375_MSK_WD12_VOLCOML	GENMASK(3, 0)
+#define MT6375_SFT_WD12_VOLCOML	(0)
+/* PMU MT6375_REG_DPDM_CTRL1: 0x153 */
+#define MT6375_MSK_DMDET_EN	BIT(0)
+#define MT6375_MSK_DPDET_EN	BIT(1)
+#define MT6375_MSK_DPDMDET_EN \
+	(MT6375_MSK_DPDET_EN | MT6375_MSK_DMDET_EN)
+#define MT6375_MSK_MANUAL_MODE	BIT(7)
+
+struct mt6375_tcpc_data {
+	struct device *dev;
+	struct regmap *rmap;
+	struct tcpc_desc *desc;
+	struct tcpc_device *tcpc;
+	struct kthread_worker irq_worker;
+	struct kthread_work irq_work;
+	struct task_struct *irq_worker_task;
+	struct iio_channel *adc_iio;
+	int irq;
+	u16 did;
+
+	atomic_t wd_protect_rty;
+
+#if CONFIG_WATER_DETECTION
+#if CONFIG_WD_POLLING_ONLY
+	struct delayed_work wd_poll_dwork;
+#endif /* CONFIG_WD_POLLING_ONLY */
+#endif /* CONFIG_WATER_DETECTION */
+
+	bool handle_init_ctd;
+	enum tcpc_cable_type init_cable_type;
+
+	bool handle_init_fod;
+	enum tcpc_fod_status init_fod;
+
+	struct alarm hidet_debtimer;
+	struct delayed_work hidet_dwork;
+};
+
+enum mt6375_vend_int {
+	MT6375_VEND_INT1 = 0,
+	MT6375_VEND_INT2,
+	MT6375_VEND_INT3,
+	MT6375_VEND_INT4,
+	MT6375_VEND_INT5,
+	MT6375_VEND_INT6,
+	MT6375_VEND_INT7,
+	MT6375_VEND_INT_NUM,
+};
+
+enum mt6375_wd_ldo {
+	MT6375_WD_LDO_0_6V,
+	MT6375_WD_LDO_1_8V,
+	MT6375_WD_LDO_2_5V,
+	MT6375_WD_LDO_3_0V,
+};
+
+enum mt6375_wd_status {
+	MT6375_WD_PULL,
+	MT6375_WD_DISCHG,
+	MT6375_WD_STATUS_NUM,
+};
+
+enum mt6375_wd_chan {
+	MT6375_WD_CHAN_WD1,
+	MT6375_WD_CHAN_WD2,
+	MT6375_WD_CHAN_NUM,
+};
+
+enum mt6375_wd_ipull {
+	MT6375_WD_IPULL_2UA,
+	MT6375_WD_IPULL_6UA,
+	MT6375_WD_IPULL_10UA,
+	MT6375_WD_IPULL_20UA,
+	MT6375_WD_IPULL_40UA,
+	MT6375_WD_IPULL_80UA,
+	MT6375_WD_IPULL_160UA,
+	MT6375_WD_IPULL_240UA,
+};
+
+enum mt6375_wd_rpull {
+	MT6375_WD_RPULL_500K,
+	MT6375_WD_RPULL_200K,
+	MT6375_WD_RPULL_75K,
+	MT6375_WD_RPULL_40K,
+	MT6375_WD_RPULL_20K,
+	MT6375_WD_RPULL_10K,
+	MT6375_WD_RPULL_5K,
+	MT6375_WD_RPULL_1K,
+};
+
+enum mt6375_wd_volcmpl {
+	MT6375_WD_VOLCMPL_200MV,
+	MT6375_WD_VOLCMPL_240MV,
+	MT6375_WD_VOLCMPL_400MV,
+	MT6375_WD_VOLCMPL_440MV,
+	MT6375_WD_VOLCMPL_600MV,
+	MT6375_WD_VOLCMPL_700MV,
+	MT6375_WD_VOLCMPL_1000MV,
+	MT6375_WD_VOLCMPL_1100MV,
+	MT6375_WD_VOLCMPL_1200MV,
+	MT6375_WD_VOLCMPL_1300MV,
+	MT6375_WD_VOLCMPL_1440MV,
+	MT6375_WD_VOLCMPL_1540MV,
+	MT6375_WD_VOLCMPL_2000MV,
+	MT6375_WD_VOLCMPL_2100MV,
+	MT6375_WD_VOLCMPL_2200MV,
+	MT6375_WD_VOLCMPL_2300MV,
+};
+
+enum mt6375_wd_tdet {
+	MT6375_WD_TDET_400US,
+	MT6375_WD_TDET_1MS,
+	MT6375_WD_TDET_2MS,
+	MT6375_WD_TDET_4MS,
+	MT6375_WD_TDET_10MS,
+	MT6375_WD_TDET_40MS,
+	MT6375_WD_TDET_100MS,
+	MT6375_WD_TDET_400MS,
+};
+
+static const u8 mt6375_vend_alert_clearall[MT6375_VEND_INT_NUM] = {
+	0x3F, 0xFF, 0xF0, 0xE3, 0xFF, 0xF8, 0x3F,
+};
+
+static const u8 mt6375_vend_alert_maskall[MT6375_VEND_INT_NUM] = {
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+#if CONFIG_WATER_DETECTION
+/* REG RT2 0x20 ~ 0x2D */
+static const u8 mt6375_rt2_wd_init_setting[] = {
+	0x50, 0x34, 0x44, 0xCA, 0x00, 0x00, 0x00, 0x00,
+	0x44, 0xCA, 0x00, 0x00, 0x00, 0x00,
+};
+
+static const bool mt6375_wd_chan_en[MT6375_WD_CHAN_NUM] = {
+	MT6375_WD1_EN,
+	MT6375_WD2_EN,
+};
+
+static const u8 mt6375_wd_path_reg[MT6375_WD_CHAN_NUM] = {
+	MT6375_REG_WD1PATHEN,
+	MT6375_REG_WD2PATHEN,
+};
+
+static const u8 mt6375_wd_polling_path[MT6375_WD_CHAN_NUM] = {
+	MT6375_MSK_WDSBU1_EN,
+	MT6375_MSK_WDSBU2_EN,
+};
+
+static const u8 mt6375_wd_protection_path[MT6375_WD_CHAN_NUM] = {
+	MT6375_MSK_WDSBU1_EN | MT6375_MSK_WDSBU2_EN |
+	MT6375_MSK_WDCC1_EN | MT6375_MSK_WDCC2_EN |
+	MT6375_MSK_WDDP_EN | MT6375_MSK_WDDM_EN,
+	MT6375_MSK_WDSBU1_EN | MT6375_MSK_WDSBU2_EN |
+	MT6375_MSK_WDCC1_EN | MT6375_MSK_WDCC2_EN |
+	MT6375_MSK_WDDP_EN | MT6375_MSK_WDDM_EN,
+};
+
+static const u8 mt6375_wd_miscctrl_reg[MT6375_WD_CHAN_NUM] = {
+	MT6375_REG_WD1MISCCTRL,
+	MT6375_REG_WD2MISCCTRL,
+};
+
+static const u8 mt6375_wd_status_reg[MT6375_WD_CHAN_NUM] = {
+	MT6375_REG_WD1PULLST,
+	MT6375_REG_WD2PULLST,
+};
+
+static const u8 __maybe_unused mt6375_wd_ipull_reg[MT6375_WD_CHAN_NUM] = {
+	MT6375_REG_WD1MISCSET,
+	MT6375_REG_WD2MISCSET
+};
+
+static const u8 mt6375_wd_rpull_reg[MT6375_WD_CHAN_NUM] = {
+	MT6375_REG_WD1MISCSET,
+	MT6375_REG_WD2MISCSET
+};
+
+static const u8 mt6375_wd_volcmp_reg[MT6375_WD_CHAN_NUM] = {
+	MT6375_REG_WD1VOLCMP,
+	MT6375_REG_WD2VOLCMP,
+};
+#endif /* CONFIG_WATER_DETECTION */
+
+
+struct tcpc_desc def_tcpc_desc = {
+	.role_def = TYPEC_ROLE_DRP,
+	.rp_lvl = TYPEC_CC_RP_DFT,
+	.vconn_supply = TCPC_VCONN_SUPPLY_ALWAYS,
+	.name = "type_c_port0",
+	.en_wd = false,
+	.en_wd_sbu_polling = false,
+	.en_wd_polling_only = false,
+	.en_ctd = false,
+	.en_fod = false,
+	.en_typec_otp = false,
+	.en_floatgnd = false,
+	.wd_sbu_calib_init = CONFIG_WD_SBU_CALIB_INIT,
+	.wd_sbu_pl_bound = CONFIG_WD_SBU_PL_BOUND,
+	.wd_sbu_pl_lbound_c2c = CONFIG_WD_SBU_PL_LBOUND_C2C,
+	.wd_sbu_pl_ubound_c2c = CONFIG_WD_SBU_PL_UBOUND_C2C,
+	.wd_sbu_ph_auddev = CONFIG_WD_SBU_PH_AUDDEV,
+	.wd_sbu_ph_lbound = CONFIG_WD_SBU_PH_LBOUND,
+	.wd_sbu_ph_lbound1_c2c = CONFIG_WD_SBU_PH_LBOUND1_C2C,
+	.wd_sbu_ph_ubound1_c2c = CONFIG_WD_SBU_PH_UBOUND1_C2C,
+	.wd_sbu_ph_ubound2_c2c = CONFIG_WD_SBU_PH_UBOUND2_C2C,
+	.wd_sbu_aud_ubound = CONFIG_WD_SBU_AUD_UBOUND,
+};
+
+static inline int mt6375_write8(struct mt6375_tcpc_data *ddata, u32 reg,
+				u8 data)
+{
+	return regmap_write(ddata->rmap, reg, data);
+}
+
+static inline int mt6375_read8(struct mt6375_tcpc_data *ddata, u32 reg,
+			       u8 *data)
+{
+	int ret;
+	u32 _data;
+
+	ret = regmap_read(ddata->rmap, reg, &_data);
+	if (ret < 0)
+		return ret;
+	*data = _data;
+	return 0;
+}
+
+static inline int mt6375_write16(struct mt6375_tcpc_data *ddata, u32 reg,
+				 u16 data)
+{
+	data = cpu_to_le16(data);
+	return regmap_bulk_write(ddata->rmap, reg, &data, 2);
+}
+
+static inline int mt6375_read16(struct mt6375_tcpc_data *ddata, u32 reg,
+				u16 *data)
+{
+	int ret;
+
+	ret = regmap_bulk_read(ddata->rmap, reg, data, 2);
+	if (ret < 0)
+		return ret;
+	*data = le16_to_cpu(*data);
+	return 0;
+}
+
+static inline int mt6375_bulk_write(struct mt6375_tcpc_data *ddata, u32 reg,
+				    const void *data, size_t count)
+{
+	return regmap_bulk_write(ddata->rmap, reg, data, count);
+}
+
+
+static inline int mt6375_bulk_read(struct mt6375_tcpc_data *ddata, u32 reg,
+				   void *data, size_t count)
+{
+	return regmap_bulk_read(ddata->rmap, reg, data, count);
+}
+
+static inline int mt6375_update_bits(struct mt6375_tcpc_data *ddata, u32 reg,
+				     u8 mask, u8 data)
+{
+	return regmap_update_bits(ddata->rmap, reg, mask, data);
+}
+
+static inline int mt6375_set_bits(struct mt6375_tcpc_data *ddata, u32 reg,
+				  u8 mask)
+{
+	return mt6375_update_bits(ddata, reg, mask, mask);
+}
+
+static inline int mt6375_clr_bits(struct mt6375_tcpc_data *ddata, u32 reg,
+				  u8 mask)
+{
+	return mt6375_update_bits(ddata, reg, mask, 0);
+}
+
+static inline int mt6375_write8_rt2(struct mt6375_tcpc_data *ddata, u32 reg,
+				    u8 data)
+{
+	return regmap_write(ddata->rmap, reg + MT6375_REG_RT2BASEADDR, data);
+}
+
+static inline int mt6375_bulk_write_rt2(struct mt6375_tcpc_data *ddata, u32 reg,
+					const void *data, size_t count)
+{
+	return regmap_bulk_write(ddata->rmap, reg + MT6375_REG_RT2BASEADDR,
+				 data, count);
+}
+
+static inline int mt6375_update_bits_rt2(struct mt6375_tcpc_data *ddata,
+					 u32 reg, u8 mask, u8 data)
+{
+	return regmap_update_bits(ddata->rmap, reg + MT6375_REG_RT2BASEADDR,
+				  mask, data);
+}
+
+static int mt6375_sw_reset(struct mt6375_tcpc_data *ddata)
+{
+	int ret;
+
+	ret = mt6375_write8(ddata, MT6375_REG_SYSCTRL3, 0x01);
+	if (ret < 0)
+		return ret;
+	usleep_range(1000, 2000);
+	return 0;
+}
+
+static int mt6375_init_power_status_mask(struct mt6375_tcpc_data *ddata)
+{
+	return mt6375_write8(ddata, TCPC_V10_REG_POWER_STATUS_MASK,
+			     TCPC_V10_REG_POWER_STATUS_VBUS_PRES);
+}
+
+static int mt6375_init_fault_mask(struct mt6375_tcpc_data *ddata)
+{
+	return mt6375_write8(ddata, TCPC_V10_REG_FAULT_STATUS_MASK,
+			     TCPC_V10_REG_FAULT_STATUS_VCONN_OC);
+}
+
+static int mt6375_init_ext_mask(struct mt6375_tcpc_data *ddata)
+{
+	return mt6375_write8(ddata, TCPC_V10_REG_EXT_STATUS_MASK, 0x00);
+}
+
+static int mt6375_init_vend_mask(struct mt6375_tcpc_data *ddata)
+{
+	u8 mask[MT6375_VEND_INT_NUM] = {0};
+
+	if (ddata->tcpc->tcpc_flags & TCPC_FLAGS_LPM_WAKEUP_WATCHDOG)
+		mask[MT6375_VEND_INT1] |= MT6375_MSK_WAKEUP;
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
+	mask[MT6375_VEND_INT1] |= MT6375_MSK_VBUS80;
+#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
+
+	if (ddata->tcpc->tcpc_flags & TCPC_FLAGS_TYPEC_OTP)
+		mask[MT6375_VEND_INT1] |= MT6375_MSK_TYPECOTP;
+
+	mask[MT6375_VEND_INT2] |= MT6375_MSK_VCON_FAULT;
+
+	if (ddata->tcpc->tcpc_flags & TCPC_FLAGS_CABLE_TYPE_DETECTION)
+		mask[MT6375_VEND_INT3] |= MT6375_MSK_CTD;
+
+	if (ddata->tcpc->tcpc_flags & TCPC_FLAGS_FOREIGN_OBJECT_DETECTION)
+		mask[MT6375_VEND_INT4] |= MT6375_MSK_FOD_DONE |
+					  MT6375_MSK_FOD_OV |
+					  MT6375_MSK_FOD_DISCHGF;
+
+	if (ddata->tcpc->tcpc_flags & TCPC_FLAGS_WATER_DETECTION)
+		mask[MT6375_VEND_INT7] |= MT6375_MSK_WD12_STFALL |
+					  MT6375_MSK_WD12_STRISE |
+					  MT6375_MSK_WD12_DONE;
+
+	if (ddata->tcpc->tcpc_flags & TCPC_FLAGS_FLOATING_GROUND)
+		mask[MT6375_VEND_INT7] |= MT6375_MSK_WD0_STFALL |
+					  MT6375_MSK_WD0_STRISE;
+
+	return mt6375_bulk_write(ddata, MT6375_REG_MTMASK1, mask,
+				 MT6375_VEND_INT_NUM);
+}
+
+static int mt6375_init_alert_mask(struct mt6375_tcpc_data *ddata)
+{
+	int ret;
+#if 1
+	u16 mask = TCPC_V10_REG_ALERT_CC_STATUS |
+		   TCPC_V10_REG_ALERT_POWER_STATUS |
+		   TCPC_V10_REG_VBUS_SINK_DISCONNECT |
+		   TCPC_V10_REG_ALERT_VENDOR_DEFINED;
+#else
+	u16 mask = TCPC_V10_REG_ALERT_CC_STATUS |
+		   TCPC_V10_REG_ALERT_POWER_STATUS |
+		   TCPC_V10_REG_ALERT_VENDOR_DEFINED;
+#endif
+
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
+	mask |= TCPC_V10_REG_ALERT_TX_SUCCESS |
+		TCPC_V10_REG_ALERT_TX_DISCARDED |
+		TCPC_V10_REG_ALERT_TX_FAILED |
+		TCPC_V10_REG_ALERT_RX_HARD_RST |
+		TCPC_V10_REG_ALERT_RX_STATUS |
+		TCPC_V10_REG_RX_OVERFLOW;
+#endif /* CONFIG_USB_POWER_DELIVERY */
+
+	mask |= TCPC_REG_ALERT_FAULT;
+	ret = mt6375_write16(ddata, TCPC_V10_REG_ALERT_MASK, mask);
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+static int __mt6375_set_cc(struct mt6375_tcpc_data *ddata, int rp_lvl, int pull)
+{
+	return mt6375_write8(ddata, TCPC_V10_REG_ROLE_CTRL,
+			     TCPC_V10_REG_ROLE_CTRL_RES_SET(0, rp_lvl, pull,
+			     pull));
+}
+
+static int mt6375_enable_force_discharge(struct mt6375_tcpc_data *ddata,
+					 bool en)
+{
+	return (en ? mt6375_set_bits : mt6375_clr_bits)
+		(ddata, TCPC_V10_REG_POWER_CTRL, TCPC_V10_REG_FORCE_DISC_EN);
+}
+
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
+static int mt6375_enable_vsafe0v_detect(struct mt6375_tcpc_data *ddata, bool en)
+{
+	return (en ? mt6375_set_bits : mt6375_clr_bits)
+		(ddata, MT6375_REG_MTMASK1, MT6375_MSK_VBUS80);
+}
+#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
+
+static int __maybe_unused mt6375_enable_rpdet_auto(
+					struct mt6375_tcpc_data *ddata, bool en)
+{
+	return (en ? mt6375_set_bits : mt6375_clr_bits)
+		(ddata, MT6375_REG_SHIELDCTRL1, MT6375_MSK_RPDET_AUTO);
+}
+
+static int mt6375_is_vconn_fault(struct mt6375_tcpc_data *ddata, bool *fault)
+{
+	int ret;
+	u8 status;
+
+	ret = mt6375_read8(ddata, MT6375_REG_MTST2, &status);
+	if (ret < 0)
+		return ret;
+	*fault = (status & MT6375_MSK_VCON_FAULT) ? true : false;
+	return 0;
+}
+
+static int mt6375_vend_alert_status_clear(struct mt6375_tcpc_data *ddata,
+					  const u8 *mask)
+{
+	mt6375_bulk_write(ddata, MT6375_REG_MTINT1, mask, MT6375_VEND_INT_NUM);
+	return mt6375_write16(ddata, TCPC_V10_REG_ALERT,
+			      TCPC_V10_REG_ALERT_VENDOR_DEFINED);
+}
+
+
+static int mt6375_enable_typec_otp_fwen(struct tcpc_device *tcpc, bool en)
+{
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	pr_info("%s: en=%d\n", __func__, en);
+	return (en ? mt6375_set_bits : mt6375_clr_bits)
+		(ddata, MT6375_REG_TYPECOTPCTRL, MT6375_MSK_TYPECOTP_FWEN);
+}
+
+static int mt6375_set_force_discharge(struct tcpc_device *tcpc, bool en, int mv)
+{
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	pr_info("%s en = %d", __func__, en);
+	return (en ? mt6375_set_bits : mt6375_clr_bits)
+		(ddata, TCPC_V10_REG_POWER_CTRL, TCPC_V10_REG_BLEED_DISC_EN);
+}
+
+static int mt6375_hidet_is_plugout(struct mt6375_tcpc_data *ddata, bool *out)
+{
+	int ret;
+	u8 data;
+
+	ret = mt6375_read8(ddata, MT6375_REG_MTST5, &data);
+	if (ret < 0)
+		return ret;
+	data &= MT6375_MSK_HIDET_CC;
+	*out = (data == MT6375_MSK_HIDET_CC) ? true : false;
+	return 0;
+}
+
+static void mt6375_enable_hidet_debtimer(struct mt6375_tcpc_data *ddata,
+					 bool en)
+{
+	if (en)
+		alarm_start_relative(&ddata->hidet_debtimer,
+				     ktime_set(0, 100000000));
+	else
+		alarm_cancel(&ddata->hidet_debtimer);
+}
+
+static void mt6375_hidet_dwork_handler(struct work_struct *work)
+{
+	int ret;
+	bool plugout;
+	struct delayed_work *dwork = to_delayed_work(work);
+	struct mt6375_tcpc_data *ddata = container_of(dwork,
+						      struct mt6375_tcpc_data,
+						      hidet_dwork);
+
+	tcpci_lock_typec(ddata->tcpc);
+	ret = mt6375_hidet_is_plugout(ddata, &plugout);
+	if (ret < 0)
+		goto out;
+	if (!plugout)
+		goto out;
+	MT6375_DBGINFO("plug out confirmed\n");
+	if (ddata->tcpc->tcpc_flags & TCPC_FLAGS_FOREIGN_OBJECT_DETECTION)
+		tcpc_typec_handle_fod(ddata->tcpc, TCPC_FOD_NONE);
+	tcpci_notify_plug_out(ddata->tcpc);
+out:
+	tcpci_unlock_typec(ddata->tcpc);
+}
+
+static enum alarmtimer_restart
+mt6375_hidet_debtimer_handler(struct alarm *alarm, ktime_t now)
+{
+	struct mt6375_tcpc_data *ddata = container_of(alarm,
+						      struct mt6375_tcpc_data,
+						      hidet_debtimer);
+
+	pm_wakeup_event(ddata->dev, 1000);
+	schedule_delayed_work(&ddata->hidet_dwork, 0);
+	return ALARMTIMER_NORESTART;
+}
+
+static int mt6375_hidet_cc_evt_process(struct mt6375_tcpc_data *ddata)
+{
+	int ret;
+	bool plugout;
+
+	ret = mt6375_hidet_is_plugout(ddata, &plugout);
+	if (ret < 0)
+		return ret;
+	mt6375_enable_hidet_debtimer(ddata, plugout);
+	return 0;
+}
+
+static int mt6375_get_fod_status(struct mt6375_tcpc_data *ddata,
+				 enum tcpc_fod_status *fod)
+{
+	int ret;
+	u8 data;
+
+	ret = mt6375_read8(ddata, MT6375_REG_MTST4, &data);
+	if (ret < 0)
+		return ret;
+	data &= MT6375_MSK_FOD_ALL;
+
+	/* LR possesses the highest priority */
+	if (data & MT6375_MSK_FOD_LR)
+		*fod = TCPC_FOD_LR;
+	else if (data & MT6375_MSK_FOD_HR)
+		*fod = TCPC_FOD_HR;
+	else if (data & MT6375_MSK_FOD_DISCHGF)
+		*fod = TCPC_FOD_DISCHG_FAIL;
+	else if (data & MT6375_MSK_FOD_OV)
+		*fod = TCPC_FOD_OV;
+	else if (data & MT6375_MSK_FOD_DONE)
+		*fod = TCPC_FOD_NORMAL;
+	else
+		*fod = TCPC_FOD_NONE;
+	return 0;
+}
+
+static int mt6375_fod_evt_process(struct mt6375_tcpc_data *ddata)
+{
+	int ret;
+	enum tcpc_fod_status fod;
+
+	/* Init fod is not handled yet */
+	if (ddata->handle_init_fod)
+		return 0;
+	ret = mt6375_get_fod_status(ddata, &fod);
+	if (ret < 0)
+		return ret;
+	if (tcpc_typec_ignore_fod(ddata->tcpc)) {
+		MT6375_DBGINFO("ignore fod %d\n", fod);
+		return 0;
+	}
+	tcpc_typec_handle_fod(ddata->tcpc, fod);
+
+#if CONFIG_CABLE_TYPE_DETECTION
+	/* In case ctd irq comes after fod */
+	if ((ddata->tcpc->tcpc_flags & TCPC_FLAGS_CABLE_TYPE_DETECTION) &&
+	    (ddata->tcpc->typec_fod == TCPC_FOD_LR &&
+	    ddata->tcpc->typec_cable_type == TCPC_CABLE_TYPE_NONE))
+		tcpc_typec_handle_ctd(ddata->tcpc, TCPC_CABLE_TYPE_C2C);
+#endif
+	return 0;
+}
+
+#if CONFIG_CABLE_TYPE_DETECTION
+static int mt6375_get_cable_type(struct mt6375_tcpc_data *ddata,
+				 enum tcpc_cable_type *type)
+{
+	int ret;
+	u8 data;
+
+	ret = mt6375_read8(ddata, MT6375_REG_MTST3, &data);
+	if (ret < 0)
+		return ret;
+	if (data & MT6375_MSK_CABLE_TYPEC)
+		*type = TCPC_CABLE_TYPE_C2C;
+	else if (data & MT6375_MSK_CABLE_TYPEA)
+		*type = TCPC_CABLE_TYPE_A2C;
+	else
+		*type = TCPC_CABLE_TYPE_NONE;
+	return 0;
+}
+#endif /* CONFIG_CABLE_TYPE_DETECTION */
+
+static int mt6375_init_fod_ctd(struct mt6375_tcpc_data *ddata)
+{
+	int ret = 0;
+
+#if CONFIG_CABLE_TYPE_DETECTION
+	if (ddata->tcpc->tcpc_flags & TCPC_FLAGS_CABLE_TYPE_DETECTION) {
+		ddata->tcpc->typec_cable_type = TCPC_CABLE_TYPE_NONE;
+		ddata->handle_init_ctd = true;
+		ret = mt6375_get_cable_type(ddata, &ddata->init_cable_type);
+		if (ret < 0)
+			return ret;
+	}
+#endif
+
+	if (ddata->tcpc->tcpc_flags & TCPC_FLAGS_FOREIGN_OBJECT_DETECTION) {
+		ddata->tcpc->typec_fod = TCPC_FOD_NONE;
+		ddata->handle_init_fod = true;
+		ret = mt6375_get_fod_status(ddata, &ddata->init_fod);
+	}
+	return ret;
+}
+
+static int mt6375_set_wd_ldo(struct mt6375_tcpc_data *ddata,
+			     enum mt6375_wd_ldo ldo)
+{
+	return mt6375_update_bits(ddata, MT6375_REG_WDSET, MT6375_MSK_WDLDO_SEL,
+				  ldo << MT6375_SFT_WDLDO_SEL);
+}
+
+#if CONFIG_WATER_DETECTION
+static int mt6375_get_cc(struct tcpc_device *tcpc, int *cc1, int *cc2);
+static int mt6375_is_cc_toggling(struct mt6375_tcpc_data *ddata, bool *toggling)
+{
+	int ret;
+	int cc1 = 0, cc2 = 0;
+
+	ret = mt6375_get_cc(ddata->tcpc, &cc1, &cc2);
+	if (ret < 0)
+		return ret;
+	*toggling = (cc1 == TYPEC_CC_DRP_TOGGLING &&
+		     cc2 == TYPEC_CC_DRP_TOGGLING);
+	return 0;
+}
+
+static int mt6375_init_wd(struct mt6375_tcpc_data *ddata)
+{
+	/*
+	 * WD_LDO = 1.8V
+	 * WD_CHPHYS_EN = 0
+	 * WD_SWITCH_CNT = 100
+	 * WD_POLL_SWITCH = 0
+	 * WD12_TDET_ALWAYS = 0, depend on WD_TDET[2:0]
+	 * WD0_TDET_ALWAYS = 0, depend on WD_TDET[2:0]
+	 */
+	mt6375_write8(ddata, MT6375_REG_WDSET, 0x50);
+
+	/* WD_EXIT_CNT = 4times */
+	mt6375_set_bits(ddata, MT6375_REG_WDSET1, 0x02);
+
+	/* WD1_RPULL_EN = 1, WD1_DISCHG_EN = 1 */
+	mt6375_write8(ddata, MT6375_REG_WD1MISCCTRL, 0x06);
+
+	/* WD2_RPULL_EN = 1, WD2_DISCHG_EN = 1 */
+	mt6375_write8(ddata, MT6375_REG_WD2MISCCTRL, 0x06);
+
+	/* WD0_RPULL_EN = 1, WD0_DISCHG_EN = 1 */
+	mt6375_write8(ddata, MT6375_REG_WD0SET, 0x06);
+
+	mt6375_set_wd_ldo(ddata, MT6375_WD_LDO_1_8V);
+
+	mt6375_bulk_write_rt2(ddata, MT6375_REG_WDSET2,
+			      mt6375_rt2_wd_init_setting,
+			      ARRAY_SIZE(mt6375_rt2_wd_init_setting));
+	return 0;
+}
+
+static int mt6375_set_wd_volcmpl(struct mt6375_tcpc_data *ddata,
+				 enum mt6375_wd_chan chan,
+				 enum mt6375_wd_volcmpl vcmpl)
+{
+	return mt6375_update_bits_rt2(ddata,
+				      mt6375_wd_volcmp_reg[chan],
+				      MT6375_MSK_WD12_VOLCOML,
+				      vcmpl << MT6375_SFT_WD12_VOLCOML);
+}
+
+static int mt6375_set_wd_rpull(struct mt6375_tcpc_data *ddata,
+			       enum mt6375_wd_chan chan,
+			       enum mt6375_wd_rpull rpull)
+{
+	return mt6375_update_bits_rt2(ddata, mt6375_wd_rpull_reg[chan],
+				      MT6375_MSK_WDRPULL_SEL,
+				      rpull << MT6375_SFT_WDRPULL_SEL);
+}
+
+static int  __maybe_unused mt6375_set_wd_ipull(struct mt6375_tcpc_data *ddata,
+					       enum mt6375_wd_chan chan,
+					       enum mt6375_wd_ipull ipull)
+{
+	return mt6375_update_bits_rt2(ddata, mt6375_wd_ipull_reg[chan],
+				      MT6375_MSK_WDIPULL_SEL,
+				      ipull << MT6375_SFT_WDIPULL_SEL);
+}
+
+static int mt6375_set_wd_path(struct mt6375_tcpc_data *ddata,
+			      enum mt6375_wd_chan chan, u8 path)
+{
+	return mt6375_write8(ddata, mt6375_wd_path_reg[chan], path);
+}
+
+static int mt6375_get_wd_path(struct mt6375_tcpc_data *ddata,
+			      enum mt6375_wd_chan chan, u8 *path)
+{
+	return mt6375_read8(ddata, mt6375_wd_path_reg[chan], path);
+}
+
+static int mt6375_set_wd_polling_path(struct mt6375_tcpc_data *ddata,
+				      enum mt6375_wd_chan chan)
+{
+	return mt6375_set_wd_path(ddata, chan, mt6375_wd_polling_path[chan]);
+}
+
+static int mt6375_set_wd_protection_path(struct mt6375_tcpc_data *ddata,
+					 enum mt6375_wd_chan chan)
+{
+	return mt6375_set_wd_path(ddata, chan, mt6375_wd_protection_path[chan]);
+}
+
+static int mt6375_set_wd_polling_parameter(struct mt6375_tcpc_data *ddata,
+					   enum mt6375_wd_chan chan)
+{
+	int ret;
+
+	ret = mt6375_set_wd_rpull(ddata, chan, MT6375_WD_RPULL_75K);
+	if (ret < 0)
+		return ret;
+	ret = mt6375_set_wd_volcmpl(ddata, chan , MT6375_WD_VOLCMPL_1440MV);
+	if (ret < 0)
+		return ret;
+	ret = mt6375_write8(ddata, mt6375_wd_miscctrl_reg[chan],
+			    MT6375_MSK_WDRPULL_EN | MT6375_MSK_WDDISCHG_EN);
+	if (ret < 0)
+		return ret;
+	return mt6375_set_wd_polling_path(ddata, chan);
+}
+
+static int mt6375_set_wd_protection_parameter(struct mt6375_tcpc_data *ddata,
+					      enum mt6375_wd_chan chan)
+{
+	int ret;
+
+	ret = mt6375_set_wd_rpull(ddata, chan, MT6375_WD_RPULL_75K);
+	if (ret < 0)
+		return ret;
+	ret = mt6375_set_wd_volcmpl(ddata, chan , MT6375_WD_VOLCMPL_1440MV);
+	if (ret < 0)
+		return ret;
+	ret = mt6375_write8(ddata, mt6375_wd_miscctrl_reg[chan],
+			    MT6375_MSK_WDRPULL_EN | MT6375_MSK_WDDISCHG_EN);
+	if (ret < 0)
+		return ret;
+	return mt6375_set_wd_protection_path(ddata, chan);
+}
+
+static int mt6375_check_wd_status(struct mt6375_tcpc_data *ddata,
+				  enum mt6375_wd_chan chan, bool *error)
+{
+	int i, ret;
+	u8 path;
+	u8 data[MT6375_WD_STATUS_NUM];
+
+	ret = mt6375_bulk_read(ddata, mt6375_wd_status_reg[chan], data,
+			       MT6375_WD_STATUS_NUM);
+	if (ret < 0)
+		return ret;
+	ret = mt6375_get_wd_path(ddata, chan, &path);
+	if (ret < 0)
+		return ret;
+	*error = false;
+	for (i = 0; i < MT6375_WD_STATUS_NUM; i++) {
+		if (path & data[i])
+			*error = true;
+		MT6375_DBGINFO("chan(path,stat)=%d(0x%02X,0x%02X)\n", chan,
+			       path, data[i]);
+	}
+	return 0;
+}
+
+static int mt6375_enable_wd_dischg(struct mt6375_tcpc_data *ddata,
+				   enum mt6375_wd_chan chan, bool en)
+{
+	int ret;
+
+	if (en) {
+		ret = mt6375_set_wd_polling_path(ddata, chan);
+		if (ret < 0)
+			return ret;
+		ret = mt6375_write8(ddata, mt6375_wd_miscctrl_reg[chan],
+				    MT6375_MSK_WDDISCHG_EN |
+				    MT6375_MSK_WDFWMODE_EN);
+	} else {
+		ret = mt6375_set_wd_path(ddata, chan, 0);
+		if (ret < 0)
+			return ret;
+		ret = mt6375_write8(ddata, mt6375_wd_miscctrl_reg[chan],
+				    MT6375_MSK_WDRPULL_EN |
+				    MT6375_MSK_WDDISCHG_EN);
+	}
+	return ret;
+}
+
+static int mt6375_enable_wd_pullup(struct mt6375_tcpc_data *ddata,
+				   enum mt6375_wd_chan chan,
+				   enum mt6375_wd_rpull rpull, bool en)
+{
+	int ret;
+
+	if (en) {
+		ret = mt6375_set_wd_polling_path(ddata, chan);
+		if (ret < 0)
+			return ret;
+		ret = mt6375_set_wd_rpull(ddata, chan, rpull);
+		if (ret < 0)
+			return ret;
+		ret = mt6375_write8(ddata, mt6375_wd_miscctrl_reg[chan],
+				    MT6375_MSK_WDRPULL_EN |
+				    MT6375_MSK_WDFWMODE_EN);
+	} else {
+		ret = mt6375_set_wd_path(ddata, chan, 0);
+		if (ret < 0)
+			return ret;
+		ret = mt6375_write8(ddata, mt6375_wd_miscctrl_reg[chan],
+				    MT6375_MSK_WDRPULL_EN |
+				    MT6375_MSK_WDDISCHG_EN);
+	}
+	return ret;
+}
+
+static int mt6375_get_wd_adc(struct mt6375_tcpc_data *ddata,
+			     enum mt6375_wd_chan chan, int *val)
+{
+	int ret;
+
+	ret = iio_read_channel_processed(&ddata->adc_iio[chan], val);
+	if (ret < 0)
+		return ret;
+	*val /= 1000;
+	return 0;
+}
+
+static bool mt6375_is_wd_audio_device(struct mt6375_tcpc_data *ddata,
+				      enum mt6375_wd_chan chan, int wd_adc)
+{
+	struct tcpc_desc *desc = ddata->desc;
+	int ret;
+
+	if (wd_adc >= desc->wd_sbu_ph_auddev)
+		return false;
+
+	/* Pull high with 1K resistor */
+	ret = mt6375_enable_wd_pullup(ddata, chan, MT6375_WD_RPULL_1K, true);
+	if (ret < 0) {
+		MT6375_DBGINFO("chan%d pull up 1k fail(%d)\n", chan, ret);
+		goto not_auddev;
+	}
+
+	ret = mt6375_get_wd_adc(ddata, chan, &wd_adc);
+	if (ret < 0) {
+		MT6375_DBGINFO("get chan%d adc fail(%d)\n", chan, ret);
+		goto not_auddev;
+	}
+
+	if (wd_adc >= desc->wd_sbu_aud_ubound)
+		goto not_auddev;
+	return true;
+
+not_auddev:
+	mt6375_enable_wd_pullup(ddata, chan, MT6375_WD_RPULL_500K, true);
+	return false;
+}
+
+static int __mt6375_is_water_detected(struct mt6375_tcpc_data *ddata,
+				      enum mt6375_wd_chan chan, bool *wd)
+{
+	int ret, wd_adc, i;
+	struct tcpc_desc *desc = ddata->desc;
+	u32 lb = desc->wd_sbu_ph_lbound;
+	u32 ub = desc->wd_sbu_calib_init * 110 / 100;
+	enum tcpc_cable_type cable_type;
+	u8 ctd_evt;
+
+	pm_stay_awake(ddata->dev);
+	/* Check WD1/2 pulled low */
+	for (i = 0; i < CONFIG_WD_SBU_PL_RETRY; i++) {
+		ret = mt6375_enable_wd_dischg(ddata, chan, true);
+		if (ret < 0) {
+			MT6375_DBGINFO("en chan%d dischg fail(%d)\n", chan,
+				       ret);
+			goto out;
+		}
+		ret = mt6375_get_wd_adc(ddata, chan, &wd_adc);
+		if (ret < 0) {
+			MT6375_DBGINFO("get chan%d adc fail(%d)\n", chan, ret);
+			goto out;
+		}
+		MT6375_DBGINFO("chan%d pull low %dmV\n", chan, wd_adc);
+		ret = mt6375_enable_wd_dischg(ddata, chan, false);
+		if (ret < 0) {
+			MT6375_DBGINFO("disable chan%d dischg fail(%d)\n", chan,
+				       ret);
+			goto out;
+		}
+		if (wd_adc <= desc->wd_sbu_pl_bound ||
+			(wd_adc >= desc->wd_sbu_pl_lbound_c2c &&
+			wd_adc <= desc->wd_sbu_pl_ubound_c2c))
+			break;
+	}
+	if (i == CONFIG_WD_SBU_PL_RETRY) {
+		*wd = true;
+		goto out;
+	}
+
+	ret = mt6375_enable_wd_pullup(ddata, chan, MT6375_WD_RPULL_500K, true);
+	if (ret < 0) {
+		MT6375_DBGINFO("chan%d pull up 500k fail(%d)\n", chan, ret);
+		goto out;
+	}
+
+	for (i = 0; i < CONFIG_WD_SBU_PH_RETRY; i++) {
+		ret = mt6375_get_wd_adc(ddata, chan, &wd_adc);
+		if (ret < 0) {
+			MT6375_DBGINFO("get chan%d adc fail(%d)\n", chan, ret);
+			goto out;
+		}
+		MT6375_DBGINFO("chan%d pull high %dmV(lb %d, ub %d)\n", chan,
+			       wd_adc, lb, ub);
+		if (wd_adc >= lb && wd_adc <= ub) {
+			*wd = false;
+			goto out;
+		}
+		msleep(20);
+	}
+
+#if CONFIG_CABLE_TYPE_DETECTION
+	if (ddata->tcpc->tcpc_flags & TCPC_FLAGS_CABLE_TYPE_DETECTION) {
+		cable_type = ddata->tcpc->typec_cable_type;
+		if (cable_type == TCPC_CABLE_TYPE_NONE) {
+			ret = mt6375_read8(ddata, MT6375_REG_MTINT3, &ctd_evt);
+			if (ret >= 0 && (ctd_evt & MT6375_MSK_CTD))
+				ret = mt6375_get_cable_type(ddata, &cable_type);
+		}
+		if (cable_type == TCPC_CABLE_TYPE_C2C) {
+			if (((wd_adc >= desc->wd_sbu_ph_lbound1_c2c) &&
+			    (wd_adc <= desc->wd_sbu_ph_ubound1_c2c)) ||
+			    (wd_adc > desc->wd_sbu_ph_ubound2_c2c)) {
+				MT6375_DBGINFO("ignore water for C2C\n");
+				*wd = false;
+				goto out;
+			}
+		}
+	}
+#endif
+
+	if (mt6375_is_wd_audio_device(ddata, chan, wd_adc)) {
+		MT6375_DBGINFO("suspect audio device but not water\n");
+		*wd = false;
+		goto out;
+	}
+	*wd = true;
+out:
+	MT6375_DBGINFO("water %s\n", *wd ? "detected" : "not detected");
+	mt6375_write8(ddata, mt6375_wd_miscctrl_reg[chan],
+		      MT6375_MSK_WDRPULL_EN | MT6375_MSK_WDDISCHG_EN);
+	pm_relax(ddata->dev);
+	return ret;
+}
+
+static int mt6375_enable_wd_polling(struct mt6375_tcpc_data *ddata, bool en)
+{
+	int ret, i;
+
+	if (en) {
+		ret = mt6375_update_bits_rt2(ddata,
+					     MT6375_REG_WDSET3,
+					     MT6375_MASK_WD_TDET,
+					     MT6375_WD_TDET_10MS <<
+						MT6375_SHFT_WD_TDET);
+		if (ret < 0)
+			return ret;
+		for (i = 0; i < MT6375_WD_CHAN_NUM; i++) {
+			if (!mt6375_wd_chan_en[i])
+				continue;
+			ret = mt6375_set_wd_polling_parameter(ddata, i);
+			if (ret < 0)
+				return ret;
+		}
+	}
+	return mt6375_write8(ddata, MT6375_REG_WD12MODECTRL,
+			     en ? MT6375_MSK_WD12MODE_EN : 0);
+}
+
+static int mt6375_enable_wd_protection(struct mt6375_tcpc_data *ddata, bool en)
+{
+	int i, ret;
+
+	MT6375_DBGINFO("%s: en = %d\n", __func__, en);
+	if (en) {
+		ret = mt6375_update_bits_rt2(ddata,
+					     MT6375_REG_WDSET3,
+					     MT6375_MASK_WD_TDET,
+					     MT6375_WD_TDET_1MS <<
+						MT6375_SHFT_WD_TDET);
+		if (ret < 0)
+			return ret;
+		for (i = 0; i < MT6375_WD_CHAN_NUM; i++) {
+			if (!mt6375_wd_chan_en[i])
+				continue;
+			mt6375_set_wd_protection_parameter(ddata, i);
+		}
+	}
+	/* set DPDM manual mode and DPDM_DET_EN = 1 */
+	ret = regmap_update_bits(ddata->rmap, MT6375_REG_DPDM_CTRL1,
+		MT6375_MSK_MANUAL_MODE | MT6375_MSK_DPDMDET_EN, en ? 0xff : 0);
+	if (ret < 0)
+		return ret;
+	return mt6375_write8(ddata, MT6375_REG_WD12MODECTRL,
+			     en ?
+			     MT6375_MSK_WD12MODE_EN | MT6375_MSK_WD12PROT : 0);
+}
+
+static int mt6375_wd_polling_evt_process(struct mt6375_tcpc_data *ddata)
+{
+	int i, ret;
+	bool toggling, polling = true, error = false;
+
+	/* Only handle this event if CCs are still toggling */
+	ret = mt6375_is_cc_toggling(ddata, &toggling);
+	if (ret < 0)
+		return ret;
+	if (!toggling)
+		return 0;
+
+	mt6375_enable_wd_polling(ddata, false);
+	for (i = 0; i < MT6375_WD_CHAN_NUM; i++) {
+		if (!mt6375_wd_chan_en[i])
+			continue;
+		ret = mt6375_check_wd_status(ddata, i, &error);
+		if (ret < 0 || !error)
+			continue;
+		ret = __mt6375_is_water_detected(ddata, i, &error);
+		if (ret < 0 || !error)
+			continue;
+		polling = false;
+		break;
+	}
+	if (polling)
+		mt6375_enable_wd_polling(ddata, true);
+	else
+		tcpc_typec_handle_wd(ddata->tcpc, true);
+	return 0;
+}
+
+static int mt6375_wd_protection_evt_process(struct mt6375_tcpc_data *ddata)
+{
+	int i, ret;
+	bool error[2] = {false, false}, protection = false;
+
+	for (i = 0; i < MT6375_WD_CHAN_NUM; i++) {
+		if (!mt6375_wd_chan_en[i])
+			continue;
+		ret = mt6375_check_wd_status(ddata, i, &error[0]);
+		if (ret < 0)
+			goto out;
+		ret = __mt6375_is_water_detected(ddata, i, &error[1]);
+		if (ret < 0)
+			goto out;
+		MT6375_DBGINFO("%s: err1:%d, err2:%d\n",
+			       __func__, error[0], error[1]);
+		if (!error[0] && !error[1])
+			continue;
+out:
+		protection = true;
+		break;
+	}
+	MT6375_DBGINFO("%s: retry cnt = %d\n", __func__, ddata->wd_protect_rty);
+	if (!protection && atomic_dec_and_test(&ddata->wd_protect_rty)) {
+		tcpc_typec_handle_wd(ddata->tcpc, false);
+		atomic_set(&ddata->wd_protect_rty,
+			   CONFIG_WD_PROTECT_RETRY_COUNT);
+	} else
+		mt6375_enable_wd_protection(ddata, true);
+	return 0;
+}
+
+#if CONFIG_WD_POLLING_ONLY
+static void mt6375_wd_poll_dwork_handler(struct work_struct *work)
+{
+	int ret;
+	bool toggling;
+	struct delayed_work *dwork = to_delayed_work(work);
+	struct mt6375_tcpc_data *ddata = container_of(dwork,
+						     struct mt6375_tcpc_data,
+						     wd_poll_dwork);
+
+	ret = mt6375_is_cc_toggling(ddata, &toggling);
+	if (ret < 0)
+		return;
+	if (!toggling)
+		return;
+	mt6375_enable_wd_polling(ddata, true);
+}
+#endif /* CONFIG_WD_POLLING_ONLY */
+#endif /* CONFIG_WATER_DETECTION */
+
+static int mt6375_set_cc_toggling(struct mt6375_tcpc_data *ddata, int pull)
+{
+	int ret, rp_lvl = TYPEC_CC_PULL_GET_RP_LVL(pull);
+	u8 data = TCPC_V10_REG_ROLE_CTRL_RES_SET(1, rp_lvl, TYPEC_CC_RD,
+						 TYPEC_CC_RD);
+#if CONFIG_WATER_DETECTION
+#if CONFIG_WD_POLLING_ONLY
+	struct tcpc_desc *desc = ddata->desc;
+#endif /* CONFIG_WD_POLLING_ONLY */
+#endif /* CONFIG_WATER_DETECTION */
+
+	pr_info("%s\n", __func__);
+	ret = mt6375_write8(ddata, TCPC_V10_REG_ROLE_CTRL, data);
+	if (ret < 0)
+		return ret;
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
+	ret = mt6375_enable_vsafe0v_detect(ddata, false);
+	if (ret < 0)
+		return ret;
+#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
+	/* Set Low Power LDO to 2V */
+	ret = mt6375_write8(ddata, MT6375_REG_LPWRCTRL3, 0xD8);
+	if (ret < 0)
+		return ret;
+#if CONFIG_TCPC_LOW_POWER_MODE
+	tcpci_set_low_power_mode(ddata->tcpc, true, pull);
+#endif /* CONFIG_TCPC_LOW_POWER_MODE */
+	udelay(30);
+	ret = mt6375_write8(ddata, TCPC_V10_REG_COMMAND,
+			    TCPM_CMD_LOOK_CONNECTION);
+	if (ret < 0)
+		return ret;
+
+#if CONFIG_WATER_DETECTION
+#if CONFIG_WD_POLLING_ONLY
+	if (desc->en_wd_sbu_polling) {
+		if (desc->en_wd_polling_only)
+			schedule_delayed_work(&ddata->wd_poll_dwork,
+					msecs_to_jiffies(500));
+		else
+			mt6375_enable_wd_polling(ddata, true);
+	}
+#endif /* CONFIG_WD_POLLING_ONLY */
+#endif /* CONFIG_WATER_DETECTION */
+	return 0;
+}
+
+static int mt6375_is_floating_ground_enabled(struct mt6375_tcpc_data *ddata,
+					     bool *en)
+{
+	int ret;
+	u8 data;
+
+	ret = mt6375_read8(ddata, MT6375_REG_WD0MODECTRL, &data);
+	if (ret < 0)
+		return ret;
+	*en = (data & MT6375_MSK_WD0MODE_EN) ? true : false;
+	return 0;
+}
+
+static int mt6375_enable_floating_ground(struct mt6375_tcpc_data *ddata,
+					 bool en)
+{
+	int ret;
+
+	pr_info("%s: en:%d\n", __func__, en);
+	if (en) {
+		ret = tcpci_set_cc(ddata->tcpc, TYPEC_CC_RD);
+		if (ret < 0)
+			return ret;
+		ret = mt6375_set_wd_ldo(ddata, MT6375_WD_LDO_0_6V);
+		if (ret < 0)
+			return ret;
+	}
+	ret = (en ? mt6375_set_bits : mt6375_clr_bits)
+		(ddata, MT6375_REG_WD0MODECTRL, MT6375_MSK_WD0MODE_EN);
+	if (!en) {
+		ret = mt6375_set_wd_ldo(ddata, MT6375_WD_LDO_1_8V);
+		if (ret < 0)
+			return ret;
+	}
+	return 0;
+}
+
+static int mt6375_floating_ground_evt_process(struct mt6375_tcpc_data *ddata)
+{
+	int ret;
+	bool en;
+	u8 data;
+
+	ret = mt6375_is_floating_ground_enabled(ddata, &en);
+	if (ret < 0 || !en)
+		return ret;
+	ret = mt6375_read8(ddata, MT6375_REG_WD0SET, &data);
+	if (ret < 0)
+		return ret;
+	if (data & MT6375_MSK_WD0PULL_STS)
+		return tcpci_set_cc(ddata->tcpc, TYPEC_CC_DRP);
+#if CONFIG_TCPC_LOW_POWER_MODE
+	tcpci_set_low_power_mode(ddata->tcpc, true, TYPEC_CC_DRP);
+#endif /* CONFIG_TCPC_LOW_POWER_MODE */
+	return tcpci_set_floating_ground(ddata->tcpc, true);
+}
+
+/*
+ * ==================================================================
+ * TCPC ops
+ * ==================================================================
+ */
+
+static int mt6375_tcpc_init(struct tcpc_device *tcpc, bool sw_reset)
+{
+	int ret;
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	if (sw_reset) {
+		ret = mt6375_sw_reset(ddata);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* Select PD_IRQB from synchronous to 3M path */
+	mt6375_set_bits(ddata, MT6375_REG_SYSCTRL1, 0x80);
+
+	/* UFP Both RD setting */
+	/* DRP = 0, RpVal = 0 (Default), Rd, Rd */
+	mt6375_write8(ddata, TCPC_V10_REG_ROLE_CTRL,
+		      TCPC_V10_REG_ROLE_CTRL_RES_SET(0, 0, CC_RD, CC_RD));
+
+	/* tTCPCFilter = 250us */
+	mt6375_write8(ddata, MT6375_REG_TCPCCTRL1, 0x0A);
+
+	/*
+	 * DRP Toggle Cycle : 51.2 + 6.4*val ms
+	 * DRP Duyt Ctrl : dcSRC / 1024
+	 */
+	mt6375_write8(ddata, MT6375_REG_TCPCCTRL2, 4);
+	mt6375_write16(ddata, MT6375_REG_TCPCCTRL3, TCPC_NORMAL_RP_DUTY);
+
+	/*
+	 * Transition toggle count = 7
+	 * OSC_FREQ_CFG = 0x01
+	 * RXFilter out 100ns glich = 0x00
+	 */
+	mt6375_write8(ddata, MT6375_REG_PHYCTRL1, 0x74);
+
+	/* PHY_CDR threshold = 0x3A */
+	mt6375_write8(ddata, MT6375_REG_PHYCTRL2, 0x3A);
+
+	/* Transition window time = 43.29us */
+	mt6375_write8(ddata, MT6375_REG_PHYCTRL3, 0x82);
+
+	/* BMC decoder idle time = 17.982us */
+	mt6375_write8(ddata, MT6375_REG_PHYCTRL7, 0x36);
+
+	/* Retry period = 26.208us */
+	mt6375_write8(ddata, MT6375_REG_PHYCTRL9, 0x3C);
+
+	/* Enable PD Vconn current limit mode */
+	mt6375_write8(ddata, MT6375_REG_VCONCTRL3, 0x41);
+
+	/* Set HILOCCFILTER 250us */
+	mt6375_write8(ddata, MT6375_REG_HILOCTRL9, 0x0A);
+
+	/* Enable CC open 40ms when PMIC SYSUV */
+	mt6375_set_bits(ddata, MT6375_REG_SHIELDCTRL1, MT6375_MSK_OPEN40MS_EN);
+
+	/*
+	 * Enable Alert.CCStatus assertion
+	 * when CCStatus.Looking4Connection changes
+	 */
+	mt6375_set_bits(ddata, TCPC_V10_REG_TCPC_CTRL,
+			TCPC_V10_REG_TCPC_CTRL_EN_LOOK4CONNECTION_ALERT);
+
+#if CONFIG_WATER_DETECTION
+	if (ddata->tcpc->tcpc_flags & TCPC_FLAGS_WATER_DETECTION)
+		mt6375_init_wd(ddata);
+#endif /* CONFIG_WATER_DETECTION */
+
+	tcpci_init_alert_mask(tcpc);
+
+	if (tcpc->tcpc_flags & TCPC_FLAGS_WATCHDOG_EN) {
+		/* Set watchdog timer = 3.2s and enable */
+		mt6375_write8(ddata, MT6375_REG_WATCHDOGCTRL, 0x07);
+		tcpci_set_watchdog(tcpc, true);
+	}
+
+	/* Disable bleed dischg for IQ about 2mA consumption */
+	mt6375_clr_bits(ddata, TCPC_V10_REG_POWER_CTRL,
+			TCPC_V10_REG_BLEED_DISC_EN);
+
+	/* SHIPPING off, AUTOIDLE on */
+	mt6375_set_bits(ddata, MT6375_REG_SYSCTRL1,
+			MT6375_MSK_SHIPPING_OFF | MT6375_MSK_AUTOIDLE_EN);
+	return 0;
+}
+
+static int mt6375_init_mask(struct tcpc_device *tcpc)
+{
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	mt6375_init_alert_mask(ddata);
+	mt6375_init_power_status_mask(ddata);
+	mt6375_init_fault_mask(ddata);
+	mt6375_init_ext_mask(ddata);
+	mt6375_init_vend_mask(ddata);
+
+	/* Init fod must be handled after init alert mask */
+	if ((ddata->tcpc->tcpc_flags & TCPC_FLAGS_FOREIGN_OBJECT_DETECTION) &&
+		ddata->handle_init_fod) {
+		ddata->handle_init_fod = false;
+		tcpc_typec_handle_fod(tcpc, ddata->init_fod);
+	}
+
+#if CONFIG_CABLE_TYPE_DETECTION
+	/* Init cable type must be done after fod */
+	if ((ddata->tcpc->tcpc_flags & TCPC_FLAGS_CABLE_TYPE_DETECTION) &&
+	    (ddata->handle_init_ctd)) {
+		/*
+		 * wait 3ms for exit low power mode and
+		 * TCPC filter debounce
+		 */
+		mdelay(3);
+		ddata->handle_init_ctd = false;
+		tcpc_typec_handle_ctd(tcpc, ddata->init_cable_type);
+	}
+#endif
+	return 0;
+}
+
+static int mt6375_alert_status_clear(struct tcpc_device *tcpc, u32 mask)
+{
+	u16 std_mask = mask & 0xffff;
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	return std_mask ?
+	       mt6375_write16(ddata, TCPC_V10_REG_ALERT, std_mask) : 0;
+}
+
+static int mt6375_fault_status_clear(struct tcpc_device *tcpc, u8 status)
+{
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	/*
+	 * Not sure how to react after discharge fail
+	 * follow previous H/W behavior, turn off force discharge
+	 */
+	if (status & TCPC_V10_REG_FAULT_STATUS_FORCE_DISC_FAIL)
+		mt6375_enable_force_discharge(ddata, false);
+	return mt6375_write8(ddata, TCPC_V10_REG_FAULT_STATUS, status);
+}
+
+static int mt6375_set_alert_mask(struct tcpc_device *tcpc, u32 mask)
+{
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	MT6375_DBGINFO("%s: mask = 0x%04x\n", __func__, mask);
+	return mt6375_write16(ddata, TCPC_V10_REG_ALERT_MASK, mask);
+}
+
+static int mt6375_get_alert_mask(struct tcpc_device *tcpc, u32 *mask)
+{
+	int ret;
+	u16 data;
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	ret = mt6375_read16(ddata, TCPC_V10_REG_ALERT_MASK, &data);
+	if (ret < 0)
+		return ret;
+	*mask = data;
+	return 0;
+}
+
+static int mt6375_get_alert_status(struct tcpc_device *tcpc, u32 *alert)
+{
+	int ret;
+	u16 data;
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	ret = mt6375_read16(ddata, TCPC_V10_REG_ALERT, &data);
+	if (ret < 0)
+		return ret;
+	*alert = data;
+	return 0;
+}
+
+static int mt6375_get_power_status(struct tcpc_device *tcpc, u16 *status)
+{
+	int ret;
+	u8 data;
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	ret = mt6375_read8(ddata, TCPC_V10_REG_POWER_STATUS, &data);
+	if (ret < 0)
+		return ret;
+
+	*status = 0;
+	if (data & TCPC_V10_REG_POWER_STATUS_VBUS_PRES)
+		*status |= TCPC_REG_POWER_STATUS_VBUS_PRES;
+
+	/*
+	 * Vsafe0v only triggers when vbus falls under 0.8V,
+	 * also update parameter if vbus present triggers
+	 */
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
+	ret = tcpci_is_vsafe0v(tcpc);
+	if (ret < 0)
+		goto out;
+	tcpc->vbus_safe0v = ret ? true : false;
+out:
+#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
+	return 0;
+}
+
+static int mt6375_get_fault_status(struct tcpc_device *tcpc, u8 *status)
+{
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	return mt6375_read8(ddata, TCPC_V10_REG_FAULT_STATUS, status);
+}
+
+static int mt6375_get_cc(struct tcpc_device *tcpc, int *cc1, int *cc2)
+{
+	int ret;
+	bool act_as_sink, act_as_drp;
+	u8 status, role_ctrl, cc_role;
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	ret = mt6375_read8(ddata, TCPC_V10_REG_CC_STATUS, &status);
+	if (ret < 0)
+		return ret;
+
+	ret = mt6375_read8(ddata, TCPC_V10_REG_ROLE_CTRL, &role_ctrl);
+	if (ret < 0)
+		return ret;
+
+	if (status & TCPC_V10_REG_CC_STATUS_DRP_TOGGLING) {
+		*cc1 = TYPEC_CC_DRP_TOGGLING;
+		*cc2 = TYPEC_CC_DRP_TOGGLING;
+		return 0;
+	}
+
+	*cc1 = TCPC_V10_REG_CC_STATUS_CC1(status);
+	*cc2 = TCPC_V10_REG_CC_STATUS_CC2(status);
+
+	act_as_drp = TCPC_V10_REG_ROLE_CTRL_DRP & role_ctrl;
+
+	if (act_as_drp)
+		act_as_sink = TCPC_V10_REG_CC_STATUS_DRP_RESULT(status);
+	else {
+		if (tcpc->typec_polarity)
+			cc_role = TCPC_V10_REG_CC_STATUS_CC2(role_ctrl);
+		else
+			cc_role = TCPC_V10_REG_CC_STATUS_CC1(role_ctrl);
+		act_as_sink = (cc_role == TYPEC_CC_RP) ? false : true;
+	}
+
+	/*
+	 * If status is not open, then OR in termination to convert to
+	 * enum tcpc_cc_voltage_status.
+	 */
+	if (*cc1 != TYPEC_CC_VOLT_OPEN)
+		*cc1 |= (act_as_sink << 2);
+	if (*cc2 != TYPEC_CC_VOLT_OPEN)
+		*cc2 |= (act_as_sink << 2);
+	return 0;
+}
+
+static int mt6375_set_cc(struct tcpc_device *tcpc, int pull)
+{
+	int ret;
+	int rp_lvl = TYPEC_CC_PULL_GET_RP_LVL(pull);
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+	bool en;
+
+	MT6375_INFO("%s %d\n", __func__, pull);
+	pull = TYPEC_CC_PULL_GET_RES(pull);
+	if (pull == TYPEC_CC_DRP) {
+		if (tcpc->tcpc_flags & TCPC_FLAGS_FLOATING_GROUND) {
+			ret = mt6375_is_floating_ground_enabled(ddata, &en);
+			if (!en)
+				ret = mt6375_enable_floating_ground(ddata, true);
+			else
+				ret = mt6375_set_cc_toggling(ddata, pull);
+		} else
+			ret = mt6375_set_cc_toggling(ddata, pull);
+	} else {
+#if CONFIG_WATER_DETECTION
+#if CONFIG_WD_POLLING_ONLY
+		if (tcpc->tcpc_flags & TCPC_FLAGS_WD_POLLING_ONLY) {
+			cancel_delayed_work_sync(&ddata->wd_poll_dwork);
+			mt6375_enable_wd_polling(ddata, false);
+		}
+#endif /* CONFIG_WD_POLLING_ONLY */
+#endif /* CONFIG_WATER_DETECTION */
+		ret = __mt6375_set_cc(ddata, rp_lvl, pull);
+	}
+	return ret;
+}
+
+static int mt6375_set_polarity(struct tcpc_device *tcpc, int polarity)
+{
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	return (polarity ? mt6375_set_bits : mt6375_clr_bits)
+		(ddata, TCPC_V10_REG_TCPC_CTRL,
+		 TCPC_V10_REG_TCPC_CTRL_PLUG_ORIENT);
+}
+
+static int mt6375_set_low_rp_duty(struct tcpc_device *tcpc, bool low_rp)
+{
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+	u16 duty = low_rp ? TCPC_LOW_RP_DUTY : TCPC_NORMAL_RP_DUTY;
+
+	return mt6375_write16(ddata, MT6375_REG_TCPCCTRL3, duty);
+}
+
+static int mt6375_set_vconn(struct tcpc_device *tcpc, int en)
+{
+	int ret;
+	bool fault = false;
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	/*
+	 * Set Vconn OVP RVP
+	 * Otherwise vconn present fail will be triggered
+	 */
+	if (en) {
+		mt6375_set_bits(ddata, MT6375_REG_VCONCTRL2,
+				MT6375_MSK_VCON_PROTEN);
+		usleep_range(20, 50);
+		ret = mt6375_is_vconn_fault(ddata, &fault);
+		if (ret >= 0 && fault)
+			return -EINVAL;
+	}
+	ret = (en ? mt6375_set_bits : mt6375_clr_bits)
+		(ddata, TCPC_V10_REG_POWER_CTRL, TCPC_V10_REG_POWER_CTRL_VCONN);
+	if (!en)
+		mt6375_clr_bits(ddata, MT6375_REG_VCONCTRL2,
+				MT6375_MSK_VCON_PROTEN);
+	return ret;
+}
+
+static int mt6375_tcpc_deinit(struct tcpc_device *tcpc)
+{
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+#if CONFIG_TCPC_SHUTDOWN_CC_DETACH
+	mt6375_set_cc(tcpc, TYPEC_CC_DRP);
+	mt6375_set_cc(tcpc, TYPEC_CC_OPEN);
+
+	/* Enable i2c reset and set timeout 62.5ms */
+	mt6375_write8(ddata, MT6375_REG_I2CTORSTCTRL, 0x85);
+#else
+	mt6375_write8(ddata, MT6375_REG_SYSCTRL3, 0x01);
+#endif	/* CONFIG_TCPC_SHUTDOWN_CC_DETACH */
+	return 0;
+}
+
+static int mt6375_set_watchdog(struct tcpc_device *tcpc, bool en)
+{
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	return (en ? mt6375_set_bits : mt6375_clr_bits)
+		(ddata, TCPC_V10_REG_TCPC_CTRL, TCPC_V10_REG_TCPC_CTRL_EN_WDT);
+}
+
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
+static int mt6375_is_vsafe0v(struct tcpc_device *tcpc)
+{
+	int ret;
+	u8 data;
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	ret = mt6375_read8(ddata, MT6375_REG_MTST1, &data);
+	if (ret < 0)
+		return ret;
+	return (data & MT6375_MSK_VBUS80) ? 1 : 0;
+}
+#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
+
+#if CONFIG_TCPC_LOW_POWER_MODE
+static int mt6375_is_low_power_mode(struct tcpc_device *tcpc)
+{
+	int ret;
+	u8 data;
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	ret = mt6375_read8(ddata, MT6375_REG_SYSCTRL2, &data);
+	if (ret < 0)
+		return ret;
+	return (data & MT6375_MSK_LPWR_EN) != 0;
+}
+
+static int mt6375_set_low_power_mode(struct tcpc_device *tcpc, bool en,
+				     int pull)
+{
+	u8 data;
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	if (en) {
+		data = MT6375_MSK_LPWR_EN;
+#if CONFIG_TYPEC_CAP_NORP_SRC
+		data |= MT6375_MSK_VBUSDET_EN;
+#endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
+	} else {
+		data = MT6375_MSK_VBUSDET_EN | MT6375_MSK_BMCIOOSC_EN;
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
+		mt6375_enable_vsafe0v_detect(ddata, true);
+#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
+	}
+	return mt6375_write8(ddata, MT6375_REG_SYSCTRL2, data);
+}
+#endif	/* CONFIG_TCPC_LOW_POWER_MODE */
+
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
+static int mt6375_set_msg_header(struct tcpc_device *tcpc, u8 power_role,
+				 u8 data_role)
+{
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+	u8 msg_hdr = TCPC_V10_REG_MSG_HDR_INFO_SET(data_role, power_role);
+
+	return mt6375_write8(ddata, TCPC_V10_REG_MSG_HDR_INFO, msg_hdr);
+}
+
+static int mt6375_protocol_reset(struct tcpc_device *tcpc)
+{
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	mt6375_clr_bits(ddata, MT6375_REG_PHYCTRL8, MT6375_MSK_PRLRSTB);
+	mdelay(1);
+	mt6375_set_bits(ddata, MT6375_REG_PHYCTRL8, MT6375_MSK_PRLRSTB);
+	return 0;
+}
+
+static int mt6375_set_rx_enable(struct tcpc_device *tcpc, u8 en)
+{
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	return mt6375_write8(ddata, TCPC_V10_REG_RX_DETECT, en);
+}
+
+static int mt6375_get_message(struct tcpc_device *tcpc, u32 *payload,
+			      u16 *msg_head,
+			      enum tcpm_transmit_type *frame_type)
+{
+	int ret;
+	u8 type, cnt = 0;
+	u8 buf[4] = {0};
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+	uint32_t cmd;
+
+	ret = mt6375_bulk_read(ddata, TCPC_V10_REG_RX_BYTE_CNT, buf, 4);
+	cnt = buf[0];
+	type = buf[1];
+	*msg_head = *(u16 *)&buf[2];
+
+	cmd = PD_HEADER_TYPE(*msg_head);
+	MT6375_INFO("MessageType is %d\n", cmd);
+
+	/* TCPC 1.0 ==> no need to subtract the size of msg_head */
+	if (ret >= 0 && cnt > 3) {
+		cnt -= 3; /* MSG_HDR */
+		ret = mt6375_bulk_read(ddata, TCPC_V10_REG_RX_DATA,
+				       (u8 *)payload, cnt);
+	}
+	*frame_type = (enum tcpm_transmit_type)type;
+
+	/* Read complete, clear RX status alert bit */
+	tcpci_alert_status_clear(tcpc, TCPC_V10_REG_ALERT_RX_STATUS |
+				 TCPC_V10_REG_RX_OVERFLOW);
+	return ret;
+}
+
+/* message header (2byte) + data object (7*4) */
+#define MT6375_TRANSMIT_MAX_SIZE	(sizeof(u16) + sizeof(u32) * 7)
+
+static int mt6375_transmit(struct tcpc_device *tcpc,
+			   enum tcpm_transmit_type type, u16 header,
+			   const u32 *data)
+{
+	int ret, data_cnt, packet_cnt;
+	u8 temp[MT6375_TRANSMIT_MAX_SIZE];
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+	long long t1 = 0, t2 = 0;
+
+	MT6375_INFO("%s ++\n", __func__);
+	t1 = local_clock();
+	if (type < TCPC_TX_HARD_RESET) {
+		data_cnt = sizeof(u32) * PD_HEADER_CNT(header);
+		packet_cnt = data_cnt + sizeof(u16);
+
+		temp[0] = packet_cnt;
+		memcpy(temp + 1, (u8 *)&header, 2);
+		if (data_cnt > 0)
+			memcpy(temp + 3, (u8 *)data, data_cnt);
+
+		ret = mt6375_bulk_write(ddata, TCPC_V10_REG_TX_BYTE_CNT,
+					(u8 *)temp, packet_cnt + 1);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = mt6375_write8(ddata, TCPC_V10_REG_TRANSMIT,
+			     TCPC_V10_REG_TRANSMIT_SET(tcpc->pd_retry_count,
+			     type));
+	t2 = local_clock();
+	MT6375_INFO("%s -- delta = %lluus\n",
+			__func__, (t2 - t1) / NSEC_PER_USEC);
+
+#if PD_DYNAMIC_SENDER_RESPONSE
+	tcpc->t[0] = local_clock();
+#endif
+	//tcpc->t[0] = local_clock();
+	//MT6375_INFO("%s done\n", __func__);
+	return ret;
+}
+
+static int mt6375_set_bist_test_mode(struct tcpc_device *tcpc, bool en)
+{
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	return (en ? mt6375_set_bits : mt6375_clr_bits)
+		(ddata, TCPC_V10_REG_TCPC_CTRL,
+		 TCPC_V10_REG_TCPC_CTRL_BIST_TEST_MODE);
+}
+
+static int mt6375_set_bist_carrier_mode(struct tcpc_device *tcpc, u8 pattern)
+{
+	/* Not support this function */
+	return 0;
+}
+#endif /* CONFIG_USB_POWER_DELIVERY */
+
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
+static int mt6375_retransmit(struct tcpc_device *tcpc)
+{
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	return mt6375_write8(ddata, TCPC_V10_REG_TRANSMIT,
+			     TCPC_V10_REG_TRANSMIT_SET(tcpc->pd_retry_count,
+			     TCPC_TX_SOP));
+}
+#endif /* CONFIG_USB_PD_RETRY_CRC_DISCARD */
+
+static int mt6375_set_cc_hidet(struct tcpc_device *tcpc, bool en)
+{
+	int ret;
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	if (en)
+		mt6375_enable_rpdet_auto(ddata, false);
+	ret = (en ? mt6375_set_bits : mt6375_clr_bits)
+		(ddata, MT6375_REG_HILOCTRL10, MT6375_MSK_HIDET_CC_CMPEN);
+	if (ret < 0)
+		return ret;
+	ret = (en ? mt6375_set_bits : mt6375_clr_bits)
+		(ddata, MT6375_REG_MTMASK5, MT6375_MSK_HIDET_CC);
+	if (ret < 0)
+		return ret;
+	if (!en)
+		mt6375_enable_rpdet_auto(ddata, true);
+	return ret;
+}
+
+#if CONFIG_WATER_DETECTION
+static int mt6375_is_water_detected(struct tcpc_device *tcpc)
+{
+	int ret, i;
+	bool error, wd = false;
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	for (i = 0; i < MT6375_WD_CHAN_NUM; i++) {
+		if (!mt6375_wd_chan_en[i])
+			continue;
+		ret = __mt6375_is_water_detected(ddata, i, &error);
+		if (ret < 0 || !error)
+			continue;
+		wd = true;
+		break;
+	}
+	return wd ? 1 : 0;
+}
+
+static int mt6375_set_water_protection(struct tcpc_device *tcpc, bool en)
+{
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	return mt6375_enable_wd_protection(ddata, en);
+}
+
+#if CONFIG_WD_POLLING_ONLY
+static int mt6375_set_wd_polling(struct tcpc_device *tcpc, bool en)
+{
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	if (!en && (tcpc->tcpc_flags & TCPC_FLAGS_WD_POLLING_ONLY))
+		cancel_delayed_work_sync(&ddata->wd_poll_dwork);
+	return mt6375_enable_wd_polling(ddata, en);
+}
+#endif /* CONFIG_WD_POLLING_ONLY */
+#endif /* CONFIG_WATER_DETECTION */
+
+static int mt6375_set_floating_ground(struct tcpc_device *tcpc, bool en)
+{
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	return mt6375_enable_floating_ground(ddata, en);
+}
+
+/*
+ * ==================================================================
+ * TCPC vendor irq handlers
+ * ==================================================================
+ */
+
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
+static int mt6375_vsafe0v_irq_handler(struct mt6375_tcpc_data *ddata)
+{
+	int ret;
+
+	ret = tcpci_is_vsafe0v(ddata->tcpc);
+	if (ret < 0)
+		return ret;
+	ddata->tcpc->vbus_safe0v = ret ? true : false;
+	return 0;
+}
+#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
+
+static int mt6375_typec_otp_irq_handler(struct mt6375_tcpc_data *ddata)
+{
+	int ret;
+	u8 data;
+	bool otp;
+
+	ret = mt6375_read8(ddata, MT6375_REG_MTST1, &data);
+	if (ret < 0)
+		return ret;
+	otp = (data & MT6375_MSK_TYPECOTP) ? true : false;
+	if (otp)
+		mt6375_enable_typec_otp_fwen(ddata->tcpc, true);
+	tcpc_typec_handle_otp(ddata->tcpc, otp);
+	return 0;
+}
+
+static int mt6375_wd12_strise_irq_handler(struct mt6375_tcpc_data *ddata)
+{
+	/* Pull or discharge status from 0 to 1 in normal polling mode */
+	MT6375_DBGINFO("%s\n", __func__);
+#if CONFIG_WATER_DETECTION
+	return mt6375_wd_polling_evt_process(ddata);
+#else
+	return 0;
+#endif
+}
+
+static int mt6375_wd12_done_irq_handler(struct mt6375_tcpc_data *ddata)
+{
+	/* Oneshot or protect mode done */
+	MT6375_DBGINFO("%s\n", __func__);
+#if CONFIG_WATER_DETECTION
+	return mt6375_wd_protection_evt_process(ddata);
+#else
+	return 0;
+#endif
+}
+
+static int mt6375_wd0_stfall_irq_handler(struct mt6375_tcpc_data *ddata)
+{
+	/* WD0_PULL_STS from 1 to 0 in normal polling mode */
+	return mt6375_floating_ground_evt_process(ddata);
+}
+
+static int mt6375_wd0_strise_irq_handler(struct mt6375_tcpc_data *ddata)
+{
+	/* WD0_PULL_STS from 0 to 1 in normal polling mode */
+	return mt6375_floating_ground_evt_process(ddata);
+}
+
+static int mt6375_hidet_cc1_irq_handler(struct mt6375_tcpc_data *ddata)
+{
+	return mt6375_hidet_cc_evt_process(ddata);
+}
+
+static int mt6375_hidet_cc2_irq_handler(struct mt6375_tcpc_data *ddata)
+{
+	return mt6375_hidet_cc_evt_process(ddata);
+}
+
+static int mt6375_fod_done_irq_handler(struct mt6375_tcpc_data *ddata)
+{
+	MT6375_DBGINFO("%s\n", __func__);
+	mt6375_fod_evt_process(ddata);
+	return 0;
+}
+
+static int mt6375_fod_ov_irq_handler(struct mt6375_tcpc_data *ddata)
+{
+	MT6375_DBGINFO("%s\n", __func__);
+	mt6375_fod_evt_process(ddata);
+	return 0;
+}
+
+static int mt6375_fod_dischgf_irq_handler(struct mt6375_tcpc_data *ddata)
+{
+	MT6375_DBGINFO("%s\n", __func__);
+	mt6375_fod_evt_process(ddata);
+	return 0;
+}
+
+static int mt6375_ctd_irq_handler(struct mt6375_tcpc_data *ddata)
+{
+#if CONFIG_CABLE_TYPE_DETECTION
+	int ret;
+	enum tcpc_cable_type cable_type;
+
+	ret = mt6375_get_cable_type(ddata, &cable_type);
+	if (ret < 0)
+		return ret;
+
+	tcpc_typec_handle_ctd(ddata->tcpc, cable_type);
+#endif
+	return 0;
+}
+
+struct irq_mapping_tbl {
+	u8 num;
+	const char *name;
+	int (*hdlr)(struct mt6375_tcpc_data *ddata);
+};
+
+#define MT6375_IRQ_MAPPING(_num, _name) \
+	{ .num = _num, .name = #_name, .hdlr = mt6375_##_name##_irq_handler }
+
+static struct irq_mapping_tbl mt6375_vend_irq_mapping_tbl[] = {
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
+	MT6375_IRQ_MAPPING(1, vsafe0v),
+#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
+
+	MT6375_IRQ_MAPPING(2, typec_otp),
+
+	MT6375_IRQ_MAPPING(49, wd12_strise),
+	MT6375_IRQ_MAPPING(50, wd12_done),
+
+	MT6375_IRQ_MAPPING(51, wd0_stfall),
+	MT6375_IRQ_MAPPING(52, wd0_strise),
+
+	MT6375_IRQ_MAPPING(36, hidet_cc1),
+	MT6375_IRQ_MAPPING(37, hidet_cc2),
+
+	MT6375_IRQ_MAPPING(24, fod_done),
+	MT6375_IRQ_MAPPING(25, fod_ov),
+	MT6375_IRQ_MAPPING(31, fod_dischgf),
+
+	MT6375_IRQ_MAPPING(20, ctd),
+};
+
+static int mt6375_alert_vendor_defined_handler(struct tcpc_device *tcpc)
+{
+	int ret, i, irqnum, irqbit;
+	u8 alert[MT6375_VEND_INT_NUM];
+	u8 mask[MT6375_VEND_INT_NUM];
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	ret = mt6375_bulk_read(ddata, MT6375_REG_MTINT1, alert,
+			       MT6375_VEND_INT_NUM);
+	if (ret < 0)
+		return ret;
+	ret = mt6375_bulk_read(ddata, MT6375_REG_MTMASK1, mask,
+			       MT6375_VEND_INT_NUM);
+	if (ret < 0)
+		return ret;
+
+	for (i = 0; i < MT6375_VEND_INT_NUM; i++) {
+		if (!alert[i])
+			continue;
+		MT6375_DBGINFO("vend_alert[%d]=alert,mask(0x%02X,0x%02X)\n",
+			       i + 1, alert[i], mask[i]);
+		alert[i] &= mask[i];
+	}
+
+	mt6375_vend_alert_status_clear(ddata, alert);
+
+	for (i = 0; i < ARRAY_SIZE(mt6375_vend_irq_mapping_tbl); i++) {
+		irqnum = mt6375_vend_irq_mapping_tbl[i].num / 8;
+		if (irqnum >= MT6375_VEND_INT_NUM)
+			continue;
+		alert[irqnum] &= mask[irqnum];
+		irqbit = mt6375_vend_irq_mapping_tbl[i].num % 8;
+		if (alert[irqnum] & (1 << irqbit))
+			mt6375_vend_irq_mapping_tbl[i].hdlr(ddata);
+	}
+	return 0;
+}
+
+static int mt6375_set_auto_dischg_discnt(struct tcpc_device *tcpc, bool en)
+{
+	u8 mask = TCPC_V10_REG_VBUS_MONITOR | TCPC_V10_REG_AUTO_DISCHG_DISCNT;
+	u8 val = en ? TCPC_V10_REG_AUTO_DISCHG_DISCNT
+		    : TCPC_V10_REG_VBUS_MONITOR;
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+	int ret = 0;
+
+	MT6375_INFO("%s en=%d\n", __func__, en);
+	if (en) {
+		ret |= mt6375_update_bits(ddata, TCPC_V10_REG_POWER_CTRL,
+					  TCPC_V10_REG_VBUS_MONITOR, 0);
+		ret |= mt6375_update_bits(ddata, TCPC_V10_REG_POWER_CTRL,
+					  TCPC_V10_REG_AUTO_DISCHG_DISCNT,
+					  TCPC_V10_REG_AUTO_DISCHG_DISCNT);
+		return ret;
+	}
+	return mt6375_update_bits(ddata, TCPC_V10_REG_POWER_CTRL, mask, val);
+}
+
+static int mt6375_get_vbus_voltage(struct tcpc_device *tcpc, u32 *vbus)
+{
+	int ret;
+	u16 data;
+	struct mt6375_tcpc_data *ddata = tcpc_get_dev_data(tcpc);
+
+	ret = mt6375_read16(ddata, TCPC_V10_REG_VBUS_VOLTAGE_L, &data);
+	if (ret < 0)
+		return ret;
+	/* TODO: Please re-write it */
+	*vbus = (data & 0x3FF) * 25;
+	pr_info("%s 0x%04x, %dmV\n", __func__, data, *vbus);
+	return 0;
+}
+
+static struct tcpc_ops mt6375_tcpc_ops = {
+	.init = mt6375_tcpc_init,
+	.init_alert_mask = mt6375_init_mask,
+	.alert_status_clear = mt6375_alert_status_clear,
+	.fault_status_clear = mt6375_fault_status_clear,
+	.get_alert_mask = mt6375_get_alert_mask,
+	.set_alert_mask = mt6375_set_alert_mask,
+	.get_alert_status = mt6375_get_alert_status,
+	.get_power_status = mt6375_get_power_status,
+	.get_fault_status = mt6375_get_fault_status,
+	.get_cc = mt6375_get_cc,
+	.set_cc = mt6375_set_cc,
+	.set_polarity = mt6375_set_polarity,
+	.set_low_rp_duty = mt6375_set_low_rp_duty,
+	.set_vconn = mt6375_set_vconn,
+	.deinit = mt6375_tcpc_deinit,
+	.set_watchdog = mt6375_set_watchdog,
+	.alert_vendor_defined_handler = mt6375_alert_vendor_defined_handler,
+	.set_auto_dischg_discnt = mt6375_set_auto_dischg_discnt,
+	.get_vbus_voltage = mt6375_get_vbus_voltage,
+
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
+	.is_vsafe0v = mt6375_is_vsafe0v,
+#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
+
+#if CONFIG_TCPC_LOW_POWER_MODE
+	.is_low_power_mode = mt6375_is_low_power_mode,
+	.set_low_power_mode = mt6375_set_low_power_mode,
+#endif	/* CONFIG_TCPC_LOW_POWER_MODE */
+
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
+	.set_msg_header = mt6375_set_msg_header,
+	.set_rx_enable = mt6375_set_rx_enable,
+	.protocol_reset = mt6375_protocol_reset,
+	.get_message = mt6375_get_message,
+	.transmit = mt6375_transmit,
+	.set_bist_test_mode = mt6375_set_bist_test_mode,
+	.set_bist_carrier_mode = mt6375_set_bist_carrier_mode,
+#endif	/* CONFIG_USB_POWER_DELIVERY */
+
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
+	.retransmit = mt6375_retransmit,
+#endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
+
+	.set_cc_hidet = mt6375_set_cc_hidet,
+
+#if CONFIG_WATER_DETECTION
+	.is_water_detected = mt6375_is_water_detected,
+	.set_water_protection = mt6375_set_water_protection,
+#if CONFIG_WD_POLLING_ONLY
+	.set_usbid_polling = mt6375_set_wd_polling,
+#endif /* CONFIG_WD_POLLING_ONLY */
+#endif /* CONFIG_WATER_DETECTION */
+
+	.set_floating_ground = mt6375_set_floating_ground,
+	.set_otp_fwen = mt6375_enable_typec_otp_fwen,
+	.set_force_discharge = mt6375_set_force_discharge,
+};
+
+static void mt6375_irq_work_handler(struct kthread_work *work)
+{
+	struct mt6375_tcpc_data *ddata = container_of(work,
+						      struct mt6375_tcpc_data,
+						      irq_work);
+	int ret = 0;
+	u8 data = 0;
+
+	MT6375_DBGINFO("++\n");
+	reinit_completion(&ddata->tcpc->alert_done);
+
+	tcpci_lock_typec(ddata->tcpc);
+	atomic_inc(&ddata->tcpc->suspend_pending);
+
+	do {
+		ret = tcpci_alert(ddata->tcpc);
+		if (ret < 0)
+			break;
+		ret = mt6375_read8(ddata, 0x1df, &data);
+		if (ret < 0)
+			break;
+		MT6375_DBGINFO("data = %x\n", data);
+		if (data & 0x01) {
+			ret = mt6375_write8(ddata, 0x1df, 0x01);
+			if (ret < 0)
+				break;
+		} else
+			break;
+	} while (1);
+
+	atomic_dec_if_positive(&ddata->tcpc->suspend_pending);
+	tcpci_unlock_typec(ddata->tcpc);
+	complete(&ddata->tcpc->alert_done);
+	enable_irq(ddata->irq);
+	pm_relax(ddata->dev);
+	MT6375_DBGINFO("--\n");
+}
+
+static irqreturn_t mt6375_pd_evt_handler(int irq, void *data)
+{
+	struct mt6375_tcpc_data *ddata = data;
+
+	MT6375_DBGINFO("++\n");
+	pm_stay_awake(ddata->dev);
+	disable_irq_nosync(ddata->irq);
+	kthread_queue_work(&ddata->irq_worker, &ddata->irq_work);
+	return IRQ_HANDLED;
+}
+
+static int mt6375_tcpc_init_irq(struct mt6375_tcpc_data *ddata)
+{
+	int ret;
+	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
+
+	dev_info(ddata->dev, "%s\n", __func__);
+	/* Mask all alerts & clear them */
+	mt6375_bulk_write(ddata, MT6375_REG_MTMASK1, mt6375_vend_alert_maskall,
+			  ARRAY_SIZE(mt6375_vend_alert_maskall));
+	mt6375_bulk_write(ddata, MT6375_REG_MTINT1, mt6375_vend_alert_clearall,
+			  ARRAY_SIZE(mt6375_vend_alert_clearall));
+	mt6375_write16(ddata, TCPC_V10_REG_ALERT_MASK, 0);
+	mt6375_write16(ddata, TCPC_V10_REG_ALERT, 0xFFFF);
+
+	kthread_init_worker(&ddata->irq_worker);
+	ddata->irq_worker_task = kthread_run(kthread_worker_fn,
+					     &ddata->irq_worker, "%s",
+					     ddata->desc->name);
+	if (IS_ERR(ddata->irq_worker_task)) {
+		dev_err(ddata->dev, "%s create tcpc task fail\n", __func__);
+		return -EINVAL;
+	}
+	sched_setscheduler(ddata->irq_worker_task, SCHED_FIFO, &param);
+	kthread_init_work(&ddata->irq_work, mt6375_irq_work_handler);
+
+	ret = platform_get_irq_byname(to_platform_device(ddata->dev), "pd_evt");
+	if (ret < 0) {
+		dev_err(ddata->dev, "failed to get irq pd_evt\n");
+		return ret;
+	}
+	ddata->irq = ret;
+	ret = devm_request_threaded_irq(ddata->dev, ret, NULL,
+					mt6375_pd_evt_handler, IRQF_ONESHOT |
+					IRQF_NO_SUSPEND, dev_name(ddata->dev), ddata);
+	if (ret < 0) {
+		dev_err(ddata->dev, "failed to request irq %d\n", ddata->irq);
+		return ret;
+	}
+	return 0;
+}
+
+static int mt6375_register_tcpcdev(struct mt6375_tcpc_data *ddata)
+{
+	struct device_node *boot_np, *np = ddata->dev->of_node;
+	struct tcpc_desc *desc = ddata->desc;
+	const struct {
+		u32 size;
+		u32 tag;
+		u32 boot_mode;
+		u32 boot_type;
+	} *tag;
+
+	ddata->tcpc = tcpc_device_register(ddata->dev, ddata->desc,
+					  &mt6375_tcpc_ops, ddata);
+	if (IS_ERR(ddata->tcpc))
+		return -EINVAL;
+
+	/* Init tcpc_flags */
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
+	ddata->tcpc->tcpc_flags |= TCPC_FLAGS_RETRY_CRC_DISCARD;
+#endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
+#if CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
+	ddata->tcpc->tcpc_flags |= TCPC_FLAGS_LPM_WAKEUP_WATCHDOG;
+#endif	/* CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG */
+	ddata->tcpc->tcpc_flags |= TCPC_FLAGS_DISABLE_LEGACY;
+#if CONFIG_USB_PD_REV30
+	ddata->tcpc->tcpc_flags |= TCPC_FLAGS_PD_REV30;
+#endif	/* CONFIG_USB_PD_REV30 */
+	ddata->tcpc->tcpc_flags |= TCPC_FLAGS_WATCHDOG_EN;
+
+	if (desc->en_wd)
+		ddata->tcpc->tcpc_flags |= TCPC_FLAGS_WATER_DETECTION;
+	if (desc->en_wd_sbu_polling)
+		ddata->tcpc->tcpc_flags |= TCPC_FLAGS_SBU_POLLING;
+	if (desc->en_wd_polling_only)
+		ddata->tcpc->tcpc_flags |= TCPC_FLAGS_WD_POLLING_ONLY;
+	if (desc->en_ctd)
+		ddata->tcpc->tcpc_flags |= TCPC_FLAGS_CABLE_TYPE_DETECTION;
+	if (desc->en_fod)
+		ddata->tcpc->tcpc_flags |= TCPC_FLAGS_FOREIGN_OBJECT_DETECTION;
+	if (desc->en_typec_otp)
+		ddata->tcpc->tcpc_flags |= TCPC_FLAGS_TYPEC_OTP;
+	if (desc->en_floatgnd)
+		ddata->tcpc->tcpc_flags |= TCPC_FLAGS_FLOATING_GROUND;
+
+	/* mediatek boot mode */
+	boot_np = of_parse_phandle(np, "boot_mode", 0);
+	if (!boot_np) {
+		dev_err(ddata->dev, "failed to get bootmode phandle\n");
+		return -ENODEV;
+	}
+	tag = of_get_property(boot_np, "atag,boot", NULL);
+	if (!tag) {
+		dev_err(ddata->dev, "failed to get atag,boot\n");
+		return -EINVAL;
+	}
+	dev_info(ddata->dev, "sz:0x%x tag:0x%x mode:0x%x type:0x%x\n",
+		 tag->size, tag->tag, tag->boot_mode, tag->boot_type);
+	ddata->tcpc->bootmode = tag->boot_mode;
+
+	if (ddata->tcpc->tcpc_flags & TCPC_FLAGS_PD_REV30)
+		dev_info(ddata->dev, "%s PD REV30\n", __func__);
+	else
+		dev_info(ddata->dev, "%s PD REV20\n", __func__);
+
+	return 0;
+}
+
+static int mt6375_parse_dt(struct mt6375_tcpc_data *ddata)
+{
+	struct tcpc_desc *desc = ddata->desc;
+	struct device *dev = ddata->dev;
+	u32 val;
+	int i;
+	const struct {
+		const char *name;
+		bool *val_ptr;
+	} tcpc_props_bool[] = {
+		{ "tcpc,en_wd", &desc->en_wd },
+		{ "tcpc,en_wd_sbu_polling", &desc->en_wd_sbu_polling },
+		{ "tcpc,en_wd_polling_only", &desc->en_wd_polling_only },
+		{ "tcpc,en_ctd", &desc->en_ctd },
+		{ "tcpc,en_fod", &desc->en_fod },
+		{ "tcpc,en_typec_otp", &desc->en_typec_otp },
+		{ "tcpc,en_floatgnd", &desc->en_floatgnd },
+	};
+	const struct {
+		const char *name;
+		u32 *val_ptr;
+	} tcpc_props_u32[] = {
+		{ "wd,sbu_calib_init", &desc->wd_sbu_calib_init },
+		{ "wd,sbu_pl_bound", &desc->wd_sbu_pl_bound },
+		{ "wd,sbu_pl_lbound_c2c", &desc->wd_sbu_pl_lbound_c2c },
+		{ "wd,sbu_pl_ubound_c2c", &desc->wd_sbu_pl_ubound_c2c },
+		{ "wd,sbu_ph_auddev", &desc->wd_sbu_ph_auddev },
+		{ "wd,sbu_ph_lbound", &desc->wd_sbu_ph_lbound },
+		{ "wd,sbu_ph_lbound1_c2c", &desc->wd_sbu_ph_lbound1_c2c },
+		{ "wd,sbu_ph_ubound1_c2c", &desc->wd_sbu_ph_ubound1_c2c },
+		{ "wd,sbu_ph_ubound2_c2c", &desc->wd_sbu_ph_ubound2_c2c },
+		{ "wd,sbu_aud_ubound", &desc->wd_sbu_aud_ubound },
+	};
+
+	memcpy(desc, &def_tcpc_desc, sizeof(*desc));
+
+	device_property_read_string(dev, "tcpc,name", &desc->name);
+
+	if (!device_property_read_u32(dev, "tcpc,role_def", &val) &&
+		val < TYPEC_ROLE_NR)
+		desc->role_def = val;
+
+	if (!device_property_read_u32(dev, "tcpc,rp_level", &val)) {
+		switch (val) {
+		case 0: /* RP Default */
+			desc->rp_lvl = TYPEC_CC_RP_DFT;
+			break;
+		case 1: /* RP 1.5V */
+			desc->rp_lvl = TYPEC_CC_RP_1_5;
+			break;
+		case 2: /* RP 3.0V */
+			desc->rp_lvl = TYPEC_CC_RP_3_0;
+			break;
+		default:
+			break;
+		}
+	}
+
+#if CONFIG_TCPC_VCONN_SUPPLY_MODE
+	if (!device_property_read_u32(dev, "tcpc,vconn_supply", &val) &&
+		val < TCPC_VCONN_SUPPLY_NR)
+		desc->vconn_supply = val;
+#endif	/* CONFIG_TCPC_VCONN_SUPPLY_MODE */
+
+	for (i = 0; i < ARRAY_SIZE(tcpc_props_bool); i++) {
+		*tcpc_props_bool[i].val_ptr =
+			device_property_read_bool(dev, tcpc_props_bool[i].name);
+			dev_info(dev, "props[%s] = %d\n",
+				 tcpc_props_bool[i].name,
+				 *tcpc_props_bool[i].val_ptr);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(tcpc_props_u32); i++) {
+		if (device_property_read_u32(dev, tcpc_props_u32[i].name,
+					     tcpc_props_u32[i].val_ptr))
+			dev_notice(dev, "failed to parse props[%s]\n",
+				tcpc_props_u32[i].name);
+		else
+			dev_info(dev, "props[%s] = %d\n",
+				 tcpc_props_u32[i].name,
+				 *tcpc_props_u32[i].val_ptr);
+	}
+
+	ddata->desc = desc;
+	return 0;
+}
+
+static int mt6375_check_revision(struct mt6375_tcpc_data *ddata)
+{
+	int ret;
+	u16 id;
+
+	ret = mt6375_read16(ddata, TCPC_V10_REG_VID, &id);
+	if (ret < 0) {
+		dev_err(ddata->dev, "failed to read vid(%d)\n", ret);
+		return ret;
+	}
+	if (id != MT6375_VID) {
+		dev_err(ddata->dev, "incorrect vid(0x%04X)\n", id);
+		return -ENODEV;
+	}
+
+	ret = mt6375_read16(ddata, TCPC_V10_REG_PID, &id);
+	if (ret < 0) {
+		dev_err(ddata->dev, "failed to read pid(%d)\n", ret);
+		return ret;
+	}
+	if (id != MT6375_PID) {
+		dev_err(ddata->dev, "incorrect pid(0x%04X)\n", id);
+		return -ENODEV;
+	}
+
+	ret = mt6375_read16(ddata, TCPC_V10_REG_DID, &id);
+	if (ret < 0) {
+		dev_err(ddata->dev, "failed to read did(%d)\n", ret);
+		return ret;
+	}
+	dev_info(ddata->dev, "did = 0x%04X\n", id);
+	ddata->did = id;
+	return 0;
+}
+
+static int mt6375_tcpc_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct mt6375_tcpc_data *ddata;
+
+	dev_info(&pdev->dev, "%s\n", __func__);
+
+	ddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);
+	if (!ddata)
+		return -ENOMEM;
+	ddata->dev = &pdev->dev;
+	platform_set_drvdata(pdev, ddata);
+
+	ddata->rmap = dev_get_regmap(ddata->dev->parent, NULL);
+	if (!ddata->rmap) {
+		dev_err(ddata->dev, "failed to get regmap\n");
+		return -ENODEV;
+	}
+
+	ret = mt6375_check_revision(ddata);
+	if (ret < 0) {
+		dev_err(ddata->dev, "failed to check revision(%d)\n", ret);
+		return ret;
+	}
+
+	ddata->desc = devm_kzalloc(ddata->dev, sizeof(ddata->desc), GFP_KERNEL);
+	if (!ddata->desc)
+		return -ENOMEM;
+	ret = mt6375_parse_dt(ddata);
+	if (ret < 0) {
+		dev_err(ddata->dev, "failed to parse dt(%d)\n", ret);
+		return ret;
+	}
+
+	atomic_set(&ddata->wd_protect_rty, CONFIG_WD_PROTECT_RETRY_COUNT);
+#if CONFIG_WATER_DETECTION
+#if CONFIG_WD_POLLING_ONLY
+	INIT_DELAYED_WORK(&ddata->wd_poll_dwork, mt6375_wd_poll_dwork_handler);
+#endif /* CONFIG_WD_POLLING_ONLY */
+#endif /* CONFIG_WATER_DETECTION */
+	INIT_DELAYED_WORK(&ddata->hidet_dwork, mt6375_hidet_dwork_handler);
+	alarm_init(&ddata->hidet_debtimer, ALARM_REALTIME,
+		   mt6375_hidet_debtimer_handler);
+
+	ddata->adc_iio = devm_iio_channel_get_all(ddata->dev);
+	if (IS_ERR(ddata->adc_iio)) {
+		ret = PTR_ERR(ddata->adc_iio);
+		dev_err(ddata->dev, "failed to get adc iio(%d)\n", ret);
+		return ret;
+	}
+
+	ret = mt6375_register_tcpcdev(ddata);
+	if (ret < 0) {
+		dev_err(ddata->dev, "failed to register tcpcdev(%d)\n", ret);
+		return ret;
+	}
+
+	/* Must init before sw reset */
+	ret = mt6375_init_fod_ctd(ddata);
+	if (ret < 0) {
+		dev_err(ddata->dev, "failed to init fod ctd(%d)\n", ret);
+		goto err;
+	}
+
+	ret = mt6375_sw_reset(ddata);
+	if (ret < 0) {
+		dev_err(ddata->dev, "failed to reset sw(%d)\n", ret);
+		goto err;
+	}
+
+	/* disable fod */
+	if (!ddata->desc->en_fod) {
+		ret = mt6375_update_bits(ddata, 0xcf, 0x40, 0x00);
+		if (ret < 0) {
+			dev_err(ddata->dev, "failed to disable fod\n");
+			goto err;
+		}
+	}
+
+	ret = mt6375_tcpc_init_irq(ddata);
+	if (ret < 0) {
+		dev_err(ddata->dev, "failed to init irq\n");
+		goto err;
+	}
+
+	device_init_wakeup(ddata->dev, true);
+	dev_info(ddata->dev, "%s successfully!\n", __func__);
+	return 0;
+err:
+	tcpc_device_unregister(ddata->dev, ddata->tcpc);
+	return ret;
+}
+
+static void mt6375_shutdown(struct platform_device *pdev)
+{
+	struct mt6375_tcpc_data *ddata = platform_get_drvdata(pdev);
+
+	if (ddata->irq) {
+		disable_irq(ddata->irq);
+		kthread_flush_worker(&ddata->irq_worker);
+		kthread_stop(ddata->irq_worker_task);
+	}
+
+	alarm_cancel(&ddata->hidet_debtimer);
+	cancel_delayed_work_sync(&ddata->hidet_dwork);
+#if CONFIG_WATER_DETECTION
+#if CONFIG_WD_POLLING_ONLY
+	if (ddata->desc->en_wd_polling_only)
+		cancel_delayed_work_sync(&ddata->wd_poll_dwork);
+#endif /* CONFIG_WD_POLLING_ONLY */
+#endif /* CONFIG_WATER_DETECTION */
+
+	tcpm_shutdown(ddata->tcpc);
+}
+
+static const struct of_device_id __maybe_unused mt6375_tcpc_of_match[] = {
+	{ .compatible = "mediatek,mt6375-tcpc", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, mt6375_tcpc_of_match);
+
+static struct platform_driver mt6375_tcpc_driver = {
+	.probe = mt6375_tcpc_probe,
+	.shutdown = mt6375_shutdown,
+	.driver = {
+		.name = "mt6375-tcpc",
+		.of_match_table = of_match_ptr(mt6375_tcpc_of_match),
+	},
+};
+module_platform_driver(mt6375_tcpc_driver);
+
+MODULE_AUTHOR("Gene Chen <gene_chen@richtek.com>");
+MODULE_DESCRIPTION("MT6375 USB Type-C Port Controller Interface Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.0");
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpc_rt1711h.c b/drivers/misc/mediatek/typec/tcpc/tcpc_rt1711h.c
index eac77d6..5ff4006 100644
--- a/drivers/misc/mediatek/typec/tcpc/tcpc_rt1711h.c
+++ b/drivers/misc/mediatek/typec/tcpc/tcpc_rt1711h.c
@@ -1,16 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * Richtek RT1711H Type-C Port Control Driver
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include <linux/init.h>
@@ -35,15 +25,14 @@
 #include "inc/tcpci.h"
 #include "inc/rt1711h.h"
 
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 #include <mt-plat/rt-regmap.h>
 #endif /* CONFIG_RT_REGMAP */
 
-#if 1 /*  #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))*/
 #include <linux/sched/rt.h>
-#endif /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)) */
 
 /* #define DEBUG_GPIO	66 */
+#define DEBUG_GPIO 0
 
 #define RT1711H_DRV_VERSION	"2.0.5_MTK"
 
@@ -52,7 +41,7 @@
 struct rt1711_chip {
 	struct i2c_client *client;
 	struct device *dev;
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	struct rt_regmap_device *m_dev;
 #endif /* CONFIG_RT_REGMAP */
 	struct semaphore io_lock;
@@ -72,7 +61,7 @@ struct rt1711_chip {
 	int chip_id;
 };
 
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 RT_REG_DECL(TCPC_V10_REG_VID, 2, RT_NORMAL_WR_ONCE, {});
 RT_REG_DECL(TCPC_V10_REG_PID, 2, RT_NORMAL_WR_ONCE, {});
 RT_REG_DECL(TCPC_V10_REG_DID, 2, RT_NORMAL_WR_ONCE, {});
@@ -228,7 +217,7 @@ static int rt1711_reg_read(struct i2c_client *i2c, u8 reg)
 	u8 val = 0;
 	int ret = 0;
 
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	ret = rt_regmap_block_read(chip->m_dev, reg, 1, &val);
 #else
 	ret = rt1711_read_device(chip->client, reg, 1, &val);
@@ -245,7 +234,7 @@ static int rt1711_reg_write(struct i2c_client *i2c, u8 reg, const u8 data)
 	struct rt1711_chip *chip = i2c_get_clientdata(i2c);
 	int ret = 0;
 
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	ret = rt_regmap_block_write(chip->m_dev, reg, 1, &data);
 #else
 	ret = rt1711_write_device(chip->client, reg, 1, &data);
@@ -260,11 +249,11 @@ static int rt1711_block_read(struct i2c_client *i2c,
 {
 	struct rt1711_chip *chip = i2c_get_clientdata(i2c);
 	int ret = 0;
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	ret = rt_regmap_block_read(chip->m_dev, reg, len, dst);
 #else
 	ret = rt1711_read_device(chip->client, reg, len, dst);
-#endif /* #ifdef CONFIG_RT_REGMAP */
+#endif /* #if IS_ENABLED(CONFIG_RT_REGMAP) */
 	if (ret < 0)
 		dev_err(chip->dev, "rt1711 block read fail\n");
 	return ret;
@@ -275,11 +264,11 @@ static int rt1711_block_write(struct i2c_client *i2c,
 {
 	struct rt1711_chip *chip = i2c_get_clientdata(i2c);
 	int ret = 0;
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	ret = rt_regmap_block_write(chip->m_dev, reg, len, src);
 #else
 	ret = rt1711_write_device(chip->client, reg, len, src);
-#endif /* #ifdef CONFIG_RT_REGMAP */
+#endif /* #if IS_ENABLED(CONFIG_RT_REGMAP) */
 	if (ret < 0)
 		dev_err(chip->dev, "rt1711 block write fail\n");
 	return ret;
@@ -341,7 +330,7 @@ static inline int rt1711_i2c_read16(
 	return data;
 }
 
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 static struct rt_regmap_fops rt1711_regmap_fops = {
 	.read_device = rt1711_read_device,
 	.write_device = rt1711_write_device,
@@ -350,7 +339,7 @@ static struct rt_regmap_fops rt1711_regmap_fops = {
 
 static int rt1711_regmap_init(struct rt1711_chip *chip)
 {
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	struct rt_regmap_properties *props;
 	char name[32];
 	int len;
@@ -389,7 +378,7 @@ static int rt1711_regmap_init(struct rt1711_chip *chip)
 
 static int rt1711_regmap_deinit(struct rt1711_chip *chip)
 {
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	rt_regmap_device_unregister(chip->m_dev);
 #endif
 	return 0;
@@ -398,13 +387,13 @@ static int rt1711_regmap_deinit(struct rt1711_chip *chip)
 static inline int rt1711_software_reset(struct tcpc_device *tcpc)
 {
 	int ret = rt1711_i2c_write8(tcpc, RT1711H_REG_SWRESET, 1);
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	struct rt1711_chip *chip = tcpc_get_dev_data(tcpc);
 #endif /* CONFIG_RT_REGMAP */
 
 	if (ret < 0)
 		return ret;
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	rt_regmap_cache_reload(chip->m_dev);
 #endif /* CONFIG_RT_REGMAP */
 	usleep_range(1000, 2000);
@@ -461,7 +450,7 @@ static int rt1711_init_alert_mask(struct tcpc_device *tcpc)
 
 	mask = TCPC_V10_REG_ALERT_CC_STATUS | TCPC_V10_REG_ALERT_POWER_STATUS;
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	/* Need to handle RX overflow */
 	mask |= TCPC_V10_REG_ALERT_TX_SUCCESS | TCPC_V10_REG_ALERT_TX_DISCARDED
 			| TCPC_V10_REG_ALERT_TX_FAILED
@@ -496,19 +485,19 @@ static int rt1711_init_fault_mask(struct tcpc_device *tcpc)
 static int rt1711_init_rt_mask(struct tcpc_device *tcpc)
 {
 	uint8_t rt_mask = 0;
-#ifdef CONFIG_TCPC_WATCHDOG_EN
+#if CONFIG_TCPC_WATCHDOG_EN
 	rt_mask |= RT1711H_REG_M_WATCHDOG;
 #endif /* CONFIG_TCPC_WATCHDOG_EN */
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	rt_mask |= RT1711H_REG_M_VBUS_80;
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 
-#ifdef CONFIG_TYPEC_CAP_RA_DETACH
+#if CONFIG_TYPEC_CAP_RA_DETACH
 	if (tcpc->tcpc_flags & TCPC_FLAGS_CHECK_RA_DETACHE)
 		rt_mask |= RT1711H_REG_M_RA_DETACH;
 #endif /* CONFIG_TYPEC_CAP_RA_DETACH */
 
-#ifdef CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
+#if CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
 	if (tcpc->tcpc_flags & TCPC_FLAGS_LPM_WAKEUP_WATCHDOG)
 		rt_mask |= RT1711H_REG_M_WAKEUP;
 #endif	/* CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG */
@@ -541,7 +530,7 @@ static void rt1711_irq_work_handler(struct kthread_work *work)
 	down(&chip->suspend_lock);
 	tcpci_lock_typec(chip->tcpc);
 
-#ifdef DEBUG_GPIO
+#if DEBUG_GPIO
 	gpio_set_value(DEBUG_GPIO, 1);
 #endif
 
@@ -555,7 +544,7 @@ static void rt1711_irq_work_handler(struct kthread_work *work)
 	tcpci_unlock_typec(chip->tcpc);
 	up(&chip->suspend_lock);
 
-#ifdef DEBUG_GPIO
+#if DEBUG_GPIO
 	gpio_set_value(DEBUG_GPIO, 1);
 #endif
 }
@@ -575,7 +564,7 @@ static irqreturn_t rt1711_intr_handler(int irq, void *data)
 
 	__pm_wakeup_event(chip->irq_wake_lock, RT1711H_IRQ_WAKE_TIME);
 
-#ifdef DEBUG_GPIO
+#if DEBUG_GPIO
 	gpio_set_value(DEBUG_GPIO, 0);
 #endif
 	kthread_queue_work(&chip->irq_worker, &chip->irq_work);
@@ -605,7 +594,7 @@ static int rt1711_init_alert(struct tcpc_device *tcpc)
 				chip->tcpc_desc->name, chip->irq_gpio);
 
 	ret = devm_gpio_request(chip->dev, chip->irq_gpio, name);
-#ifdef DEBUG_GPIO
+#if DEBUG_GPIO
 	gpio_request(DEBUG_GPIO, "debug_latency_pin");
 	gpio_direction_output(DEBUG_GPIO, 1);
 #endif
@@ -662,7 +651,7 @@ int rt1711_alert_status_clear(struct tcpc_device *tcpc, uint32_t mask)
 	int ret;
 	uint16_t mask_t1;
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	uint8_t mask_t2;
 #endif
 
@@ -674,7 +663,7 @@ int rt1711_alert_status_clear(struct tcpc_device *tcpc, uint32_t mask)
 			return ret;
 	}
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	mask_t2 = mask >> 16;
 	if (mask_t2) {
 		ret = rt1711_i2c_write8(tcpc, RT1711H_REG_RT_INT, mask_t2);
@@ -690,7 +679,7 @@ static int rt1711h_set_clock_gating(struct tcpc_device *tcpc, bool en)
 {
 	int ret = 0;
 
-#ifdef CONFIG_TCPC_CLOCK_GATING
+#if CONFIG_TCPC_CLOCK_GATING
 	int i = 0;
 	uint8_t clk2 = RT1711H_REG_CLK_DIV_600K_EN
 		| RT1711H_REG_CLK_DIV_300K_EN | RT1711H_REG_CLK_CK_300K_EN;
@@ -723,8 +712,8 @@ static inline int rt1711h_init_cc_params(
 {
 	int rv = 0;
 
-#ifdef CONFIG_USB_POWER_DELIVERY
-#ifdef CONFIG_USB_PD_SNK_DFT_NO_GOOD_CRC
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
+#if CONFIG_USB_PD_SNK_DFT_NO_GOOD_CRC
 	uint8_t en, sel;
 	struct rt1711_chip *chip = tcpc_get_dev_data(tcpc);
 
@@ -762,7 +751,7 @@ static int rt1711_tcpc_init(struct tcpc_device *tcpc, bool sw_reset)
 			return ret;
 	}
 
-#ifdef CONFIG_TCPC_I2CRST_EN
+#if CONFIG_TCPC_I2CRST_EN
 	rt1711_i2c_write8(tcpc,
 		RT1711H_REG_I2CRST_CTRL,
 		RT1711H_REG_I2CRST_SET(true, 0x0f));
@@ -848,7 +837,7 @@ int rt1711_fault_status_clear(struct tcpc_device *tcpc, uint8_t status)
 int rt1711_get_alert_mask(struct tcpc_device *tcpc, uint32_t *mask)
 {
 	int ret;
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	uint8_t v2;
 #endif
 
@@ -858,7 +847,7 @@ int rt1711_get_alert_mask(struct tcpc_device *tcpc, uint32_t *mask)
 
 	*mask = (uint16_t) ret;
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	ret = rt1711_i2c_read8(tcpc, RT1711H_REG_RT_MASK);
 	if (ret < 0)
 		return ret;
@@ -873,7 +862,7 @@ int rt1711_get_alert_mask(struct tcpc_device *tcpc, uint32_t *mask)
 int rt1711_get_alert_status(struct tcpc_device *tcpc, uint32_t *alert)
 {
 	int ret;
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	uint8_t v2;
 #endif
 
@@ -883,7 +872,7 @@ int rt1711_get_alert_status(struct tcpc_device *tcpc, uint32_t *alert)
 
 	*alert = (uint16_t) ret;
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	ret = rt1711_i2c_read8(tcpc, RT1711H_REG_RT_INT);
 	if (ret < 0)
 		return ret;
@@ -909,7 +898,7 @@ static int rt1711_get_power_status(
 	if (ret & TCPC_V10_REG_POWER_STATUS_VBUS_PRES)
 		*pwr_status |= TCPC_REG_POWER_STATUS_VBUS_PRES;
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	ret = rt1711_i2c_read8(tcpc, RT1711H_REG_RT_STATUS);
 	if (ret < 0)
 		return ret;
@@ -958,10 +947,7 @@ static int rt1711_get_cc(struct tcpc_device *tcpc, int *cc1, int *cc2)
 	if (act_as_drp) {
 		act_as_sink = TCPC_V10_REG_CC_STATUS_DRP_RESULT(status);
 	} else {
-		if (tcpc->typec_polarity)
-			cc_role = TCPC_V10_REG_CC_STATUS_CC2(role_ctrl);
-		else
-			cc_role = TCPC_V10_REG_CC_STATUS_CC1(role_ctrl);
+		cc_role =  TCPC_V10_REG_CC_STATUS_CC1(role_ctrl);
 		if (cc_role == TYPEC_CC_RP)
 			act_as_sink = false;
 		else
@@ -985,7 +971,7 @@ static int rt1711_get_cc(struct tcpc_device *tcpc, int *cc1, int *cc2)
 	return 0;
 }
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 static int rt1711_enable_vsafe0v_detect(
 	struct tcpc_device *tcpc, bool enable)
 {
@@ -1009,7 +995,7 @@ static int rt1711_set_cc(struct tcpc_device *tcpc, int pull)
 	uint8_t data;
 	int rp_lvl = TYPEC_CC_PULL_GET_RP_LVL(pull), pull1, pull2;
 
-	RT1711_INFO("pull = 0x%02X\n", pull);
+	RT1711_INFO("\n");
 	pull = TYPEC_CC_PULL_GET_RES(pull);
 	if (pull == TYPEC_CC_DRP) {
 		data = TCPC_V10_REG_ROLE_CTRL_RES_SET(
@@ -1019,20 +1005,22 @@ static int rt1711_set_cc(struct tcpc_device *tcpc, int pull)
 			tcpc, TCPC_V10_REG_ROLE_CTRL, data);
 
 		if (ret == 0) {
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 			rt1711_enable_vsafe0v_detect(tcpc, false);
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 			ret = rt1711_command(tcpc, TCPM_CMD_LOOK_CONNECTION);
 		}
 	} else {
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 		if (pull == TYPEC_CC_RD && tcpc->pd_wait_pr_swap_complete)
 			rt1711h_init_cc_params(tcpc, TYPEC_CC_VOLT_SNK_DFT);
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
 		pull1 = pull2 = pull;
 
-		if (pull == TYPEC_CC_RP && tcpc->typec_is_attached_src) {
+		if ((pull == TYPEC_CC_RP_DFT || pull == TYPEC_CC_RP_1_5 ||
+			pull == TYPEC_CC_RP_3_0) &&
+			tcpc->typec_is_attached_src) {
 			if (tcpc->typec_polarity)
 				pull1 = TYPEC_CC_OPEN;
 			else
@@ -1091,7 +1079,7 @@ static int rt1711_set_vconn(struct tcpc_device *tcpc, int enable)
 		RT1711H_REG_IDLE_SET(0, 1, enable ? 0 : 1, 0));
 }
 
-#ifdef CONFIG_TCPC_LOW_POWER_MODE
+#if CONFIG_TCPC_LOW_POWER_MODE
 static int rt1711_is_low_power_mode(struct tcpc_device *tcpc)
 {
 	int rv = rt1711_i2c_read8(tcpc, RT1711H_REG_BMC_CTRL);
@@ -1112,7 +1100,7 @@ static int rt1711_set_low_power_mode(
 		RT1711H_REG_IDLE_SET(0, 1, en ? 0 : 1, 0));
 	if (ret < 0)
 		return ret;
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	rt1711_enable_vsafe0v_detect(tcpc, !en);
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 	if (en) {
@@ -1121,7 +1109,7 @@ static int rt1711_set_low_power_mode(
 		if (pull & TYPEC_CC_RP)
 			data |= RT1711H_REG_BMCIO_LPRPRD;
 
-#ifdef CONFIG_TYPEC_CAP_NORP_SRC
+#if CONFIG_TYPEC_CAP_NORP_SRC
 		data |= RT1711H_REG_BMCIO_BG_EN | RT1711H_REG_VBUS_DET_EN;
 #endif
 	} else {
@@ -1133,7 +1121,7 @@ static int rt1711_set_low_power_mode(
 }
 #endif	/* CONFIG_TCPC_LOW_POWER_MODE */
 
-#ifdef CONFIG_TCPC_WATCHDOG_EN
+#if CONFIG_TCPC_WATCHDOG_EN
 int rt1711h_set_watchdog(struct tcpc_device *tcpc, bool en)
 {
 	uint8_t data = RT1711H_REG_WATCHDOG_CTRL_SET(en, 7);
@@ -1143,7 +1131,7 @@ int rt1711h_set_watchdog(struct tcpc_device *tcpc, bool en)
 }
 #endif	/* CONFIG_TCPC_WATCHDOG_EN */
 
-#ifdef CONFIG_TCPC_INTRST_EN
+#if CONFIG_TCPC_INTRST_EN
 int rt1711h_set_intrst(struct tcpc_device *tcpc, bool en)
 {
 	return rt1711_i2c_write8(tcpc,
@@ -1153,11 +1141,11 @@ int rt1711h_set_intrst(struct tcpc_device *tcpc, bool en)
 
 static int rt1711_tcpc_deinit(struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	struct rt1711_chip *chip = tcpc_get_dev_data(tcpc);
 #endif /* CONFIG_RT_REGMAP */
 
-#ifdef CONFIG_TCPC_SHUTDOWN_CC_DETACH
+#if CONFIG_TCPC_SHUTDOWN_CC_DETACH
 	rt1711_set_cc(tcpc, TYPEC_CC_DRP);
 	rt1711_set_cc(tcpc, TYPEC_CC_OPEN);
 
@@ -1171,14 +1159,14 @@ static int rt1711_tcpc_deinit(struct tcpc_device *tcpc)
 #else
 	rt1711_i2c_write8(tcpc, RT1711H_REG_SWRESET, 1);
 #endif	/* CONFIG_TCPC_SHUTDOWN_CC_DETACH */
-#ifdef CONFIG_RT_REGMAP
+#if IS_ENABLED(CONFIG_RT_REGMAP)
 	rt_regmap_cache_reload(chip->m_dev);
 #endif /* CONFIG_RT_REGMAP */
 
 	return 0;
 }
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 static int rt1711_set_msg_header(
 	struct tcpc_device *tcpc, uint8_t power_role, uint8_t data_role)
 {
@@ -1254,7 +1242,7 @@ static int rt1711_set_bist_carrier_mode(
 	return 0;
 }
 
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 static int rt1711_retransmit(struct tcpc_device *tcpc)
 {
 	return rt1711_i2c_write8(tcpc, TCPC_V10_REG_TRANSMIT,
@@ -1331,20 +1319,20 @@ static struct tcpc_ops rt1711_tcpc_ops = {
 	.set_vconn = rt1711_set_vconn,
 	.deinit = rt1711_tcpc_deinit,
 
-#ifdef CONFIG_TCPC_LOW_POWER_MODE
+#if CONFIG_TCPC_LOW_POWER_MODE
 	.is_low_power_mode = rt1711_is_low_power_mode,
 	.set_low_power_mode = rt1711_set_low_power_mode,
 #endif	/* CONFIG_TCPC_LOW_POWER_MODE */
 
-#ifdef CONFIG_TCPC_WATCHDOG_EN
+#if CONFIG_TCPC_WATCHDOG_EN
 	.set_watchdog = rt1711h_set_watchdog,
 #endif	/* CONFIG_TCPC_WATCHDOG_EN */
 
-#ifdef CONFIG_TCPC_INTRST_EN
+#if CONFIG_TCPC_INTRST_EN
 	.set_intrst = rt1711h_set_intrst,
 #endif	/* CONFIG_TCPC_INTRST_EN */
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	.set_msg_header = rt1711_set_msg_header,
 	.set_rx_enable = rt1711_set_rx_enable,
 	.protocol_reset = rt1711_protocol_reset,
@@ -1354,7 +1342,7 @@ static struct tcpc_ops rt1711_tcpc_ops = {
 	.set_bist_carrier_mode = rt1711_set_bist_carrier_mode,
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 	.retransmit = rt1711_retransmit,
 #endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
 };
@@ -1373,7 +1361,7 @@ static int rt_parse_dt(struct rt1711_chip *chip, struct device *dev)
 	}
 	dev->of_node = np;
 
-#if (!defined(CONFIG_MTK_GPIO) || defined(CONFIG_MTK_GPIOLIB_STAND))
+#if IS_ENABLED(CONFIG_MTK_GPIO) || IS_ENABLED(CONFIG_MTK_GPIOLIB_STAND)
 	ret = of_get_named_gpio(np, "rt1711pd,intr_gpio", 0);
 	if (ret < 0) {
 		pr_err("%s no intr_gpio info\n", __func__);
@@ -1402,7 +1390,7 @@ static void check_printk_performance(void)
 	u64 t1, t2;
 	u32 nsrem;
 
-#ifdef CONFIG_PD_DBG_INFO
+#if IS_ENABLED(CONFIG_PD_DBG_INFO)
 	for (i = 0; i < 10; i++) {
 		t1 = local_clock();
 		pd_dbg_info("%d\n", i);
@@ -1469,17 +1457,21 @@ static int rt1711_tcpcdev_init(struct rt1711_chip *chip, struct device *dev)
 
 	if (of_property_read_u32(np, "rt-tcpc,rp_level", &val) >= 0) {
 		switch (val) {
-		case TYPEC_RP_DFT:
-		case TYPEC_RP_1_5:
-		case TYPEC_RP_3_0:
-			desc->rp_lvl = val;
+		case 0: /* RP Default */
+			desc->rp_lvl = TYPEC_CC_RP_DFT;
+			break;
+		case 1: /* RP 1.5V */
+			desc->rp_lvl = TYPEC_CC_RP_1_5;
+			break;
+		case 2: /* RP 3.0V */
+			desc->rp_lvl = TYPEC_CC_RP_3_0;
 			break;
 		default:
 			break;
 		}
 	}
 
-#ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
+#if CONFIG_TCPC_VCONN_SUPPLY_MODE
 	if (of_property_read_u32(np, "rt-tcpc,vconn_supply", &val) >= 0) {
 		if (val >= TCPC_VCONN_SUPPLY_NR)
 			desc->vconn_supply = TCPC_VCONN_SUPPLY_ALWAYS;
@@ -1507,26 +1499,21 @@ static int rt1711_tcpcdev_init(struct rt1711_chip *chip, struct device *dev)
 
 	chip->tcpc = tcpc_device_register(dev,
 			desc, &rt1711_tcpc_ops, chip);
-	if (IS_ERR_OR_NULL(chip->tcpc))
+	if (IS_ERR(chip->tcpc))
 		return -EINVAL;
 
-#ifdef CONFIG_USB_PD_DISABLE_PE
-	chip->tcpc->disable_pe =
-			of_property_read_bool(np, "rt-tcpc,disable_pe");
-#endif	/* CONFIG_USB_PD_DISABLE_PE */
-
 	chip->tcpc->tcpc_flags = TCPC_FLAGS_LPM_WAKEUP_WATCHDOG |
 			TCPC_FLAGS_VCONN_SAFE5V_ONLY;
 
 	if (chip->chip_id > RT1711H_DID_B)
 		chip->tcpc->tcpc_flags |= TCPC_FLAGS_CHECK_RA_DETACHE;
 
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 	if (chip->chip_id > RT1715_DID_D)
 		chip->tcpc->tcpc_flags |= TCPC_FLAGS_RETRY_CRC_DISCARD;
 #endif  /* CONFIG_USB_PD_RETRY_CRC_DISCARD */
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	if (chip->chip_id >= RT1715_DID_D)
 		chip->tcpc->tcpc_flags |= TCPC_FLAGS_PD_REV30;
 
@@ -1677,7 +1664,7 @@ static int rt1711_i2c_remove(struct i2c_client *client)
 	return 0;
 }
 
-#ifdef CONFIG_PM
+#if CONFIG_PM
 static int rt1711_i2c_suspend(struct device *dev)
 {
 	struct rt1711_chip *chip;
@@ -1721,7 +1708,7 @@ static void rt1711_shutdown(struct i2c_client *client)
 	}
 }
 
-#ifdef CONFIG_PM_RUNTIME
+#if IS_ENABLED(CONFIG_PM_RUNTIME)
 static int rt1711_pm_suspend_runtime(struct device *device)
 {
 	dev_dbg(device, "pm_runtime: suspending...\n");
@@ -1733,19 +1720,19 @@ static int rt1711_pm_resume_runtime(struct device *device)
 	dev_dbg(device, "pm_runtime: resuming...\n");
 	return 0;
 }
-#endif /* #ifdef CONFIG_PM_RUNTIME */
+#endif /* CONFIG_PM_RUNTIME */
 
 static const struct dev_pm_ops rt1711_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(
 			rt1711_i2c_suspend,
 			rt1711_i2c_resume)
-#ifdef CONFIG_PM_RUNTIME
+#if IS_ENABLED(CONFIG_PM_RUNTIME)
 	SET_RUNTIME_PM_OPS(
 		rt1711_pm_suspend_runtime,
 		rt1711_pm_resume_runtime,
 		NULL
 	)
-#endif /* #ifdef CONFIG_PM_RUNTIME */
+#endif /* CONFIG_PM_RUNTIME */
 };
 #define RT1711_PM_OPS	(&rt1711_pm_ops)
 #else
diff --git a/./tcpc_rt5081.c b/drivers/misc/mediatek/typec/tcpc/tcpc_rt5081.c
new file mode 100644
index 0000000..91c8048
--- /dev/null
+++ b/drivers/misc/mediatek/typec/tcpc/tcpc_rt5081.c
@@ -0,0 +1,1687 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/semaphore.h>
+#include <linux/pm_runtime.h>
+#include <linux/workqueue.h>
+#include <linux/kthread.h>
+#include <linux/cpu.h>
+#include <linux/version.h>
+#include <linux/wakelock.h>
+
+#include "inc/pd_dbg_info.h"
+#include "inc/tcpci.h"
+#include "inc/rt5081.h"
+
+#if IS_ENABLED(CONFIG_RT_REGMAP)
+#include <mt-plat/rt-regmap.h>
+#endif /* CONFIG_RT_REGMAP */
+
+#include <linux/sched/rt.h>
+
+/* #define DEBUG_GPIO	66 */
+#define DEBUG_GPIO 0
+
+#define RT5081_DRV_VERSION	"2.0.1_MTK"
+
+#define RT5081_IRQ_WAKE_TIME	(500) /* ms */
+
+struct rt5081_chip {
+	struct i2c_client *client;
+	struct device *dev;
+#if IS_ENABLED(CONFIG_RT_REGMAP)
+	struct rt_regmap_device *m_dev;
+#endif /* CONFIG_RT_REGMAP */
+	struct semaphore io_lock;
+	struct semaphore suspend_lock;
+	struct tcpc_desc *tcpc_desc;
+	struct tcpc_device *tcpc;
+	struct kthread_worker irq_worker;
+	struct kthread_work irq_work;
+	struct task_struct *irq_worker_task;
+	struct wakeup_source *irq_wake_lock;
+
+	atomic_t poll_count;
+	struct delayed_work	poll_work;
+
+	int irq_gpio;
+	int irq;
+	int chip_id;
+};
+
+#if IS_ENABLED(CONFIG_RT_REGMAP)
+RT_REG_DECL(TCPC_V10_REG_VID, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_PID, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_DID, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TYPEC_REV, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_PD_REV, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_PDIF_REV, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_ALERT, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_ALERT_MASK, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_POWER_STATUS_MASK, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_FAULT_STATUS_MASK, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TCPC_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_ROLE_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_FAULT_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_POWER_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_CC_STATUS, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_POWER_STATUS, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_FAULT_STATUS, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_COMMAND, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_MSG_HDR_INFO, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_RX_DETECT, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_RX_BYTE_CNT, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_RX_BUF_FRAME_TYPE, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_RX_HDR, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_RX_DATA, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TRANSMIT, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TX_BYTE_CNT, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TX_HDR, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TX_DATA, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_PHY_CTRL1, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_PHY_CTRL3, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_CLK_CTRL2, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_CLK_CTRL3, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_BMC_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_BMCIO_RXDZSEL, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_RT_STATUS, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_RT_INT, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_RT_MASK, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_BMCIO_RXDZEN, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_IDLE_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_INTRST_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_WATCHDOG_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_I2CRST_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_SWRESET, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_TTCPC_FILTER, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_DRP_TOGGLE_CYCLE, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_DRP_DUTY_CTRL, 1, RT_VOLATILE, {});
+
+static const rt_register_map_t rt5081_chip_regmap[] = {
+	RT_REG(TCPC_V10_REG_VID),
+	RT_REG(TCPC_V10_REG_PID),
+	RT_REG(TCPC_V10_REG_DID),
+	RT_REG(TCPC_V10_REG_TYPEC_REV),
+	RT_REG(TCPC_V10_REG_PD_REV),
+	RT_REG(TCPC_V10_REG_PDIF_REV),
+	RT_REG(TCPC_V10_REG_ALERT),
+	RT_REG(TCPC_V10_REG_ALERT_MASK),
+	RT_REG(TCPC_V10_REG_POWER_STATUS_MASK),
+	RT_REG(TCPC_V10_REG_FAULT_STATUS_MASK),
+	RT_REG(TCPC_V10_REG_TCPC_CTRL),
+	RT_REG(TCPC_V10_REG_ROLE_CTRL),
+	RT_REG(TCPC_V10_REG_FAULT_CTRL),
+	RT_REG(TCPC_V10_REG_POWER_CTRL),
+	RT_REG(TCPC_V10_REG_CC_STATUS),
+	RT_REG(TCPC_V10_REG_POWER_STATUS),
+	RT_REG(TCPC_V10_REG_FAULT_STATUS),
+	RT_REG(TCPC_V10_REG_COMMAND),
+	RT_REG(TCPC_V10_REG_MSG_HDR_INFO),
+	RT_REG(TCPC_V10_REG_RX_DETECT),
+	RT_REG(TCPC_V10_REG_RX_BYTE_CNT),
+	RT_REG(TCPC_V10_REG_RX_BUF_FRAME_TYPE),
+	RT_REG(TCPC_V10_REG_RX_HDR),
+	RT_REG(TCPC_V10_REG_RX_DATA),
+	RT_REG(TCPC_V10_REG_TRANSMIT),
+	RT_REG(TCPC_V10_REG_TX_BYTE_CNT),
+	RT_REG(TCPC_V10_REG_TX_HDR),
+	RT_REG(TCPC_V10_REG_TX_DATA),
+	RT_REG(RT5081_REG_PHY_CTRL1),
+	RT_REG(RT5081_REG_PHY_CTRL3),
+	RT_REG(RT5081_REG_CLK_CTRL2),
+	RT_REG(RT5081_REG_CLK_CTRL3),
+	RT_REG(RT5081_REG_BMC_CTRL),
+	RT_REG(RT5081_REG_BMCIO_RXDZSEL),
+	RT_REG(RT5081_REG_RT_STATUS),
+	RT_REG(RT5081_REG_RT_INT),
+	RT_REG(RT5081_REG_RT_MASK),
+	RT_REG(RT5081_REG_BMCIO_RXDZEN),
+	RT_REG(RT5081_REG_IDLE_CTRL),
+	RT_REG(RT5081_REG_INTRST_CTRL),
+	RT_REG(RT5081_REG_WATCHDOG_CTRL),
+	RT_REG(RT5081_REG_I2CRST_CTRL),
+	RT_REG(RT5081_REG_SWRESET),
+	RT_REG(RT5081_REG_TTCPC_FILTER),
+	RT_REG(RT5081_REG_DRP_TOGGLE_CYCLE),
+	RT_REG(RT5081_REG_DRP_DUTY_CTRL),
+};
+#define RT5081_CHIP_REGMAP_SIZE ARRAY_SIZE(rt5081_chip_regmap)
+
+#endif /* CONFIG_RT_REGMAP */
+
+static int rt5081_read_device(void *client, u32 reg, int len, void *dst)
+{
+	struct i2c_client *i2c = (struct i2c_client *)client;
+	int ret = 0, count = 5;
+
+	while (count) {
+		if (len > 1) {
+			ret = i2c_smbus_read_i2c_block_data(i2c, reg, len, dst);
+			if (ret < 0)
+				count--;
+			else
+				return ret;
+		} else {
+			ret = i2c_smbus_read_byte_data(i2c, reg);
+			if (ret < 0)
+				count--;
+			else {
+				*(u8 *)dst = (u8)ret;
+				return ret;
+			}
+		}
+		udelay(100);
+	}
+	return ret;
+}
+
+static int rt5081_write_device(void *client, u32 reg, int len, const void *src)
+{
+	const u8 *data;
+	struct i2c_client *i2c = (struct i2c_client *)client;
+	int ret = 0, count = 5;
+
+	while (count) {
+		if (len > 1) {
+			ret = i2c_smbus_write_i2c_block_data(i2c,
+							reg, len, src);
+			if (ret < 0)
+				count--;
+			else
+				return ret;
+		} else {
+			data = src;
+			ret = i2c_smbus_write_byte_data(i2c, reg, *data);
+			if (ret < 0)
+				count--;
+			else
+				return ret;
+		}
+		udelay(100);
+	}
+	return ret;
+}
+
+static int rt5081_reg_read(struct i2c_client *i2c, u8 reg)
+{
+	struct rt5081_chip *chip = i2c_get_clientdata(i2c);
+	u8 val = 0;
+	int ret = 0;
+
+#if IS_ENABLED(CONFIG_RT_REGMAP)
+	ret = rt_regmap_block_read(chip->m_dev, reg, 1, &val);
+#else
+	ret = rt5081_read_device(chip->client, reg, 1, &val);
+#endif /* CONFIG_RT_REGMAP */
+	if (ret < 0) {
+		dev_err(chip->dev, "rt5081 reg read fail\n");
+		return ret;
+	}
+	return val;
+}
+
+static int rt5081_reg_write(struct i2c_client *i2c, u8 reg, const u8 data)
+{
+	struct rt5081_chip *chip = i2c_get_clientdata(i2c);
+	int ret = 0;
+
+#if IS_ENABLED(CONFIG_RT_REGMAP)
+	ret = rt_regmap_block_write(chip->m_dev, reg, 1, &data);
+#else
+	ret = rt5081_write_device(chip->client, reg, 1, &data);
+#endif /* CONFIG_RT_REGMAP */
+	if (ret < 0)
+		dev_err(chip->dev, "rt5081 reg write fail\n");
+	return ret;
+}
+
+static int rt5081_block_read(struct i2c_client *i2c,
+			u8 reg, int len, void *dst)
+{
+	struct rt5081_chip *chip = i2c_get_clientdata(i2c);
+	int ret = 0;
+#if IS_ENABLED(CONFIG_RT_REGMAP)
+	ret = rt_regmap_block_read(chip->m_dev, reg, len, dst);
+#else
+	ret = rt5081_read_device(chip->client, reg, len, dst);
+#endif /* #if IS_ENABLED(CONFIG_RT_REGMAP) */
+	if (ret < 0)
+		dev_err(chip->dev, "rt5081 block read fail\n");
+	return ret;
+}
+
+static int rt5081_block_write(struct i2c_client *i2c,
+			u8 reg, int len, const void *src)
+{
+	struct rt5081_chip *chip = i2c_get_clientdata(i2c);
+	int ret = 0;
+#if IS_ENABLED(CONFIG_RT_REGMAP)
+	ret = rt_regmap_block_write(chip->m_dev, reg, len, src);
+#else
+	ret = rt5081_write_device(chip->client, reg, len, src);
+#endif /* #if IS_ENABLED(CONFIG_RT_REGMAP) */
+	if (ret < 0)
+		dev_err(chip->dev, "rt5081 block write fail\n");
+	return ret;
+}
+
+static int32_t rt5081_write_word(struct i2c_client *client,
+					uint8_t reg_addr, uint16_t data)
+{
+	int ret;
+
+	/* don't need swap */
+	ret = rt5081_block_write(client, reg_addr, 2, (uint8_t *)&data);
+	return ret;
+}
+
+static int32_t rt5081_read_word(struct i2c_client *client,
+					uint8_t reg_addr, uint16_t *data)
+{
+	int ret;
+
+	/* don't need swap */
+	ret = rt5081_block_read(client, reg_addr, 2, (uint8_t *)data);
+	return ret;
+}
+
+static inline int rt5081_i2c_write8(
+	struct tcpc_device *tcpc, u8 reg, const u8 data)
+{
+	struct rt5081_chip *chip = tcpc_get_dev_data(tcpc);
+
+	return rt5081_reg_write(chip->client, reg, data);
+}
+
+static inline int rt5081_i2c_write16(
+		struct tcpc_device *tcpc, u8 reg, const u16 data)
+{
+	struct rt5081_chip *chip = tcpc_get_dev_data(tcpc);
+
+	return rt5081_write_word(chip->client, reg, data);
+}
+
+static inline int rt5081_i2c_read8(struct tcpc_device *tcpc, u8 reg)
+{
+	struct rt5081_chip *chip = tcpc_get_dev_data(tcpc);
+
+	return rt5081_reg_read(chip->client, reg);
+}
+
+static inline int rt5081_i2c_read16(
+	struct tcpc_device *tcpc, u8 reg)
+{
+	struct rt5081_chip *chip = tcpc_get_dev_data(tcpc);
+	u16 data;
+	int ret;
+
+	ret = rt5081_read_word(chip->client, reg, &data);
+	if (ret < 0)
+		return ret;
+	return data;
+}
+
+#if IS_ENABLED(CONFIG_RT_REGMAP)
+static struct rt_regmap_fops rt5081_regmap_fops = {
+	.read_device = rt5081_read_device,
+	.write_device = rt5081_write_device,
+};
+#endif /* CONFIG_RT_REGMAP */
+
+static int rt5081_regmap_init(struct rt5081_chip *chip)
+{
+#if IS_ENABLED(CONFIG_RT_REGMAP)
+	struct rt_regmap_properties *props;
+	char name[32];
+	int len;
+
+	props = devm_kzalloc(chip->dev, sizeof(*props), GFP_KERNEL);
+	if (!props)
+		return -ENOMEM;
+
+	props->register_num = RT5081_CHIP_REGMAP_SIZE;
+	props->rm = rt5081_chip_regmap;
+
+	props->rt_regmap_mode = RT_MULTI_BYTE | RT_CACHE_DISABLE |
+				RT_IO_PASS_THROUGH | RT_DBG_GENERAL;
+	snprintf(name, sizeof(name), "rt5081-%02x", chip->client->addr);
+
+	len = strlen(name);
+	props->name = kzalloc(len+1, GFP_KERNEL);
+	props->aliases = kzalloc(len+1, GFP_KERNEL);
+
+	if ((!props->name) || (!props->aliases))
+		return -ENOMEM;
+
+	strlcpy((char *)props->name, name, len+1);
+	strlcpy((char *)props->aliases, name, len+1);
+	props->io_log_en = 0;
+
+	chip->m_dev = rt_regmap_device_register(props,
+			&rt5081_regmap_fops, chip->dev, chip->client, chip);
+	if (!chip->m_dev) {
+		dev_err(chip->dev, "rt5081 chip rt_regmap register fail\n");
+		return -EINVAL;
+	}
+#endif
+	return 0;
+}
+
+static int rt5081_regmap_deinit(struct rt5081_chip *chip)
+{
+#if IS_ENABLED(CONFIG_RT_REGMAP)
+	rt_regmap_device_unregister(chip->m_dev);
+#endif
+	return 0;
+}
+
+static inline int rt5081_software_reset(struct tcpc_device *tcpc)
+{
+	int ret = rt5081_i2c_write8(tcpc, RT5081_REG_SWRESET, 1);
+
+	if (ret < 0)
+		return ret;
+
+	usleep_range(1000, 2000);
+	return 0;
+}
+
+static inline int rt5081_command(struct tcpc_device *tcpc, uint8_t cmd)
+{
+	return rt5081_i2c_write8(tcpc, TCPC_V10_REG_COMMAND, cmd);
+}
+
+static int rt5081_init_alert_mask(struct tcpc_device *tcpc)
+{
+	uint16_t mask;
+	struct rt5081_chip *chip = tcpc_get_dev_data(tcpc);
+
+	mask = TCPC_V10_REG_ALERT_CC_STATUS | TCPC_V10_REG_ALERT_POWER_STATUS;
+
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
+	/* Need to handle RX overflow */
+	mask |= TCPC_V10_REG_ALERT_TX_SUCCESS | TCPC_V10_REG_ALERT_TX_DISCARDED
+			| TCPC_V10_REG_ALERT_TX_FAILED
+			| TCPC_V10_REG_ALERT_RX_HARD_RST
+			| TCPC_V10_REG_ALERT_RX_STATUS
+			| TCPC_V10_REG_RX_OVERFLOW;
+#endif
+
+	mask |= TCPC_REG_ALERT_FAULT;
+
+	return rt5081_write_word(chip->client, TCPC_V10_REG_ALERT_MASK, mask);
+}
+
+static int rt5081_init_power_status_mask(struct tcpc_device *tcpc)
+{
+	const uint8_t mask = TCPC_V10_REG_POWER_STATUS_VBUS_PRES;
+
+	return rt5081_i2c_write8(tcpc,
+			TCPC_V10_REG_POWER_STATUS_MASK, mask);
+}
+
+static int rt5081_init_fault_mask(struct tcpc_device *tcpc)
+{
+	const uint8_t mask =
+		TCPC_V10_REG_FAULT_STATUS_VCONN_OV |
+		TCPC_V10_REG_FAULT_STATUS_VCONN_OC;
+
+	return rt5081_i2c_write8(tcpc,
+			TCPC_V10_REG_FAULT_STATUS_MASK, mask);
+}
+
+static int rt5081_init_rt_mask(struct tcpc_device *tcpc)
+{
+	uint8_t rt_mask = 0;
+#if CONFIG_TCPC_WATCHDOG_EN
+	rt_mask |= RT5081_REG_M_WATCHDOG;
+#endif /* CONFIG_TCPC_WATCHDOG_EN */
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
+	rt_mask |= RT5081_REG_M_VBUS_80;
+#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
+
+#if CONFIG_TYPEC_CAP_RA_DETACH
+	if (tcpc->tcpc_flags & TCPC_FLAGS_CHECK_RA_DETACHE)
+		rt_mask |= RT5081_REG_M_RA_DETACH;
+#endif /* CONFIG_TYPEC_CAP_RA_DETACH */
+
+#if CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
+	if (tcpc->tcpc_flags & TCPC_FLAGS_LPM_WAKEUP_WATCHDOG)
+		rt_mask |= RT5081_REG_M_WAKEUP;
+#endif	/* CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG */
+
+	return rt5081_i2c_write8(tcpc, RT5081_REG_RT_MASK, rt_mask);
+}
+
+static inline void rt5081_poll_ctrl(struct rt5081_chip *chip)
+{
+	cancel_delayed_work_sync(&chip->poll_work);
+
+	if (atomic_read(&chip->poll_count) == 0) {
+		atomic_inc(&chip->poll_count);
+		cpu_idle_poll_ctrl(true);
+	}
+
+	schedule_delayed_work(
+		&chip->poll_work, msecs_to_jiffies(40));
+}
+
+static void rt5081_irq_work_handler(struct kthread_work *work)
+{
+	struct rt5081_chip *chip =
+			container_of(work, struct rt5081_chip, irq_work);
+	int regval = 0;
+	int gpio_val;
+
+	rt5081_poll_ctrl(chip);
+	/* make sure I2C bus had resumed */
+	down(&chip->suspend_lock);
+	tcpci_lock_typec(chip->tcpc);
+
+#if DEBUG_GPIO
+	gpio_set_value(DEBUG_GPIO, 1);
+#endif
+
+	do {
+		regval = tcpci_alert(chip->tcpc);
+		if (regval)
+			break;
+		gpio_val = gpio_get_value(chip->irq_gpio);
+	} while (gpio_val == 0);
+
+	tcpci_unlock_typec(chip->tcpc);
+	up(&chip->suspend_lock);
+
+#if DEBUG_GPIO
+	gpio_set_value(DEBUG_GPIO, 1);
+#endif
+}
+
+static void rt5081_poll_work(struct work_struct *work)
+{
+	struct rt5081_chip *chip = container_of(
+		work, struct rt5081_chip, poll_work.work);
+
+	if (atomic_dec_and_test(&chip->poll_count))
+		cpu_idle_poll_ctrl(false);
+}
+
+static irqreturn_t rt5081_intr_handler(int irq, void *data)
+{
+	struct rt5081_chip *chip = data;
+
+	__pm_wakeup_event(chip->irq_wake_lock, RT5081_IRQ_WAKE_TIME);
+
+#if DEBUG_GPIO
+	gpio_set_value(DEBUG_GPIO, 0);
+#endif
+	kthread_queue_work(&chip->irq_worker, &chip->irq_work);
+	return IRQ_HANDLED;
+}
+
+static int rt5081_init_alert(struct tcpc_device *tcpc)
+{
+	struct rt5081_chip *chip = tcpc_get_dev_data(tcpc);
+	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
+	int ret;
+	char *name;
+	int len;
+
+	/* Clear Alert Mask & Status */
+	rt5081_write_word(chip->client, TCPC_V10_REG_ALERT_MASK, 0);
+	rt5081_write_word(chip->client, TCPC_V10_REG_ALERT, 0xffff);
+
+	len = strlen(chip->tcpc_desc->name);
+	name = devm_kzalloc(chip->dev, len+5, GFP_KERNEL);
+	if (!name)
+		return -ENOMEM;
+
+	snprintf(name, PAGE_SIZE, "%s-IRQ", chip->tcpc_desc->name);
+
+	pr_info("%s name = %s, gpio = %d\n", __func__,
+				chip->tcpc_desc->name, chip->irq_gpio);
+
+	ret = devm_gpio_request(chip->dev, chip->irq_gpio, name);
+#if DEBUG_GPIO
+	gpio_request(DEBUG_GPIO, "debug_latency_pin");
+	gpio_direction_output(DEBUG_GPIO, 1);
+#endif
+	if (ret < 0) {
+		pr_err("Error: failed to request GPIO%d (ret = %d)\n",
+		chip->irq_gpio, ret);
+		goto init_alert_err;
+	}
+
+	ret = gpio_direction_input(chip->irq_gpio);
+	if (ret < 0) {
+		pr_err("Error: failed to set GPIO%d as input pin(ret = %d)\n",
+		chip->irq_gpio, ret);
+		goto init_alert_err;
+	}
+
+	chip->irq = gpio_to_irq(chip->irq_gpio);
+	if (chip->irq <= 0) {
+		pr_err("%s gpio to irq fail, chip->irq(%d)\n",
+						__func__, chip->irq);
+		goto init_alert_err;
+	}
+
+	pr_info("%s : IRQ number = %d\n", __func__, chip->irq);
+
+	kthread_init_worker(&chip->irq_worker);
+	chip->irq_worker_task = kthread_run(kthread_worker_fn,
+			&chip->irq_worker, chip->tcpc_desc->name);
+	if (IS_ERR(chip->irq_worker_task)) {
+		pr_err("Error: Could not create tcpc task\n");
+		goto init_alert_err;
+	}
+
+	sched_setscheduler(chip->irq_worker_task, SCHED_FIFO, &param);
+	kthread_init_work(&chip->irq_work, rt5081_irq_work_handler);
+
+	pr_info("IRQF_NO_THREAD Test\n");
+	ret = request_irq(chip->irq, rt5081_intr_handler,
+		IRQF_TRIGGER_FALLING | IRQF_NO_THREAD, name, chip);
+	if (ret < 0) {
+		pr_err("Error: failed to request irq%d (gpio = %d, ret = %d)\n",
+			chip->irq, chip->irq_gpio, ret);
+		goto init_alert_err;
+	}
+
+	enable_irq_wake(chip->irq);
+	return 0;
+init_alert_err:
+	return -EINVAL;
+}
+
+int rt5081_alert_status_clear(struct tcpc_device *tcpc, uint32_t mask)
+{
+	int ret;
+	uint16_t mask_t1;
+
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
+	uint8_t mask_t2;
+#endif
+
+	/* Write 1 clear */
+	mask_t1 = (uint16_t) mask;
+	if (mask_t1) {
+		ret = rt5081_i2c_write16(tcpc, TCPC_V10_REG_ALERT, mask_t1);
+		if (ret < 0)
+			return ret;
+	}
+
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
+	mask_t2 = mask >> 16;
+	if (mask_t2) {
+		ret = rt5081_i2c_write8(tcpc, RT5081_REG_RT_INT, mask_t2);
+		if (ret < 0)
+			return ret;
+	}
+#endif
+
+	return 0;
+}
+
+static int rt5081_set_clock_gating(struct tcpc_device *tcpc,
+									bool en)
+{
+	int ret = 0;
+
+#if CONFIG_TCPC_CLOCK_GATING
+	uint8_t clk2 = RT5081_REG_CLK_DIV_600K_EN
+		| RT5081_REG_CLK_DIV_300K_EN | RT5081_REG_CLK_CK_300K_EN;
+
+	uint8_t clk3 = RT5081_REG_CLK_DIV_2P4M_EN;
+
+	if (!en) {
+		clk2 |=
+			RT5081_REG_CLK_BCLK2_EN | RT5081_REG_CLK_BCLK_EN;
+		clk3 |=
+			RT5081_REG_CLK_CK_24M_EN | RT5081_REG_CLK_PCLK_EN;
+	}
+
+	if (en) {
+		ret = rt5081_alert_status_clear(tcpc,
+			TCPC_REG_ALERT_RX_STATUS |
+			TCPC_REG_ALERT_RX_HARD_RST |
+			TCPC_REG_ALERT_RX_BUF_OVF);
+	}
+
+	if (ret == 0)
+		ret = rt5081_i2c_write8(tcpc, RT5081_REG_CLK_CTRL2, clk2);
+	if (ret == 0)
+		ret = rt5081_i2c_write8(tcpc, RT5081_REG_CLK_CTRL3, clk3);
+#endif	/* CONFIG_TCPC_CLOCK_GATING */
+
+	return ret;
+}
+
+static inline int rt5081_init_cc_params(
+			struct tcpc_device *tcpc, uint8_t cc_res)
+{
+	int rv = 0;
+
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
+#if CONFIG_USB_PD_SNK_DFT_NO_GOOD_CRC
+	uint8_t en, sel;
+	struct rt5081_chip *chip = tcpc_get_dev_data(tcpc);
+
+	if (cc_res == TYPEC_CC_VOLT_SNK_DFT) { /* 0.55 */
+		en = 1;
+		sel = 0x81;
+	} else if (chip->chip_id >= RT1715_DID_D) { /* 0.35 & 0.75 */
+		en = 1;
+		sel = 0x81;
+	} else { /* 0.4 & 0.7 */
+		en = 0;
+		sel = 0x80;
+	}
+
+	rv = rt5081_i2c_write8(tcpc, RT5081_REG_BMCIO_RXDZEN, en);
+	if (rv == 0)
+		rv = rt5081_i2c_write8(tcpc, RT5081_REG_BMCIO_RXDZSEL, sel);
+#endif	/* CONFIG_USB_PD_SNK_DFT_NO_GOOD_CRC */
+#endif	/* CONFIG_USB_POWER_DELIVERY */
+
+	return rv;
+}
+
+static int rt5081_tcpc_init(struct tcpc_device *tcpc, bool sw_reset)
+{
+	int ret;
+	bool retry_discard_old = false;
+	struct rt5081_chip *chip = tcpc_get_dev_data(tcpc);
+
+	RT5081_INFO("\n");
+
+	if (sw_reset) {
+		ret = rt5081_software_reset(tcpc);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* CK_300K from 320K, SHIPPING off, AUTOIDLE enable, TIMEOUT = 32ms */
+	rt5081_i2c_write8(tcpc, RT5081_REG_IDLE_CTRL,
+		RT5081_REG_IDLE_SET(0, 1, 1, 2));
+
+	/* For No-GoodCRC Case (0x70) */
+	rt5081_i2c_write8(tcpc, RT5081_REG_PHY_CTRL3, 0x70);
+	/* For BIST, Change Transition Toggle Counter (Noise) from 3 to 7 */
+	rt5081_i2c_write8(tcpc, RT5081_REG_PHY_CTRL1, 0x71);
+
+#if CONFIG_TCPC_I2CRST_EN
+	rt5081_i2c_write8(tcpc,
+		RT5081_REG_I2CRST_CTRL,
+		RT5081_REG_I2CRST_SET(true, 0x0f));
+#endif	/* CONFIG_TCPC_I2CRST_EN */
+
+	/* UFP Both RD setting */
+	/* DRP = 0, RpVal = 0 (Default), Rd, Rd */
+	rt5081_i2c_write8(tcpc, TCPC_V10_REG_ROLE_CTRL,
+		TCPC_V10_REG_ROLE_CTRL_RES_SET(0, 0, CC_RD, CC_RD));
+
+	if (chip->chip_id == RT5081_DID_A) {
+		rt5081_i2c_write8(tcpc, TCPC_V10_REG_FAULT_CTRL,
+			TCPC_V10_REG_FAULT_CTRL_DIS_VCONN_OV);
+	}
+
+	/*
+	 * CC Detect Debounce : 26.7*val us
+	 * Transition window count : spec 12~20us, based on 2.4MHz
+	 * DRP Toggle Cycle : 51.2 + 6.4*val ms
+	 * DRP Duyt Ctrl : dcSRC: /1024
+	 */
+
+	rt5081_i2c_write8(tcpc, RT5081_REG_TTCPC_FILTER, 5);
+	rt5081_i2c_write8(tcpc, RT5081_REG_DRP_TOGGLE_CYCLE, 4);
+	rt5081_i2c_write16(tcpc, RT5081_REG_DRP_DUTY_CTRL, TCPC_NORMAL_RP_DUTY);
+
+	/* Vconn OC */
+	rt5081_i2c_write8(tcpc, RT5081_REG_VCONN_CLIMITEN, 1);
+
+	/* RX/TX Clock Gating (Auto Mode)*/
+	if (!sw_reset)
+		rt5081_set_clock_gating(tcpc, true);
+
+	if (!(tcpc->tcpc_flags & TCPC_FLAGS_RETRY_CRC_DISCARD))
+		retry_discard_old = true;
+
+	rt5081_i2c_write8(tcpc, RT5081_REG_PHY_CTRL1,
+		RT5081_REG_PHY_CTRL1_SET(retry_discard_old, 7, 0, 1));
+
+	tcpci_alert_status_clear(tcpc, 0xffffffff);
+
+	rt5081_init_power_status_mask(tcpc);
+	rt5081_init_alert_mask(tcpc);
+	rt5081_init_fault_mask(tcpc);
+	rt5081_init_rt_mask(tcpc);
+
+	return 0;
+}
+
+static inline int rt5081_fault_status_vconn_ov(struct tcpc_device *tcpc)
+{
+	int ret;
+
+	ret = rt5081_i2c_read8(tcpc, RT5081_REG_BMC_CTRL);
+	if (ret < 0)
+		return ret;
+
+	ret &= ~RT5081_REG_DISCHARGE_EN;
+	return rt5081_i2c_write8(tcpc, RT5081_REG_BMC_CTRL, ret);
+}
+
+static inline int rt5081_fault_status_vconn_oc(struct tcpc_device *tcpc)
+{
+	const uint8_t mask =
+		TCPC_V10_REG_FAULT_STATUS_VCONN_OV;
+
+	return rt5081_i2c_write8(tcpc,
+		TCPC_V10_REG_FAULT_STATUS_MASK, mask);
+}
+
+int rt5081_fault_status_clear(struct tcpc_device *tcpc, uint8_t status)
+{
+	int ret;
+
+	if (status & TCPC_V10_REG_FAULT_STATUS_VCONN_OV)
+		ret = rt5081_fault_status_vconn_ov(tcpc);
+	if (status & TCPC_V10_REG_FAULT_STATUS_VCONN_OC)
+		ret = rt5081_fault_status_vconn_oc(tcpc);
+
+	rt5081_i2c_write8(tcpc, TCPC_V10_REG_FAULT_STATUS, status);
+	return 0;
+}
+
+int rt5081_get_alert_status(struct tcpc_device *tcpc, uint32_t *alert)
+{
+	int ret;
+
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
+	uint8_t v2;
+#endif
+
+	ret = rt5081_i2c_read16(tcpc, TCPC_V10_REG_ALERT);
+	if (ret < 0)
+		return ret;
+
+	*alert = (uint16_t) ret;
+
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
+	ret = rt5081_i2c_read8(tcpc, RT5081_REG_RT_INT);
+	if (ret < 0)
+		return ret;
+
+	v2 = (uint8_t) ret;
+	*alert |= v2 << 16;
+#endif
+
+	return 0;
+}
+
+static int rt5081_get_power_status(
+		struct tcpc_device *tcpc, uint16_t *pwr_status)
+{
+	int ret;
+
+	ret = rt5081_i2c_read8(tcpc, TCPC_V10_REG_POWER_STATUS);
+	if (ret < 0)
+		return ret;
+
+	*pwr_status = 0;
+
+	if (ret & TCPC_V10_REG_POWER_STATUS_VBUS_PRES)
+		*pwr_status |= TCPC_REG_POWER_STATUS_VBUS_PRES;
+
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
+	ret = rt5081_i2c_read8(tcpc, RT5081_REG_RT_STATUS);
+	if (ret < 0)
+		return ret;
+
+	if (ret & RT5081_REG_VBUS_80)
+		*pwr_status |= TCPC_REG_POWER_STATUS_EXT_VSAFE0V;
+#endif
+	return 0;
+}
+
+int rt5081_get_fault_status(struct tcpc_device *tcpc, uint8_t *status)
+{
+	int ret;
+
+	ret = rt5081_i2c_read8(tcpc, TCPC_V10_REG_FAULT_STATUS);
+	if (ret < 0)
+		return ret;
+	*status = (uint8_t) ret;
+	return 0;
+}
+
+static int rt5081_get_cc(struct tcpc_device *tcpc, int *cc1, int *cc2)
+{
+	int status, role_ctrl, cc_role;
+	bool act_as_sink, act_as_drp;
+
+	status = rt5081_i2c_read8(tcpc, TCPC_V10_REG_CC_STATUS);
+	if (status < 0)
+		return status;
+
+	role_ctrl = rt5081_i2c_read8(tcpc, TCPC_V10_REG_ROLE_CTRL);
+	if (role_ctrl < 0)
+		return role_ctrl;
+
+	if (status & TCPC_V10_REG_CC_STATUS_DRP_TOGGLING) {
+		*cc1 = TYPEC_CC_DRP_TOGGLING;
+		*cc2 = TYPEC_CC_DRP_TOGGLING;
+		return 0;
+	}
+
+	*cc1 = TCPC_V10_REG_CC_STATUS_CC1(status);
+	*cc2 = TCPC_V10_REG_CC_STATUS_CC2(status);
+
+	act_as_drp = TCPC_V10_REG_ROLE_CTRL_DRP & role_ctrl;
+
+	if (act_as_drp) {
+		act_as_sink = TCPC_V10_REG_CC_STATUS_DRP_RESULT(status);
+	} else {
+		cc_role =  TCPC_V10_REG_CC_STATUS_CC1(role_ctrl);
+		if (cc_role == TYPEC_CC_RP)
+			act_as_sink = false;
+		else
+			act_as_sink = true;
+	}
+
+	/*
+	 * If status is not open, then OR in termination to convert to
+	 * enum tcpc_cc_voltage_status.
+	 */
+
+	if (*cc1 != TYPEC_CC_VOLT_OPEN)
+		*cc1 |= (act_as_sink << 2);
+
+	if (*cc2 != TYPEC_CC_VOLT_OPEN)
+		*cc2 |= (act_as_sink << 2);
+
+	rt5081_init_cc_params(tcpc,
+		(uint8_t)tcpc->typec_polarity ? *cc2 : *cc1);
+
+	return 0;
+}
+
+static int rt5081_set_cc(struct tcpc_device *tcpc, int pull)
+{
+	int ret;
+	uint8_t data;
+	int rp_lvl = TYPEC_CC_PULL_GET_RP_LVL(pull);
+
+	RT5081_INFO("\n");
+	pull = TYPEC_CC_PULL_GET_RES(pull);
+	if (pull == TYPEC_CC_DRP) {
+		data = TCPC_V10_REG_ROLE_CTRL_RES_SET(
+				1, rp_lvl, TYPEC_CC_RD, TYPEC_CC_RD);
+
+		ret = rt5081_i2c_write8(
+			tcpc, TCPC_V10_REG_ROLE_CTRL, data);
+
+		if (ret == 0)
+			ret = rt5081_command(tcpc, TCPM_CMD_LOOK_CONNECTION);
+	} else {
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
+		if (pull == TYPEC_CC_RD && tcpc->pd_wait_pr_swap_complete)
+			rt5081_init_cc_params(tcpc, TYPEC_CC_VOLT_SNK_DFT);
+#endif	/* CONFIG_USB_POWER_DELIVERY */
+		data = TCPC_V10_REG_ROLE_CTRL_RES_SET(0, rp_lvl, pull, pull);
+		ret = rt5081_i2c_write8(tcpc, TCPC_V10_REG_ROLE_CTRL, data);
+	}
+
+	return 0;
+}
+
+static int rt5081_set_polarity(struct tcpc_device *tcpc, int polarity)
+{
+	int data;
+
+	data = rt5081_init_cc_params(tcpc,
+		tcpc->typec_remote_cc[polarity]);
+	if (data)
+		return data;
+
+	data = rt5081_i2c_read8(tcpc, TCPC_V10_REG_TCPC_CTRL);
+	if (data < 0)
+		return data;
+
+	data &= ~TCPC_V10_REG_TCPC_CTRL_PLUG_ORIENT;
+	data |= polarity ? TCPC_V10_REG_TCPC_CTRL_PLUG_ORIENT : 0;
+
+	return rt5081_i2c_write8(tcpc, TCPC_V10_REG_TCPC_CTRL, data);
+}
+
+static int rt5081_set_low_rp_duty(struct tcpc_device *tcpc, bool low_rp)
+{
+	uint16_t duty = low_rp ? TCPC_LOW_RP_DUTY : TCPC_NORMAL_RP_DUTY;
+
+	return rt5081_i2c_write16(tcpc, RT5081_REG_DRP_DUTY_CTRL, duty);
+}
+
+static int rt5081_set_vconn(struct tcpc_device *tcpc, int enable)
+{
+	int rv;
+	int data;
+
+	data = rt5081_i2c_read8(tcpc, TCPC_V10_REG_POWER_CTRL);
+	if (data < 0)
+		return data;
+
+	data &= ~TCPC_V10_REG_POWER_CTRL_VCONN;
+	data |= enable ? TCPC_V10_REG_POWER_CTRL_VCONN : 0;
+
+	rv = rt5081_i2c_write8(tcpc, TCPC_V10_REG_POWER_CTRL, data);
+	if (rv < 0)
+		return rv;
+
+#if !CONFIG_TCPC_IDLE_MODE
+	rv = rt5081_i2c_write8(tcpc, RT5081_REG_IDLE_CTRL,
+		RT5081_REG_IDLE_SET(0, 1, enable ? 0 : 1, 2));
+#endif /* CONFIG_TCPC_IDLE_MODE */
+
+	if (enable)
+		rt5081_init_fault_mask(tcpc);
+
+	return rv;
+}
+
+#if CONFIG_TCPC_LOW_POWER_MODE
+static int rt5081_is_low_power_mode(struct tcpc_device *tcpc)
+{
+	int rv = rt5081_i2c_read8(tcpc, RT5081_REG_BMC_CTRL);
+
+	if (rv < 0)
+		return rv;
+
+	return (rv & RT5081_REG_BMCIO_LPEN) != 0;
+}
+
+static int rt5081_set_low_power_mode(
+		struct tcpc_device *tcpc, bool en, int pull)
+{
+	int rv = 0;
+	uint8_t data;
+
+	if (en) {
+		data = RT5081_REG_BMCIO_LPEN;
+
+		if (pull & TYPEC_CC_RP)
+			data |= RT5081_REG_BMCIO_LPRPRD;
+	} else
+		data = RT5081_REG_BMCIO_BG_EN |
+			RT5081_REG_VBUS_DET_EN | RT5081_REG_BMCIO_OSC_EN;
+
+	rv = rt5081_i2c_write8(tcpc, RT5081_REG_BMC_CTRL, data);
+	return rv;
+}
+#endif	/* CONFIG_TCPC_LOW_POWER_MODE */
+
+#if CONFIG_TCPC_WATCHDOG_EN
+int rt5081_set_watchdog(struct tcpc_device *tcpc, bool en)
+{
+	uint8_t data = RT5081_REG_WATCHDOG_CTRL_SET(en, 7);
+
+	return rt5081_i2c_write8(tcpc,
+		RT5081_REG_WATCHDOG_CTRL, data);
+}
+#endif	/* CONFIG_TCPC_WATCHDOG_EN */
+
+#if CONFIG_TCPC_INTRST_EN
+int rt5081_set_intrst(struct tcpc_device *tcpc, bool en)
+{
+	return rt5081_i2c_write8(tcpc,
+		RT5081_REG_INTRST_CTRL, RT5081_REG_INTRST_SET(en, 3));
+}
+#endif	/* CONFIG_TCPC_INTRST_EN */
+
+static int rt5081_tcpc_deinit(struct tcpc_device *tcpc)
+{
+#if CONFIG_TCPC_SHUTDOWN_CC_DETACH
+	rt5081_set_cc(tcpc, TYPEC_CC_DRP);
+	rt5081_set_cc(tcpc, TYPEC_CC_OPEN);
+
+	rt5081_i2c_write8(tcpc,
+		RT5081_REG_I2CRST_CTRL,
+		RT5081_REG_I2CRST_SET(true, 4));
+
+	rt5081_i2c_write8(tcpc,
+		RT5081_REG_INTRST_CTRL,
+		RT5081_REG_INTRST_SET(true, 0));
+#else
+	rt5081_i2c_write8(tcpc, RT5081_REG_SWRESET, 1);
+#endif	/* CONFIG_TCPC_SHUTDOWN_CC_DETACH */
+
+	return 0;
+}
+
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
+static int rt5081_set_msg_header(
+	struct tcpc_device *tcpc, uint8_t power_role, uint8_t data_role)
+{
+	uint8_t msg_hdr = TCPC_V10_REG_MSG_HDR_INFO_SET(
+		data_role, power_role);
+
+	return rt5081_i2c_write8(
+		tcpc, TCPC_V10_REG_MSG_HDR_INFO, msg_hdr);
+}
+
+static int rt5081_protocol_reset(struct tcpc_device *tcpc)
+{
+	rt5081_i2c_write8(tcpc, RT5081_REG_PRL_FSM_RESET, 0);
+	mdelay(1);
+	rt5081_i2c_write8(tcpc, RT5081_REG_PRL_FSM_RESET, 1);
+	return 0;
+}
+
+static int rt5081_set_rx_enable(struct tcpc_device *tcpc, uint8_t enable)
+{
+	int ret = 0;
+
+	if (enable)
+		ret = rt5081_set_clock_gating(tcpc, false);
+
+	if (ret == 0)
+		ret = rt5081_i2c_write8(tcpc, TCPC_V10_REG_RX_DETECT, enable);
+
+	if ((ret == 0) && (!enable))
+		ret = rt5081_set_clock_gating(tcpc, true);
+
+	/* For testing */
+	if (!enable)
+		rt5081_protocol_reset(tcpc);
+	return ret;
+}
+
+static int rt5081_get_message(struct tcpc_device *tcpc, uint32_t *payload,
+			uint16_t *msg_head, enum tcpm_transmit_type *frame_type)
+{
+	struct rt5081_chip *chip = tcpc_get_dev_data(tcpc);
+	int rv;
+	uint8_t type, cnt = 0;
+	uint8_t buf[4];
+	const uint16_t alert_rx =
+		TCPC_V10_REG_ALERT_RX_STATUS|TCPC_V10_REG_RX_OVERFLOW;
+
+	rv = rt5081_block_read(chip->client,
+			TCPC_V10_REG_RX_BYTE_CNT, 4, buf);
+	cnt = buf[0];
+	type = buf[1];
+	*msg_head = *(uint16_t *)&buf[2];
+
+	/* TCPC 1.0 ==> no need to subtract the size of msg_head */
+	if (rv >= 0 && cnt > 3) {
+		cnt -= 3; /* MSG_HDR */
+		rv = rt5081_block_read(chip->client, TCPC_V10_REG_RX_DATA, cnt,
+				(uint8_t *) payload);
+	}
+
+	*frame_type = (enum tcpm_transmit_type) type;
+
+	/* Read complete, clear RX status alert bit */
+	tcpci_alert_status_clear(tcpc, alert_rx);
+
+	/*mdelay(1); */
+	return rv;
+}
+
+static int rt5081_set_bist_carrier_mode(
+	struct tcpc_device *tcpc, uint8_t pattern)
+{
+	/* Don't support this function */
+	return 0;
+}
+
+/* transmit count (1byte) + message header (2byte) + data object (4byte * 7) */
+#define RT5081_TRANSMIT_MAX_SIZE (1 + sizeof(uint16_t) + sizeof(uint32_t) * 7)
+
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
+static int rt5081_retransmit(struct tcpc_device *tcpc)
+{
+	return rt5081_i2c_write8(tcpc, TCPC_V10_REG_TRANSMIT,
+			TCPC_V10_REG_TRANSMIT_SET(
+			tcpc->pd_retry_count, TCPC_TX_SOP));
+}
+#endif
+
+static int rt5081_transmit(struct tcpc_device *tcpc,
+	enum tcpm_transmit_type type, uint16_t header, const uint32_t *data)
+{
+	struct rt5081_chip *chip = tcpc_get_dev_data(tcpc);
+	int rv;
+	int data_cnt, packet_cnt;
+	uint8_t temp[RT5081_TRANSMIT_MAX_SIZE];
+
+	if (type < TCPC_TX_HARD_RESET) {
+		data_cnt = sizeof(uint32_t) * PD_HEADER_CNT(header);
+		packet_cnt = data_cnt + sizeof(uint16_t);
+
+		temp[0] = packet_cnt;
+		memcpy(temp+1, (uint8_t *)&header, 2);
+		if (data_cnt > 0)
+			memcpy(temp+3, (uint8_t *)data, data_cnt);
+
+		rv = rt5081_block_write(chip->client,
+				TCPC_V10_REG_TX_BYTE_CNT,
+				packet_cnt+1, (uint8_t *)temp);
+		if (rv < 0)
+			return rv;
+	}
+
+	rv = rt5081_i2c_write8(tcpc, TCPC_V10_REG_TRANSMIT,
+			TCPC_V10_REG_TRANSMIT_SET(
+			tcpc->pd_retry_count, type));
+	return rv;
+}
+
+static int rt5081_set_bist_test_mode(struct tcpc_device *tcpc, bool en)
+{
+	int data;
+
+	data = rt5081_i2c_read8(tcpc, TCPC_V10_REG_TCPC_CTRL);
+	if (data < 0)
+		return data;
+
+	data &= ~TCPC_V10_REG_TCPC_CTRL_BIST_TEST_MODE;
+	data |= en ? TCPC_V10_REG_TCPC_CTRL_BIST_TEST_MODE : 0;
+
+	return rt5081_i2c_write8(tcpc, TCPC_V10_REG_TCPC_CTRL, data);
+}
+#endif /* CONFIG_USB_POWER_DELIVERY */
+
+static struct tcpc_ops rt5081_tcpc_ops = {
+	.init = rt5081_tcpc_init,
+	.alert_status_clear = rt5081_alert_status_clear,
+	.fault_status_clear = rt5081_fault_status_clear,
+	.get_alert_status = rt5081_get_alert_status,
+	.get_power_status = rt5081_get_power_status,
+	.get_fault_status = rt5081_get_fault_status,
+	.get_cc = rt5081_get_cc,
+	.set_cc = rt5081_set_cc,
+	.set_polarity = rt5081_set_polarity,
+	.set_low_rp_duty = rt5081_set_low_rp_duty,
+	.set_vconn = rt5081_set_vconn,
+	.deinit = rt5081_tcpc_deinit,
+
+#if CONFIG_TCPC_LOW_POWER_MODE
+	.is_low_power_mode = rt5081_is_low_power_mode,
+	.set_low_power_mode = rt5081_set_low_power_mode,
+#endif	/* CONFIG_TCPC_LOW_POWER_MODE */
+
+#if CONFIG_TCPC_WATCHDOG_EN
+	.set_watchdog = rt5081_set_watchdog,
+#endif	/* CONFIG_TCPC_WATCHDOG_EN */
+
+#if CONFIG_TCPC_INTRST_EN
+	.set_intrst = rt5081_set_intrst,
+#endif	/* CONFIG_TCPC_INTRST_EN */
+
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
+	.set_msg_header = rt5081_set_msg_header,
+	.set_rx_enable = rt5081_set_rx_enable,
+	.protocol_reset = rt5081_protocol_reset,
+	.get_message = rt5081_get_message,
+	.transmit = rt5081_transmit,
+	.set_bist_test_mode = rt5081_set_bist_test_mode,
+	.set_bist_carrier_mode = rt5081_set_bist_carrier_mode,
+#endif	/* CONFIG_USB_POWER_DELIVERY */
+
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
+	.retransmit = rt5081_retransmit,
+#endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
+};
+
+
+static int rt_parse_dt(struct rt5081_chip *chip, struct device *dev)
+{
+	struct device_node *np = dev->of_node;
+	int ret;
+
+	if (!np)
+		return -EINVAL;
+
+	pr_info("%s\n", __func__);
+
+	np = of_find_node_by_name(NULL, "type_c_port0");
+	if (!np) {
+		pr_err("%s find node rt5081 fail\n", __func__);
+		return -ENODEV;
+	}
+
+#if IS_ENABLED(CONFIG_MTK_GPIO) || IS_ENABLED(CONFIG_MTK_GPIOLIB_STAND)
+	ret = of_get_named_gpio(np, "rt5081pd,intr_gpio", 0);
+	if (ret < 0) {
+		pr_err("%s no intr_gpio info\n", __func__);
+		return ret;
+	}
+	chip->irq_gpio = ret;
+#else
+	ret = of_property_read_u32(
+		np, "rt5081pd,intr_gpio_num", &chip->irq_gpio);
+	if (ret < 0)
+		pr_err("%s no intr_gpio info\n", __func__);
+#endif
+	return ret;
+}
+
+/*
+ * In some platform pr_info may spend too much time on printing debug message.
+ * So we use this function to test the printk performance.
+ * If your platform cannot not pass this check function, please config
+ * PD_DBG_INFO, this will provide the threaded debug message for you.
+ */
+#if TCPC_ENABLE_ANYMSG
+static void check_printk_performance(void)
+{
+	int i;
+	u64 t1, t2;
+	u32 nsrem;
+
+#if IS_ENABLED(CONFIG_PD_DBG_INFO)
+	for (i = 0; i < 10; i++) {
+		t1 = local_clock();
+		pd_dbg_info("%d\n", i);
+		t2 = local_clock();
+		t2 -= t1;
+		nsrem = do_div(t2, 1000000000);
+		pd_dbg_info("pd_dbg_info : t2-t1 = %lu\n",
+				(unsigned long)nsrem / 1000);
+	}
+	for (i = 0; i < 10; i++) {
+		t1 = local_clock();
+		pr_info("%d\n", i);
+		t2 = local_clock();
+		t2 -= t1;
+		nsrem = do_div(t2, 1000000000);
+		pr_info("pr_info : t2-t1 = %lu\n",
+				(unsigned long)nsrem / 1000);
+	}
+#else
+	for (i = 0; i < 10; i++) {
+		t1 = local_clock();
+		pr_info("%d\n", i);
+		t2 = local_clock();
+		t2 -= t1;
+		nsrem = do_div(t2, 1000000000);
+		pr_info("t2-t1 = %lu\n",
+				(unsigned long)nsrem /  1000);
+		PD_BUG_ON(nsrem > 100*1000);
+	}
+#endif /* CONFIG_PD_DBG_INFO */
+}
+#endif /* TCPC_ENABLE_ANYMSG */
+
+static int rt5081_tcpcdev_init(struct rt5081_chip *chip, struct device *dev)
+{
+	struct tcpc_desc *desc;
+	struct device_node *np;
+	u32 val, len;
+	const char *name = "default";
+
+	np = of_find_node_by_name(NULL, "type_c_port0");
+	if (!np) {
+		pr_err("%s find node rt5081 fail\n", __func__);
+		return -ENODEV;
+	}
+
+	desc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);
+	if (!desc)
+		return -ENOMEM;
+	if (of_property_read_u32(np, "rt-tcpc,role_def", &val) >= 0) {
+		if (val >= TYPEC_ROLE_NR)
+			desc->role_def = TYPEC_ROLE_DRP;
+		else
+			desc->role_def = val;
+	} else {
+		dev_info(dev, "use default Role DRP\n");
+		desc->role_def = TYPEC_ROLE_DRP;
+	}
+
+	if (of_property_read_u32(
+		np, "rt-tcpc,notifier_supply_num", &val) >= 0) {
+		if (val < 0)
+			desc->notifier_supply_num = 0;
+		else
+			desc->notifier_supply_num = val;
+	} else
+		desc->notifier_supply_num = 0;
+
+	if (of_property_read_u32(np, "rt-tcpc,rp_level", &val) >= 0) {
+		switch (val) {
+		case 0: /* RP Default */
+			desc->rp_lvl = TYPEC_CC_RP_DFT;
+			break;
+		case 1: /* RP 1.5V */
+			desc->rp_lvl = TYPEC_CC_RP_1_5;
+			break;
+		case 2: /* RP 3.0V */
+			desc->rp_lvl = TYPEC_CC_RP_3_0;
+			break;
+		default:
+			break;
+		}
+	}
+
+#if CONFIG_TCPC_VCONN_SUPPLY_MODE
+	if (of_property_read_u32(np, "rt-tcpc,vconn_supply", &val) >= 0) {
+		if (val >= TCPC_VCONN_SUPPLY_NR)
+			desc->vconn_supply = TCPC_VCONN_SUPPLY_ALWAYS;
+		else
+			desc->vconn_supply = val;
+	} else {
+		dev_info(dev, "use default VconnSupply\n");
+		desc->vconn_supply = TCPC_VCONN_SUPPLY_ALWAYS;
+	}
+#endif	/* CONFIG_TCPC_VCONN_SUPPLY_MODE */
+
+	of_property_read_string(np, "rt-tcpc,name", (char const **)&name);
+
+	len = strlen(name);
+	desc->name = kzalloc(len+1, GFP_KERNEL);
+	if (!desc->name)
+		return -ENOMEM;
+
+	strlcpy((char *)desc->name, name, len+1);
+
+	chip->tcpc_desc = desc;
+
+	chip->tcpc = tcpc_device_register(dev,
+			desc, &rt5081_tcpc_ops, chip);
+	if (IS_ERR(chip->tcpc))
+		return -EINVAL;
+
+	chip->tcpc->tcpc_flags =
+		TCPC_FLAGS_LPM_WAKEUP_WATCHDOG |
+		TCPC_FLAGS_RETRY_CRC_DISCARD;
+
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
+	chip->tcpc->tcpc_flags |= TCPC_FLAGS_RETRY_CRC_DISCARD;
+#endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
+
+#if CONFIG_USB_PD_REV30
+	chip->tcpc->tcpc_flags |= TCPC_FLAGS_PD_REV30;
+
+	if (chip->tcpc->tcpc_flags & TCPC_FLAGS_PD_REV30)
+		dev_info(dev, "PD_REV30\n");
+	else
+		dev_info(dev, "PD_REV20\n");
+#endif	/* CONFIG_USB_PD_REV30 */
+	return 0;
+}
+
+#define MEDIATEK_5081_VID	0x29cf
+#define MEDIATEK_5081_PID	0x5081
+
+static inline int rt5081_check_revision(struct i2c_client *client)
+{
+	u16 vid, pid, did;
+	int ret;
+	u8 data = 1;
+
+	ret = rt5081_read_device(client, TCPC_V10_REG_VID, 2, &vid);
+	if (ret < 0) {
+		dev_err(&client->dev, "read chip ID fail\n");
+		return -EIO;
+	}
+
+	if (vid != MEDIATEK_5081_VID) {
+		pr_info("%s failed, VID=0x%04x\n", __func__, vid);
+		return -ENODEV;
+	}
+
+	ret = rt5081_read_device(client, TCPC_V10_REG_PID, 2, &pid);
+	if (ret < 0) {
+		dev_err(&client->dev, "read product ID fail\n");
+		return -EIO;
+	}
+
+	if (pid != MEDIATEK_5081_PID) {
+		pr_info("%s failed, PID=0x%04x\n", __func__, pid);
+		return -ENODEV;
+	}
+
+	ret = rt5081_write_device(client, RT5081_REG_SWRESET, 1, &data);
+	if (ret < 0)
+		return ret;
+
+	usleep_range(1000, 2000);
+
+	ret = rt5081_read_device(client, TCPC_V10_REG_DID, 2, &did);
+	if (ret < 0) {
+		dev_err(&client->dev, "read device ID fail\n");
+		return -EIO;
+	}
+
+	return did;
+}
+
+static int rt5081_i2c_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	struct rt5081_chip *chip;
+	int ret = 0, chip_id;
+	bool use_dt = client->dev.of_node;
+
+	pr_info("%s\n", __func__);
+	if (i2c_check_functionality(client->adapter,
+			I2C_FUNC_SMBUS_I2C_BLOCK | I2C_FUNC_SMBUS_BYTE_DATA))
+		pr_info("I2C functionality : OK...\n");
+	else
+		pr_info("I2C functionality check : failuare...\n");
+
+	chip_id = rt5081_check_revision(client);
+	if (chip_id < 0)
+		return chip_id;
+
+#if TCPC_ENABLE_ANYMSG
+	check_printk_performance();
+#endif /* TCPC_ENABLE_ANYMSG */
+
+	chip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	if (use_dt)
+		rt_parse_dt(chip, &client->dev);
+	else {
+		dev_err(&client->dev, "no dts node\n");
+		return -ENODEV;
+	}
+	chip->dev = &client->dev;
+	chip->client = client;
+	sema_init(&chip->io_lock, 1);
+	sema_init(&chip->suspend_lock, 1);
+	i2c_set_clientdata(client, chip);
+	INIT_DELAYED_WORK(&chip->poll_work, rt5081_poll_work);
+	chip->irq_wake_lock =
+		wakeup_source_register(chip->dev, "rt5081_irq_wakelock");
+
+	chip->chip_id = chip_id;
+	pr_info("rt5081_chipID = 0x%0x\n", chip_id);
+
+	ret = rt5081_regmap_init(chip);
+	if (ret < 0) {
+		dev_err(chip->dev, "rt5081 regmap init fail\n");
+		return -EINVAL;
+	}
+
+	ret = rt5081_tcpcdev_init(chip, &client->dev);
+	if (ret < 0) {
+		dev_err(&client->dev, "rt5081 tcpc dev init fail\n");
+		goto err_tcpc_reg;
+	}
+
+	ret = rt5081_init_alert(chip->tcpc);
+	if (ret < 0) {
+		pr_err("rt5081 init alert fail\n");
+		goto err_irq_init;
+	}
+
+	tcpc_schedule_init_work(chip->tcpc);
+	pr_info("%s probe OK!\n", __func__);
+	return 0;
+
+err_irq_init:
+	tcpc_device_unregister(chip->dev, chip->tcpc);
+err_tcpc_reg:
+	rt5081_regmap_deinit(chip);
+	return ret;
+}
+
+static int rt5081_i2c_remove(struct i2c_client *client)
+{
+	struct rt5081_chip *chip = i2c_get_clientdata(client);
+
+	if (chip) {
+		cancel_delayed_work_sync(&chip->poll_work);
+
+		tcpc_device_unregister(chip->dev, chip->tcpc);
+		rt5081_regmap_deinit(chip);
+	}
+
+	return 0;
+}
+
+#if CONFIG_PM
+static int rt5081_i2c_suspend(struct device *dev)
+{
+	struct rt5081_chip *chip;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (client) {
+		chip = i2c_get_clientdata(client);
+		if (chip)
+			down(&chip->suspend_lock);
+	}
+
+	return 0;
+}
+
+static int rt5081_i2c_resume(struct device *dev)
+{
+	struct rt5081_chip *chip;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (client) {
+		chip = i2c_get_clientdata(client);
+		if (chip)
+			up(&chip->suspend_lock);
+	}
+
+	return 0;
+}
+
+static void rt5081_shutdown(struct i2c_client *client)
+{
+	struct rt5081_chip *chip = i2c_get_clientdata(client);
+
+	/* Please reset IC here */
+	if (chip != NULL) {
+		if (chip->irq)
+			disable_irq(chip->irq);
+		tcpm_shutdown(chip->tcpc);
+	} else {
+		i2c_smbus_write_byte_data(
+			client, RT5081_REG_SWRESET, 0x01);
+	}
+}
+
+#if IS_ENABLED(CONFIG_PM_RUNTIME)
+static int rt5081_pm_suspend_runtime(struct device *device)
+{
+	dev_dbg(device, "pm_runtime: suspending...\n");
+	return 0;
+}
+
+static int rt5081_pm_resume_runtime(struct device *device)
+{
+	dev_dbg(device, "pm_runtime: resuming...\n");
+	return 0;
+}
+#endif /* CONFIG_PM_RUNTIME */
+
+
+static const struct dev_pm_ops rt5081_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(
+			rt5081_i2c_suspend,
+			rt5081_i2c_resume)
+#if IS_ENABLED(CONFIG_PM_RUNTIME)
+	SET_RUNTIME_PM_OPS(
+		rt5081_pm_suspend_runtime,
+		rt5081_pm_resume_runtime,
+		NULL
+	)
+#endif /* CONFIG_PM_RUNTIME */
+};
+#define RT5081_PM_OPS	(&rt5081_pm_ops)
+#else
+#define RT5081_PM_OPS	(NULL)
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id rt5081_id_table[] = {
+	{"rt5081", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, rt5081_id_table);
+
+static const struct of_device_id rt_match_table[] = {
+	{.compatible = "mediatek,usb_type_c",},
+	{},
+};
+
+static struct i2c_driver rt5081_driver = {
+	.driver = {
+		.name = "usb_type_c",
+		.owner = THIS_MODULE,
+		.of_match_table = rt_match_table,
+		.pm = RT5081_PM_OPS,
+	},
+	.probe = rt5081_i2c_probe,
+	.remove = rt5081_i2c_remove,
+	.shutdown = rt5081_shutdown,
+	.id_table = rt5081_id_table,
+};
+
+static int __init rt5081_init(void)
+{
+	struct device_node *np;
+
+	pr_info("rt5081h_init (%s): initializing...\n", RT5081_DRV_VERSION);
+	np = of_find_node_by_name(NULL, "usb_type_c");
+	if (np != NULL)
+		pr_info("usb_type_c node found...\n");
+	else
+		pr_info("usb_type_c node not found...\n");
+
+	return i2c_add_driver(&rt5081_driver);
+}
+subsys_initcall(rt5081_init);
+
+static void __exit rt5081_exit(void)
+{
+	i2c_del_driver(&rt5081_driver);
+}
+module_exit(rt5081_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("RT5081 TCPC Driver");
+MODULE_VERSION(RT5081_DRV_VERSION);
+
+/**** Release Note ****
+ * 2.0.1_MTK
+ *	First released PD3.0 Driver on MTK platform
+ */
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpci.c b/drivers/misc/mediatek/typec/tcpc/tcpci.c
index 115d6c7..cdbd99d 100644
--- a/drivers/misc/mediatek/typec/tcpc/tcpci.c
+++ b/drivers/misc/mediatek/typec/tcpc/tcpci.c
@@ -1,23 +1,18 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2017 MediaTek Inc.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include "inc/tcpci.h"
+#include <linux/usb/typec_mux.h>
+#include <linux/usb/typec.h>
 #include <linux/time.h>
 #include <linux/slab.h>
+#include <linux/sched/clock.h>
 
 #define TCPC_NOTIFY_OVERTIME	(20) /* ms */
 
-#ifdef CONFIG_TCPC_NOTIFICATION_NON_BLOCKING
+#if CONFIG_TCPC_NOTIFICATION_NON_BLOCKING
 struct tcp_notify_work {
 	struct work_struct work;
 	struct tcpc_device *tcpc;
@@ -34,15 +29,15 @@ static void tcp_notify_func(struct work_struct *work)
 	struct tcp_notify *tcp_noti = &tn_work->tcp_noti;
 	uint8_t type = tn_work->type;
 	uint8_t state = tn_work->state;
-#ifdef CONFIG_PD_BEGUG_ON
-	struct timeval begin, end;
+#if CONFIG_PD_BEGUG_ON
+	long long begin = 0, end = 0;
 	int timeval = 0;
 
-	do_gettimeofday(&begin);
+	begin = local_clock();
 	srcu_notifier_call_chain(&tcpc->evt_nh[type], state, tcp_noti);
-	do_gettimeofday(&end);
-	timeval = (timeval_to_ns(end) - timeval_to_ns(begin))/1000/1000;
-	PD_BUG_ON(timeval > TCPC_NOTIFY_OVERTIME);
+	end = local_clock();
+	timeval = (end - begin) / NSEC_PER_USEC;
+	PD_BUG_ON(timeval > (TCPC_NOTIFY_OVERTIME * 1000));
 #else
 	srcu_notifier_call_chain(&tcpc->evt_nh[type], state, tcp_noti);
 #endif
@@ -72,7 +67,7 @@ static int tcpc_check_notify_time(struct tcpc_device *tcpc,
 	struct tcp_notify *tcp_noti, uint8_t type, uint8_t state)
 {
 	int ret;
-#ifdef CONFIG_PD_BEGUG_ON
+#if CONFIG_PD_BEGUG_ON
 	struct timeval begin, end;
 	int timeval = 0;
 
@@ -102,13 +97,36 @@ int tcpci_check_vbus_valid_from_ic(struct tcpc_device *tcpc)
 
 	return tcpci_check_vbus_valid(tcpc);
 }
+EXPORT_SYMBOL(tcpci_check_vbus_valid_from_ic);
+
+int tcpci_set_auto_dischg_discnt(struct tcpc_device *tcpc, bool en)
+{
+	int rv = 0;
+
+	if (tcpc->ops->set_auto_dischg_discnt)
+		rv = tcpc->ops->set_auto_dischg_discnt(tcpc, en);
+
+	return rv;
+}
+EXPORT_SYMBOL(tcpci_set_auto_dischg_discnt);
+
+int tcpci_get_vbus_voltage(struct tcpc_device *tcpc, u32 *vbus)
+{
+	int rv = 0;
+
+	if (tcpc->ops->get_vbus_voltage)
+		rv = tcpc->ops->get_vbus_voltage(tcpc, vbus);
+
+	return rv;
+}
+EXPORT_SYMBOL(tcpci_get_vbus_voltage);
 
 int tcpci_check_vsafe0v(
 	struct tcpc_device *tcpc, bool detect_en)
 {
 	int ret = 0;
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	ret = (tcpc->vbus_level == TCPC_VBUS_SAFE0V);
 #else
 	ret = (tcpc->vbus_level == TCPC_VBUS_INVALID);
@@ -116,6 +134,7 @@ int tcpci_check_vsafe0v(
 
 	return ret;
 }
+EXPORT_SYMBOL(tcpci_check_vsafe0v);
 
 int tcpci_alert_status_clear(
 	struct tcpc_device *tcpc, uint32_t mask)
@@ -124,6 +143,7 @@ int tcpci_alert_status_clear(
 
 	return tcpc->ops->alert_status_clear(tcpc, mask);
 }
+EXPORT_SYMBOL(tcpci_alert_status_clear);
 
 int tcpci_fault_status_clear(
 	struct tcpc_device *tcpc, uint8_t status)
@@ -132,6 +152,7 @@ int tcpci_fault_status_clear(
 
 	return tcpc->ops->fault_status_clear(tcpc, status);
 }
+EXPORT_SYMBOL(tcpci_fault_status_clear);
 
 int tcpci_set_alert_mask(struct tcpc_device *tcpc, uint32_t mask)
 {
@@ -142,6 +163,7 @@ int tcpci_set_alert_mask(struct tcpc_device *tcpc, uint32_t mask)
 
 	return rv;
 }
+EXPORT_SYMBOL(tcpci_set_alert_mask);
 
 int tcpci_get_alert_mask(
 	struct tcpc_device *tcpc, uint32_t *mask)
@@ -150,6 +172,7 @@ int tcpci_get_alert_mask(
 
 	return tcpc->ops->get_alert_mask(tcpc, mask);
 }
+EXPORT_SYMBOL(tcpci_get_alert_mask);
 
 int tcpci_get_alert_status(
 	struct tcpc_device *tcpc, uint32_t *alert)
@@ -158,6 +181,7 @@ int tcpci_get_alert_status(
 
 	return tcpc->ops->get_alert_status(tcpc, alert);
 }
+EXPORT_SYMBOL(tcpci_get_alert_status);
 
 int tcpci_get_fault_status(
 	struct tcpc_device *tcpc, uint8_t *fault)
@@ -168,6 +192,7 @@ int tcpci_get_fault_status(
 	*fault = 0;
 	return 0;
 }
+EXPORT_SYMBOL(tcpci_get_fault_status);
 
 int tcpci_get_power_status(
 	struct tcpc_device *tcpc, uint16_t *pw_status)
@@ -183,6 +208,7 @@ int tcpci_get_power_status(
 	tcpci_vbus_level_init(tcpc, *pw_status);
 	return 0;
 }
+EXPORT_SYMBOL(tcpci_get_power_status);
 
 int tcpci_init(struct tcpc_device *tcpc, bool sw_reset)
 {
@@ -197,6 +223,7 @@ int tcpci_init(struct tcpc_device *tcpc, bool sw_reset)
 
 	return tcpci_get_power_status(tcpc, &power_status);
 }
+EXPORT_SYMBOL(tcpci_init);
 
 int tcpci_init_alert_mask(struct tcpc_device *tcpc)
 {
@@ -204,6 +231,7 @@ int tcpci_init_alert_mask(struct tcpc_device *tcpc)
 		return tcpc->ops->init_alert_mask(tcpc);
 	return 0;
 }
+EXPORT_SYMBOL(tcpci_init_alert_mask);
 
 int tcpci_get_cc(struct tcpc_device *tcpc)
 {
@@ -226,18 +254,20 @@ int tcpci_get_cc(struct tcpc_device *tcpc)
 
 	return 1;
 }
+EXPORT_SYMBOL(tcpci_get_cc);
 
 int tcpci_set_cc(struct tcpc_device *tcpc, int pull)
 {
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
-#ifdef CONFIG_TYPEC_LEGACY3_ALWAYS_LOCAL_RP
-	uint8_t rp_lvl = TYPEC_RP_DFT, res = TYPEC_CC_DRP;
-#endif /* CONFIG_TYPEC_LEGACY3_ALWAYS_LOCAL_RP */
-#endif /* CONFIG_TYPEC_CHECK_LEGACY_CABLE */
+	PD_BUG_ON(tcpc->ops->set_cc == NULL);
+
+#if CONFIG_USB_PD_DBG_ALWAYS_LOCAL_RP
+	if (pull == TYPEC_CC_RP)
+		pull = tcpc->typec_local_rp_level;
+#endif /* CONFIG_USB_PD_DBG_ALWAYS_LOCAL_RP */
 
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE
 	if (pull == TYPEC_CC_DRP && tcpc->typec_legacy_cable) {
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE2
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE2
 		if (tcpc->typec_legacy_cable == 2)
 			pull = TYPEC_CC_RP;
 		else if (tcpc->typec_legacy_retry_wk > 1)
@@ -246,18 +276,19 @@ int tcpci_set_cc(struct tcpc_device *tcpc, int pull)
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE2 */
 			pull = TYPEC_CC_RP_1_5;
 		TCPC_DBG2("LC->Toggling (%d)\n", pull);
-	} else if (!tcpc->typec_legacy_cable) {
-#ifdef CONFIG_TYPEC_LEGACY3_ALWAYS_LOCAL_RP
-		rp_lvl = TYPEC_CC_PULL_GET_RP_LVL(pull);
-		res = TYPEC_CC_PULL_GET_RES(pull);
-		pull = TYPEC_CC_PULL(rp_lvl == TYPEC_RP_DFT ?
-			tcpc->typec_local_rp_level : rp_lvl, res);
-#endif /* CONFIG_TYPEC_LEGACY3_ALWAYS_LOCAL_RP */
 	}
 #endif /* CONFIG_TYPEC_CHECK_LEGACY_CABLE */
 
-	return __tcpci_set_cc(tcpc, pull);
+	if (pull & TYPEC_CC_DRP) {
+		tcpc->typec_remote_cc[0] =
+		tcpc->typec_remote_cc[1] =
+			TYPEC_CC_DRP_TOGGLING;
+	}
+
+	tcpc->typec_local_cc = pull;
+	return tcpc->ops->set_cc(tcpc, pull);
 }
+EXPORT_SYMBOL(tcpci_set_cc);
 
 int tcpci_set_polarity(struct tcpc_device *tcpc, int polarity)
 {
@@ -265,10 +296,11 @@ int tcpci_set_polarity(struct tcpc_device *tcpc, int polarity)
 
 	return tcpc->ops->set_polarity(tcpc, polarity);
 }
+EXPORT_SYMBOL(tcpci_set_polarity);
 
 int tcpci_set_low_rp_duty(struct tcpc_device *tcpc, bool low_rp)
 {
-#ifdef CONFIG_TYPEC_CAP_LOW_RP_DUTY
+#if CONFIG_TYPEC_CAP_LOW_RP_DUTY
 	if (low_rp)
 		TCPC_INFO("low_rp_duty\n");
 
@@ -278,10 +310,11 @@ int tcpci_set_low_rp_duty(struct tcpc_device *tcpc, bool low_rp)
 
 	return 0;
 }
+EXPORT_SYMBOL(tcpci_set_low_rp_duty);
 
 int tcpci_set_vconn(struct tcpc_device *tcpc, int enable)
 {
-#ifdef CONFIG_TCPC_SOURCE_VCONN
+#if CONFIG_TCPC_SOURCE_VCONN
 	struct tcp_notify tcp_noti;
 
 	if (tcpc->tcpc_source_vconn == enable)
@@ -299,31 +332,34 @@ int tcpci_set_vconn(struct tcpc_device *tcpc, int enable)
 
 	return 0;
 }
+EXPORT_SYMBOL(tcpci_set_vconn);
 
 int tcpci_is_low_power_mode(struct tcpc_device *tcpc)
 {
 	int rv = 1;
 
-#ifdef CONFIG_TCPC_LOW_POWER_MODE
+#if CONFIG_TCPC_LOW_POWER_MODE
 	if (tcpc->ops->is_low_power_mode)
 		rv = tcpc->ops->is_low_power_mode(tcpc);
 #endif	/* CONFIG_TCPC_LOW_POWER_MODE */
 
 	return rv;
 }
+EXPORT_SYMBOL(tcpci_is_low_power_mode);
 
 int tcpci_set_low_power_mode(
 	struct tcpc_device *tcpc, bool en, int pull)
 {
 	int rv = 0;
 
-#ifdef CONFIG_TCPC_LOW_POWER_MODE
+#if CONFIG_TCPC_LOW_POWER_MODE
 	if (tcpc->ops->set_low_power_mode)
 		rv = tcpc->ops->set_low_power_mode(tcpc, en, pull);
 #endif	/* CONFIG_TCPC_LOW_POWER_MODE */
 
 	return rv;
 }
+EXPORT_SYMBOL(tcpci_set_low_power_mode);
 
 int tcpci_set_watchdog(struct tcpc_device *tcpc, bool en)
 {
@@ -335,6 +371,7 @@ int tcpci_set_watchdog(struct tcpc_device *tcpc, bool en)
 
 	return rv;
 }
+EXPORT_SYMBOL(tcpci_set_watchdog);
 
 int tcpci_alert_vendor_defined_handler(struct tcpc_device *tcpc)
 {
@@ -345,8 +382,9 @@ int tcpci_alert_vendor_defined_handler(struct tcpc_device *tcpc)
 
 	return rv;
 }
+EXPORT_SYMBOL(tcpci_alert_vendor_defined_handler);
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 int tcpci_is_vsafe0v(struct tcpc_device *tcpc)
 {
 	int rv = -ENOTSUPP;
@@ -356,15 +394,17 @@ int tcpci_is_vsafe0v(struct tcpc_device *tcpc)
 
 	return rv;
 }
+EXPORT_SYMBOL(tcpci_is_vsafe0v);
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 int tcpci_is_water_detected(struct tcpc_device *tcpc)
 {
 	if (tcpc->ops->is_water_detected)
 		return tcpc->ops->is_water_detected(tcpc);
 	return 0;
 }
+EXPORT_SYMBOL(tcpci_is_water_detected);
 
 int tcpci_set_water_protection(struct tcpc_device *tcpc, bool en)
 {
@@ -372,6 +412,7 @@ int tcpci_set_water_protection(struct tcpc_device *tcpc, bool en)
 		return tcpc->ops->set_water_protection(tcpc, en);
 	return 0;
 }
+EXPORT_SYMBOL(tcpci_set_water_protection);
 
 int tcpci_set_usbid_polling(struct tcpc_device *tcpc, bool en)
 {
@@ -379,6 +420,7 @@ int tcpci_set_usbid_polling(struct tcpc_device *tcpc, bool en)
 		return tcpc->ops->set_usbid_polling(tcpc, en);
 	return 0;
 }
+EXPORT_SYMBOL(tcpci_set_usbid_polling);
 
 int tcpci_notify_wd_status(struct tcpc_device *tcpc, bool water_detected)
 {
@@ -388,9 +430,19 @@ int tcpci_notify_wd_status(struct tcpc_device *tcpc, bool water_detected)
 	return tcpc_check_notify_time(tcpc, &tcp_noti, TCP_NOTIFY_IDX_MISC,
 				      TCP_NOTIFY_WD_STATUS);
 }
+EXPORT_SYMBOL(tcpci_notify_wd_status);
 #endif /* CONFIG_WATER_DETECTION */
+int tcpci_notify_fod_status(struct tcpc_device *tcpc)
+{
+	struct tcp_notify tcp_noti;
 
-#ifdef CONFIG_CABLE_TYPE_DETECTION
+	tcp_noti.fod_status.fod = tcpc->typec_fod;
+	return tcpc_check_notify_time(tcpc, &tcp_noti, TCP_NOTIFY_IDX_MISC,
+				      TCP_NOTIFY_FOD_STATUS);
+}
+EXPORT_SYMBOL(tcpci_notify_fod_status);
+
+#if CONFIG_CABLE_TYPE_DETECTION
 int tcpci_notify_cable_type(struct tcpc_device *tcpc)
 {
 	struct tcp_notify tcp_noti;
@@ -399,9 +451,62 @@ int tcpci_notify_cable_type(struct tcpc_device *tcpc)
 	return tcpc_check_notify_time(tcpc, &tcp_noti, TCP_NOTIFY_IDX_MISC,
 				      TCP_NOTIFY_CABLE_TYPE);
 }
+EXPORT_SYMBOL(tcpci_notify_cable_type);
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+int tcpci_notify_typec_otp(struct tcpc_device *tcpc)
+{
+	struct tcp_notify tcp_noti;
+
+	tcp_noti.typec_otp.otp = tcpc->typec_otp;
+	return tcpc_check_notify_time(tcpc, &tcp_noti, TCP_NOTIFY_IDX_MISC,
+				      TCP_NOTIFY_TYPEC_OTP);
+}
+EXPORT_SYMBOL(tcpci_notify_typec_otp);
+
+int tcpci_set_cc_hidet(struct tcpc_device *tcpc, bool en)
+{
+	int rv = 0;
+
+	if (tcpc->ops->set_cc_hidet)
+		rv = tcpc->ops->set_cc_hidet(tcpc, en);
+
+	return rv;
+}
+EXPORT_SYMBOL(tcpci_set_cc_hidet);
+
+int tcpci_notify_plug_out(struct tcpc_device *tcpc)
+{
+	struct tcp_notify tcp_noti;
+
+	return tcpc_check_notify_time(tcpc, &tcp_noti, TCP_NOTIFY_IDX_MISC,
+				      TCP_NOTIFY_PLUG_OUT);
+}
+EXPORT_SYMBOL(tcpci_notify_plug_out);
+
+int tcpci_set_floating_ground(struct tcpc_device *tcpc, bool en)
+{
+	int rv = 0;
+
+	if (tcpc->ops->set_floating_ground)
+		rv = tcpc->ops->set_floating_ground(tcpc, en);
+
+	return rv;
+}
+EXPORT_SYMBOL(tcpci_set_floating_ground);
+
+int tcpci_set_otp_fwen(struct tcpc_device *tcpc, bool en)
+{
+	int rv = 0;
+
+	if (tcpc->ops->set_otp_fwen)
+		rv = tcpc->ops->set_otp_fwen(tcpc, en);
+
+	return rv;
+}
+EXPORT_SYMBOL(tcpci_set_otp_fwen);
+
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 
 int tcpci_set_msg_header(struct tcpc_device *tcpc,
 	uint8_t power_role, uint8_t data_role)
@@ -410,6 +515,7 @@ int tcpci_set_msg_header(struct tcpc_device *tcpc,
 
 	return tcpc->ops->set_msg_header(tcpc, power_role, data_role);
 }
+EXPORT_SYMBOL(tcpci_set_msg_header);
 
 int tcpci_set_rx_enable(struct tcpc_device *tcpc, uint8_t enable)
 {
@@ -417,6 +523,7 @@ int tcpci_set_rx_enable(struct tcpc_device *tcpc, uint8_t enable)
 
 	return tcpc->ops->set_rx_enable(tcpc, enable);
 }
+EXPORT_SYMBOL(tcpci_set_rx_enable);
 
 int tcpci_protocol_reset(struct tcpc_device *tcpc)
 {
@@ -425,6 +532,7 @@ int tcpci_protocol_reset(struct tcpc_device *tcpc)
 
 	return 0;
 }
+EXPORT_SYMBOL(tcpci_protocol_reset);
 
 int tcpci_get_message(struct tcpc_device *tcpc,
 	uint32_t *payload, uint16_t *head, enum tcpm_transmit_type *type)
@@ -433,6 +541,7 @@ int tcpci_get_message(struct tcpc_device *tcpc,
 
 	return tcpc->ops->get_message(tcpc, payload, head, type);
 }
+EXPORT_SYMBOL(tcpci_get_message);
 
 int tcpci_transmit(struct tcpc_device *tcpc,
 	enum tcpm_transmit_type type, uint16_t header, const uint32_t *data)
@@ -441,6 +550,7 @@ int tcpci_transmit(struct tcpc_device *tcpc,
 
 	return tcpc->ops->transmit(tcpc, type, header, data);
 }
+EXPORT_SYMBOL(tcpci_transmit);
 
 int tcpci_set_bist_test_mode(struct tcpc_device *tcpc, bool en)
 {
@@ -449,6 +559,7 @@ int tcpci_set_bist_test_mode(struct tcpc_device *tcpc, bool en)
 
 	return 0;
 }
+EXPORT_SYMBOL(tcpci_set_bist_test_mode);
 
 int tcpci_set_bist_carrier_mode(struct tcpc_device *tcpc, uint8_t pattern)
 {
@@ -459,14 +570,16 @@ int tcpci_set_bist_carrier_mode(struct tcpc_device *tcpc, uint8_t pattern)
 
 	return tcpc->ops->set_bist_carrier_mode(tcpc, pattern);
 }
+EXPORT_SYMBOL(tcpci_set_bist_carrier_mode);
 
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 int tcpci_retransmit(struct tcpc_device *tcpc)
 {
 	PD_BUG_ON(tcpc->ops->retransmit == NULL);
 
 	return tcpc->ops->retransmit(tcpc);
 }
+EXPORT_SYMBOL(tcpci_retransmit);
 #endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
@@ -485,6 +598,7 @@ int tcpci_notify_typec_state(struct tcpc_device *tcpc)
 		TCP_NOTIFY_IDX_USB, TCP_NOTIFY_TYPEC_STATE);
 	return ret;
 }
+EXPORT_SYMBOL(tcpci_notify_typec_state);
 
 int tcpci_notify_role_swap(
 	struct tcpc_device *tcpc, uint8_t event, uint8_t role)
@@ -497,6 +611,7 @@ int tcpci_notify_role_swap(
 		TCP_NOTIFY_IDX_MISC, event);
 	return ret;
 }
+EXPORT_SYMBOL(tcpci_notify_role_swap);
 
 int tcpci_notify_pd_state(struct tcpc_device *tcpc, uint8_t connect)
 {
@@ -508,16 +623,18 @@ int tcpci_notify_pd_state(struct tcpc_device *tcpc, uint8_t connect)
 		TCP_NOTIFY_IDX_USB, TCP_NOTIFY_PD_STATE);
 	return ret;
 }
+EXPORT_SYMBOL(tcpci_notify_pd_state);
 
 int tcpci_set_intrst(struct tcpc_device *tcpc, bool en)
 {
-#ifdef CONFIG_TCPC_INTRST_EN
+#if CONFIG_TCPC_INTRST_EN
 	if (tcpc->ops->set_intrst)
 		tcpc->ops->set_intrst(tcpc, en);
 #endif	/* CONFIG_TCPC_INTRST_EN */
 
 	return 0;
 }
+EXPORT_SYMBOL(tcpci_set_intrst);
 
 int tcpci_enable_watchdog(struct tcpc_device *tcpc, bool en)
 {
@@ -535,7 +652,7 @@ int tcpci_enable_watchdog(struct tcpc_device *tcpc, bool en)
 	if (tcpc->ops->set_watchdog)
 		tcpc->ops->set_watchdog(tcpc, en);
 
-#ifdef CONFIG_TCPC_INTRST_EN
+#if CONFIG_TCPC_INTRST_EN
 	if (!en || tcpc->attach_wake_lock.active)
 		tcpci_set_intrst(tcpc, en);
 #endif	/* CONFIG_TCPC_INTRST_EN */
@@ -544,6 +661,7 @@ int tcpci_enable_watchdog(struct tcpc_device *tcpc, bool en)
 
 	return 0;
 }
+EXPORT_SYMBOL(tcpci_enable_watchdog);
 
 int tcpci_source_vbus(
 	struct tcpc_device *tcpc, uint8_t type, int mv, int ma)
@@ -551,7 +669,7 @@ int tcpci_source_vbus(
 	struct tcp_notify tcp_noti;
 	int ret;
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	if (type >= TCP_VBUS_CTRL_PD &&
 			tcpc->pd_port.pe_data.pd_prev_connected)
 		type |= TCP_VBUS_CTRL_PD_DETECT;
@@ -560,14 +678,14 @@ int tcpci_source_vbus(
 	if (ma < 0) {
 		if (mv != 0) {
 			switch (tcpc->typec_local_rp_level) {
-			case TYPEC_RP_3_0:
-				ma = 3000;
-				break;
-			case TYPEC_RP_1_5:
+			case TYPEC_CC_RP_1_5:
 				ma = 1500;
 				break;
-			case TYPEC_RP_DFT:
+			case TYPEC_CC_RP_3_0:
+				ma = 3000;
+				break;
 			default:
+			case TYPEC_CC_RP_DFT:
 				ma = CONFIG_TYPEC_SRC_CURR_DFT;
 				break;
 			}
@@ -585,6 +703,7 @@ int tcpci_source_vbus(
 		TCP_NOTIFY_IDX_VBUS, TCP_NOTIFY_SOURCE_VBUS);
 	return ret;
 }
+EXPORT_SYMBOL(tcpci_source_vbus);
 
 int tcpci_sink_vbus(
 	struct tcpc_device *tcpc, uint8_t type, int mv, int ma)
@@ -592,7 +711,7 @@ int tcpci_sink_vbus(
 	struct tcp_notify tcp_noti;
 	int ret;
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	if (type >= TCP_VBUS_CTRL_PD &&
 			tcpc->pd_port.pe_data.pd_prev_connected)
 		type |= TCP_VBUS_CTRL_PD_DETECT;
@@ -629,10 +748,11 @@ int tcpci_sink_vbus(
 		TCP_NOTIFY_IDX_VBUS, TCP_NOTIFY_SINK_VBUS);
 	return ret;
 }
+EXPORT_SYMBOL(tcpci_sink_vbus);
 
 int tcpci_disable_vbus_control(struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_TYPEC_USE_DIS_VBUS_CTRL
+#if CONFIG_TYPEC_USE_DIS_VBUS_CTRL
 	struct tcp_notify tcp_noti;
 	int ret;
 
@@ -648,20 +768,21 @@ int tcpci_disable_vbus_control(struct tcpc_device *tcpc)
 	return 0;
 #endif	/* CONFIG_TYPEC_USE_DIS_VBUS_CTRL */
 }
+EXPORT_SYMBOL(tcpci_disable_vbus_control);
 
 int tcpci_notify_attachwait_state(struct tcpc_device *tcpc, bool as_sink)
 {
-#ifdef CONFIG_TYPEC_NOTIFY_ATTACHWAIT
+#if CONFIG_TYPEC_NOTIFY_ATTACHWAIT
 	uint8_t notify = 0;
 	struct tcp_notify tcp_noti;
 	int ret;
 
-#ifdef CONFIG_TYPEC_NOTIFY_ATTACHWAIT_SNK
+#if CONFIG_TYPEC_NOTIFY_ATTACHWAIT_SNK
 	if (as_sink)
 		notify = TCP_NOTIFY_ATTACHWAIT_SNK;
 #endif	/* CONFIG_TYPEC_NOTIFY_ATTACHWAIT_SNK */
 
-#ifdef CONFIG_TYPEC_NOTIFY_ATTACHWAIT_SRC
+#if CONFIG_TYPEC_NOTIFY_ATTACHWAIT_SRC
 	if (!as_sink)
 		notify = TCP_NOTIFY_ATTACHWAIT_SRC;
 #endif	/* CONFIG_TYPEC_NOTIFY_ATTACHWAIT_SRC */
@@ -677,13 +798,14 @@ int tcpci_notify_attachwait_state(struct tcpc_device *tcpc, bool as_sink)
 #endif	/* CONFIG_TYPEC_NOTIFY_ATTACHWAIT */
 
 }
+EXPORT_SYMBOL(tcpci_notify_attachwait_state);
 
 int tcpci_enable_auto_discharge(struct tcpc_device *tcpc, bool en)
 {
 	int ret = 0;
 
-#ifdef CONFIG_TYPEC_CAP_AUTO_DISCHARGE
-#ifdef CONFIG_TCPC_AUTO_DISCHARGE_IC
+#if CONFIG_TYPEC_CAP_AUTO_DISCHARGE
+#if CONFIG_TCPC_AUTO_DISCHARGE_IC
 	if (tcpc->typec_auto_discharge != en) {
 		tcpc->typec_auto_discharge = en;
 		if (tcpc->ops->set_auto_discharge)
@@ -694,14 +816,15 @@ int tcpci_enable_auto_discharge(struct tcpc_device *tcpc, bool en)
 
 	return ret;
 }
+EXPORT_SYMBOL(tcpci_enable_auto_discharge);
 
-static int __tcpci_enable_force_discharge(
+int __tcpci_enable_force_discharge(
 	struct tcpc_device *tcpc, bool en, int mv)
 {
 	int ret = 0;
 
-#ifdef CONFIG_TYPEC_CAP_FORCE_DISCHARGE
-#ifdef CONFIG_TCPC_FORCE_DISCHARGE_IC
+#if CONFIG_TYPEC_CAP_FORCE_DISCHARGE
+#if CONFIG_TCPC_FORCE_DISCHARGE_IC
 	if (tcpc->pd_force_discharge != en) {
 		tcpc->pd_force_discharge = en;
 		if (tcpc->ops->set_force_discharge)
@@ -712,12 +835,14 @@ static int __tcpci_enable_force_discharge(
 
 	return ret;
 }
+EXPORT_SYMBOL(__tcpci_enable_force_discharge);
 
+#if CONFIG_TCPC_FORCE_DISCHARGE_EXT
 static int __tcpci_enable_ext_discharge(struct tcpc_device *tcpc, bool en)
 {
 	int ret = 0;
 
-#ifdef CONFIG_TCPC_EXT_DISCHARGE
+#if CONFIG_TCPC_EXT_DISCHARGE
 	struct tcp_notify tcp_noti;
 
 	if (tcpc->typec_ext_discharge != en) {
@@ -731,22 +856,24 @@ static int __tcpci_enable_ext_discharge(struct tcpc_device *tcpc, bool en)
 
 	return ret;
 }
+#endif	/* CONFIG_TCPC_FORCE_DISCHARGE_EXT */
 
 int tcpci_enable_force_discharge(struct tcpc_device *tcpc, bool en, int mv)
 {
 	int ret = 0;
 
-#ifdef CONFIG_TYPEC_CAP_FORCE_DISCHARGE
+#if CONFIG_TYPEC_CAP_FORCE_DISCHARGE
 	ret = __tcpci_enable_force_discharge(tcpc, en, mv);
-#ifdef CONFIG_TCPC_FORCE_DISCHARGE_EXT
+#if CONFIG_TCPC_FORCE_DISCHARGE_EXT
 	ret = __tcpci_enable_ext_discharge(tcpc, en);
 #endif	/* CONFIG_TCPC_FORCE_DISCHARGE_EXT */
 #endif	/* CONFIG_TYPEC_CAP_FORCE_DISCHARGE */
 
 	return ret;
 }
+EXPORT_SYMBOL(tcpci_enable_force_discharge);
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 
 int tcpci_notify_hard_reset_state(struct tcpc_device *tcpc, uint8_t state)
 {
@@ -766,6 +893,7 @@ int tcpci_notify_hard_reset_state(struct tcpc_device *tcpc, uint8_t state)
 		TCP_NOTIFY_IDX_MISC, TCP_NOTIFY_HARD_RESET_STATE);
 	return ret;
 }
+EXPORT_SYMBOL(tcpci_notify_hard_reset_state);
 
 int tcpci_enter_mode(struct tcpc_device *tcpc,
 	uint16_t svid, uint8_t ops, uint32_t mode)
@@ -781,6 +909,7 @@ int tcpci_enter_mode(struct tcpc_device *tcpc,
 		TCP_NOTIFY_IDX_MODE, TCP_NOTIFY_ENTER_MODE);
 	return ret;
 }
+EXPORT_SYMBOL(tcpci_enter_mode);
 
 int tcpci_exit_mode(struct tcpc_device *tcpc, uint16_t svid)
 {
@@ -793,8 +922,9 @@ int tcpci_exit_mode(struct tcpc_device *tcpc, uint16_t svid)
 	return ret;
 
 }
+EXPORT_SYMBOL(tcpci_exit_mode);
 
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 
 int tcpci_report_hpd_state(struct tcpc_device *tcpc, uint32_t dp_status)
 {
@@ -813,6 +943,7 @@ int tcpci_report_hpd_state(struct tcpc_device *tcpc, uint32_t dp_status)
 
 	return 0;
 }
+EXPORT_SYMBOL(tcpci_report_hpd_state);
 
 int tcpci_dp_status_update(struct tcpc_device *tcpc, uint32_t dp_status)
 {
@@ -820,6 +951,7 @@ int tcpci_dp_status_update(struct tcpc_device *tcpc, uint32_t dp_status)
 	tcpci_report_hpd_state(tcpc, dp_status);
 	return 0;
 }
+EXPORT_SYMBOL(tcpci_dp_status_update);
 
 int tcpci_dp_configure(struct tcpc_device *tcpc, uint32_t dp_config)
 {
@@ -849,10 +981,12 @@ int tcpci_dp_configure(struct tcpc_device *tcpc, uint32_t dp_config)
 	tcp_noti.ama_dp_state.signal = (dp_config >> 2) & 0x0f;
 	tcp_noti.ama_dp_state.polarity = tcpc->typec_polarity;
 	tcp_noti.ama_dp_state.active = 1;
+
 	ret = tcpc_check_notify_time(tcpc, &tcp_noti,
 		TCP_NOTIFY_IDX_MODE, TCP_NOTIFY_AMA_DP_STATE);
 	return ret;
 }
+EXPORT_SYMBOL(tcpci_dp_configure);
 
 int tcpci_dp_attention(struct tcpc_device *tcpc, uint32_t dp_status)
 {
@@ -865,6 +999,7 @@ int tcpci_dp_attention(struct tcpc_device *tcpc, uint32_t dp_status)
 		TCP_NOTIFY_IDX_MODE, TCP_NOTIFY_AMA_DP_ATTENTION);
 	return tcpci_report_hpd_state(tcpc, dp_status);
 }
+EXPORT_SYMBOL(tcpci_dp_attention);
 
 int tcpci_dp_notify_status_update_done(
 	struct tcpc_device *tcpc, uint32_t dp_status, bool ack)
@@ -873,6 +1008,7 @@ int tcpci_dp_notify_status_update_done(
 	DP_INFO("Status1: 0x%x, ack=%d\n", dp_status, ack);
 	return 0;
 }
+EXPORT_SYMBOL(tcpci_dp_notify_status_update_done);
 
 int tcpci_dp_notify_config_start(struct tcpc_device *tcpc)
 {
@@ -886,6 +1022,7 @@ int tcpci_dp_notify_config_start(struct tcpc_device *tcpc)
 		TCP_NOTIFY_IDX_MODE, TCP_NOTIFY_AMA_DP_STATE);
 	return 0;
 }
+EXPORT_SYMBOL(tcpci_dp_notify_config_start);
 
 int tcpci_dp_notify_config_done(struct tcpc_device *tcpc,
 	uint32_t local_cfg, uint32_t remote_cfg, bool ack)
@@ -901,10 +1038,11 @@ int tcpci_dp_notify_config_done(struct tcpc_device *tcpc,
 
 	return 0;
 }
+EXPORT_SYMBOL(tcpci_dp_notify_config_done);
 
 #endif	/* CONFIG_USB_PD_ALT_MODE */
 
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 int tcpci_notify_uvdm(struct tcpc_device *tcpc, bool ack)
 {
 	struct tcp_notify tcp_noti;
@@ -922,9 +1060,10 @@ int tcpci_notify_uvdm(struct tcpc_device *tcpc, bool ack)
 		TCP_NOTIFY_IDX_MODE, TCP_NOTIFY_UVDM);
 	return 0;
 }
+EXPORT_SYMBOL(tcpci_notify_uvdm);
 #endif	/* CONFIG_USB_PD_CUSTOM_VDM */
 
-#ifdef CONFIG_USB_PD_ALT_MODE_RTDC
+#if CONFIG_USB_PD_ALT_MODE_RTDC
 int tcpci_dc_notify_en_unlock(struct tcpc_device *tcpc)
 {
 	struct tcp_notify tcp_noti;
@@ -935,13 +1074,14 @@ int tcpci_dc_notify_en_unlock(struct tcpc_device *tcpc)
 		TCP_NOTIFY_IDX_MODE, TCP_NOTIFY_DC_EN_UNLOCK);
 	return ret;
 }
+EXPORT_SYMBOL(tcpci_dc_notify_en_unlock);
 #endif	/* CONFIG_USB_PD_ALT_MODE_RTDC */
 
 /* ---- Policy Engine (PD30) ---- */
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
+#if CONFIG_USB_PD_REV30_ALERT_REMOTE
 int tcpci_notify_alert(struct tcpc_device *tcpc, uint32_t ado)
 {
 	struct tcp_notify tcp_noti;
@@ -952,9 +1092,10 @@ int tcpci_notify_alert(struct tcpc_device *tcpc, uint32_t ado)
 		TCP_NOTIFY_IDX_MISC, TCP_NOTIFY_ALERT);
 	return ret;
 }
+EXPORT_SYMBOL(tcpci_notify_alert);
 #endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_STATUS_REMOTE
+#if CONFIG_USB_PD_REV30_STATUS_REMOTE
 int tcpci_notify_status(struct tcpc_device *tcpc, struct pd_status *sdb)
 {
 	struct tcp_notify tcp_noti;
@@ -965,9 +1106,10 @@ int tcpci_notify_status(struct tcpc_device *tcpc, struct pd_status *sdb)
 		TCP_NOTIFY_IDX_MISC, TCP_NOTIFY_STATUS);
 	return ret;
 }
+EXPORT_SYMBOL(tcpci_notify_status);
 #endif	/* CONFIG_USB_PD_REV30_STATUS_REMOTE */
 
-#ifdef CONFIG_USB_PD_REV30_BAT_INFO
+#if CONFIG_USB_PD_REV30_BAT_INFO
 int tcpci_notify_request_bat_info(
 	struct tcpc_device *tcpc, enum pd_battery_reference ref)
 {
@@ -979,9 +1121,7 @@ int tcpci_notify_request_bat_info(
 		TCP_NOTIFY_IDX_MISC, TCP_NOTIFY_REQUEST_BAT_INFO);
 	return ret;
 }
+EXPORT_SYMBOL(tcpci_notify_request_bat_info);
 #endif	/* CONFIG_USB_PD_REV30_BAT_INFO */
-
 #endif	/* CONFIG_USB_PD_REV30 */
-
 #endif	/* CONFIG_USB_POWER_DELIVERY */
-
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpci_alert.c b/drivers/misc/mediatek/typec/tcpc/tcpci_alert.c
index aa58760..fa78184 100644
--- a/drivers/misc/mediatek/typec/tcpc/tcpci_alert.c
+++ b/drivers/misc/mediatek/typec/tcpc/tcpci_alert.c
@@ -1,14 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2021 MediaTek Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
+ * Copyright (c) 2021 MediaTek Inc.
  */
 
 #include <linux/init.h>
@@ -18,18 +10,15 @@
 #include <linux/list.h>
 #include <linux/delay.h>
 #include <linux/cpu.h>
+#include <linux/sched/clock.h>
 
 #include "inc/tcpci.h"
 #include "inc/tcpci_typec.h"
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 #include "inc/tcpci_event.h"
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
-#ifdef CONFIG_DUAL_ROLE_USB_INTF
-#include <linux/usb/class-dual-role.h>
-#endif /* CONFIG_DUAL_ROLE_USB_INTF */
-
 /*
  * [BLOCK] TCPCI IRQ Handler
  */
@@ -39,14 +28,14 @@ static int tcpci_alert_cc_changed(struct tcpc_device *tcpc)
 	return tcpc_typec_handle_cc_change(tcpc);
 }
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 
 static inline int tcpci_alert_vsafe0v(struct tcpc_device *tcpc)
 {
 	tcpc_typec_handle_vsafe0v(tcpc);
 
-#ifdef CONFIG_USB_POWER_DELIVERY
-#ifdef CONFIG_USB_PD_SAFE0V_DELAY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
+#if CONFIG_USB_PD_SAFE0V_DELAY
 	tcpc_enable_timer(tcpc, PD_TIMER_VSAFE0V_DELAY);
 #else
 	pd_put_vbus_safe0v_event(tcpc);
@@ -67,7 +56,7 @@ static inline void tcpci_vbus_level_init_v10(
 			power_status & TCPC_REG_POWER_STATUS_VBUS_PRES ?
 			TCPC_VBUS_VALID : TCPC_VBUS_INVALID;
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	if (power_status & TCPC_REG_POWER_STATUS_EXT_VSAFE0V) {
 		if (tcpc->vbus_level == TCPC_VBUS_INVALID)
 			tcpc->vbus_level = TCPC_VBUS_SAFE0V;
@@ -84,7 +73,7 @@ static inline void __tcpci_vbus_level_refresh(struct tcpc_device *tcpc)
 	tcpc->vbus_level = tcpc->vbus_present ? TCPC_VBUS_VALID :
 			       TCPC_VBUS_INVALID;
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	if (tcpc->vbus_safe0v) {
 		if (tcpc->vbus_level == TCPC_VBUS_INVALID)
 			tcpc->vbus_level = TCPC_VBUS_SAFE0V;
@@ -126,7 +115,7 @@ static inline int tcpci_alert_power_status_changed_v10(struct tcpc_device *tcpc)
 	if (rv < 0)
 		return rv;
 
-#ifdef CONFIG_USB_PD_DIRECT_CHARGE
+#if CONFIG_USB_PD_DIRECT_CHARGE
 	if (tcpc->pd_during_direct_charge && tcpc->vbus_level != 0)
 		show_msg = false;
 #endif	/* CONFIG_USB_PD_DIRECT_CHARGE */
@@ -138,11 +127,11 @@ static inline int tcpci_alert_power_status_changed_v10(struct tcpc_device *tcpc)
 	if (rv < 0)
 		return rv;
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	pd_put_vbus_changed_event(tcpc, true);
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	if (tcpc->vbus_level == TCPC_VBUS_SAFE0V)
 		rv = tcpci_alert_vsafe0v(tcpc);
 #endif	/* CONFIG_TCPC_VSAFE0V_DETECT_IC */
@@ -155,7 +144,7 @@ static inline int tcpci_vbus_level_changed(struct tcpc_device *tcpc)
 	int rv = 0;
 	bool show_msg = true;
 
-#ifdef CONFIG_USB_PD_DIRECT_CHARGE
+#if CONFIG_USB_PD_DIRECT_CHARGE
 	if (tcpc->pd_during_direct_charge && tcpc->vbus_level != 0)
 		show_msg = false;
 #endif	/* CONFIG_USB_PD_DIRECT_CHARGE */
@@ -167,11 +156,11 @@ static inline int tcpci_vbus_level_changed(struct tcpc_device *tcpc)
 	if (rv < 0)
 		return rv;
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	pd_put_vbus_changed_event(tcpc, true);
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	if (tcpc->vbus_level == TCPC_VBUS_SAFE0V)
 		rv = tcpci_alert_vsafe0v(tcpc);
 #endif	/* CONFIG_TCPC_VSAFE0V_DETECT_IC */
@@ -195,7 +184,7 @@ static int tcpci_alert_power_status_changed(struct tcpc_device *tcpc)
 	return rv;
 }
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 static int tcpci_alert_tx_success(struct tcpc_device *tcpc)
 {
 	uint8_t tx_state;
@@ -207,6 +196,11 @@ static int tcpci_alert_tx_success(struct tcpc_device *tcpc)
 	};
 
 	mutex_lock(&tcpc->access_lock);
+#if PD_DYNAMIC_SENDER_RESPONSE
+	tcpc->t[1] = local_clock();
+	tcpc->tx_time_diff = (tcpc->t[1] - tcpc->t[0]) / NSEC_PER_USEC;
+	pd_dbg_info("%s, diff = %d\n", __func__, tcpc->tx_time_diff);
+#endif /* PD_DYNAMIC_SENDER_RESPONSE */
 	tx_state = tcpc->pd_transmit_state;
 	tcpc->pd_transmit_state = PD_TX_STATE_GOOD_CRC;
 	mutex_unlock(&tcpc->access_lock);
@@ -216,6 +210,7 @@ static int tcpci_alert_tx_success(struct tcpc_device *tcpc)
 	else
 		pd_put_event(tcpc, &evt, false);
 
+	pd_dbg_info("%s\n", __func__);
 	return 0;
 }
 
@@ -224,6 +219,9 @@ static int tcpci_alert_tx_failed(struct tcpc_device *tcpc)
 	uint8_t tx_state;
 
 	mutex_lock(&tcpc->access_lock);
+#if PD_DYNAMIC_SENDER_RESPONSE
+	tcpc->tx_time_diff = 0;
+#endif
 	tx_state = tcpc->pd_transmit_state;
 	tcpc->pd_transmit_state = PD_TX_STATE_NO_GOOD_CRC;
 	mutex_unlock(&tcpc->access_lock);
@@ -242,6 +240,9 @@ static int tcpci_alert_tx_discard(struct tcpc_device *tcpc)
 	bool retry_crc_discard = false;
 
 	mutex_lock(&tcpc->access_lock);
+#if PD_DYNAMIC_SENDER_RESPONSE
+	tcpc->tx_time_diff = 0;
+#endif
 	tx_state = tcpc->pd_transmit_state;
 	tcpc->pd_transmit_state = PD_TX_STATE_DISCARD;
 	mutex_unlock(&tcpc->access_lock);
@@ -256,7 +257,7 @@ static int tcpci_alert_tx_discard(struct tcpc_device *tcpc)
 					TCPC_FLAGS_RETRY_CRC_DISCARD) != 0;
 
 		if (retry_crc_discard) {
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 			tcpc->pd_discard_pending = true;
 			tcpc_enable_timer(tcpc, PD_TIMER_DISCARD);
 #else
@@ -337,7 +338,7 @@ static int tcpci_alert_fault(struct tcpc_device *tcpc)
 	return 0;
 }
 
-#ifdef CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
+#if CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
 static int tcpci_alert_wakeup(struct tcpc_device *tcpc)
 {
 	if (tcpc->tcpc_flags & TCPC_FLAGS_LPM_WAKEUP_WATCHDOG) {
@@ -351,7 +352,7 @@ static int tcpci_alert_wakeup(struct tcpc_device *tcpc)
 }
 #endif /* CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG */
 
-#ifdef CONFIG_TYPEC_CAP_RA_DETACH
+#if CONFIG_TYPEC_CAP_RA_DETACH
 static int tcpci_alert_ra_detach(struct tcpc_device *tcpc)
 {
 	if (tcpc->tcpc_flags & TCPC_FLAGS_CHECK_RA_DETACHE) {
@@ -377,7 +378,7 @@ struct tcpci_alert_handler {
 
 static const struct tcpci_alert_handler tcpci_alert_handlers[] = {
 	DECL_TCPCI_ALERT_HANDLER(15, tcpci_alert_vendor_defined),
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	DECL_TCPCI_ALERT_HANDLER(4, tcpci_alert_tx_failed),
 	DECL_TCPCI_ALERT_HANDLER(5, tcpci_alert_tx_discard),
 	DECL_TCPCI_ALERT_HANDLER(6, tcpci_alert_tx_success),
@@ -388,11 +389,11 @@ static const struct tcpci_alert_handler tcpci_alert_handlers[] = {
 	DECL_TCPCI_ALERT_HANDLER(10, tcpci_alert_rx_overflow),
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
-#ifdef CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
+#if CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
 	DECL_TCPCI_ALERT_HANDLER(16, tcpci_alert_wakeup),
 #endif /* CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG */
 
-#ifdef CONFIG_TYPEC_CAP_RA_DETACH
+#if CONFIG_TYPEC_CAP_RA_DETACH
 	DECL_TCPCI_ALERT_HANDLER(21, tcpci_alert_ra_detach),
 #endif /* CONFIG_TYPEC_CAP_RA_DETACH */
 
@@ -401,7 +402,7 @@ static const struct tcpci_alert_handler tcpci_alert_handlers[] = {
 	DECL_TCPCI_ALERT_HANDLER(1, tcpci_alert_power_status_changed),
 };
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 static inline bool tcpci_check_hard_reset_complete(
 	struct tcpc_device *tcpc, uint32_t alert_status)
 {
@@ -422,7 +423,10 @@ static inline bool tcpci_check_hard_reset_complete(
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 int tcpci_alert(struct tcpc_device *tcpc)
 {
-	int rv, i;
+#if !CONFIG_USB_PD_DBG_SKIP_ALERT_HANDLER
+	int i;
+#endif /* CONFIG_USB_PD_DBG_SKIP_ALERT_HANDLER */
+	int rv;
 	uint32_t alert_status;
 	uint32_t alert_mask;
 
@@ -439,7 +443,7 @@ int tcpci_alert(struct tcpc_device *tcpc)
 	if (rv)
 		return rv;
 
-#ifdef CONFIG_USB_PD_DBG_ALERT_STATUS
+#if CONFIG_USB_PD_DBG_ALERT_STATUS
 	if (alert_status != 0)
 		TCPC_INFO("Alert:0x%04x, Mask:0x%04x\n",
 			  alert_status, alert_mask);
@@ -457,14 +461,14 @@ int tcpci_alert(struct tcpc_device *tcpc)
 	    (alert_status & TCPC_REG_ALERT_EXT_VBUS_80))
 		alert_status |= TCPC_REG_ALERT_POWER_STATUS;
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	if (tcpc->pd_transmit_state == PD_TX_STATE_WAIT_HARD_RESET) {
 		tcpci_check_hard_reset_complete(tcpc, alert_status);
 		alert_status &= ~TCPC_REG_ALERT_TX_MASK;
 	}
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
-#ifndef CONFIG_USB_PD_DBG_SKIP_ALERT_HANDLER
+#if !CONFIG_USB_PD_DBG_SKIP_ALERT_HANDLER
 	for (i = 0; i < ARRAY_SIZE(tcpci_alert_handlers); i++) {
 		if (tcpci_alert_handlers[i].bit_mask & alert_status) {
 			if (tcpci_alert_handlers[i].handler != 0)
@@ -485,6 +489,7 @@ int tcpci_alert(struct tcpc_device *tcpc)
 	tcpci_vbus_level_changed(tcpc);
 	return 0;
 }
+EXPORT_SYMBOL(tcpci_alert);
 
 /*
  * [BLOCK] TYPEC device changed
@@ -492,7 +497,7 @@ int tcpci_alert(struct tcpc_device *tcpc)
 
 static inline void tcpci_attach_wake_lock(struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_TCPC_ATTACH_WAKE_LOCK_TOUT
+#if CONFIG_TCPC_ATTACH_WAKE_LOCK_TOUT
 	__pm_wakeup_event(tcpc->attach_wake_lock,
 		CONFIG_TCPC_ATTACH_WAKE_LOCK_TOUT);
 #else
@@ -563,33 +568,12 @@ static inline int tcpci_set_wake_lock_pd(
 static inline int tcpci_report_usb_port_attached(struct tcpc_device *tcpc)
 {
 	TCPC_INFO("usb_port_attached\n");
-#ifdef CONFIG_DUAL_ROLE_USB_INTF
-	switch (tcpc->typec_attach_new) {
-	case TYPEC_ATTACHED_SNK:
-	case TYPEC_ATTACHED_CUSTOM_SRC:
-	case TYPEC_ATTACHED_NORP_SRC:
-		tcpc->dual_role_pr = DUAL_ROLE_PROP_PR_SNK;
-		tcpc->dual_role_dr = DUAL_ROLE_PROP_DR_DEVICE;
-		tcpc->dual_role_mode = DUAL_ROLE_PROP_MODE_UFP;
-		tcpc->dual_role_vconn = DUAL_ROLE_PROP_VCONN_SUPPLY_NO;
-		break;
-	case TYPEC_ATTACHED_SRC:
-		tcpc->dual_role_pr = DUAL_ROLE_PROP_PR_SRC;
-		tcpc->dual_role_dr = DUAL_ROLE_PROP_DR_HOST;
-		tcpc->dual_role_mode = DUAL_ROLE_PROP_MODE_DFP;
-		tcpc->dual_role_vconn = DUAL_ROLE_PROP_VCONN_SUPPLY_YES;
-		break;
-	default:
-		break;
-	}
-	dual_role_instance_changed(tcpc->dr_usb);
-#endif /* CONFIG_DUAL_ROLE_USB_INTF */
 
 	tcpci_set_wake_lock_pd(tcpc, true);
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 
-#ifdef CONFIG_USB_PD_DISABLE_PE
+#if CONFIG_USB_PD_DISABLE_PE
 	if (tcpc->disable_pe)
 		return 0;
 #endif	/* CONFIG_USB_PD_DISABLE_PE */
@@ -604,16 +588,9 @@ static inline int tcpci_report_usb_port_attached(struct tcpc_device *tcpc)
 
 static inline int tcpci_report_usb_port_detached(struct tcpc_device *tcpc)
 {
-	TCPC_INFO("usb_port_detached\n");
-#ifdef CONFIG_DUAL_ROLE_USB_INTF
-	tcpc->dual_role_pr = DUAL_ROLE_PROP_PR_NONE;
-	tcpc->dual_role_dr = DUAL_ROLE_PROP_DR_NONE;
-	tcpc->dual_role_mode = DUAL_ROLE_PROP_MODE_NONE;
-	tcpc->dual_role_vconn = DUAL_ROLE_PROP_VCONN_SUPPLY_NO;
-	dual_role_instance_changed(tcpc->dr_usb);
-#endif /* CONFIG_DUAL_ROLE_USB_INTF */
-
-#ifdef CONFIG_USB_POWER_DELIVERY
+	TCPC_INFO("usb_port_detached\r\n");
+
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	/* MTK Only */
 	if (tcpc->pd_inited_flag)
 		pd_put_cc_detached_event(tcpc);
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpci_core.c b/drivers/misc/mediatek/typec/tcpc/tcpci_core.c
index aebdf77..d079f62 100644
--- a/drivers/misc/mediatek/typec/tcpc/tcpci_core.c
+++ b/drivers/misc/mediatek/typec/tcpc/tcpci_core.c
@@ -1,16 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * Richtek TypeC Port Control Interface Core Driver
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include <linux/init.h>
@@ -25,15 +15,15 @@
 #include "inc/tcpci.h"
 #include "inc/tcpci_typec.h"
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 #include "pd_dpm_prv.h"
 #include "inc/tcpm.h"
-#ifdef CONFIG_RECV_BAT_ABSENT_NOTIFY
+#if CONFIG_RECV_BAT_ABSENT_NOTIFY
 #include "mtk_battery.h"
 #endif /* CONFIG_RECV_BAT_ABSENT_NOTIFY */
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
-#define TCPC_CORE_VERSION		"2.0.17_MTK"
+#define TCPC_CORE_VERSION		"2.0.16_MTK"
 
 static ssize_t tcpc_show_property(struct device *dev,
 				  struct device_attribute *attr, char *buf);
@@ -48,7 +38,7 @@ static ssize_t tcpc_store_property(struct device *dev,
 	.store = tcpc_store_property,					\
 }
 
-static struct class *tcpc_class;
+struct class *tcpc_class;
 EXPORT_SYMBOL_GPL(tcpc_class);
 
 static struct device_type tcpc_dev_type;
@@ -98,14 +88,14 @@ static ssize_t tcpc_show_property(struct device *dev,
 	struct tcpc_device *tcpc = to_tcpc_device(dev);
 	const ptrdiff_t offset = attr - tcpc_device_attributes;
 	int i = 0, ret;
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	struct pe_data *pe_data;
 	struct pd_port *pd_port;
 	struct tcpm_power_cap_val cap;
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
 	switch (offset) {
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	case TCPC_DESC_CAP_INFO:
 		pd_port = &tcpc->pd_port;
 		pe_data = &pd_port->pe_data;
@@ -176,15 +166,15 @@ static ssize_t tcpc_show_property(struct device *dev,
 			break;
 		break;
 	case TCPC_DESC_RP_LEVEL:
-		if (tcpc->typec_local_rp_level == TYPEC_RP_DFT) {
+		if (tcpc->typec_local_rp_level == TYPEC_CC_RP_DFT) {
 			ret = snprintf(buf, 256, "%s\n", "Default");
 			if (ret < 0)
 				break;
-		} else if (tcpc->typec_local_rp_level == TYPEC_RP_1_5) {
+		} else if (tcpc->typec_local_rp_level == TYPEC_CC_RP_1_5) {
 			ret = snprintf(buf, 256, "%s\n", "1.5");
 			if (ret < 0)
 				break;
-		} else if (tcpc->typec_local_rp_level == TYPEC_RP_3_0) {
+		} else if (tcpc->typec_local_rp_level == TYPEC_CC_RP_3_0) {
 			ret = snprintf(buf, 256, "%s\n", "3.0");
 			if (ret < 0)
 				break;
@@ -208,21 +198,21 @@ static ssize_t tcpc_show_property(struct device *dev,
 			256, "role = %s\n", role_text[tcpc->desc.role_def]);
 		if (i < 0)
 			break;
-		if (tcpc->typec_local_rp_level == TYPEC_RP_DFT) {
+		if (tcpc->typec_local_rp_level == TYPEC_CC_RP_DFT) {
 			i += snprintf(buf + i, 256, "rplvl = %s\n", "Default");
 			if (i < 0)
 				break;
-		} else if (tcpc->typec_local_rp_level == TYPEC_RP_1_5) {
+		} else if (tcpc->typec_local_rp_level == TYPEC_CC_RP_1_5) {
 			i += snprintf(buf + i, 256, "rplvl = %s\n", "1.5");
 			if (i < 0)
 				break;
-		} else if (tcpc->typec_local_rp_level == TYPEC_RP_3_0) {
+		} else if (tcpc->typec_local_rp_level == TYPEC_CC_RP_3_0) {
 			i += snprintf(buf + i, 256, "rplvl = %s\n", "3.0");
 			if (i < 0)
 				break;
 		}
 		break;
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	case TCPC_DESC_PE_READY:
 		pd_port = &tcpc->pd_port;
 		if (pd_port->pe_data.pe_ready) {
@@ -264,14 +254,14 @@ static ssize_t tcpc_store_property(struct device *dev,
 				   struct device_attribute *attr,
 				   const char *buf, size_t count)
 {
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	uint8_t role;
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
 	struct tcpc_device *tcpc = to_tcpc_device(dev);
 	const ptrdiff_t offset = attr - tcpc_device_attributes;
 	int ret;
-	long int val;
+	long val;
 
 	switch (offset) {
 	case TCPC_DESC_ROLE_DEF:
@@ -289,7 +279,7 @@ static ssize_t tcpc_store_property(struct device *dev,
 			dev_err(dev, "get parameters fail\n");
 			return -EINVAL;
 		}
-		#ifdef CONFIG_USB_POWER_DELIVERY
+		#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 		if (val > 0 && val <= PD_PE_TIMER_END_ID)
 			pd_enable_timer(&tcpc->pd_port, val);
 		else if (val > PD_PE_TIMER_END_ID && val < PD_TIMER_NR)
@@ -299,7 +289,7 @@ static ssize_t tcpc_store_property(struct device *dev,
 			tcpc_enable_timer(tcpc, val);
 		#endif /* CONFIG_USB_POWER_DELIVERY */
 		break;
-	#ifdef CONFIG_USB_POWER_DELIVERY
+	#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	case TCPC_DESC_PD_TEST:
 		ret = get_parameters((char *)buf, &val, 1);
 		if (ret < 0) {
@@ -374,6 +364,7 @@ struct tcpc_device *tcpc_dev_get_by_name(const char *name)
 			NULL, (const void *)name, tcpc_match_device_by_name);
 	return dev ? dev_get_drvdata(dev) : NULL;
 }
+EXPORT_SYMBOL(tcpc_dev_get_by_name);
 
 static void tcpc_device_release(struct device *dev)
 {
@@ -382,7 +373,7 @@ static void tcpc_device_release(struct device *dev)
 	pr_info("%s : %s device release\n", __func__, dev_name(dev));
 	PD_BUG_ON(tcpc == NULL);
 	/* Un-init pe thread */
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	tcpci_event_deinit(tcpc);
 #endif /* CONFIG_USB_POWER_DELIVERY */
 	/* Un-init timer thread */
@@ -403,7 +394,7 @@ struct tcpc_device *tcpc_device_register(struct device *parent,
 	pr_info("%s register tcpc device (%s)\n", __func__, tcpc_desc->name);
 	tcpc = devm_kzalloc(parent, sizeof(*tcpc), GFP_KERNEL);
 	if (!tcpc) {
-		pr_err("%s : allocate tcpc memeory failed\n", __func__);
+		pr_err("%s : allocate tcpc memory failed\n", __func__);
 		return NULL;
 	}
 
@@ -411,6 +402,7 @@ struct tcpc_device *tcpc_device_register(struct device *parent,
 	for (i = 0; i < TCP_NOTIFY_IDX_NR; i++)
 		srcu_init_notifier_head(&tcpc->evt_nh[i]);
 
+	init_completion(&tcpc->alert_done);
 	mutex_init(&tcpc->access_lock);
 	mutex_init(&tcpc->typec_lock);
 	mutex_init(&tcpc->timer_lock);
@@ -429,7 +421,7 @@ struct tcpc_device *tcpc_device_register(struct device *parent,
 	tcpc->ops = ops;
 	tcpc->typec_local_rp_level = tcpc_desc->rp_lvl;
 
-#ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
+#if CONFIG_TCPC_VCONN_SUPPLY_MODE
 	tcpc->tcpc_vconn_supply = tcpc_desc->vconn_supply;
 #endif	/* CONFIG_TCPC_VCONN_SUPPLY_MODE */
 
@@ -453,25 +445,21 @@ struct tcpc_device *tcpc_device_register(struct device *parent,
 		wakeup_source_register(&tcpc->dev, "tcpc_detach_wake_lock");
 
 	tcpci_timer_init(tcpc);
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	pd_core_init(tcpc);
 #endif /* CONFIG_USB_POWER_DELIVERY */
-#ifdef CONFIG_DUAL_ROLE_USB_INTF
-	ret = tcpc_dual_role_phy_init(tcpc);
-	if (ret < 0)
-		dev_err(&tcpc->dev, "dual role usb init fail\n");
-#endif /* CONFIG_DUAL_ROLE_USB_INTF */
+
 	return tcpc;
 }
 EXPORT_SYMBOL(tcpc_device_register);
 
-static int tcpc_device_irq_enable(struct tcpc_device *tcpc)
+int tcpc_device_irq_enable(struct tcpc_device *tcpc)
 {
 	int ret;
 
 	if (!tcpc->ops->init) {
 		pr_notice("%s Please implment tcpc ops init function\n",
-			  __func__);
+		__func__);
 		return -EINVAL;
 	}
 
@@ -496,8 +484,9 @@ static int tcpc_device_irq_enable(struct tcpc_device *tcpc)
 	pr_info("%s : tcpc irq enable OK!\n", __func__);
 	return 0;
 }
+EXPORT_SYMBOL(tcpc_device_irq_enable);
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 static void bat_update_work_func(struct work_struct *work)
 {
 	struct tcpc_device *tcpc = container_of(work,
@@ -555,15 +544,24 @@ static int bat_nb_call_func(
 
 static void tcpc_event_init_work(struct work_struct *work)
 {
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	struct tcpc_device *tcpc = container_of(
 			work, struct tcpc_device, event_init_work.work);
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	int retval;
 #endif /* CONFIG_USB_PD_REV30 */
 
 	tcpci_lock_typec(tcpc);
 	tcpci_event_init(tcpc);
+#if CONFIG_USB_PD_WAIT_BC12
+	tcpc->chg_psy = devm_power_supply_get_by_phandle(
+		tcpc->dev.parent, "charger");
+	if (IS_ERR_OR_NULL(tcpc->chg_psy)) {
+		tcpci_unlock_typec(tcpc);
+		TCPC_ERR("%s get charger psy fail\n", __func__);
+		return;
+	}
+#endif /* CONFIG_USB_PD_WAIT_BC12 */
 	tcpc->pd_inited_flag = 1; /* MTK Only */
 	pr_info("%s typec attach new = %d\n",
 			__func__, tcpc->typec_attach_new);
@@ -571,7 +569,7 @@ static void tcpc_event_init_work(struct work_struct *work)
 		pd_put_cc_attached_event(tcpc, tcpc->typec_attach_new);
 	tcpci_unlock_typec(tcpc);
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	INIT_DELAYED_WORK(&tcpc->bat_update_work, bat_update_work_func);
 	tcpc->bat_psy = power_supply_get_by_name("battery");
 	if (!tcpc->bat_psy) {
@@ -595,7 +593,7 @@ static void tcpc_init_work(struct work_struct *work)
 	struct tcpc_device *tcpc = container_of(
 		work, struct tcpc_device, init_work.work);
 
-#ifndef CONFIG_TCPC_NOTIFIER_LATE_SYNC
+#if !CONFIG_TCPC_NOTIFIER_LATE_SYNC
 	if (tcpc->desc.notifier_supply_num == 0)
 		return;
 #endif
@@ -607,7 +605,7 @@ static void tcpc_init_work(struct work_struct *work)
 
 int tcpc_schedule_init_work(struct tcpc_device *tcpc)
 {
-#ifndef CONFIG_TCPC_NOTIFIER_LATE_SYNC
+#if !CONFIG_TCPC_NOTIFIER_LATE_SYNC
 	if (tcpc->desc.notifier_supply_num == 0)
 		return tcpc_device_irq_enable(tcpc);
 
@@ -618,6 +616,7 @@ int tcpc_schedule_init_work(struct tcpc_device *tcpc)
 #endif
 	return 0;
 }
+EXPORT_SYMBOL(tcpc_schedule_init_work);
 
 struct tcp_notifier_block_wrapper {
 	struct notifier_block stub_nb;
@@ -728,7 +727,7 @@ int register_tcp_dev_notifier(struct tcpc_device *tcp_dev,
 		}
 	}
 
-#ifndef CONFIG_TCPC_NOTIFIER_LATE_SYNC
+#if !CONFIG_TCPC_NOTIFIER_LATE_SYNC
 	if (tcp_dev->desc.notifier_supply_num == 0) {
 		pr_info("%s already started\n", __func__);
 		return 0;
@@ -820,14 +819,11 @@ void tcpc_device_unregister(struct device *dev, struct tcpc_device *tcpc)
 
 	tcpc_typec_deinit(tcpc);
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	wakeup_source_unregister(tcpc->pd_port.pps_request_wake_lock);
 #endif /* CONFIG_USB_PD_REV30 */
 	wakeup_source_unregister(tcpc->detach_wake_lock);
 	wakeup_source_unregister(tcpc->attach_wake_lock);
-#ifdef CONFIG_DUAL_ROLE_USB_INTF
-	devm_dual_role_instance_unregister(&tcpc->dev, tcpc->dr_usb);
-#endif /* CONFIG_DUAL_ROLE_USB_INTF */
 
 	device_unregister(&tcpc->dev);
 
@@ -844,11 +840,13 @@ void tcpci_lock_typec(struct tcpc_device *tcpc)
 {
 	mutex_lock(&tcpc->typec_lock);
 }
+EXPORT_SYMBOL(tcpci_lock_typec);
 
 void tcpci_unlock_typec(struct tcpc_device *tcpc)
 {
 	mutex_unlock(&tcpc->typec_lock);
 }
+EXPORT_SYMBOL(tcpci_unlock_typec);
 
 static void tcpc_init_attrs(struct device_type *dev_type)
 {
@@ -863,7 +861,7 @@ static int __init tcpc_class_init(void)
 {
 	pr_info("%s (%s)\n", __func__, TCPC_CORE_VERSION);
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	dpm_check_supported_modes();
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
@@ -874,8 +872,6 @@ static int __init tcpc_class_init(void)
 		return PTR_ERR(tcpc_class);
 	}
 	tcpc_init_attrs(&tcpc_dev_type);
-	tcpc_class->suspend = NULL;
-	tcpc_class->resume = NULL;
 
 	pr_info("TCPC class init OK\n");
 	return 0;
@@ -890,89 +886,12 @@ static void __exit tcpc_class_exit(void)
 subsys_initcall(tcpc_class_init);
 module_exit(tcpc_class_exit);
 
-
-#ifdef CONFIG_USB_POWER_DELIVERY
-#ifdef CONFIG_TCPC_NOTIFIER_LATE_SYNC
-#ifdef CONFIG_RECV_BAT_ABSENT_NOTIFY
-static int fg_bat_notifier_call(struct notifier_block *nb,
-				unsigned long event, void *data)
-{
-	struct pd_port *pd_port = container_of(nb, struct pd_port, fg_bat_nb);
-	struct tcpc_device *tcpc = pd_port->tcpc;
-
-	switch (event) {
-	case EVENT_BATTERY_PLUG_OUT:
-		dev_info(&tcpc->dev, "%s: fg battery absent\n", __func__);
-		schedule_work(&pd_port->fg_bat_work);
-		break;
-	default:
-		break;
-	}
-	return NOTIFY_OK;
-}
-#endif /* CONFIG_RECV_BAT_ABSENT_NOTIFY */
-#endif /* CONFIG_TCPC_NOTIFIER_LATE_SYNC */
-#endif /* CONFIG_USB_POWER_DELIVERY */
-
-#ifdef CONFIG_TCPC_NOTIFIER_LATE_SYNC
-static int __tcpc_class_complete_work(struct device *dev, void *data)
-{
-	struct tcpc_device *tcpc = dev_get_drvdata(dev);
-#ifdef CONFIG_USB_POWER_DELIVERY
-#ifdef CONFIG_RECV_BAT_ABSENT_NOTIFY
-	struct notifier_block *fg_bat_nb = &tcpc->pd_port.fg_bat_nb;
-	int ret = 0;
-#endif /* CONFIG_RECV_BAT_ABSENT_NOTIFY */
-#endif /* CONFIG_USB_POWER_DELIVERY */
-
-	if (tcpc != NULL) {
-		pr_info("%s = %s\n", __func__, dev_name(dev));
-#if 1
-		tcpc_device_irq_enable(tcpc);
-#else
-		schedule_delayed_work(&tcpc->init_work,
-			msecs_to_jiffies(1000));
-#endif
-
-#ifdef CONFIG_USB_POWER_DELIVERY
-#ifdef CONFIG_RECV_BAT_ABSENT_NOTIFY
-		fg_bat_nb->notifier_call = fg_bat_notifier_call;
-#if CONFIG_MTK_GAUGE_VERSION == 30
-		ret = register_battery_notifier(fg_bat_nb);
-#endif
-		if (ret < 0) {
-			pr_notice("%s: register bat notifier fail\n", __func__);
-			return -EINVAL;
-		}
-#endif /* CONFIG_RECV_BAT_ABSENT_NOTIFY */
-#endif /* CONFIG_USB_POWER_DELIVERY */
-	}
-	return 0;
-}
-
-static int __init tcpc_class_complete_init(void)
-{
-	if (!IS_ERR(tcpc_class)) {
-		class_for_each_device(tcpc_class, NULL, NULL,
-			__tcpc_class_complete_work);
-	}
-	return 0;
-}
-late_initcall_sync(tcpc_class_complete_init);
-#endif /* CONFIG_TCPC_NOTIFIER_LATE_SYNC */
-
 MODULE_DESCRIPTION("Richtek TypeC Port Control Core");
 MODULE_AUTHOR("Jeff Chang <jeff_chang@richtek.com>");
 MODULE_VERSION(TCPC_CORE_VERSION);
 MODULE_LICENSE("GPL");
 
 /* Release Version
- * 2.0.17_MTK
- * (1) Add CONFIG_TYPEC_LEGACY3_ALWAYS_LOCAL_RP
- * (2) Fix a synchronization/locking problem in pd_notify_pe_error_recovery()
- * (3) Add USB_VID_MQP
- * (4) Revise the return value checking of tcpc_device_register()
- *
  * 2.0.16_MTK
  * (1) Check the return value of wait_event_interruptible()
  * (2) Revise *_get_cc()
@@ -1013,7 +932,7 @@ MODULE_LICENSE("GPL");
  *
  * 2.0.13_MTK
  * (1) Add TCPC flags for VCONN_SAFE5V_ONLY
- * (2) Add boolean property attemp_discover_svid in dts/dtsi
+ * (2) Add boolean property attempt_discover_svid in dts/dtsi
  * (3) Add a TCPM API for postponing Type-C role change until unattached
  * (4) Update VDOs according new PD spec
  * (5) Add an option for enabling/disabling the support of DebugAccessory.SRC
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpci_dual_role.c b/drivers/misc/mediatek/typec/tcpc/tcpci_dual_role.c
deleted file mode 100644
index 1dcf1ff..0000000
--- a/drivers/misc/mediatek/typec/tcpc/tcpci_dual_role.c
+++ /dev/null
@@ -1,291 +0,0 @@
-/*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * TCPC Interface for dual role
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/slab.h>
-#include <linux/of.h>
-#include "inc/tcpci.h"
-#include "inc/tcpci_typec.h"
-
-#ifdef CONFIG_DUAL_ROLE_USB_INTF
-static enum dual_role_property tcpc_dual_role_props[] = {
-	DUAL_ROLE_PROP_SUPPORTED_MODES,
-	DUAL_ROLE_PROP_MODE,
-	DUAL_ROLE_PROP_PR,
-	DUAL_ROLE_PROP_DR,
-	DUAL_ROLE_PROP_VCONN_SUPPLY,
-};
-
-static int tcpc_dual_role_get_prop(struct dual_role_phy_instance *dual_role,
-			enum dual_role_property prop, unsigned int *val)
-{
-	struct tcpc_device *tcpc = dev_get_drvdata(dual_role->dev.parent);
-	int ret = 0;
-
-	switch (prop) {
-	case DUAL_ROLE_PROP_SUPPORTED_MODES:
-		*val = tcpc->dual_role_supported_modes;
-		break;
-	case DUAL_ROLE_PROP_MODE:
-		*val = tcpc->dual_role_mode;
-		break;
-	case DUAL_ROLE_PROP_PR:
-		*val = tcpc->dual_role_pr;
-		break;
-	case DUAL_ROLE_PROP_DR:
-		*val = tcpc->dual_role_dr;
-		break;
-	case DUAL_ROLE_PROP_VCONN_SUPPLY:
-		*val = tcpc->dual_role_vconn;
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
-	return ret;
-}
-
-static	int tcpc_dual_role_prop_is_writeable(
-	struct dual_role_phy_instance *dual_role, enum dual_role_property prop)
-{
-	int retval = -EINVAL;
-	struct tcpc_device *tcpc = dev_get_drvdata(dual_role->dev.parent);
-
-	switch (prop) {
-#ifdef CONFIG_USB_POWER_DELIVERY
-	case DUAL_ROLE_PROP_PR:
-	case DUAL_ROLE_PROP_DR:
-	case DUAL_ROLE_PROP_VCONN_SUPPLY:
-#else
-	case DUAL_ROLE_PROP_MODE:
-#endif	/* CONFIG_USB_POWER_DELIVERY */
-		if (tcpc->dual_role_supported_modes ==
-			DUAL_ROLE_SUPPORTED_MODES_DFP_AND_UFP)
-			retval = 1;
-		break;
-	default:
-		break;
-	}
-	return retval;
-}
-
-#ifdef CONFIG_USB_POWER_DELIVERY
-
-static int tcpc_dual_role_set_prop_pr(
-	struct tcpc_device *tcpc, unsigned int val)
-{
-	int ret;
-	uint8_t role;
-
-	switch (val) {
-	case DUAL_ROLE_PROP_PR_SRC:
-		role = PD_ROLE_SOURCE;
-		break;
-	case DUAL_ROLE_PROP_PR_SNK:
-		role = PD_ROLE_SINK;
-		break;
-	default:
-		return 0;
-	}
-
-	if (val == tcpc->dual_role_pr) {
-		pr_info("%s wrong role (%d->%d)\n",
-			__func__, tcpc->dual_role_pr, val);
-		return 0;
-	}
-
-	ret = tcpm_dpm_pd_power_swap(tcpc, role, NULL);
-	pr_info("%s power role swap (%d->%d): %d\n",
-		__func__, tcpc->dual_role_pr, val, ret);
-
-	if (ret == TCPM_ERROR_NO_PD_CONNECTED) {
-		ret = tcpm_typec_role_swap(tcpc);
-		pr_info("%s typec role swap (%d->%d): %d\n",
-			__func__, tcpc->dual_role_pr, val, ret);
-	}
-
-	return ret;
-}
-
-static int tcpc_dual_role_set_prop_dr(
-	struct tcpc_device *tcpc, unsigned int val)
-{
-	int ret;
-	uint8_t role;
-
-	switch (val) {
-	case DUAL_ROLE_PROP_DR_HOST:
-		role = PD_ROLE_DFP;
-		break;
-	case DUAL_ROLE_PROP_DR_DEVICE:
-		role = PD_ROLE_UFP;
-		break;
-	default:
-		return 0;
-	}
-
-	if (val == tcpc->dual_role_dr) {
-		pr_info("%s wrong role (%d->%d)\n",
-			__func__, tcpc->dual_role_dr, val);
-		return 0;
-	}
-
-	ret = tcpm_dpm_pd_data_swap(tcpc, role, NULL);
-	pr_info("%s data role swap (%d->%d): %d\n",
-		__func__, tcpc->dual_role_dr, val, ret);
-
-	return ret;
-}
-
-static int tcpc_dual_role_set_prop_vconn(
-	struct tcpc_device *tcpc, unsigned int val)
-{
-	int ret;
-	uint8_t role;
-
-	switch (val) {
-	case DUAL_ROLE_PROP_VCONN_SUPPLY_NO:
-		role = PD_ROLE_VCONN_OFF;
-		break;
-	case DUAL_ROLE_PROP_VCONN_SUPPLY_YES:
-		role = PD_ROLE_VCONN_ON;
-		break;
-	default:
-		return 0;
-	}
-
-	if (val == tcpc->dual_role_vconn) {
-		pr_info("%s wrong role (%d->%d)\n",
-			__func__, tcpc->dual_role_vconn, val);
-		return 0;
-	}
-
-	ret = tcpm_dpm_pd_vconn_swap(tcpc, role, NULL);
-	pr_info("%s vconn swap (%d->%d): %d\n",
-		__func__, tcpc->dual_role_vconn, val, ret);
-
-	return ret;
-}
-
-#else	/* TypeC Only */
-
-static int tcpc_dual_role_set_prop_mode(
-	struct tcpc_device *tcpc, unsigned int val)
-{
-	int ret;
-
-	if (val == tcpc->dual_role_mode) {
-		pr_info("%s wrong role (%d->%d)\n",
-			__func__, tcpc->dual_role_mode, val);
-		return 0;
-	}
-
-	ret = tcpm_typec_role_swap(tcpc);
-	pr_info("%s typec role swap (%d->%d): %d\n",
-		__func__, tcpc->dual_role_mode, val, ret);
-
-	return ret;
-}
-
-#endif	/* CONFIG_USB_POWER_DELIVERY */
-
-static int tcpc_dual_role_set_prop(struct dual_role_phy_instance *dual_role,
-			enum dual_role_property prop, const unsigned int *val)
-{
-	struct tcpc_device *tcpc = dev_get_drvdata(dual_role->dev.parent);
-
-	switch (prop) {
-#ifdef CONFIG_USB_POWER_DELIVERY
-	case DUAL_ROLE_PROP_PR:
-		tcpc_dual_role_set_prop_pr(tcpc, *val);
-		break;
-	case DUAL_ROLE_PROP_DR:
-		tcpc_dual_role_set_prop_dr(tcpc, *val);
-		break;
-	case DUAL_ROLE_PROP_VCONN_SUPPLY:
-		tcpc_dual_role_set_prop_vconn(tcpc, *val);
-		break;
-#else /* TypeC Only */
-	case DUAL_ROLE_PROP_MODE:
-		tcpc_dual_role_set_prop_mode(tcpc, *val);
-		break;
-#endif /* CONFIG_USB_POWER_DELIVERY */
-
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static void tcpc_get_dual_desc(struct tcpc_device *tcpc)
-{
-	struct device_node *np = of_find_node_by_name(NULL, tcpc->desc.name);
-	u32 val;
-
-	if (!np)
-		return;
-
-	if (of_property_read_u32(np, "tcpc-dual,supported_modes", &val) >= 0) {
-		if (val > DUAL_ROLE_PROP_SUPPORTED_MODES_TOTAL)
-			tcpc->dual_role_supported_modes =
-					DUAL_ROLE_SUPPORTED_MODES_DFP_AND_UFP;
-		else
-			tcpc->dual_role_supported_modes = val;
-	}
-}
-
-int tcpc_dual_role_phy_init(
-			struct tcpc_device *tcpc)
-{
-	struct dual_role_phy_desc *dual_desc;
-	int len;
-	char *str_name;
-
-	tcpc->dr_usb = devm_kzalloc(&tcpc->dev,
-				sizeof(*tcpc->dr_usb), GFP_KERNEL);
-
-	dual_desc = devm_kzalloc(&tcpc->dev, sizeof(*dual_desc), GFP_KERNEL);
-	if (!dual_desc)
-		return -ENOMEM;
-
-	tcpc_get_dual_desc(tcpc);
-
-	len = strlen(tcpc->desc.name);
-	str_name = devm_kzalloc(&tcpc->dev, len+11, GFP_KERNEL);
-	snprintf(str_name, PAGE_SIZE, "dual-role-%s", tcpc->desc.name);
-	dual_desc->name = str_name;
-
-	dual_desc->properties = tcpc_dual_role_props;
-	dual_desc->num_properties = ARRAY_SIZE(tcpc_dual_role_props);
-	dual_desc->get_property = tcpc_dual_role_get_prop;
-	dual_desc->set_property = tcpc_dual_role_set_prop;
-	dual_desc->property_is_writeable = tcpc_dual_role_prop_is_writeable;
-
-	tcpc->dr_usb = devm_dual_role_instance_register(&tcpc->dev, dual_desc);
-	if (IS_ERR(tcpc->dr_usb)) {
-		dev_err(&tcpc->dev, "tcpc fail to register dual role usb\n");
-		return -EINVAL;
-	}
-	/* init dual role phy instance property */
-	tcpc->dual_role_pr = DUAL_ROLE_PROP_PR_NONE;
-	tcpc->dual_role_dr = DUAL_ROLE_PROP_DR_NONE;
-	tcpc->dual_role_mode = DUAL_ROLE_PROP_MODE_NONE;
-	tcpc->dual_role_vconn = DUAL_ROLE_PROP_VCONN_SUPPLY_NO;
-	return 0;
-}
-#endif /* CONFIG_DUAL_ROLE_USB_INTF */
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpci_event.c b/drivers/misc/mediatek/typec/tcpc/tcpci_event.c
index f399040..9493d68 100644
--- a/drivers/misc/mediatek/typec/tcpc/tcpci_event.c
+++ b/drivers/misc/mediatek/typec/tcpc/tcpci_event.c
@@ -1,16 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * TCPC Interface for event handler
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include <linux/kthread.h>
@@ -29,7 +19,7 @@
 #include "inc/pd_policy_engine.h"
 #include "inc/pd_dpm_core.h"
 
-#ifdef CONFIG_USB_PD_POSTPONE_VDM
+#if CONFIG_USB_PD_POSTPONE_VDM
 static void postpone_vdm_event(struct tcpc_device *tcpc)
 {
 	/*
@@ -167,7 +157,7 @@ static bool __pd_put_event(struct tcpc_device *tcpc,
 {
 	int index;
 
-#ifdef CONFIG_USB_PD_POSTPONE_OTHER_VDM
+#if CONFIG_USB_PD_POSTPONE_OTHER_VDM
 	if (from_port_partner)
 		postpone_vdm_event(tcpc);
 #endif	/* CONFIG_USB_PD_POSTPONE_OTHER_VDM */
@@ -226,7 +216,7 @@ static inline bool pd_check_vdm_state_ready(struct pd_port *pd_port)
 	switch (pd_port->pe_vdm_state) {
 	case PE_SNK_READY:
 	case PE_SRC_READY:
-#ifdef CONFIG_USB_PD_CUSTOM_DBGACC
+#if CONFIG_USB_PD_CUSTOM_DBGACC
 	case PE_DBG_READY:
 #endif	/* CONFIG_USB_PD_CUSTOM_DBGACC */
 		return true;
@@ -385,7 +375,7 @@ bool pd_put_vdm_event(struct tcpc_device *tcpc,
 		tcpc->pd_last_vdm_msg = *pd_msg;
 		reset_pe_vdm_state(tcpc, pd_msg->payload[0]);
 
-#ifdef CONFIG_USB_PD_POSTPONE_FIRST_VDM
+#if CONFIG_USB_PD_POSTPONE_FIRST_VDM
 		postpone_vdm_event(tcpc);
 		mutex_unlock(&tcpc->access_lock);
 		return true;
@@ -433,7 +423,7 @@ bool pd_put_last_vdm_event(struct tcpc_device *tcpc)
 	tcpc->pd_pending_vdm_event = true;
 	tcpc->pd_postpone_vdm_timeout = true;
 
-#ifdef CONFIG_USB_PD_POSTPONE_RETRY_VDM
+#if CONFIG_USB_PD_POSTPONE_RETRY_VDM
 	postpone_vdm_event(tcpc);
 #endif	/* CONFIG_USB_PD_POSTPONE_RETRY_VDM */
 
@@ -471,8 +461,8 @@ bool pd_get_deferred_tcp_event(
 
 	mutex_lock(&tcpc->access_lock);
 	ret = __pd_get_deferred_tcp_event(tcpc, tcp_event);
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	if (tcpc->tcp_event_count)
 		tcpc_restart_timer(tcpc, PD_TIMER_DEFERRED_EVT);
 	else
@@ -537,8 +527,8 @@ bool pd_put_deferred_tcp_event(
 	}
 
 	ret = __pd_put_deferred_tcp_event(tcpc, tcp_event);
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	if (ret)
 		pd_port->pe_data.pd_traffic_idle = false;
 	if (tcpc->tcp_event_count == 1)
@@ -557,7 +547,7 @@ unlock_out:
 
 void pd_notify_tcp_vdm_event_2nd_result(struct pd_port *pd_port, uint8_t ret)
 {
-#ifdef CONFIG_USB_PD_TCPM_CB_2ND
+#if CONFIG_USB_PD_TCPM_CB_2ND
 	struct tcp_dpm_event *tcp_event = &pd_port->tcp_event;
 
 	if (pd_port->tcp_event_id_2nd  == TCP_DPM_EVT_UNKONW)
@@ -576,7 +566,7 @@ void pd_notify_tcp_vdm_event_2nd_result(struct pd_port *pd_port, uint8_t ret)
 
 void pd_notify_tcp_event_2nd_result(struct pd_port *pd_port, int ret)
 {
-#ifdef CONFIG_USB_PD_TCPM_CB_2ND
+#if CONFIG_USB_PD_TCPM_CB_2ND
 	struct tcp_dpm_event *tcp_event = &pd_port->tcp_event;
 	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
@@ -629,7 +619,7 @@ void pd_notify_tcp_event_1st_result(struct pd_port *pd_port, int ret)
 	TCPC_DBG2("tcp_event_1st:evt%d=%d\n",
 		pd_port->tcp_event_id_1st, ret);
 
-#ifdef CONFIG_USB_PD_TCPM_CB_2ND
+#if CONFIG_USB_PD_TCPM_CB_2ND
 	if (ret == TCP_DPM_RET_SENT) {
 		cb = false;
 		pd_port->tcp_event_id_2nd = tcp_event->event_id;
@@ -751,13 +741,21 @@ bool pd_put_cc_attached_event(
 		struct tcpc_device *tcpc, uint8_t type)
 {
 	bool ret = false;
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
+#if CONFIG_USB_PD_WAIT_BC12
+	int rv = 0;
+	union power_supply_propval val = {.intval = 0};
+#endif /* CONFIG_USB_PD_WAIT_BC12 */
+#endif /* CONFIG_USB_POWER_DELIVERY */
 
 	mutex_lock(&tcpc->access_lock);
 
-#ifdef CONFIG_USB_POWER_DELIVERY
-#ifdef CONFIG_USB_PD_WAIT_BC12
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
+#if CONFIG_USB_PD_WAIT_BC12
+	rv = power_supply_get_property(tcpc->chg_psy,
+		POWER_SUPPLY_PROP_USB_TYPE, &val);
 	if ((type == TYPEC_ATTACHED_SNK || type == TYPEC_ATTACHED_DBGACC_SNK) &&
-		mt_get_charger_type() == CHARGER_UNKNOWN) {
+		(rv < 0 || val.intval == POWER_SUPPLY_USB_TYPE_UNKNOWN)) {
 		tcpc->pd_wait_bc12_count = 1;
 		tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_PD_WAIT_BC12);
 		mutex_unlock(&tcpc->access_lock);
@@ -779,8 +777,8 @@ void pd_put_cc_detached_event(struct tcpc_device *tcpc)
 {
 	mutex_lock(&tcpc->access_lock);
 
-#ifdef CONFIG_USB_POWER_DELIVERY
-#ifdef CONFIG_USB_PD_WAIT_BC12
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
+#if CONFIG_USB_PD_WAIT_BC12
 	tcpc->pd_wait_bc12_count = 0;
 	tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_PD_WAIT_BC12);
 #endif /* CONFIG_USB_PD_WAIT_BC12 */
@@ -800,11 +798,11 @@ void pd_put_cc_detached_event(struct tcpc_device *tcpc)
 	tcpc->pd_bist_mode = PD_BIST_MODE_DISABLE;
 	tcpc->pd_ping_event_pending = false;
 
-#ifdef CONFIG_USB_PD_DIRECT_CHARGE
+#if CONFIG_USB_PD_DIRECT_CHARGE
 	tcpc->pd_during_direct_charge = false;
 #endif	/* CONFIG_USB_PD_DIRECT_CHARGE */
 
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 	tcpc->pd_discard_pending = false;
 #endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
 
@@ -829,12 +827,12 @@ void pd_put_recv_hard_reset_event(struct tcpc_device *tcpc)
 		tcpc->pd_hard_reset_event_pending = true;
 		tcpc->pd_ping_event_pending = false;
 
-#ifdef CONFIG_USB_PD_DIRECT_CHARGE
+#if CONFIG_USB_PD_DIRECT_CHARGE
 		tcpc->pd_during_direct_charge = false;
 #endif	/* CONFIG_USB_PD_DIRECT_CHARGE */
 	}
 
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 	tcpc->pd_discard_pending = false;
 #endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
 
@@ -860,7 +858,7 @@ bool pd_put_pd_msg_event(struct tcpc_device *tcpc, struct pd_msg *pd_msg)
 {
 	uint32_t cnt, cmd, extend;
 
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 	bool discard_pending = false;
 #endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
 
@@ -882,7 +880,7 @@ bool pd_put_pd_msg_event(struct tcpc_device *tcpc, struct pd_msg *pd_msg)
 		return 0;
 	}
 
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 	if (tcpc->pd_discard_pending &&
 		(pd_msg->frame_type == TCPC_TX_SOP) &&
 		(tcpc->tcpc_flags & TCPC_FLAGS_RETRY_CRC_DISCARD)) {
@@ -903,7 +901,7 @@ bool pd_put_pd_msg_event(struct tcpc_device *tcpc, struct pd_msg *pd_msg)
 	}
 #endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
 
-#ifdef CONFIG_USB_PD_DROP_REPEAT_PING
+#if CONFIG_USB_PD_DROP_REPEAT_PING
 	if (cnt == 0 && cmd == PD_CTRL_PING) {
 		/* reset ping_test_mode only if cc_detached */
 		if (!tcpc->pd_ping_event_pending) {
@@ -923,7 +921,7 @@ bool pd_put_pd_msg_event(struct tcpc_device *tcpc, struct pd_msg *pd_msg)
 
 	mutex_unlock(&tcpc->access_lock);
 
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 	if (discard_pending) {
 		tcpc_disable_timer(tcpc, PD_TIMER_DISCARD);
 		pd_put_hw_event(tcpc, PD_HW_TX_DISCARD);
@@ -983,7 +981,7 @@ void pd_put_vbus_changed_event(struct tcpc_device *tcpc, bool from_ic)
 
 void pd_put_vbus_safe0v_event(struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_USB_PD_SAFE0V_TIMEOUT
+#if CONFIG_USB_PD_SAFE0V_TIMEOUT
 	tcpc_disable_timer(tcpc, PD_TIMER_VSAFE0V_TOUT);
 #endif	/* CONFIG_USB_PD_SAFE0V_TIMEOUT */
 
@@ -1001,7 +999,7 @@ void pd_put_vbus_stable_event(struct tcpc_device *tcpc)
 	mutex_lock(&tcpc->access_lock);
 	if (tcpc->pd_wait_vbus_once == PD_WAIT_VBUS_STABLE_ONCE) {
 		tcpc->pd_wait_vbus_once = PD_WAIT_VBUS_DISABLE;
-#ifdef CONFIG_USB_PD_SRC_HIGHCAP_POWER
+#if CONFIG_USB_PD_SRC_HIGHCAP_POWER
 		tcpci_enable_force_discharge(tcpc, false, 0);
 #endif	/* CONFIG_USB_PD_SRC_HIGHCAP_POWER */
 		__pd_put_hw_event(tcpc, PD_HW_VBUS_STABLE);
@@ -1063,7 +1061,7 @@ void pd_notify_pe_wait_vbus_once(struct pd_port *pd_port, int wait_evt)
 		break;
 
 	case PD_WAIT_VBUS_SAFE0V_ONCE:
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT
+#if CONFIG_TCPC_VSAFE0V_DETECT
 		if (tcpci_check_vsafe0v(tcpc, true)) {
 			pd_put_vbus_safe0v_event(tcpc);
 			break;
@@ -1072,7 +1070,7 @@ void pd_notify_pe_wait_vbus_once(struct pd_port *pd_port, int wait_evt)
 		pd_enable_timer(pd_port, PD_TIMER_VSAFE0V_DELAY);
 #endif	/* CONFIG_TCPC_VSAFE0V_DETECT */
 
-#ifdef CONFIG_USB_PD_SAFE0V_TIMEOUT
+#if CONFIG_USB_PD_SAFE0V_TIMEOUT
 		pd_enable_timer(pd_port, PD_TIMER_VSAFE0V_TOUT);
 #endif	/* CONFIG_USB_PD_SAFE0V_TIMEOUT */
 
@@ -1096,12 +1094,10 @@ void pd_notify_pe_error_recovery(struct pd_port *pd_port)
 	__tcp_event_buf_reset(tcpc, TCP_DPM_RET_DROP_ERROR_REOCVERY);
 	mutex_unlock(&tcpc->access_lock);
 
-	tcpci_lock_typec(tcpc);
 	tcpc_typec_error_recovery(tcpc);
-	tcpci_unlock_typec(tcpc);
 }
 
-#ifdef CONFIG_USB_PD_RECV_HRESET_COUNTER
+#if CONFIG_USB_PD_RECV_HRESET_COUNTER
 void pd_notify_pe_over_recv_hreset(struct pd_port *pd_port)
 {
 	struct tcpc_device *tcpc = pd_port->tcpc;
@@ -1133,7 +1129,7 @@ void pd_notify_pe_transit_to_default(struct pd_port *pd_port)
 	tcpc->pd_wait_pr_swap_complete = false;
 	tcpc->pd_bist_mode = PD_BIST_MODE_DISABLE;
 
-#ifdef CONFIG_USB_PD_DIRECT_CHARGE
+#if CONFIG_USB_PD_DIRECT_CHARGE
 	tcpc->pd_during_direct_charge = false;
 #endif	/* CONFIG_USB_PD_DIRECT_CHARGE */
 	mutex_unlock(&tcpc->access_lock);
@@ -1251,7 +1247,7 @@ void pd_notify_pe_pr_changed(struct pd_port *pd_port)
 
 void pd_notify_pe_snk_explicit_contract(struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	struct pe_data *pe_data = &pd_port->pe_data;
 	struct tcpc_device *tcpc = pd_port->tcpc;
 
@@ -1263,7 +1259,7 @@ void pd_notify_pe_snk_explicit_contract(struct pd_port *pd_port)
 	else
 		pe_data->pd_traffic_control = PD_SINK_TX_NG;
 
-#ifdef CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
+#if CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
 	if (pe_data->pd_traffic_control == PD_SINK_TX_OK) {
 		pe_data->pd_traffic_control = PD_SINK_TX_START;
 		pd_restart_timer(pd_port, PD_TIMER_SNK_FLOW_DELAY);
@@ -1280,8 +1276,8 @@ void pd_notify_pe_src_explicit_contract(struct pd_port *pd_port)
 	struct tcpc_device *tcpc = pd_port->tcpc;
 
 	if (pe_data->explicit_contract) {
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
-#ifdef CONFIG_USB_PD_REV30_SRC_FLOW_DELAY_STARTUP
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_SRC_FLOW_DELAY_STARTUP
 		if (pd_check_rev30(pd_port) &&
 			(pe_data->pd_traffic_control == PD_SOURCE_TX_START))
 			pd_restart_timer(pd_port, PD_TIMER_SINK_TX);
@@ -1290,14 +1286,14 @@ void pd_notify_pe_src_explicit_contract(struct pd_port *pd_port)
 		return;
 	}
 
-	if (tcpc->typec_local_rp_level == TYPEC_RP_DFT)
-		pull = TYPEC_CC_RP_1_5;
+	if (tcpc->typec_local_rp_level == TYPEC_CC_RP_DFT)
+		pull = TYPEC_CC_RP_3_0;
 
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	if (pd_check_rev30(pd_port)) {
 		pull = TYPEC_CC_RP_3_0;
 
-#ifdef CONFIG_USB_PD_REV30_SRC_FLOW_DELAY_STARTUP
+#if CONFIG_USB_PD_REV30_SRC_FLOW_DELAY_STARTUP
 		pe_data->pd_traffic_control = PD_SOURCE_TX_START;
 		pd_enable_timer(pd_port, PD_TIMER_SINK_TX);
 #else
@@ -1313,12 +1309,12 @@ void pd_notify_pe_src_explicit_contract(struct pd_port *pd_port)
 	}
 }
 
-#ifdef CONFIG_USB_PD_DIRECT_CHARGE
+#if CONFIG_USB_PD_DIRECT_CHARGE
 void pd_notify_pe_direct_charge(struct pd_port *pd_port, bool en)
 {
 	struct tcpc_device *tcpc = pd_port->tcpc;
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 	/* TODO: check it later */
 	if (pd_port->request_apdo)
 		en = true;
@@ -1354,9 +1350,11 @@ static int tcpc_event_thread_fn(void *data)
 			dev_notice(&tcpc->dev, "%s exits(%d)\n", __func__, ret);
 			break;
 		}
+		atomic_inc(&tcpc->suspend_pending);
 		do {
 			atomic_dec_if_positive(&tcpc->pending_event);
 		} while (pd_policy_engine_run(tcpc) && !kthread_should_stop());
+		atomic_dec_if_positive(&tcpc->suspend_pending);
 	}
 
 	return 0;
diff --git a/./tcpci_late_sync.c b/drivers/misc/mediatek/typec/tcpc/tcpci_late_sync.c
new file mode 100644
index 0000000..d20e3d4
--- /dev/null
+++ b/drivers/misc/mediatek/typec/tcpc/tcpci_late_sync.c
@@ -0,0 +1,89 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020 MediaTek Inc.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/version.h>
+#include <linux/slab.h>
+
+#include "inc/tcpci.h"
+#include "inc/tcpci_typec.h"
+
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
+#include "pd_dpm_prv.h"
+#include "inc/tcpm.h"
+#if CONFIG_RECV_BAT_ABSENT_NOTIFY && CONFIG_MTK_BATTERY
+#include "mtk_battery.h"
+#endif /* CONFIG_RECV_BAT_ABSENT_NOTIFY && CONFIG_MTK_BATTERY */
+#endif /* CONFIG_USB_POWER_DELIVERY */
+
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
+#if CONFIG_TCPC_NOTIFIER_LATE_SYNC
+#if CONFIG_RECV_BAT_ABSENT_NOTIFY && CONFIG_MTK_BATTERY
+static int fg_bat_notifier_call(struct notifier_block *nb,
+				unsigned long event, void *data)
+{
+	struct pd_port *pd_port = container_of(nb, struct pd_port, fg_bat_nb);
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
+
+	switch (event) {
+	case EVT_INT_BAT_PLUGOUT:
+		dev_info(&tcpc_dev->dev, "%s: fg battery absent\n", __func__);
+		schedule_work(&pd_port->fg_bat_work);
+		break;
+	default:
+		break;
+	}
+	return NOTIFY_OK;
+}
+#endif /* CONFIG_RECV_BAT_ABSENT_NOTIFY && CONFIG_MTK_BATTERY */
+#endif /* CONFIG_TCPC_NOTIFIER_LATE_SYNC */
+#endif /* CONFIG_USB_POWER_DELIVERY */
+
+#if CONFIG_TCPC_NOTIFIER_LATE_SYNC
+static int __tcpc_class_complete_work(struct device *dev, void *data)
+{
+	struct tcpc_device *tcpc = dev_get_drvdata(dev);
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
+#if CONFIG_RECV_BAT_ABSENT_NOTIFY && CONFIG_MTK_BATTERY
+	struct notifier_block *fg_bat_nb = &tcpc->pd_port.fg_bat_nb;
+	int ret = 0;
+#endif /* CONFIG_RECV_BAT_ABSENT_NOTIFY && CONFIG_MTK_BATTERY */
+#endif /* CONFIG_USB_POWER_DELIVERY */
+
+	if (tcpc != NULL) {
+		pr_info("%s = %s\n", __func__, dev_name(dev));
+		tcpc_device_irq_enable(tcpc);
+
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
+#if CONFIG_RECV_BAT_ABSENT_NOTIFY && CONFIG_MTK_BATTERY
+		fg_bat_nb->notifier_call = fg_bat_notifier_call;
+		ret = register_battery_notifier(fg_bat_nb);
+		if (ret < 0) {
+			pr_notice("%s: register bat notifier fail\n", __func__);
+			return -EINVAL;
+		}
+#endif /* CONFIG_RECV_BAT_ABSENT_NOTIFY && CONFIG_MTK_BATTERY */
+#endif /* CONFIG_USB_POWER_DELIVERY */
+	}
+	return 0;
+}
+
+static int __init tcpc_class_complete_init(void)
+{
+	if (!IS_ERR(tcpc_class)) {
+		class_for_each_device(tcpc_class, NULL, NULL,
+			__tcpc_class_complete_work);
+	}
+	return 0;
+}
+late_initcall_sync(tcpc_class_complete_init);
+#endif /* CONFIG_TCPC_NOTIFIER_LATE_SYNC */
+
+MODULE_DESCRIPTION("Richtek TypeC Port Late Sync Driver");
+MODULE_AUTHOR("Jeff Chang <jeff_chang@richtek.com>");
+MODULE_VERSION("1.0.0_MTK");
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpci_timer.c b/drivers/misc/mediatek/typec/tcpc/tcpci_timer.c
index 0335acf..da76463 100644
--- a/drivers/misc/mediatek/typec/tcpc/tcpci_timer.c
+++ b/drivers/misc/mediatek/typec/tcpc/tcpci_timer.c
@@ -1,16 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * TCPC Interface for timer handler
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include <linux/kernel.h>
@@ -130,7 +120,7 @@ static inline void tcpc_set_timer_tick(struct tcpc_device *tcpc, int nr)
 
 #if TCPC_TIMER_DBG_EN || TCPC_TIMER_INFO_EN
 static const char *const tcpc_timer_name[] = {
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	"PD_TIMER_DISCOVER_ID",
 	"PD_TIMER_BIST_CONT_MODE",
 	"PD_TIMER_HARD_RESET_COMPLETE",
@@ -145,7 +135,7 @@ static const char *const tcpc_timer_name[] = {
 	"PD_TIMER_SOURCE_CAPABILITY",
 	"PD_TIMER_SOURCE_START",
 	"PD_TIMER_VCONN_ON",
-#ifdef CONFIG_USB_PD_VCONN_STABLE_DELAY
+#if CONFIG_USB_PD_VCONN_STABLE_DELAY
 	"PD_TIMER_VCONN_STABLE",
 #endif	/* CONFIG_USB_PD_VCONN_STABLE_DELAY */
 	"PD_TIMER_VDM_MODE_ENTRY",
@@ -153,12 +143,12 @@ static const char *const tcpc_timer_name[] = {
 	"PD_TIMER_VDM_RESPONSE",
 	"PD_TIMER_SOURCE_TRANSITION",
 	"PD_TIMER_SRC_RECOVER",
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	"PD_TIMER_CK_NOT_SUPPORTED",
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	"PD_TIMER_SINK_TX",
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
-#ifdef CONFIG_USB_PD_REV30_PPS_SOURCE
+#if CONFIG_USB_PD_REV30_PPS_SOURCE
 	"PD_TIMER_SOURCE_PPS_TIMEOUT",
 #endif	/* CONFIG_USB_PD_REV30_PPS_SOURCE */
 #endif	/* CONFIG_USB_PD_REV30 */
@@ -175,10 +165,11 @@ static const char *const tcpc_timer_name[] = {
 	"PD_TIMER_VCONN_READY",
 	"PD_PE_VDM_POSTPONE",
 
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	"PD_TIMER_DEFERRED_EVT",
-#ifdef CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
+
+#if CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
 	"PD_TIMER_SNK_FLOW_DELAY",
 #endif	/* CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP */
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
@@ -198,9 +189,10 @@ static const char *const tcpc_timer_name[] = {
 	"TYPEC_RT_TIMER_LEGACY_RECYCLE",
 	"TYPEC_RT_TIMER_AUTO_DISCHARGE",
 	"TYPEC_RT_TIMER_LOW_POWER_MODE",
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	"TYPEC_RT_TIMER_PE_IDLE",
-#ifdef CONFIG_USB_PD_WAIT_BC12
+
+#if CONFIG_USB_PD_WAIT_BC12
 	"TYPEC_RT_TIMER_PD_WAIT_BC12",
 #endif /* CONFIG_USB_PD_WAIT_BC12 */
 #endif	/* CONFIG_USB_POWER_DELIVERY */
@@ -211,19 +203,19 @@ static const char *const tcpc_timer_name[] = {
 /* TYPEC-DEBOUNCE-TIMER */
 	"TYPEC_TIMER_CCDEBOUNCE",
 	"TYPEC_TIMER_PDDEBOUNCE",
-#ifdef CONFIG_COMPATIBLE_APPLE_TA
+#if CONFIG_COMPATIBLE_APPLE_TA
 	"TYPEC_TIMER_APPLE_CC_OPEN",
 #endif /* CONFIG_COMPATIBLE_APPLE_TA */
 	"TYPEC_TIMER_TRYCCDEBOUNCE",
 	"TYPEC_TIMER_SRCDISCONNECT",
 	"TYPEC_TIMER_DRP_SRC_TOGGLE",
-#ifdef CONFIG_TYPEC_CAP_NORP_SRC
+#if CONFIG_TYPEC_CAP_NORP_SRC
 	"TYPEC_TIMER_NORP_SRC",
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
 };
 #endif /* TCPC_TIMER_DBG_EN || TCPC_TIMER_INFO_EN */
 /* CONFIG_USB_PD_SAFE0V_DELAY */
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT
+#if CONFIG_TCPC_VSAFE0V_DETECT
 #define PD_TIMER_VSAFE0V_DLY_TOUT		50
 #else
 /* #ifndef CONFIG_TCPC_VSAFE0V_DETECT (equal timeout)*/
@@ -231,7 +223,7 @@ static const char *const tcpc_timer_name[] = {
 #endif	/* CONFIG_TCPC_VSAFE0V_DETECT */
 
 /* CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_DELAY */
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT
+#if CONFIG_TCPC_VSAFE0V_DETECT
 #define TYPEC_RT_TIMER_SAFE0V_DLY_TOUT		35
 #else
 #define TYPEC_RT_TIMER_SAFE0V_DLY_TOUT		100
@@ -247,7 +239,7 @@ static const char *const tcpc_timer_name[] = {
 	TIMEOUT_RANGE(min, max)
 
 static const uint32_t tcpc_timer_timeout[PD_TIMER_NR] = {
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_DISCOVER_ID, 40, 50),
 DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_BIST_CONT_MODE, 30, 60),
 DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_HARD_RESET_COMPLETE, 4, 5),
@@ -265,23 +257,23 @@ DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_SOURCE_CAPABILITY, 100, 200),
 DECL_TCPC_TIMEOUT(PD_TIMER_SOURCE_START, 20),
 DECL_TCPC_TIMEOUT(PD_TIMER_VCONN_ON, 100),
 
-#ifdef CONFIG_USB_PD_VCONN_STABLE_DELAY
+#if CONFIG_USB_PD_VCONN_STABLE_DELAY
 DECL_TCPC_TIMEOUT(PD_TIMER_VCONN_STABLE, 50),
 #endif	/* CONFIG_USB_PD_VCONN_STABLE_DELAY */
 
 DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_VDM_MODE_ENTRY, 40, 50),
 DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_VDM_MODE_EXIT, 40, 50),
-DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_VDM_RESPONSE, 24, 30),
+DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_VDM_RESPONSE, 24, 30),	/* 24 ~ 30 */
 
 DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_SOURCE_TRANSITION, 25, 35),
 DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_SRC_RECOVER, 660, 1000),
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_CK_NOT_SUPPORTED, 40, 50),
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
-DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_SINK_TX, 16, 20),
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
+DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_SINK_TX, 16, 20),	/* 16 ~ 20 */
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
-#ifdef CONFIG_USB_PD_REV30_PPS_SOURCE
+#if CONFIG_USB_PD_REV30_PPS_SOURCE
 DECL_TCPC_TIMEOUT(PD_TIMER_SOURCE_PPS_TIMEOUT, 14000),
 #endif	/* CONFIG_USB_PD_REV30_PPS_SOURCE */
 #endif	/* CONFIG_USB_PD_REV30 */
@@ -306,10 +298,10 @@ DECL_TCPC_TIMEOUT(PD_TIMER_VCONN_READY,
 
 DECL_TCPC_TIMEOUT_US(PD_PE_VDM_POSTPONE, 3000),
 
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 DECL_TCPC_TIMEOUT(PD_TIMER_DEFERRED_EVT, 5000),
-#ifdef CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
+#if CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
 DECL_TCPC_TIMEOUT(PD_TIMER_SNK_FLOW_DELAY,
 	CONFIG_USB_PD_UFP_FLOW_DLY),
 #endif	/* CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP */
@@ -336,9 +328,9 @@ DECL_TCPC_TIMEOUT(TYPEC_RT_TIMER_LEGACY_RECYCLE, 300*1000),
 DECL_TCPC_TIMEOUT(TYPEC_RT_TIMER_DISCHARGE, CONFIG_TYPEC_CAP_DISCHARGE_TOUT),
 DECL_TCPC_TIMEOUT(TYPEC_RT_TIMER_LOW_POWER_MODE, 500),
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 DECL_TCPC_TIMEOUT(TYPEC_RT_TIMER_PE_IDLE, 1),
-#ifdef CONFIG_USB_PD_WAIT_BC12
+#if CONFIG_USB_PD_WAIT_BC12
 DECL_TCPC_TIMEOUT(TYPEC_RT_TIMER_PD_WAIT_BC12, 50),
 #endif /* CONFIG_USB_PD_WAIT_BC12 */
 #endif	/* CONFIG_USB_POWER_DELIVERY */
@@ -351,20 +343,20 @@ DECL_TCPC_TIMEOUT_RANGE(TYPEC_TRY_TIMER_DRP_TRYWAIT, 400, 800),
 /* TYPEC-DEBOUNCE-TIMER */
 DECL_TCPC_TIMEOUT_RANGE(TYPEC_TIMER_CCDEBOUNCE, 100, 200),
 DECL_TCPC_TIMEOUT_RANGE(TYPEC_TIMER_PDDEBOUNCE, 10, 10),
-#ifdef CONFIG_COMPATIBLE_APPLE_TA
+#if CONFIG_COMPATIBLE_APPLE_TA
 DECL_TCPC_TIMEOUT_RANGE(TYPEC_TIMER_APPLE_CC_OPEN, 200, 200),
 #endif /* CONFIG_COMPATIBLE_APPLE_TA */
 DECL_TCPC_TIMEOUT_RANGE(TYPEC_TIMER_TRYCCDEBOUNCE, 10, 20),
 DECL_TCPC_TIMEOUT_RANGE(TYPEC_TIMER_SRCDISCONNECT, 0, 20),
 DECL_TCPC_TIMEOUT(TYPEC_TIMER_DRP_SRC_TOGGLE, 60),
-#ifdef CONFIG_TYPEC_CAP_NORP_SRC
+#if CONFIG_TYPEC_CAP_NORP_SRC
 DECL_TCPC_TIMEOUT(TYPEC_TIMER_NORP_SRC, 300),
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
 };
 
 typedef enum hrtimer_restart (*tcpc_hrtimer_call)(struct hrtimer *timer);
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 static inline void on_pe_timer_timeout(
 		struct tcpc_device *tcpc, uint32_t timer_id)
 {
@@ -388,7 +380,7 @@ static inline void on_pe_timer_timeout(
 		pd_put_vbus_safe0v_event(tcpc);
 		break;
 
-#ifdef CONFIG_USB_PD_SAFE0V_TIMEOUT
+#if CONFIG_USB_PD_SAFE0V_TIMEOUT
 	case PD_TIMER_VSAFE0V_TOUT:
 		TCPC_INFO("VSafe0V TOUT (%d)\n", tcpc->vbus_level);
 		if (!tcpci_check_vbus_valid_from_ic(tcpc))
@@ -396,7 +388,7 @@ static inline void on_pe_timer_timeout(
 		break;
 #endif	/* CONFIG_USB_PD_SAFE0V_TIMEOUT */
 
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+#if CONFIG_USB_PD_RETRY_CRC_DISCARD
 	case PD_TIMER_DISCARD:
 		tcpc->pd_discard_pending = false;
 		pd_put_hw_event(tcpc, PD_HW_TX_DISCARD);
@@ -439,7 +431,7 @@ static inline void on_pe_timer_timeout(
 	wake_up(&tcpc->timer_wait_que);	\
 } while (0)
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 static enum hrtimer_restart tcpc_timer_bist_cont_mode(struct hrtimer *timer)
 {
 	int index = PD_TIMER_BIST_CONT_MODE;
@@ -581,7 +573,7 @@ static enum hrtimer_restart tcpc_timer_vconn_on(struct hrtimer *timer)
 	return HRTIMER_NORESTART;
 }
 
-#ifdef CONFIG_USB_PD_VCONN_STABLE_DELAY
+#if CONFIG_USB_PD_VCONN_STABLE_DELAY
 static enum hrtimer_restart tcpc_timer_vconn_stable(struct hrtimer *timer)
 {
 	int index = PD_TIMER_VCONN_STABLE;
@@ -643,7 +635,7 @@ static enum hrtimer_restart tcpc_timer_src_recover(struct hrtimer *timer)
 	return HRTIMER_NORESTART;
 }
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 static enum hrtimer_restart tcpc_timer_ck_no_support(struct hrtimer *timer)
 {
 	int index = PD_TIMER_CK_NOT_SUPPORTED;
@@ -654,7 +646,7 @@ static enum hrtimer_restart tcpc_timer_ck_no_support(struct hrtimer *timer)
 	return HRTIMER_NORESTART;
 }
 
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 static enum hrtimer_restart tcpc_timer_sink_tx(struct hrtimer *timer)
 {
 	int index = PD_TIMER_SINK_TX;
@@ -666,7 +658,7 @@ static enum hrtimer_restart tcpc_timer_sink_tx(struct hrtimer *timer)
 }
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SOURCE
+#if CONFIG_USB_PD_REV30_PPS_SOURCE
 static enum hrtimer_restart tcpc_timer_source_pps(struct hrtimer *timer)
 {
 	int index = PD_TIMER_SOURCE_PPS_TIMEOUT;
@@ -781,8 +773,8 @@ static enum hrtimer_restart tcpc_timer_vdm_postpone(struct hrtimer *timer)
 	return HRTIMER_NORESTART;
 }
 
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 static enum hrtimer_restart tcpc_timer_deferred_evt(struct hrtimer *timer)
 {
 	int index = PD_TIMER_DEFERRED_EVT;
@@ -793,7 +785,7 @@ static enum hrtimer_restart tcpc_timer_deferred_evt(struct hrtimer *timer)
 	return HRTIMER_NORESTART;
 }
 
-#ifdef CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
+#if CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
 static enum hrtimer_restart tcpc_timer_snk_flow_delay(struct hrtimer *timer)
 {
 	int index = PD_TIMER_SNK_FLOW_DELAY;
@@ -921,7 +913,7 @@ static enum hrtimer_restart tcpc_timer_rt_low_power_mode(struct hrtimer *timer)
 	return HRTIMER_NORESTART;
 }
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 static enum hrtimer_restart tcpc_timer_rt_pe_idle(struct hrtimer *timer)
 {
 	int index = TYPEC_RT_TIMER_PE_IDLE;
@@ -932,7 +924,7 @@ static enum hrtimer_restart tcpc_timer_rt_pe_idle(struct hrtimer *timer)
 	return HRTIMER_NORESTART;
 }
 
-#ifdef CONFIG_USB_PD_WAIT_BC12
+#if CONFIG_USB_PD_WAIT_BC12
 static enum hrtimer_restart tcpc_timer_rt_pd_wait_bc12(struct hrtimer *timer)
 {
 	int index = TYPEC_RT_TIMER_PD_WAIT_BC12;
@@ -987,7 +979,7 @@ static enum hrtimer_restart tcpc_timer_pddebounce(struct hrtimer *timer)
 	return HRTIMER_NORESTART;
 }
 
-#ifdef CONFIG_COMPATIBLE_APPLE_TA
+#if CONFIG_COMPATIBLE_APPLE_TA
 static enum hrtimer_restart tcpc_timer_apple_cc_open(struct hrtimer *timer)
 {
 	int index = TYPEC_TIMER_APPLE_CC_OPEN;
@@ -1037,7 +1029,7 @@ static void wake_up_work_func(struct work_struct *work)
 	mutex_lock(&tcpc->typec_lock);
 
 	TCPC_INFO("%s\n", __func__);
-#ifdef CONFIG_TYPEC_WAKEUP_ONCE_LOW_DUTY
+#if CONFIG_TYPEC_WAKEUP_ONCE_LOW_DUTY
 	tcpc->typec_wakeup_once = true;
 #endif	/* CONFIG_TYPEC_WAKEUP_ONCE_LOW_DUTY */
 
@@ -1068,7 +1060,7 @@ static enum hrtimer_restart tcpc_timer_drp_src_toggle(struct hrtimer *timer)
 	return HRTIMER_NORESTART;
 }
 
-#ifdef CONFIG_TYPEC_CAP_NORP_SRC
+#if CONFIG_TYPEC_CAP_NORP_SRC
 static enum hrtimer_restart tcpc_timer_norp_src(struct hrtimer *timer)
 {
 	int index = TYPEC_TIMER_NORP_SRC;
@@ -1081,7 +1073,7 @@ static enum hrtimer_restart tcpc_timer_norp_src(struct hrtimer *timer)
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
 
 static tcpc_hrtimer_call tcpc_timer_call[PD_TIMER_NR] = {
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	tcpc_timer_discover_id,
 	tcpc_timer_bist_cont_mode,
 	tcpc_timer_hard_reset_complete,
@@ -1096,7 +1088,7 @@ static tcpc_hrtimer_call tcpc_timer_call[PD_TIMER_NR] = {
 	tcpc_timer_source_capability,
 	tcpc_timer_source_start,
 	tcpc_timer_vconn_on,
-#ifdef CONFIG_USB_PD_VCONN_STABLE_DELAY
+#if CONFIG_USB_PD_VCONN_STABLE_DELAY
 	tcpc_timer_vconn_stable,
 #endif	/* CONFIG_USB_PD_VCONN_STABLE_DELAY */
 	tcpc_timer_vdm_mode_entry,
@@ -1104,12 +1096,12 @@ static tcpc_hrtimer_call tcpc_timer_call[PD_TIMER_NR] = {
 	tcpc_timer_vdm_response,
 	tcpc_timer_source_transition,
 	tcpc_timer_src_recover,
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	tcpc_timer_ck_no_support,
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	tcpc_timer_sink_tx,
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
-#ifdef CONFIG_USB_PD_REV30_PPS_SOURCE
+#if CONFIG_USB_PD_REV30_PPS_SOURCE
 	tcpc_timer_source_pps,
 #endif	/* CONFIG_USB_PD_REV30_PPS_SOURCE */
 #endif	/* CONFIG_USB_PD_REV30 */
@@ -1126,10 +1118,10 @@ static tcpc_hrtimer_call tcpc_timer_call[PD_TIMER_NR] = {
 	tcpc_timer_vconn_ready,
 	tcpc_timer_vdm_postpone,
 
-#ifdef CONFIG_USB_PD_REV30
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+#if CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30_COLLISION_AVOID
 	tcpc_timer_deferred_evt,
-#ifdef CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
+#if CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
 	tcpc_timer_snk_flow_delay,
 #endif	/* CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP */
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
@@ -1149,9 +1141,9 @@ static tcpc_hrtimer_call tcpc_timer_call[PD_TIMER_NR] = {
 	tcpc_timer_rt_legacy_recycle,
 	tcpc_timer_rt_discharge,
 	tcpc_timer_rt_low_power_mode,
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	tcpc_timer_rt_pe_idle,
-#ifdef CONFIG_USB_PD_WAIT_BC12
+#if CONFIG_USB_PD_WAIT_BC12
 	tcpc_timer_rt_pd_wait_bc12,
 #endif /* CONFIG_USB_PD_WAIT_BC12 */
 #endif	/* CONFIG_USB_POWER_DELIVERY */
@@ -1162,13 +1154,13 @@ static tcpc_hrtimer_call tcpc_timer_call[PD_TIMER_NR] = {
 /* TYPEC-DEBOUNCE-TIMER */
 	tcpc_timer_ccdebounce,
 	tcpc_timer_pddebounce,
-#ifdef CONFIG_COMPATIBLE_APPLE_TA
+#if CONFIG_COMPATIBLE_APPLE_TA
 	tcpc_timer_apple_cc_open,
 #endif /* CONFIG_COMPATIBLE_APPLE_TA */
 	tcpc_timer_tryccdebounce,
 	tcpc_timer_srcdisconnect,
 	tcpc_timer_drp_src_toggle,
-#ifdef CONFIG_TYPEC_CAP_NORP_SRC
+#if CONFIG_TYPEC_CAP_NORP_SRC
 	tcpc_timer_norp_src,
 #endif
 };
@@ -1184,7 +1176,7 @@ static void __tcpc_enable_wakeup_timer(struct tcpc_device *tcpc, bool en)
 	if (en) {
 		TCPC_INFO("wakeup_timer\n");
 
-#ifdef CONFIG_TYPEC_WAKEUP_ONCE_LOW_DUTY
+#if CONFIG_TYPEC_WAKEUP_ONCE_LOW_DUTY
 		if (!tcpc->typec_wakeup_once) {
 			if (tcpc->typec_low_rp_duty_cntdown)
 				tout = 5;
@@ -1210,6 +1202,7 @@ static inline void tcpc_reset_timer_range(
 		if (mask & RT_MASK64(i)) {
 			hrtimer_try_to_cancel(&tcpc->tcpc_timer[i]);
 			tcpc_clear_timer_enable_mask(tcpc, i);
+			atomic_dec_if_positive(&tcpc->suspend_pending);
 		}
 	}
 
@@ -1233,7 +1226,9 @@ void tcpc_enable_wakeup_timer(struct tcpc_device *tcpc, bool en)
 void tcpc_enable_timer(struct tcpc_device *tcpc, uint32_t timer_id)
 {
 	uint32_t r, mod, tout;
+	uint64_t mask_curr, mask_prev;
 
+	mask_prev = tcpc_get_timer_enable_mask(tcpc);
 	TCPC_TIMER_EN_DBG(tcpc, timer_id);
 	if (timer_id >= PD_TIMER_NR) {
 		PD_BUG_ON(1);
@@ -1245,9 +1240,22 @@ void tcpc_enable_timer(struct tcpc_device *tcpc, uint32_t timer_id)
 
 	tcpc_set_timer_enable_mask(tcpc, timer_id);
 
+	mask_curr = tcpc_get_timer_enable_mask(tcpc);
+	if (mask_prev ^ mask_curr)
+		atomic_inc(&tcpc->suspend_pending);
+	else
+		atomic_dec_if_positive(&tcpc->suspend_pending);
+
 	tout = tcpc_timer_timeout[timer_id];
+#if PD_DYNAMIC_SENDER_RESPONSE
+	if ((timer_id == PD_TIMER_SENDER_RESPONSE) &&
+		(tout > tcpc->tx_time_diff) && (tcpc->tx_time_diff > 2000)) {
+		tout -= (tcpc->tx_time_diff - 2000);
+		tcpc->tx_time_diff = 0;
+	}
+#endif
 
-#ifdef CONFIG_USB_PD_RANDOM_FLOW_DELAY
+#if CONFIG_USB_PD_RANDOM_FLOW_DELAY
 	if (timer_id == PD_TIMER_DFP_FLOW_DELAY ||
 		timer_id == PD_TIMER_UFP_FLOW_DELAY)
 		tout += TIMEOUT_VAL(jiffies & 0x07);
@@ -1274,10 +1282,11 @@ void tcpc_disable_timer(struct tcpc_device *tcpc, uint32_t timer_id)
 	if (mask & RT_MASK64(timer_id)) {
 		hrtimer_try_to_cancel(&tcpc->tcpc_timer[timer_id]);
 		tcpc_clear_timer_enable_mask(tcpc, timer_id);
+		atomic_dec_if_positive(&tcpc->suspend_pending);
 	}
 }
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 void tcpc_reset_pe_timer(struct tcpc_device *tcpc)
 {
 	mutex_lock(&tcpc->timer_lock);
@@ -1307,7 +1316,8 @@ static void tcpc_handle_timer_triggered(struct tcpc_device *tcpc)
 	uint64_t triggered_timer = tcpc_get_timer_tick(tcpc);
 	uint64_t enable_mask = tcpc_get_timer_enable_mask(tcpc);
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+	atomic_inc(&tcpc->suspend_pending);
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	for (i = 0; i < PD_PE_TIMER_END_ID; i++) {
 		if (triggered_timer & RT_MASK64(i)) {
 			TCPC_TIMER_DBG(tcpc, i);
@@ -1330,7 +1340,7 @@ static void tcpc_handle_timer_triggered(struct tcpc_device *tcpc)
 		}
 	}
 	mutex_unlock(&tcpc->typec_lock);
-
+	atomic_dec_if_positive(&tcpc->suspend_pending);
 }
 
 static int tcpc_timer_thread_fn(void *data)
@@ -1343,15 +1353,14 @@ static int tcpc_timer_thread_fn(void *data)
 
 	while (true) {
 		ret = wait_event_interruptible(tcpc->timer_wait_que,
-					       tcpc_get_timer_tick(tcpc) ||
-					       kthread_should_stop());
+				tcpc_get_timer_tick(tcpc) ||
+				kthread_should_stop());
 		if (kthread_should_stop() || ret) {
 			dev_notice(&tcpc->dev, "%s exits(%d)\n", __func__, ret);
 			break;
 		}
 		tcpc_handle_timer_triggered(tcpc);
 	}
-
 	return 0;
 }
 
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpci_typec.c b/drivers/misc/mediatek/typec/tcpc/tcpci_typec.c
index 25149bb..24334c5 100644
--- a/drivers/misc/mediatek/typec/tcpc/tcpci_typec.c
+++ b/drivers/misc/mediatek/typec/tcpc/tcpci_typec.c
@@ -1,47 +1,35 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * TCPC Type-C Driver for Richtek
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include <linux/delay.h>
 #include <linux/cpu.h>
+#include <linux/power_supply.h>
 
 #include "inc/tcpci.h"
 #include "inc/tcpci_typec.h"
 #include "inc/tcpci_timer.h"
 
-/* MTK only */
-#include <mt-plat/mtk_boot.h>
-
-#ifdef CONFIG_TYPEC_CAP_TRY_SOURCE
-#define CONFIG_TYPEC_CAP_TRY_STATE
+#if (CONFIG_TYPEC_CAP_TRY_SOURCE || CONFIG_TYPEC_CAP_TRY_SINK)
+#define CONFIG_TYPEC_CAP_TRY_STATE 1
+#else
+#define CONFIG_TYPEC_CAP_TRY_STATE 0
 #endif
 
-#ifdef CONFIG_TYPEC_CAP_TRY_SINK
-#undef CONFIG_TYPEC_CAP_TRY_STATE
-#define CONFIG_TYPEC_CAP_TRY_STATE
-#endif /* CONFIG_TYPEC_CAP_TRY_SINK */
-
-#define RICHTEK_PD_COMPLIANCE_FAKE_AUDIO_ACC	/* For Rp3A */
-#define RICHTEK_PD_COMPLIANCE_FAKE_EMRAK_ONLY	/* For Rp3A */
-#define RICHTEK_PD_COMPLIANCE_FAKE_RA_DETACH	/* For Rp-DFT */
+/* For Rp3A */
+#define RICHTEK_PD_COMPLIANCE_FAKE_AUDIO_ACC 1
+/* For Rp3A */
+#define RICHTEK_PD_COMPLIANCE_FAKE_EMRAK_ONLY 1
+/* For Rp-DFT */
+#define RICHTEK_PD_COMPLIANCE_FAKE_RA_DETACH 1
 
 enum TYPEC_WAIT_PS_STATE {
 	TYPEC_WAIT_PS_DISABLE = 0,
 	TYPEC_WAIT_PS_SNK_VSAFE5V,
 	TYPEC_WAIT_PS_SRC_VSAFE0V,
 	TYPEC_WAIT_PS_SRC_VSAFE5V,
-#ifdef CONFIG_TYPEC_CAP_DBGACC
+#if CONFIG_TYPEC_CAP_DBGACC
 	TYPEC_WAIT_PS_DBG_VSAFE5V,
 #endif	/* CONFIG_TYPEC_CAP_DBGACC */
 };
@@ -62,7 +50,6 @@ static const char *const typec_wait_ps_name[] = {
 };
 #endif	/* TYPEC_INFO2_ENABLE */
 
-extern int standard_charger_500;
 static inline void typec_wait_ps_change(struct tcpc_device *tcpc,
 					enum TYPEC_WAIT_PS_STATE state)
 {
@@ -74,7 +61,7 @@ static inline void typec_wait_ps_change(struct tcpc_device *tcpc,
 		TYPEC_INFO2("wait_ps=%s\n", typec_wait_ps_name[new_state]);
 #endif	/* TYPEC_INFO2_ENABLE */
 
-#ifdef CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_TIMEOUT
+#if CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_TIMEOUT
 	if (state == TYPEC_WAIT_PS_SRC_VSAFE0V)
 		tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_SAFE0V_TOUT);
 #endif	/* CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_TIMEOUT */
@@ -83,7 +70,7 @@ static inline void typec_wait_ps_change(struct tcpc_device *tcpc,
 		&& state != TYPEC_WAIT_PS_SRC_VSAFE0V) {
 		tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_SAFE0V_DELAY);
 
-#ifdef CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_TIMEOUT
+#if CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_TIMEOUT
 		tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_SAFE0V_TOUT);
 #endif	/* CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_TIMEOUT */
 	}
@@ -91,8 +78,8 @@ static inline void typec_wait_ps_change(struct tcpc_device *tcpc,
 	tcpc->typec_wait_ps_change = (uint8_t) state;
 }
 
-/* #define TYPEC_EXIT_ATTACHED_SRC_NO_DEBOUNCE */
-#define TYPEC_EXIT_ATTACHED_SNK_VIA_VBUS
+#define TYPEC_EXIT_ATTACHED_SRC_NO_DEBOUNCE 0
+#define TYPEC_EXIT_ATTACHED_SNK_VIA_VBUS 1
 
 static inline int typec_enable_low_power_mode(
 	struct tcpc_device *tcpc, uint8_t pull);
@@ -130,12 +117,10 @@ static inline int typec_enable_low_power_mode(
 
 static inline int typec_enable_vconn(struct tcpc_device *tcpc)
 {
-#ifndef CONFIG_USB_POWER_DELIVERY
 	if (!typec_is_sink_with_emark())
 		return 0;
-#endif /* CONFIG_TCPC_VCONN_SUPPLY_MODE */
 
-#ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
+#if CONFIG_TCPC_VCONN_SUPPLY_MODE
 	if (tcpc->tcpc_vconn_supply == TCPC_VCONN_SUPPLY_NEVER)
 		return 0;
 #endif /* CONFIG_TCPC_VCONN_SUPPLY_MODE */
@@ -160,7 +145,7 @@ enum TYPEC_CONNECTION_STATE {
 	typec_attached_snk,
 	typec_attached_src,
 
-#ifdef CONFIG_TYPEC_CAP_TRY_SOURCE
+#if CONFIG_TYPEC_CAP_TRY_SOURCE
 	/* Require : Assert Rp
 	 * Exit(-> Attached.SRC) : Detect Rd (tPDDebounce).
 	 * Exit(-> TryWait.SNK) : Not detect Rd after tDRPTry
@@ -176,7 +161,7 @@ enum TYPEC_CONNECTION_STATE {
 	typec_trywait_snk_pe,
 #endif
 
-#ifdef CONFIG_TYPEC_CAP_TRY_SINK
+#if CONFIG_TYPEC_CAP_TRY_SINK
 
 	/* Require : Assert Rd
 	 * Wait for tDRPTry and only then begin monitoring CC.
@@ -196,31 +181,35 @@ enum TYPEC_CONNECTION_STATE {
 #endif	/* CONFIG_TYPEC_CAP_TRY_SINK */
 
 	typec_audioaccessory,
-#ifdef CONFIG_TYPEC_CAP_DBGACC
+#if CONFIG_TYPEC_CAP_DBGACC
 	typec_debugaccessory,
 #endif	/* CONFIG_TYPEC_CAP_DBGACC */
 
-#ifdef CONFIG_TYPEC_CAP_DBGACC_SNK
+#if CONFIG_TYPEC_CAP_DBGACC_SNK
 	typec_attached_dbgacc_snk,
 #endif	/* CONFIG_TYPEC_CAP_DBGACC_SNK */
 
-#ifdef CONFIG_TYPEC_CAP_CUSTOM_SRC
+#if CONFIG_TYPEC_CAP_CUSTOM_SRC
 	typec_attached_custom_src,
 #endif	/* CONFIG_TYPEC_CAP_CUSTOM_SRC */
 
-#ifdef CONFIG_TYPEC_CAP_NORP_SRC
+#if CONFIG_TYPEC_CAP_NORP_SRC
 	typec_attached_norp_src,
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
 
-#ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
+#if CONFIG_TYPEC_CAP_ROLE_SWAP
 	typec_role_swap,
 #endif	/* CONFIG_TYPEC_CAP_ROLE_SWAP */
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 	typec_water_protection_wait,
 	typec_water_protection,
 #endif /* CONFIG_WATER_DETECTION */
 
+	typec_foreign_object_protection,
+
+	typec_otp,
+
 	typec_unattachwait_pe,	/* Wait Policy Engine go to Idle */
 };
 
@@ -238,44 +227,48 @@ static const char *const typec_state_name[] = {
 	"Attached.SNK",
 	"Attached.SRC",
 
-#ifdef CONFIG_TYPEC_CAP_TRY_SOURCE
+#if CONFIG_TYPEC_CAP_TRY_SOURCE
 	"Try.SRC",
 	"TryWait.SNK",
 	"TryWait.SNK.PE",
 #endif	/* CONFIG_TYPEC_CAP_TRY_SOURCE */
 
-#ifdef CONFIG_TYPEC_CAP_TRY_SINK
+#if CONFIG_TYPEC_CAP_TRY_SINK
 	"Try.SNK",
 	"TryWait.SRC",
 	"TryWait.SRC.PE",
 #endif	/* CONFIG_TYPEC_CAP_TRY_SINK */
 
 	"AudioAccessory",
-#ifdef CONFIG_TYPEC_CAP_DBGACC
+#if CONFIG_TYPEC_CAP_DBGACC
 	"DebugAccessory",
 #endif	/* CONFIG_TYPEC_CAP_DBGACC */
 
-#ifdef CONFIG_TYPEC_CAP_DBGACC_SNK
+#if CONFIG_TYPEC_CAP_DBGACC_SNK
 	"DBGACC.SNK",
 #endif	/* CONFIG_TYPEC_CAP_DBGACC_SNK */
 
-#ifdef CONFIG_TYPEC_CAP_CUSTOM_SRC
+#if CONFIG_TYPEC_CAP_CUSTOM_SRC
 	"Custom.SRC",
 #endif	/* CONFIG_TYPEC_CAP_CUSTOM_SRC */
 
-#ifdef CONFIG_TYPEC_CAP_NORP_SRC
+#if CONFIG_TYPEC_CAP_NORP_SRC
 	"NoRp.SRC",
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
 
-#ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
+#if CONFIG_TYPEC_CAP_ROLE_SWAP
 	"RoleSwap",
 #endif	/* CONFIG_TYPEC_CAP_ROLE_SWAP */
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 	"WaterProtection.Wait",
 	"WaterProtection",
 #endif /* CONFIG_WATER_DETECTION */
 
+	"ForeignObjectProtection",
+
+	"TypeC.OTP",
+
 	"UnattachWait.PE",
 };
 #endif /* TYPEC_INFO_ENABLE || TCPC_INFO_ENABLE */
@@ -315,7 +308,7 @@ static int typec_alert_attach_state_change(struct tcpc_device *tcpc)
 {
 	int ret = 0;
 
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE
 	if (tcpc->typec_legacy_cable)
 		tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_NOT_LEGACY);
 	else
@@ -330,11 +323,6 @@ static int typec_alert_attach_state_change(struct tcpc_device *tcpc)
 
 	TYPEC_INFO("Attached-> %s\n",
 		   typec_attach_name[tcpc->typec_attach_new]);
-	if(!strcmp(typec_attach_name[tcpc->typec_attach_new], "NORP_SRC"))
-	{
-		standard_charger_500 = 1;
-		printk("renxianzhou: standard_charger_500 =%d  line = %d\n",standard_charger_500,__LINE__);
-	}
 
 	/*Report function */
 	ret = tcpci_report_usb_port_changed(tcpc);
@@ -354,7 +342,7 @@ static inline int typec_set_drp_toggling(struct tcpc_device *tcpc)
 	return typec_enable_low_power_mode(tcpc, TYPEC_CC_DRP);
 }
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 static int typec_check_water_status(struct tcpc_device *tcpc)
 {
 	int ret;
@@ -377,7 +365,7 @@ static int typec_check_water_status(struct tcpc_device *tcpc)
  * [BLOCK] NoRpSRC Entry
  */
 
-#ifdef CONFIG_TYPEC_CAP_NORP_SRC
+#if CONFIG_TYPEC_CAP_NORP_SRC
 static bool typec_try_enter_norp_src(struct tcpc_device *tcpc)
 {
 	if (tcpci_check_vbus_valid_from_ic(tcpc) &&
@@ -408,14 +396,17 @@ static bool typec_try_exit_norp_src(struct tcpc_device *tcpc)
 
 static inline int typec_norp_src_attached_entry(struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_WATER_DETECTION
-#ifdef CONFIG_WD_POLLING_ONLY
-	if (!tcpc->typec_power_ctrl) {
-		if (get_boot_mode() == KERNEL_POWER_OFF_CHARGING_BOOT ||
-		    get_boot_mode() == LOW_POWER_OFF_CHARGING_BOOT)
-			typec_check_water_status(tcpc);
+#if CONFIG_WATER_DETECTION
+#if CONFIG_WD_POLLING_ONLY
+	if (tcpc->tcpc_flags & TCPC_FLAGS_WATER_DETECTION) {
+		if (tcpc->tcpc_flags & TCPC_FLAGS_WD_POLLING_ONLY) {
+			if (!tcpc->typec_power_ctrl) {
+				if (tcpc->bootmode == 8 || tcpc->bootmode == 9)
+					typec_check_water_status(tcpc);
 
-		tcpci_set_usbid_polling(tcpc, false);
+				tcpci_set_usbid_polling(tcpc, false);
+			}
+		}
 	}
 #else
 	if (!tcpc->typec_power_ctrl && typec_check_water_status(tcpc))
@@ -426,7 +417,7 @@ static inline int typec_norp_src_attached_entry(struct tcpc_device *tcpc)
 	TYPEC_NEW_STATE(typec_attached_norp_src);
 	tcpc->typec_attach_new = TYPEC_ATTACHED_NORP_SRC;
 
-#ifdef CONFIG_TYPEC_CAP_A2C_C2C
+#if CONFIG_TYPEC_CAP_A2C_C2C
 	tcpc->typec_a2c_cable = true;
 #endif	/* CONFIG_TYPEC_CAP_A2C_C2C */
 
@@ -449,7 +440,7 @@ static inline int typec_try_low_power_mode(struct tcpc_device *tcpc)
 	if (ret < 0)
 		return ret;
 
-#ifdef CONFIG_TCPC_LPM_CONFIRM
+#if CONFIG_TCPC_LPM_CONFIRM
 	ret = tcpci_is_low_power_mode(tcpc);
 	if (ret < 0)
 		return ret;
@@ -474,7 +465,7 @@ static inline int typec_enter_low_power_mode(struct tcpc_device *tcpc)
 {
 	int ret = 0;
 
-#ifdef CONFIG_TCPC_LPM_POSTPONE
+#if CONFIG_TCPC_LPM_POSTPONE
 	tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_LOW_POWER_MODE);
 #else
 	ret = typec_try_low_power_mode(tcpc);
@@ -488,7 +479,7 @@ static inline int typec_enable_low_power_mode(
 {
 	int ret = 0;
 
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE
 	if (tcpc->typec_legacy_cable) {
 		TYPEC_DBG("LPM_LCOnly\n");
 		return 0;
@@ -498,7 +489,7 @@ static inline int typec_enable_low_power_mode(
 	if (tcpc->typec_cable_only) {
 		TYPEC_DBG("LPM_RaOnly\n");
 
-#ifdef CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
+#if CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
 		if (tcpc->tcpc_flags & TCPC_FLAGS_LPM_WAKEUP_WATCHDOG)
 			tcpc_enable_wakeup_timer(tcpc, true);
 #endif	/* CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG */
@@ -528,7 +519,7 @@ static inline int typec_disable_low_power_mode(
 		ret = tcpci_set_low_power_mode(tcpc, false, TYPEC_CC_DRP);
 	}
 
-#ifdef CONFIG_TYPEC_WAKEUP_ONCE_LOW_DUTY
+#if CONFIG_TYPEC_WAKEUP_ONCE_LOW_DUTY
 	tcpc->typec_wakeup_once = 0;
 	tcpc->typec_low_rp_duty_cntdown = 0;
 #endif	/* CONFIG_TYPEC_WAKEUP_ONCE_LOW_DUTY */
@@ -557,33 +548,40 @@ static inline void typec_unattached_src_and_drp_entry(struct tcpc_device *tcpc)
 static inline void typec_unattached_snk_and_drp_entry(struct tcpc_device *tcpc)
 {
 	TYPEC_NEW_STATE(typec_unattached_snk);
+	tcpci_set_auto_dischg_discnt(tcpc, false);
 	tcpci_set_cc(tcpc, TYPEC_CC_DRP);
 	typec_enable_low_power_mode(tcpc, TYPEC_CC_DRP);
 }
 
 static inline void typec_unattached_cc_entry(struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
+#if CONFIG_TYPEC_CAP_ROLE_SWAP
 	if (tcpc->typec_during_role_swap) {
 		TYPEC_NEW_STATE(typec_role_swap);
 		return;
 	}
 #endif	/* CONFIG_TYPEC_CAP_ROLE_SWAP */
-#ifdef CONFIG_CABLE_TYPE_DETECTION
-	if (tcpc->typec_state == typec_attached_snk ||
-	    tcpc->typec_state == typec_unattachwait_pe)
+
+	if (tcpc->tcpc_flags & TCPC_FLAGS_FOREIGN_OBJECT_DETECTION)
+		tcpc_typec_handle_fod(tcpc, TCPC_FOD_NONE);
+#if CONFIG_CABLE_TYPE_DETECTION
+	if ((tcpc->tcpc_flags & TCPC_FLAGS_CABLE_TYPE_DETECTION) &&
+	    (tcpc->typec_state == typec_attached_snk ||
+	    tcpc->typec_state == typec_unattachwait_pe))
 		tcpc_typec_handle_ctd(tcpc, TCPC_CABLE_TYPE_NONE);
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
 
 	tcpc->typec_role = tcpc->typec_role_new;
+
 	switch (tcpc->typec_role) {
 	case TYPEC_ROLE_SNK:
 		TYPEC_NEW_STATE(typec_unattached_snk);
+		tcpci_set_auto_dischg_discnt(tcpc, false);
 		tcpci_set_cc(tcpc, TYPEC_CC_RD);
 		typec_enable_low_power_mode(tcpc, TYPEC_CC_RD);
 		break;
 	case TYPEC_ROLE_SRC:
-#ifdef CONFIG_TYPEC_CHECK_SRC_UNATTACH_OPEN
+#if CONFIG_TYPEC_CHECK_SRC_UNATTACH_OPEN
 		if (typec_check_cc_any(TYPEC_CC_VOLT_RD)) {
 			TYPEC_DBG("typec_src_unattach not open\n");
 			tcpci_set_cc(tcpc, TYPEC_CC_OPEN);
@@ -613,14 +611,14 @@ static inline void typec_unattached_cc_entry(struct tcpc_device *tcpc)
 		break;
 	}
 
-#ifdef CONFIG_TYPEC_CAP_NORP_SRC
+#if CONFIG_TYPEC_CAP_NORP_SRC
 	typec_try_enter_norp_src(tcpc);
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
 }
 
 static void typec_unattached_entry(struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_TYPEC_CAP_CUSTOM_HV
+#if CONFIG_TYPEC_CAP_CUSTOM_HV
 	tcpc->typec_during_custom_hv = false;
 #endif	/* CONFIG_TYPEC_CAP_CUSTOM_HV */
 
@@ -636,7 +634,7 @@ static void typec_unattach_wait_pe_idle_entry(struct tcpc_device *tcpc)
 {
 	tcpc->typec_attach_new = TYPEC_UNATTACHED;
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	if (tcpc->pd_pe_running) {
 		TYPEC_NEW_STATE(typec_unattachwait_pe);
 		return;
@@ -689,14 +687,14 @@ static inline int typec_set_polarity(struct tcpc_device *tcpc,
 }
 
 static inline int typec_set_plug_orient(struct tcpc_device *tcpc,
-				uint8_t pull, bool polarity)
+				uint8_t res, bool polarity)
 {
 	int rv = typec_set_polarity(tcpc, polarity);
 
 	if (rv)
 		return rv;
 
-	return tcpci_set_cc(tcpc, pull);
+	return tcpci_set_cc(tcpc, res);
 }
 
 static void typec_source_attached_with_vbus_entry(struct tcpc_device *tcpc)
@@ -713,7 +711,7 @@ static inline void typec_source_attached_entry(struct tcpc_device *tcpc)
 
 	tcpc_disable_timer(tcpc, TYPEC_TRY_TIMER_DRP_TRY);
 
-#ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
+#if CONFIG_TYPEC_CAP_ROLE_SWAP
 	if (tcpc->typec_during_role_swap) {
 		tcpc->typec_during_role_swap = TYPEC_ROLE_SWAP_NONE;
 		tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_ROLE_SWAP_STOP);
@@ -721,7 +719,7 @@ static inline void typec_source_attached_entry(struct tcpc_device *tcpc)
 #endif	/* CONFIG_TYPEC_CAP_ROLE_SWAP */
 
 	typec_set_plug_orient(tcpc,
-		TYPEC_CC_PULL(tcpc->typec_local_rp_level, TYPEC_CC_RP),
+		tcpc->typec_local_rp_level,
 		typec_check_cc2(TYPEC_CC_VOLT_RD));
 
 	tcpci_report_power_control(tcpc, true);
@@ -737,12 +735,12 @@ static inline void typec_sink_attached_entry(struct tcpc_device *tcpc)
 
 	tcpc->typec_attach_new = TYPEC_ATTACHED_SNK;
 
-#ifdef CONFIG_TYPEC_CAP_TRY_STATE
+#if CONFIG_TYPEC_CAP_TRY_STATE
 	if (tcpc->typec_role >= TYPEC_ROLE_DRP)
 		tcpc_reset_typec_try_timer(tcpc);
 #endif	/* CONFIG_TYPEC_CAP_TRY_STATE */
 
-#ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
+#if CONFIG_TYPEC_CAP_ROLE_SWAP
 	if (tcpc->typec_during_role_swap) {
 		tcpc->typec_during_role_swap = TYPEC_ROLE_SWAP_NONE;
 		tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_ROLE_SWAP_STOP);
@@ -753,6 +751,7 @@ static inline void typec_sink_attached_entry(struct tcpc_device *tcpc)
 		!typec_check_cc2(TYPEC_CC_VOLT_OPEN));
 	tcpc->typec_remote_rp_level = typec_get_cc_res();
 
+	tcpci_set_auto_dischg_discnt(tcpc, true);
 	tcpci_report_power_control(tcpc, true);
 	tcpci_sink_vbus(tcpc, TCP_VBUS_CTRL_TYPEC, TCPC_VBUS_SINK_5V, -1);
 }
@@ -760,13 +759,13 @@ static inline void typec_sink_attached_entry(struct tcpc_device *tcpc)
 static inline void typec_custom_src_attached_entry(
 	struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_TYPEC_CAP_DBGACC_SNK
+#if CONFIG_TYPEC_CAP_DBGACC_SNK
 	TYPEC_DBG("[Warning] Same Rp (%d)\n", typec_get_cc1());
 #else
 	TYPEC_DBG("[Warning] CC Both Rp\n");
 #endif
 
-#ifdef CONFIG_TYPEC_CAP_CUSTOM_SRC
+#if CONFIG_TYPEC_CAP_CUSTOM_SRC
 	TYPEC_NEW_STATE(typec_attached_custom_src);
 	tcpc->typec_attach_new = TYPEC_ATTACHED_CUSTOM_SRC;
 
@@ -777,7 +776,7 @@ static inline void typec_custom_src_attached_entry(
 #endif	/* CONFIG_TYPEC_CAP_CUSTOM_SRC */
 }
 
-#ifdef CONFIG_TYPEC_CAP_DBGACC_SNK
+#if CONFIG_TYPEC_CAP_DBGACC_SNK
 
 static inline uint8_t typec_get_sink_dbg_acc_rp_level(
 	int cc1, int cc2)
@@ -832,7 +831,7 @@ static inline void typec_sink_dbg_acc_attached_entry(
  * [BLOCK] Try.SRC / TryWait.SNK
  */
 
-#ifdef CONFIG_TYPEC_CAP_TRY_SOURCE
+#if CONFIG_TYPEC_CAP_TRY_SOURCE
 
 static inline bool typec_role_is_try_src(
 	struct tcpc_device *tcpc)
@@ -840,7 +839,7 @@ static inline bool typec_role_is_try_src(
 	if (tcpc->typec_role != TYPEC_ROLE_TRY_SRC)
 		return false;
 
-#ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
+#if CONFIG_TYPEC_CAP_ROLE_SWAP
 	if (tcpc->typec_during_role_swap)
 		return false;
 #endif	/* CONFIG_TYPEC_CAP_ROLE_SWAP */
@@ -875,7 +874,7 @@ static inline void typec_trywait_snk_pe_entry(struct tcpc_device *tcpc)
 {
 	tcpc->typec_attach_new = TYPEC_UNATTACHED;
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	if (tcpc->typec_attach_old) {
 		TYPEC_NEW_STATE(typec_trywait_snk_pe);
 		return;
@@ -891,7 +890,7 @@ static inline void typec_trywait_snk_pe_entry(struct tcpc_device *tcpc)
  * [BLOCK] Try.SNK / TryWait.SRC
  */
 
-#ifdef CONFIG_TYPEC_CAP_TRY_SINK
+#if CONFIG_TYPEC_CAP_TRY_SINK
 
 static inline bool typec_role_is_try_sink(
 	struct tcpc_device *tcpc)
@@ -899,7 +898,7 @@ static inline bool typec_role_is_try_sink(
 	if (tcpc->typec_role != TYPEC_ROLE_TRY_SNK)
 		return false;
 
-#ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
+#if CONFIG_TYPEC_CAP_ROLE_SWAP
 	if (tcpc->typec_during_role_swap)
 		return false;
 #endif	/* CONFIG_TYPEC_CAP_ROLE_SWAP */
@@ -942,7 +941,7 @@ static inline void typec_cc_snk_detect_vsafe5v_entry(
 		return;
 	}
 
-#ifdef CONFIG_TYPEC_CAP_TRY_SOURCE
+#if CONFIG_TYPEC_CAP_TRY_SOURCE
 	if (typec_role_is_try_src(tcpc)) {
 		if (tcpc->typec_state == typec_attachwait_snk) {
 			typec_try_src_entry(tcpc);
@@ -968,7 +967,7 @@ static inline void typec_cc_src_detect_vsafe0v_entry(
 {
 	typec_wait_ps_change(tcpc, TYPEC_WAIT_PS_DISABLE);
 
-#ifdef CONFIG_TYPEC_CAP_TRY_SINK
+#if CONFIG_TYPEC_CAP_TRY_SINK
 	if (typec_role_is_try_sink(tcpc)) {
 		if (tcpc->typec_state == typec_attachwait_src) {
 			typec_try_snk_entry(tcpc);
@@ -998,7 +997,7 @@ static inline void typec_cc_src_remove_entry(struct tcpc_device *tcpc)
 
 	tcpc->typec_is_attached_src = false;
 
-#ifdef CONFIG_TYPEC_CAP_TRY_SOURCE
+#if CONFIG_TYPEC_CAP_TRY_SOURCE
 	if (typec_role_is_try_src(tcpc)) {
 		switch (tcpc->typec_state) {
 		case typec_attached_src:
@@ -1018,7 +1017,7 @@ static inline void typec_cc_snk_remove_entry(struct tcpc_device *tcpc)
 {
 	typec_wait_ps_change(tcpc, TYPEC_WAIT_PS_DISABLE);
 
-#ifdef CONFIG_TYPEC_CAP_TRY_SINK
+#if CONFIG_TYPEC_CAP_TRY_SINK
 	if (tcpc->typec_state == typec_try_snk) {
 		typec_trywait_src_entry(tcpc);
 		return;
@@ -1032,7 +1031,7 @@ static inline void typec_cc_snk_remove_entry(struct tcpc_device *tcpc)
  * [BLOCK] Check Legacy Cable
  */
 
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE
 
 static inline void typec_legacy_reset_cable_suspect(
 	struct tcpc_device *tcpc)
@@ -1045,7 +1044,7 @@ static inline void typec_legacy_reset_cable_suspect(
 static inline void typec_legacy_reset_retry_wk(
 	struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE2
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE2
 	tcpc->typec_legacy_retry_wk = 0;
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE2 */
 }
@@ -1053,7 +1052,7 @@ static inline void typec_legacy_reset_retry_wk(
 static inline void typec_legacy_enable_discharge(
 	struct tcpc_device *tcpc, bool en)
 {
-#ifdef CONFIG_TYPEC_CAP_FORCE_DISCHARGE
+#if CONFIG_TYPEC_CAP_FORCE_DISCHARGE
 	if (tcpc->tcpc_flags & TCPC_FLAGS_PREFER_LEGACY2) {
 		mutex_lock(&tcpc->access_lock);
 		tcpci_enable_force_discharge(tcpc, en, 0);
@@ -1065,7 +1064,7 @@ static inline void typec_legacy_enable_discharge(
 static inline void typec_legacy_keep_default_rp(
 	struct tcpc_device *tcpc, bool en)
 {
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE2
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE2
 	typec_legacy_enable_discharge(tcpc, en);
 
 	if (en) {
@@ -1154,7 +1153,7 @@ static inline bool typec_legacy_stable1(struct tcpc_device *tcpc)
 	return true;
 }
 
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE2
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE2
 
 static inline bool typec_is_run_legacy_stable2(struct tcpc_device *tcpc)
 {
@@ -1182,7 +1181,7 @@ static inline bool typec_legacy_stable2(struct tcpc_device *tcpc)
 
 	tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_LEGACY_STABLE);
 
-#ifdef CONFIG_TYPEC_LEGACY2_AUTO_RECYCLE
+#if CONFIG_TYPEC_LEGACY2_AUTO_RECYCLE
 	tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_LEGACY_RECYCLE);
 #endif	/* CONFIG_TYPEC_LEGACY2_AUTO_RECYCLE */
 
@@ -1196,7 +1195,7 @@ static inline bool typec_legacy_confirm(struct tcpc_device *tcpc)
 	tcpc->typec_legacy_cable = 1;
 	tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_NOT_LEGACY);
 
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE2
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE2
 	if (typec_is_run_legacy_stable2(tcpc))
 		return typec_legacy_stable2(tcpc);
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE2 */
@@ -1211,7 +1210,7 @@ static inline bool typec_legacy_check_cable(struct tcpc_device *tcpc)
 	if (tcpc->tcpc_flags & TCPC_FLAGS_DISABLE_LEGACY)
 		return false;
 
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE2
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE2
 	if (tcpc->typec_legacy_cable == 2) {
 		typec_unattached_src_and_drp_entry(tcpc);
 		return true;
@@ -1243,7 +1242,7 @@ static inline bool typec_legacy_check_cable(struct tcpc_device *tcpc)
 
 static inline void typec_legacy_reset_timer(struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE2
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE2
 	if (tcpc->typec_legacy_cable == 2)
 		tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_LEGACY_RECYCLE);
 
@@ -1270,7 +1269,7 @@ static inline void typec_legacy_reach_vsafe0v(struct tcpc_device *tcpc)
 static inline void typec_legacy_handle_ps_change(
 	struct tcpc_device *tcpc, int vbus_level)
 {
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE2
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE2
 	if (tcpc->typec_legacy_cable != 1)
 		return;
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE2 */
@@ -1303,7 +1302,7 @@ static inline void typec_legacy_handle_detach(struct tcpc_device *tcpc)
 
 static inline int typec_legacy_handle_cc_open(struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE2
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE2
 	if (tcpc->typec_legacy_cable == 2) {
 		typec_legacy_keep_default_rp(tcpc, false);
 		return 1;
@@ -1315,7 +1314,7 @@ static inline int typec_legacy_handle_cc_open(struct tcpc_device *tcpc)
 
 static inline int typec_legacy_handle_cc_present(struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE2
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE2
 	return tcpc->typec_legacy_cable == 1;
 #else
 	return 1;
@@ -1348,7 +1347,7 @@ static inline int typec_legacy_handle_cc_change(struct tcpc_device *tcpc)
  * [BLOCK] CC Change (after debounce)
  */
 
-#ifdef CONFIG_TYPEC_CAP_DBGACC
+#if CONFIG_TYPEC_CAP_DBGACC
 static void typec_debug_acc_attached_with_vbus_entry(
 		struct tcpc_device *tcpc)
 {
@@ -1359,7 +1358,7 @@ static void typec_debug_acc_attached_with_vbus_entry(
 
 static inline void typec_debug_acc_attached_entry(struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_TYPEC_CAP_DBGACC
+#if CONFIG_TYPEC_CAP_DBGACC
 	TYPEC_NEW_STATE(typec_debugaccessory);
 	TYPEC_DBG("[Debug] CC1&2 Both Rd\n");
 	typec_wait_ps_change(tcpc, TYPEC_WAIT_PS_DBG_VSAFE5V);
@@ -1370,7 +1369,7 @@ static inline void typec_debug_acc_attached_entry(struct tcpc_device *tcpc)
 #endif	/* CONFIG_TYPEC_CAP_DBGACC */
 }
 
-#ifdef CONFIG_TYPEC_CAP_AUDIO_ACC_SINK_VBUS
+#if CONFIG_TYPEC_CAP_AUDIO_ACC_SINK_VBUS
 static inline bool typec_audio_acc_sink_vbus(
 	struct tcpc_device *tcpc, bool vbus_valid)
 {
@@ -1388,20 +1387,24 @@ static inline bool typec_audio_acc_sink_vbus(
 }
 #endif	/* CONFIG_TYPEC_CAP_AUDIO_ACC_SINK_VBUS */
 
+#if RICHTEK_PD_COMPLIANCE_FAKE_AUDIO_ACC ||\
+			RICHTEK_PD_COMPLIANCE_FAKE_EMRAK_ONLY
 static bool typec_is_fake_ra_rp30(struct tcpc_device *tcpc)
 {
-	if (TYPEC_CC_PULL_GET_RP_LVL(tcpc->typec_local_cc) == TYPEC_RP_3_0) {
-		__tcpci_set_cc(tcpc, TYPEC_CC_RP_DFT);
+	if (tcpc->typec_local_cc == TYPEC_CC_RP_3_0
+		|| tcpc->typec_local_cc == TYPEC_CC_DRP_3_0) {
+		tcpci_set_cc(tcpc, TYPEC_CC_RP_DFT);
 		usleep_range(1000, 2000);
 		return tcpci_get_cc(tcpc) != 0;
 	}
 
 	return false;
 }
+#endif
 
 static inline bool typec_audio_acc_attached_entry(struct tcpc_device *tcpc)
 {
-#ifdef RICHTEK_PD_COMPLIANCE_FAKE_AUDIO_ACC
+#if RICHTEK_PD_COMPLIANCE_FAKE_AUDIO_ACC
 	if (typec_is_fake_ra_rp30(tcpc)) {
 		TYPEC_DBG("[Audio] Fake Both Ra\n");
 		if (typec_check_cc_any(TYPEC_CC_VOLT_RD))
@@ -1416,7 +1419,7 @@ static inline bool typec_audio_acc_attached_entry(struct tcpc_device *tcpc)
 	TYPEC_DBG("[Audio] CC1&2 Both Ra\n");
 	tcpc->typec_attach_new = TYPEC_ATTACHED_AUDIO;
 
-#ifdef CONFIG_TYPEC_CAP_AUDIO_ACC_SINK_VBUS
+#if CONFIG_TYPEC_CAP_AUDIO_ACC_SINK_VBUS
 	if (tcpci_check_vbus_valid(tcpc))
 		typec_audio_acc_sink_vbus(tcpc, true);
 #endif	/* CONFIG_TYPEC_CAP_AUDIO_ACC_SINK_VBUS */
@@ -1437,7 +1440,7 @@ static inline bool typec_cc_change_source_entry(struct tcpc_device *tcpc)
 		if (!typec_check_cc_both(TYPEC_CC_VOLT_RA))
 			src_remove = true;
 		break;
-#ifdef CONFIG_TYPEC_CAP_DBGACC
+#if CONFIG_TYPEC_CAP_DBGACC
 	case typec_debugaccessory:
 		if (!typec_check_cc_both(TYPEC_CC_VOLT_RD))
 			src_remove = true;
@@ -1469,7 +1472,7 @@ static inline bool typec_attached_snk_cc_change(struct tcpc_device *tcpc)
 		TYPEC_INFO("RpLvl Change\n");
 		tcpc->typec_remote_rp_level = cc_res;
 
-#ifdef CONFIG_TYPEC_CAP_CUSTOM_HV
+#if CONFIG_TYPEC_CAP_CUSTOM_HV
 		if (tcpc->typec_during_custom_hv)
 			return true;
 #endif	/* CONFIG_TYPEC_CAP_CUSTOM_HV */
@@ -1493,7 +1496,7 @@ static inline bool typec_cc_change_sink_entry(struct tcpc_device *tcpc)
 			typec_attached_snk_cc_change(tcpc);
 		break;
 
-#ifdef CONFIG_TYPEC_CAP_DBGACC_SNK
+#if CONFIG_TYPEC_CAP_DBGACC_SNK
 	case typec_attached_dbgacc_snk:
 		if (typec_get_cc_res() == TYPEC_CC_VOLT_OPEN)
 			snk_remove = true;
@@ -1502,7 +1505,7 @@ static inline bool typec_cc_change_sink_entry(struct tcpc_device *tcpc)
 		break;
 #endif	/* CONFIG_TYPEC_CAP_DBGACC_SNK */
 
-#ifdef CONFIG_TYPEC_CAP_CUSTOM_SRC
+#if CONFIG_TYPEC_CAP_CUSTOM_SRC
 	case typec_attached_custom_src:
 		if (typec_check_cc_any(TYPEC_CC_VOLT_OPEN))
 			snk_remove = true;
@@ -1527,7 +1530,7 @@ bool tcpc_typec_is_act_as_sink_role(struct tcpc_device *tcpc)
 	bool as_sink = true;
 	uint8_t cc_sum;
 
-	switch (TYPEC_CC_PULL_GET_RES(tcpc->typec_local_cc)) {
+	switch (tcpc->typec_local_cc & 0x07) {
 	case TYPEC_CC_RP:
 		as_sink = false;
 		break;
@@ -1542,6 +1545,7 @@ bool tcpc_typec_is_act_as_sink_role(struct tcpc_device *tcpc)
 
 	return as_sink;
 }
+EXPORT_SYMBOL(tcpc_typec_is_act_as_sink_role);
 
 static inline bool typec_handle_cc_changed_entry(struct tcpc_device *tcpc)
 {
@@ -1565,13 +1569,13 @@ static inline bool typec_handle_cc_changed_entry(struct tcpc_device *tcpc)
 static inline void typec_attach_wait_entry(struct tcpc_device *tcpc)
 {
 	bool as_sink;
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	struct pd_port *pd_port = &tcpc->pd_port;
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
 	if (tcpc->typec_attach_old == TYPEC_ATTACHED_SNK ||
 	    tcpc->typec_attach_old == TYPEC_ATTACHED_DBGACC_SNK) {
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 		if (pd_port->pe_data.pd_connected && pd_check_rev30(pd_port))
 			pd_put_sink_tx_event(tcpc, typec_get_cc_res());
 #endif	/* CONFIG_USB_POWER_DELIVERY */
@@ -1584,15 +1588,13 @@ static inline void typec_attach_wait_entry(struct tcpc_device *tcpc)
 		tcpc->typec_state == typec_attached_src) {
 		tcpc_reset_typec_debounce_timer(tcpc);
 		TYPEC_DBG("Attached, Ignore cc_attach\n");
-#ifndef CONFIG_USB_POWER_DELIVERY
 		typec_enable_vconn(tcpc);
-#endif /* CONFIG_USB_POWER_DELIVERY */
 		return;
 	}
 
 	switch (tcpc->typec_state) {
 
-#ifdef CONFIG_TYPEC_CAP_TRY_SOURCE
+#if CONFIG_TYPEC_CAP_TRY_SOURCE
 	case typec_try_src:
 		tcpc_enable_timer(tcpc, TYPEC_TIMER_TRYCCDEBOUNCE);
 		return;
@@ -1602,7 +1604,7 @@ static inline void typec_attach_wait_entry(struct tcpc_device *tcpc)
 		return;
 #endif
 
-#ifdef CONFIG_TYPEC_CAP_TRY_SINK
+#if CONFIG_TYPEC_CAP_TRY_SINK
 	case typec_try_snk:	/* typec_drp_try_timeout = true */
 		tcpc_enable_timer(tcpc, TYPEC_TIMER_TRYCCDEBOUNCE);
 		return;
@@ -1612,7 +1614,7 @@ static inline void typec_attach_wait_entry(struct tcpc_device *tcpc)
 		return;
 #endif	/* CONFIG_TYPEC_CAP_TRY_SINK */
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	case typec_unattachwait_pe:
 		TYPEC_INFO("Force PE Idle\n");
 		tcpc->pd_wait_pe_idle = false;
@@ -1626,12 +1628,12 @@ static inline void typec_attach_wait_entry(struct tcpc_device *tcpc)
 
 	as_sink = tcpc_typec_is_act_as_sink_role(tcpc);
 
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE
 	if (!as_sink && typec_legacy_check_cable(tcpc))
 		return;
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE */
 
-#ifdef CONFIG_TYPEC_NOTIFY_ATTACHWAIT
+#if CONFIG_TYPEC_NOTIFY_ATTACHWAIT
 	tcpci_notify_attachwait_state(tcpc, as_sink);
 #endif	/* CONFIG_TYPEC_NOTIFY_ATTACHWAIT */
 
@@ -1639,25 +1641,24 @@ static inline void typec_attach_wait_entry(struct tcpc_device *tcpc)
 		TYPEC_NEW_STATE(typec_attachwait_snk);
 	else {
 		/* Advertise Rp level before Attached.SRC Ellisys 3.1.6359 */
-		tcpci_set_cc(tcpc,
-			TYPEC_CC_PULL(tcpc->typec_local_rp_level, TYPEC_CC_RP));
+		tcpci_set_cc(tcpc, tcpc->typec_local_rp_level);
 		TYPEC_NEW_STATE(typec_attachwait_src);
 	}
 
 	tcpc_enable_timer(tcpc, TYPEC_TIMER_CCDEBOUNCE);
 }
 
-#ifdef TYPEC_EXIT_ATTACHED_SNK_VIA_VBUS
+#if TYPEC_EXIT_ATTACHED_SNK_VIA_VBUS
 static inline int typec_attached_snk_cc_detach(struct tcpc_device *tcpc)
 {
 	tcpc_reset_typec_debounce_timer(tcpc);
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	/*
 	 * For Source detach during HardReset,
 	 * However Apple TA may keep cc_open about 150 ms during HardReset
 	 */
 	if (tcpc->pd_wait_hard_reset_complete) {
-#ifdef CONFIG_COMPATIBLE_APPLE_TA
+#if CONFIG_COMPATIBLE_APPLE_TA
 		TYPEC_INFO2("Detach_CC (HardReset), compatible apple TA\n");
 		tcpc_enable_timer(tcpc, TYPEC_TIMER_APPLE_CC_OPEN);
 #else
@@ -1675,14 +1676,14 @@ static inline int typec_attached_snk_cc_detach(struct tcpc_device *tcpc)
 
 static inline void typec_detach_wait_entry(struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE
 	typec_legacy_handle_detach(tcpc);
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE */
 
 	switch (tcpc->typec_state) {
-#ifdef TYPEC_EXIT_ATTACHED_SNK_VIA_VBUS
+#if TYPEC_EXIT_ATTACHED_SNK_VIA_VBUS
 	case typec_attached_snk:
-#ifdef CONFIG_TYPEC_CAP_DBGACC_SNK
+#if CONFIG_TYPEC_CAP_DBGACC_SNK
 	case typec_attached_dbgacc_snk:
 #endif	/* CONFIG_TYPEC_CAP_DBGACC_SNK */
 		typec_attached_snk_cc_detach(tcpc);
@@ -1697,7 +1698,7 @@ static inline void typec_detach_wait_entry(struct tcpc_device *tcpc)
 		tcpc_enable_timer(tcpc, TYPEC_TIMER_CCDEBOUNCE);
 		break;
 
-#ifdef TYPEC_EXIT_ATTACHED_SRC_NO_DEBOUNCE
+#if TYPEC_EXIT_ATTACHED_SRC_NO_DEBOUNCE
 	case typec_attached_src:
 		TYPEC_INFO("Exit Attached.SRC immediately\n");
 		tcpc_reset_typec_debounce_timer(tcpc);
@@ -1710,7 +1711,7 @@ static inline void typec_detach_wait_entry(struct tcpc_device *tcpc)
 		break;
 #endif /* TYPEC_EXIT_ATTACHED_SRC_NO_DEBOUNCE */
 
-#ifdef CONFIG_TYPEC_CAP_TRY_SOURCE
+#if CONFIG_TYPEC_CAP_TRY_SOURCE
 	case typec_try_src:
 		if (tcpc->typec_drp_try_timeout)
 			tcpc_enable_timer(tcpc, TYPEC_TIMER_PDDEBOUNCE);
@@ -1721,7 +1722,7 @@ static inline void typec_detach_wait_entry(struct tcpc_device *tcpc)
 		break;
 #endif	/* CONFIG_TYPEC_CAP_TRY_SOURCE */
 
-#ifdef CONFIG_TYPEC_CAP_TRY_SINK
+#if CONFIG_TYPEC_CAP_TRY_SINK
 	case typec_trywait_src:
 		if (tcpc->typec_drp_try_timeout)
 			tcpc_enable_timer(tcpc, TYPEC_TIMER_TRYCCDEBOUNCE);
@@ -1746,7 +1747,7 @@ static inline bool typec_is_cc_attach(struct tcpc_device *tcpc)
 
 	tcpc->typec_cable_only = false;
 
-#ifdef RICHTEK_PD_COMPLIANCE_FAKE_RA_DETACH
+#if RICHTEK_PD_COMPLIANCE_FAKE_RA_DETACH
 	if (tcpc->typec_attach_old == TYPEC_ATTACHED_SRC
 		&& (cc_res == TYPEC_CC_VOLT_RA) &&
 		(tcpc->typec_local_cc == TYPEC_CC_RP_DFT)) {
@@ -1769,7 +1770,7 @@ static inline bool typec_is_cc_attach(struct tcpc_device *tcpc)
 				(cc_res != TYPEC_CC_VOLT_RA))
 			cc_attach = true;
 		break;
-#ifdef CONFIG_TYPEC_CAP_CUSTOM_SRC
+#if CONFIG_TYPEC_CAP_CUSTOM_SRC
 	case TYPEC_ATTACHED_CUSTOM_SRC:
 		if ((cc_res != TYPEC_CC_VOLT_OPEN) &&
 				(cc_res != TYPEC_CC_VOLT_RA))
@@ -1777,7 +1778,7 @@ static inline bool typec_is_cc_attach(struct tcpc_device *tcpc)
 		break;
 #endif	/* CONFIG_TYPEC_CAP_CUSTOM_SRC */
 
-#ifdef CONFIG_TYPEC_CAP_DBGACC_SNK
+#if CONFIG_TYPEC_CAP_DBGACC_SNK
 	case TYPEC_ATTACHED_DBGACC_SNK:
 		if ((cc_res != TYPEC_CC_VOLT_OPEN) &&
 				(cc_res != TYPEC_CC_VOLT_RA))
@@ -1789,7 +1790,7 @@ static inline bool typec_is_cc_attach(struct tcpc_device *tcpc)
 			cc_attach = true;
 		break;
 
-#ifdef CONFIG_TYPEC_CAP_DBGACC
+#if CONFIG_TYPEC_CAP_DBGACC
 	case TYPEC_ATTACHED_DEBUG:
 		if (typec_check_cc_both(TYPEC_CC_VOLT_RD))
 			cc_attach = true;
@@ -1804,7 +1805,7 @@ static inline bool typec_is_cc_attach(struct tcpc_device *tcpc)
 
 		/* Cable Only, no device */
 		if ((cc1+cc2) == TYPEC_CC_VOLT_RA) {
-#ifdef RICHTEK_PD_COMPLIANCE_FAKE_EMRAK_ONLY
+#if RICHTEK_PD_COMPLIANCE_FAKE_EMRAK_ONLY
 			if (typec_is_fake_ra_rp30(tcpc)) {
 				TYPEC_DBG("[Cable] Fake Ra\n");
 				if ((cc1+cc2) == TYPEC_CC_VOLT_RD)
@@ -1885,13 +1886,13 @@ static inline bool typec_check_false_ra_detach(struct tcpc_device *tcpc)
 		return true;
 	}
 
-#ifdef CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
+#if CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
 	if (tcpc->typec_cable_only &&
 		tcpc->tcpc_flags & TCPC_FLAGS_LPM_WAKEUP_WATCHDOG)
 		tcpc_enable_wakeup_timer(tcpc, true);
 #endif	/* CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG */
 
-#ifdef CONFIG_TYPEC_WAKEUP_ONCE_LOW_DUTY
+#if CONFIG_TYPEC_WAKEUP_ONCE_LOW_DUTY
 	if (!tcpc->typec_cable_only) {
 		if (tcpc->typec_low_rp_duty_cntdown)
 			tcpci_set_low_rp_duty(tcpc, true);
@@ -1933,13 +1934,13 @@ int tcpc_typec_enter_lpm_again(struct tcpc_device *tcpc)
 	return 0;
 }
 
-#ifdef CONFIG_TYPEC_CAP_TRY_SINK
+#if CONFIG_TYPEC_CAP_TRY_SINK
 static inline int typec_handle_try_sink_cc_change(
 	struct tcpc_device *tcpc)
 {
 	/*
 	 * The port shall wait for tDRPTry and only then begin
-	 * begin monitoring the CC1 and CC2 pins for the SNK.Rp state
+	 * monitoring the CC1 and CC2 pins for the SNK.Rp state
 	 */
 
 	if (!tcpc->typec_drp_try_timeout) {
@@ -1979,13 +1980,17 @@ static bool typec_is_cc_open_state(struct tcpc_device *tcpc)
 	if (tcpc->typec_state == typec_disabled)
 		return true;
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 	if ((tcpc->tcpc_flags & TCPC_FLAGS_WATER_DETECTION) &&
 	    (tcpc->typec_state == typec_water_protection_wait ||
 	    tcpc->typec_state == typec_water_protection))
 		return true;
 #endif /* CONFIG_WATER_DETECTION */
 
+	if ((tcpc->tcpc_flags & TCPC_FLAGS_FOREIGN_OBJECT_DETECTION) &&
+	    tcpc->typec_state == typec_foreign_object_protection)
+		return true;
+
 	return false;
 }
 
@@ -1995,14 +2000,14 @@ static inline bool typec_is_ignore_cc_change(
 	if (typec_is_cc_open_state(tcpc))
 		return true;
 
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE
 	if (tcpc->typec_legacy_cable &&
 		typec_legacy_handle_cc_change(tcpc)) {
 		return true;
 	}
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE */
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	if (tcpc->typec_state == typec_attachwait_snk &&
 		typec_get_rp_present_flag(tcpc) == rp_present) {
 		TYPEC_DBG("[AttachWait] Ignore RpLvl Alert\n");
@@ -2015,7 +2020,7 @@ static inline bool typec_is_ignore_cc_change(
 	}
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
-#ifdef CONFIG_TYPEC_CAP_TRY_SINK
+#if CONFIG_TYPEC_CAP_TRY_SINK
 	if (tcpc->typec_state == typec_try_snk) {
 		if (typec_handle_try_sink_cc_change(tcpc) > 0)
 			return true;
@@ -2027,13 +2032,19 @@ static inline bool typec_is_ignore_cc_change(
 	}
 #endif	/* CONFIG_TYPEC_CAP_TRY_SINK */
 
-#ifdef CONFIG_TYPEC_CAP_TRY_SOURCE
+#if CONFIG_TYPEC_CAP_TRY_SOURCE
 	if (tcpc->typec_state == typec_trywait_snk_pe) {
 		TYPEC_DBG("[Try.PE] Ignore CC_Alert\n");
 		return true;
 	}
 #endif	/* CONFIG_TYPEC_CAP_TRY_SOURCE */
 
+	if ((tcpc->tcpc_flags & TCPC_FLAGS_TYPEC_OTP) &&
+	    tcpc->typec_otp) {
+		TYPEC_INFO("[TypeC.OTP] Ignore CC_Alert\n");
+		return true;
+	}
+
 	return false;
 }
 
@@ -2042,7 +2053,7 @@ int tcpc_typec_handle_cc_change(struct tcpc_device *tcpc)
 	int ret;
 	uint8_t rp_present;
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 	/* For ellisys rp/rp to rp/open */
 	u8 typec_state_old = tcpc->typec_state;
 #endif /* CONFIG_WATER_DETECTION */
@@ -2063,7 +2074,7 @@ int tcpc_typec_handle_cc_change(struct tcpc_device *tcpc)
 			return 0;
 	}
 
-#ifdef CONFIG_TYPEC_CAP_NORP_SRC
+#if CONFIG_TYPEC_CAP_NORP_SRC
 	if (typec_try_exit_norp_src(tcpc))
 		return 0;
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
@@ -2078,20 +2089,29 @@ int tcpc_typec_handle_cc_change(struct tcpc_device *tcpc)
 	if (typec_is_cc_attach(tcpc)) {
 		typec_disable_low_power_mode(tcpc);
 		typec_attach_wait_entry(tcpc);
-#ifdef CONFIG_WATER_DETECTION
-		if (typec_state_old == typec_unattached_snk ||
-		    typec_state_old == typec_unattached_src) {
-#ifdef CONFIG_WD_POLLING_ONLY
-			if (get_boot_mode() == KERNEL_POWER_OFF_CHARGING_BOOT
-			    || get_boot_mode() == LOW_POWER_OFF_CHARGING_BOOT)
-				typec_check_water_status(tcpc);
+		if (tcpc->tcpc_flags & TCPC_FLAGS_FLOATING_GROUND)
+			tcpci_set_floating_ground(tcpc, false);
+		if ((tcpc->tcpc_flags & TCPC_FLAGS_TYPEC_OTP) &&
+			((typec_get_cc1() + typec_get_cc2()) >= TYPEC_CC_VOLT_SNK_DFT))
+			tcpci_set_otp_fwen(tcpc, true);
+#if CONFIG_WATER_DETECTION
+		if ((tcpc->tcpc_flags & TCPC_FLAGS_WATER_DETECTION) &&
+			(typec_state_old == typec_unattached_snk ||
+			typec_state_old == typec_unattached_src))
+#if CONFIG_WD_POLLING_ONLY
+			if (tcpc->tcpc_flags & TCPC_FLAGS_WD_POLLING_ONLY)
+				if (tcpc->bootmode == 8 ||
+				    tcpc->bootmode == 9)
+					typec_check_water_status(tcpc);
 #else
-			typec_check_water_status(tcpc);
+				typec_check_water_status(tcpc);
 #endif /* CONFIG_WD_POLLING_ONLY */
-		}
 #endif /* CONFIG_WATER_DETECTION */
-	} else
+	} else {
+		if (tcpc->tcpc_flags & TCPC_FLAGS_TYPEC_OTP)
+			tcpci_set_otp_fwen(tcpc, false);
 		typec_detach_wait_entry(tcpc);
+	}
 
 	return 0;
 }
@@ -2100,7 +2120,7 @@ int tcpc_typec_handle_cc_change(struct tcpc_device *tcpc)
  * [BLOCK] Handle timeout event
  */
 
-#ifdef CONFIG_TYPEC_CAP_TRY_STATE
+#if CONFIG_TYPEC_CAP_TRY_STATE
 static inline int typec_handle_drp_try_timeout(struct tcpc_device *tcpc)
 {
 	bool src_detect = false, en_timer;
@@ -2116,13 +2136,13 @@ static inline int typec_handle_drp_try_timeout(struct tcpc_device *tcpc)
 	src_detect = typec_check_cc_any(TYPEC_CC_VOLT_RD);
 
 	switch (tcpc->typec_state) {
-#ifdef CONFIG_TYPEC_CAP_TRY_SOURCE
+#if CONFIG_TYPEC_CAP_TRY_SOURCE
 	case typec_try_src:
 		en_timer = !src_detect;
 		break;
 #endif /* CONFIG_TYPEC_CAP_TRY_SOURCE */
 
-#ifdef CONFIG_TYPEC_CAP_TRY_SINK
+#if CONFIG_TYPEC_CAP_TRY_SINK
 	case typec_trywait_src:
 		en_timer = !src_detect;
 		break;
@@ -2148,7 +2168,13 @@ static inline int typec_handle_drp_try_timeout(struct tcpc_device *tcpc)
 
 static inline int typec_handle_debounce_timeout(struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_TYPEC_CAP_NORP_SRC
+	if ((tcpc->tcpc_flags & TCPC_FLAGS_TYPEC_OTP) &&
+	    tcpc->typec_state == typec_otp) {
+		TYPEC_DBG("%s TypeC.OTP not to handle cc change\n", __func__);
+		return 0;
+	}
+
+#if CONFIG_TYPEC_CAP_NORP_SRC
 	if (typec_is_cc_no_res() && tcpci_check_vbus_valid(tcpc)
 		&& (tcpc->typec_state == typec_unattached_snk))
 		return typec_norp_src_attached_entry(tcpc);
@@ -2159,7 +2185,7 @@ static inline int typec_handle_debounce_timeout(struct tcpc_device *tcpc)
 		return 0;
 	}
 
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE
 	tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_STATE_CHANGE);
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE */
 
@@ -2170,7 +2196,7 @@ static inline int typec_handle_debounce_timeout(struct tcpc_device *tcpc)
 static inline int typec_handle_error_recovery_timeout(
 						struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	tcpc->pd_wait_pe_idle = false;
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
@@ -2179,12 +2205,12 @@ static inline int typec_handle_error_recovery_timeout(
 	return 0;
 }
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 static inline int typec_handle_pe_idle(struct tcpc_device *tcpc)
 {
 	switch (tcpc->typec_state) {
 
-#ifdef CONFIG_TYPEC_CAP_TRY_SOURCE
+#if CONFIG_TYPEC_CAP_TRY_SOURCE
 	case typec_trywait_snk_pe:
 		typec_trywait_snk_entry(tcpc);
 		break;
@@ -2202,23 +2228,25 @@ static inline int typec_handle_pe_idle(struct tcpc_device *tcpc)
 	return 0;
 }
 
-#ifdef CONFIG_USB_PD_WAIT_BC12
+#if CONFIG_USB_PD_WAIT_BC12
 static inline void typec_handle_pd_wait_bc12(struct tcpc_device *tcpc)
 {
+	int ret = 0;
 	uint8_t type = TYPEC_UNATTACHED;
-	enum charger_type chg_type = CHARGER_UNKNOWN;
+	union power_supply_propval val = {.intval = 0};
 
 	mutex_lock(&tcpc->access_lock);
 
 	type = tcpc->typec_attach_new;
-	chg_type = mt_get_charger_type();
-	TYPEC_INFO("type=%d, chg_type=%d, count=%d\n", type, chg_type,
-		tcpc->pd_wait_bc12_count);
+	ret = power_supply_get_property(tcpc->chg_psy,
+		POWER_SUPPLY_PROP_USB_TYPE, &val);
+	TYPEC_INFO("type=%d, ret,chg_type=%d,%d, count=%d\n", type,
+		ret, val.intval, tcpc->pd_wait_bc12_count);
 
 	if (type != TYPEC_ATTACHED_SNK && type != TYPEC_ATTACHED_DBGACC_SNK)
 		goto out;
 
-	if (chg_type != CHARGER_UNKNOWN ||
+	if ((ret >= 0 && val.intval != POWER_SUPPLY_USB_TYPE_UNKNOWN) ||
 		tcpc->pd_wait_bc12_count >= 20) {
 		__pd_put_cc_attached_event(tcpc, type);
 	} else {
@@ -2246,7 +2274,7 @@ static inline int typec_handle_src_reach_vsafe0v(struct tcpc_device *tcpc)
 
 static inline int typec_handle_src_toggle_timeout(struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
+#if CONFIG_TYPEC_CAP_ROLE_SWAP
 	if (tcpc->typec_during_role_swap)
 		return 0;
 #endif	/* CONFIG_TYPEC_CAP_ROLE_SWAP */
@@ -2254,7 +2282,7 @@ static inline int typec_handle_src_toggle_timeout(struct tcpc_device *tcpc)
 	if (tcpc->typec_state == typec_unattached_src) {
 		typec_unattached_snk_and_drp_entry(tcpc);
 		typec_wait_ps_change(tcpc, TYPEC_WAIT_PS_DISABLE);
-#ifdef CONFIG_TYPEC_CAP_NORP_SRC
+#if CONFIG_TYPEC_CAP_NORP_SRC
 		typec_try_enter_norp_src(tcpc);
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
 	}
@@ -2262,7 +2290,7 @@ static inline int typec_handle_src_toggle_timeout(struct tcpc_device *tcpc)
 	return 0;
 }
 
-#ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
+#if CONFIG_TYPEC_CAP_ROLE_SWAP
 static inline int typec_handle_role_swap_start(struct tcpc_device *tcpc)
 {
 	uint8_t role_swap = tcpc->typec_during_role_swap;
@@ -2296,12 +2324,12 @@ int tcpc_typec_handle_timeout(struct tcpc_device *tcpc, uint32_t timer_id)
 {
 	int ret = 0;
 
-#ifdef CONFIG_TYPEC_CAP_TRY_STATE
+#if CONFIG_TYPEC_CAP_TRY_STATE
 	if (timer_id == TYPEC_TRY_TIMER_DRP_TRY)
 		return typec_handle_drp_try_timeout(tcpc);
 #endif	/* CONFIG_TYPEC_CAP_TRY_STATE */
 
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE
 	if (timer_id == TYPEC_TIMER_DRP_SRC_TOGGLE &&
 		(tcpc->typec_state != typec_unattached_src)) {
 		TCPC_DBG("Dummy SRC_TOGGLE\n");
@@ -2323,7 +2351,7 @@ int tcpc_typec_handle_timeout(struct tcpc_device *tcpc, uint32_t timer_id)
 		return 0;
 	}
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	if (tcpc->pd_wait_pr_swap_complete) {
 		TYPEC_DBG("[PR.Swap] Ignore timer_evt\n");
 		return 0;
@@ -2331,8 +2359,8 @@ int tcpc_typec_handle_timeout(struct tcpc_device *tcpc, uint32_t timer_id)
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
 	switch (timer_id) {
-#ifdef CONFIG_USB_POWER_DELIVERY
-#ifdef CONFIG_COMPATIBLE_APPLE_TA
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
+#if CONFIG_COMPATIBLE_APPLE_TA
 	case TYPEC_TIMER_APPLE_CC_OPEN:
 #endif /* CONFIG_COMPATIBLE_APPLE_TA */
 #endif	/* CONFIG_USB_POWER_DELIVERY */
@@ -2340,25 +2368,24 @@ int tcpc_typec_handle_timeout(struct tcpc_device *tcpc, uint32_t timer_id)
 	case TYPEC_TIMER_PDDEBOUNCE:
 	case TYPEC_TIMER_TRYCCDEBOUNCE:
 	case TYPEC_TIMER_SRCDISCONNECT:
-		/* fall through */
-#ifdef CONFIG_TYPEC_CAP_NORP_SRC
+#if CONFIG_TYPEC_CAP_NORP_SRC
 	case TYPEC_TIMER_NORP_SRC:
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
 		ret = typec_handle_debounce_timeout(tcpc);
 		break;
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	case TYPEC_RT_TIMER_PE_IDLE:
 		ret = typec_handle_pe_idle(tcpc);
 		break;
-#ifdef CONFIG_USB_PD_WAIT_BC12
+#if CONFIG_USB_PD_WAIT_BC12
 	case TYPEC_RT_TIMER_PD_WAIT_BC12:
 		typec_handle_pd_wait_bc12(tcpc);
 		break;
 #endif /* CONFIG_USB_PD_WAIT_BC12 */
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
-#ifdef CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_DELAY
+#if CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_DELAY
 	case TYPEC_RT_TIMER_SAFE0V_DELAY:
 		ret = typec_handle_src_reach_vsafe0v(tcpc);
 		break;
@@ -2369,7 +2396,7 @@ int tcpc_typec_handle_timeout(struct tcpc_device *tcpc, uint32_t timer_id)
 			typec_try_low_power_mode(tcpc);
 		break;
 
-#ifdef CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_TIMEOUT
+#if CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_TIMEOUT
 	case TYPEC_RT_TIMER_SAFE0V_TOUT:
 		TCPC_INFO("VSafe0V TOUT (%d)\n", tcpc->vbus_level);
 
@@ -2382,7 +2409,7 @@ int tcpc_typec_handle_timeout(struct tcpc_device *tcpc, uint32_t timer_id)
 		ret = typec_handle_src_toggle_timeout(tcpc);
 		break;
 
-#ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
+#if CONFIG_TYPEC_CAP_ROLE_SWAP
 	case TYPEC_RT_TIMER_ROLE_SWAP_START:
 		typec_handle_role_swap_start(tcpc);
 		break;
@@ -2401,20 +2428,20 @@ int tcpc_typec_handle_timeout(struct tcpc_device *tcpc, uint32_t timer_id)
 		}
 		break;
 
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE
 	case TYPEC_RT_TIMER_NOT_LEGACY:
 		tcpc->typec_legacy_cable = false;
 		typec_legacy_reset_retry_wk(tcpc);
 		typec_legacy_reset_cable_suspect(tcpc);
 		break;
 
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE2
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE2
 	case TYPEC_RT_TIMER_LEGACY_STABLE:
 		if (tcpc->typec_legacy_cable)
 			tcpc->typec_legacy_retry_wk--;
 		break;
 
-#ifdef CONFIG_TYPEC_LEGACY2_AUTO_RECYCLE
+#if CONFIG_TYPEC_LEGACY2_AUTO_RECYCLE
 	case TYPEC_RT_TIMER_LEGACY_RECYCLE:
 		if (tcpc->typec_legacy_cable == 2) {
 			TYPEC_INFO("LC->Recycle\n");
@@ -2445,7 +2472,7 @@ static inline int typec_handle_vbus_present(struct tcpc_device *tcpc)
 	case TYPEC_WAIT_PS_SRC_VSAFE5V:
 		typec_source_attached_with_vbus_entry(tcpc);
 
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE
 		if (typec_get_cc_res() != TYPEC_CC_VOLT_RD) {
 			typec_postpone_state_change(tcpc);
 			break;
@@ -2454,7 +2481,7 @@ static inline int typec_handle_vbus_present(struct tcpc_device *tcpc)
 
 		typec_alert_attach_state_change(tcpc);
 		break;
-#ifdef CONFIG_TYPEC_CAP_DBGACC
+#if CONFIG_TYPEC_CAP_DBGACC
 	case TYPEC_WAIT_PS_DBG_VSAFE5V:
 		typec_debug_acc_attached_with_vbus_entry(tcpc);
 		typec_alert_attach_state_change(tcpc);
@@ -2467,9 +2494,9 @@ static inline int typec_handle_vbus_present(struct tcpc_device *tcpc)
 
 static inline int typec_attached_snk_vbus_absent(struct tcpc_device *tcpc)
 {
-#ifdef TYPEC_EXIT_ATTACHED_SNK_VIA_VBUS
-#ifdef CONFIG_USB_POWER_DELIVERY
-#ifdef CONFIG_USB_PD_DIRECT_CHARGE
+#if TYPEC_EXIT_ATTACHED_SNK_VIA_VBUS
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
+#if CONFIG_USB_PD_DIRECT_CHARGE
 	if (tcpc->pd_during_direct_charge &&
 		!tcpci_check_vsafe0v(tcpc, true)) {
 		TYPEC_DBG("Ignore vbus_absent(snk), DirectCharge\n");
@@ -2478,7 +2505,7 @@ static inline int typec_attached_snk_vbus_absent(struct tcpc_device *tcpc)
 #endif	/* CONFIG_USB_PD_DIRECT_CHARGE */
 
 	if (tcpc->pd_wait_hard_reset_complete) {
-#ifdef CONFIG_COMPATIBLE_APPLE_TA
+#if CONFIG_COMPATIBLE_APPLE_TA
 		TYPEC_DBG("Ignore vbus_absent(snk) and CC, HReset(apple)\n");
 		return 0;
 #else
@@ -2501,7 +2528,7 @@ static inline int typec_attached_snk_vbus_absent(struct tcpc_device *tcpc)
 
 static inline int typec_handle_vbus_absent(struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	if (tcpc->pd_wait_pr_swap_complete) {
 		TYPEC_DBG("[PR.Swap] Ignore vbus_absent\n");
 		return 0;
@@ -2510,7 +2537,7 @@ static inline int typec_handle_vbus_absent(struct tcpc_device *tcpc)
 
 	switch (tcpc->typec_state) {
 	case typec_attached_snk:
-#ifdef CONFIG_TYPEC_CAP_DBGACC_SNK
+#if CONFIG_TYPEC_CAP_DBGACC_SNK
 	case typec_attached_dbgacc_snk:
 #endif	/* CONFIG_TYPEC_CAP_DBGACC_SNK */
 		typec_attached_snk_vbus_absent(tcpc);
@@ -2519,7 +2546,7 @@ static inline int typec_handle_vbus_absent(struct tcpc_device *tcpc)
 		break;
 	}
 
-#ifndef CONFIG_TCPC_VSAFE0V_DETECT
+#if !CONFIG_TCPC_VSAFE0V_DETECT
 	tcpc_typec_handle_vsafe0v(tcpc);
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT */
 
@@ -2530,14 +2557,14 @@ int tcpc_typec_handle_ps_change(struct tcpc_device *tcpc, int vbus_level)
 {
 	tcpc->typec_reach_vsafe0v = false;
 
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE
 	if (tcpc->typec_legacy_cable) {
 		typec_legacy_handle_ps_change(tcpc, vbus_level);
 		return 0;
 	}
 #endif /* CONFIG_TYPEC_CHECK_LEGACY_CABLE */
 
-#ifdef CONFIG_TYPEC_CAP_NORP_SRC
+#if CONFIG_TYPEC_CAP_NORP_SRC
 	if (!typec_try_enter_norp_src(tcpc))
 		if (typec_try_exit_norp_src(tcpc))
 			return 0;
@@ -2551,7 +2578,7 @@ int tcpc_typec_handle_ps_change(struct tcpc_device *tcpc, int vbus_level)
 			return 0;
 	}
 
-#ifdef CONFIG_TYPEC_CAP_AUDIO_ACC_SINK_VBUS
+#if CONFIG_TYPEC_CAP_AUDIO_ACC_SINK_VBUS
 	if (tcpc->typec_state == typec_audioaccessory) {
 		return typec_audio_acc_sink_vbus(
 			tcpc, vbus_level >= TCPC_VBUS_VALID);
@@ -2568,7 +2595,7 @@ int tcpc_typec_handle_ps_change(struct tcpc_device *tcpc, int vbus_level)
  * [BLOCK] Handle PE event
  */
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 
 int tcpc_typec_handle_pe_pr_swap(struct tcpc_device *tcpc)
 {
@@ -2580,8 +2607,7 @@ int tcpc_typec_handle_pe_pr_swap(struct tcpc_device *tcpc)
 		TYPEC_NEW_STATE(typec_attached_src);
 		tcpc->typec_is_attached_src = true;
 		tcpc->typec_attach_new = TYPEC_ATTACHED_SRC;
-		tcpci_set_cc(tcpc,
-			TYPEC_CC_PULL(tcpc->typec_local_rp_level, TYPEC_CC_RP));
+		tcpci_set_cc(tcpc, tcpc->typec_local_rp_level);
 		break;
 	case typec_attached_src:
 		TYPEC_NEW_STATE(typec_attached_snk);
@@ -2606,7 +2632,7 @@ int tcpc_typec_handle_pe_pr_swap(struct tcpc_device *tcpc)
 
 int tcpc_typec_handle_vsafe0v(struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 	if ((tcpc->tcpc_flags & TCPC_FLAGS_WATER_DETECTION) &&
 	    tcpc->typec_state == typec_water_protection_wait) {
 		TYPEC_NEW_STATE(typec_water_protection);
@@ -2616,7 +2642,7 @@ int tcpc_typec_handle_vsafe0v(struct tcpc_device *tcpc)
 #endif /* CONFIG_WATER_DETECTION */
 
 	if (tcpc->typec_wait_ps_change == TYPEC_WAIT_PS_SRC_VSAFE0V) {
-#ifdef CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_DELAY
+#if CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_DELAY
 		tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_SAFE0V_DELAY);
 #else
 		typec_handle_src_reach_vsafe0v(tcpc);
@@ -2641,7 +2667,7 @@ static const char *const typec_role_name[] = {
 };
 #endif /* TYPEC_INFO_ENABLE */
 
-#ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
+#if CONFIG_TYPEC_CAP_ROLE_SWAP
 int tcpc_typec_swap_role(struct tcpc_device *tcpc)
 {
 	if (tcpc->typec_role < TYPEC_ROLE_DRP)
@@ -2670,20 +2696,30 @@ int tcpc_typec_swap_role(struct tcpc_device *tcpc)
 }
 #endif /* CONFIG_TYPEC_CAP_ROLE_SWAP */
 
-int tcpc_typec_set_rp_level(struct tcpc_device *tcpc, uint8_t rp_lvl)
+int tcpc_typec_set_rp_level(struct tcpc_device *tcpc, uint8_t res)
 {
-	switch (rp_lvl) {
-	case TYPEC_RP_DFT:
-	case TYPEC_RP_1_5:
-	case TYPEC_RP_3_0:
-		TYPEC_INFO("TypeC-Rp: %d\n", rp_lvl);
-		tcpc->typec_local_rp_level = rp_lvl;
+	switch (res) {
+	case TYPEC_CC_RP_DFT:
+	case TYPEC_CC_RP_1_5:
+	case TYPEC_CC_RP_3_0:
+		TYPEC_INFO("TypeC-Rp: %d\n", res);
+		tcpc->typec_local_rp_level = res;
 		break;
+
 	default:
-		TYPEC_INFO("TypeC-Unknown-Rp (%d)\n", rp_lvl);
+		TYPEC_INFO("TypeC-Unknown-Rp (%d)\n", res);
 		return -EINVAL;
 	}
 
+#if CONFIG_USB_PD_DBG_ALWAYS_LOCAL_RP
+	tcpci_set_cc(tcpc, tcpc->typec_local_rp_level);
+#else
+	if ((tcpc->typec_attach_old != TYPEC_UNATTACHED) &&
+		(tcpc->typec_attach_new != TYPEC_UNATTACHED)) {
+		return tcpci_set_cc(tcpc, res);
+	}
+#endif
+
 	return 0;
 }
 
@@ -2735,7 +2771,7 @@ int tcpc_typec_change_role(
 		return 0;
 }
 
-#ifdef CONFIG_TYPEC_CAP_POWER_OFF_CHARGE
+#if CONFIG_TYPEC_CAP_POWER_OFF_CHARGE
 static int typec_init_power_off_charge(struct tcpc_device *tcpc)
 {
 	bool cc_open;
@@ -2749,7 +2785,7 @@ static int typec_init_power_off_charge(struct tcpc_device *tcpc)
 
 	cc_open = typec_is_cc_open();
 
-#ifndef CONFIG_TYPEC_CAP_NORP_SRC
+#if !CONFIG_TYPEC_CAP_NORP_SRC
 	if (cc_open)
 		return 0;
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
@@ -2766,7 +2802,7 @@ static int typec_init_power_off_charge(struct tcpc_device *tcpc)
 	typec_enable_low_power_mode(tcpc, TYPEC_CC_DRP);
 	usleep_range(1000, 2000);
 
-#ifdef CONFIG_TYPEC_CAP_NORP_SRC
+#if CONFIG_TYPEC_CAP_NORP_SRC
 	if (cc_open) {
 		tcpc_enable_timer(tcpc, TYPEC_TIMER_PDDEBOUNCE);
 		return 1;
@@ -2805,23 +2841,23 @@ int tcpc_typec_init(struct tcpc_device *tcpc, uint8_t typec_role)
 	mutex_unlock(&tcpc->access_lock);
 	tcpc->typec_usb_sink_curr = CONFIG_TYPEC_SNK_CURR_DFT;
 
-#ifdef CONFIG_TYPEC_CAP_CUSTOM_HV
+#if CONFIG_TYPEC_CAP_CUSTOM_HV
 	tcpc->typec_during_custom_hv = false;
 #endif	/* CONFIG_TYPEC_CAP_CUSTOM_HV */
 
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
+#if CONFIG_TYPEC_CHECK_LEGACY_CABLE
 	tcpc->typec_legacy_cable = false;
 	typec_legacy_reset_retry_wk(tcpc);
 	typec_legacy_reset_cable_suspect(tcpc);
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE */
 
-#ifdef CONFIG_TYPEC_CAP_POWER_OFF_CHARGE
+#if CONFIG_TYPEC_CAP_POWER_OFF_CHARGE
 	ret = typec_init_power_off_charge(tcpc);
 	if (ret != 0)
 		return ret;
 #endif	/* CONFIG_TYPEC_CAP_POWER_OFF_CHARGE */
 
-#ifdef CONFIG_TYPEC_POWER_CTRL_INIT
+#if CONFIG_TYPEC_POWER_CTRL_INIT
 	tcpc->typec_power_ctrl = true;
 #endif	/* CONFIG_TYPEC_POWER_CTRL_INIT */
 
@@ -2833,12 +2869,11 @@ void  tcpc_typec_deinit(struct tcpc_device *tcpc)
 {
 }
 
-#ifdef CONFIG_WATER_DETECTION
+#if CONFIG_WATER_DETECTION
 int tcpc_typec_handle_wd(struct tcpc_device *tcpc, bool wd)
 {
 	int ret = 0;
 
-	pr_info("%s: wd = %d\n", __func__, wd);
 	if (!(tcpc->tcpc_flags & TCPC_FLAGS_WATER_DETECTION))
 		return 0;
 
@@ -2849,18 +2884,14 @@ int tcpc_typec_handle_wd(struct tcpc_device *tcpc, bool wd)
 		goto out;
 	}
 
-#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
-	ret = get_boot_mode();
-	if (ret == KERNEL_POWER_OFF_CHARGING_BOOT ||
-	    ret == LOW_POWER_OFF_CHARGING_BOOT) {
+	if (tcpc->bootmode == 8 || tcpc->bootmode == 9) {
 		TYPEC_INFO("KPOC does not enter water protection\n");
 		goto out;
 	}
-#endif /* CONFIG_MTK_KERNEL_POWER_OFF_CHARGING */
 
 	tcpc->typec_attach_new = TYPEC_UNATTACHED;
 	ret = tcpci_set_cc(tcpc, TYPEC_CC_OPEN);
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+#if CONFIG_TCPC_VSAFE0V_DETECT_IC
 	ret = tcpci_is_vsafe0v(tcpc);
 	if (ret == 0) {
 		TYPEC_NEW_STATE(typec_water_protection_wait);
@@ -2882,18 +2913,122 @@ out:
 	}
 	return ret;
 }
+EXPORT_SYMBOL(tcpc_typec_handle_wd);
+
 #endif /* CONFIG_WATER_DETECTION */
 
-#ifdef CONFIG_CABLE_TYPE_DETECTION
+int tcpc_typec_handle_fod(struct tcpc_device *tcpc,
+			  enum tcpc_fod_status fod)
+{
+	int ret;
+	enum tcpc_fod_status fod_old = tcpc->typec_fod;
+
+	if (!(tcpc->tcpc_flags & TCPC_FLAGS_FOREIGN_OBJECT_DETECTION))
+		return 0;
+
+	TCPC_INFO("%s fod (%d, %d)\n", __func__, tcpc->typec_fod, fod);
+	if (tcpc->typec_fod == fod)
+		return 0;
+	if (tcpc->typec_fod != TCPC_FOD_NONE && fod != TCPC_FOD_NONE) {
+		TCPC_INFO("%s fod done once %d\n", __func__,
+			  tcpc->typec_fod);
+		return 0;
+	}
+	tcpc->typec_fod = fod;
+
+#if CONFIG_CABLE_TYPE_DETECTION
+	if ((tcpc->tcpc_flags & TCPC_FLAGS_CABLE_TYPE_DETECTION) &&
+	    (tcpc->typec_cable_type == TCPC_CABLE_TYPE_C2C))
+		tcpc_typec_handle_ctd(tcpc, tcpc->typec_cable_type);
+#endif /* CONFIG_CABLE_TYPE_DETECTION */
+
+	if ((fod_old == TCPC_FOD_LR) && (fod == TCPC_FOD_NONE)) {
+		tcpci_set_cc_hidet(tcpc, false);
+		tcpc_typec_error_recovery(tcpc);
+		goto out;
+	}
+	if (fod != TCPC_FOD_LR)
+		goto out;
+
+	if (tcpc->bootmode == 8 || tcpc->bootmode == 9) {
+		TYPEC_INFO("Not to do foreign object protection in KPOC\r\n");
+		goto out;
+	}
+
+	TYPEC_NEW_STATE(typec_foreign_object_protection);
+	tcpc->typec_attach_new = TYPEC_UNATTACHED;
+	ret = tcpci_set_cc(tcpc, TYPEC_CC_OPEN);
+	ret = tcpci_set_cc_hidet(tcpc, true);
+out:
+	tcpci_notify_fod_status(tcpc);
+	if (tcpc->typec_state == typec_foreign_object_protection) {
+		typec_alert_attach_state_change(tcpc);
+		tcpc->typec_attach_old = tcpc->typec_attach_new;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(tcpc_typec_handle_fod);
+
+bool tcpc_typec_ignore_fod(struct tcpc_device *tcpc)
+{
+	return (tcpc->typec_state == typec_attached_snk ||
+		tcpc->typec_state == typec_attached_src ||
+#if CONFIG_TYPEC_CAP_TRY_SINK
+		tcpc->typec_state == typec_try_snk ||
+#endif  /* CONFIG_TYPEC_CAP_TRY_SINK */
+		tcpc->typec_fod != TCPC_FOD_NONE);
+}
+EXPORT_SYMBOL(tcpc_typec_ignore_fod);
+
+int tcpc_typec_handle_otp(struct tcpc_device *tcpc, bool otp)
+{
+	TCPC_INFO("%s otp (%d, %d)\n", __func__, tcpc->typec_otp, otp);
+
+	if (!(tcpc->tcpc_flags & TCPC_FLAGS_TYPEC_OTP))
+		return 0;
+
+	if (tcpc->typec_otp == otp)
+		return 0;
+	tcpc->typec_otp = otp;
+	if (!otp) {
+		tcpci_set_cc_hidet(tcpc, false);
+		tcpc_typec_error_recovery(tcpc);
+		goto out;
+	}
+
+	TYPEC_NEW_STATE(typec_otp);
+	tcpc->typec_attach_new = TYPEC_UNATTACHED;
+	tcpci_set_cc(tcpc, TYPEC_CC_OPEN);
+	tcpci_set_cc_hidet(tcpc, true);
+
+out:
+	tcpci_notify_typec_otp(tcpc);
+	if (tcpc->typec_state == typec_otp) {
+		typec_alert_attach_state_change(tcpc);
+		tcpc->typec_attach_old = tcpc->typec_attach_new;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(tcpc_typec_handle_otp);
+
+#if CONFIG_CABLE_TYPE_DETECTION
 int tcpc_typec_handle_ctd(struct tcpc_device *tcpc,
 			  enum tcpc_cable_type cable_type)
 {
 	int ret;
 
 	TCPC_INFO("%s: cable_type = %d\n", __func__, cable_type);
+
 	if (!(tcpc->tcpc_flags & TCPC_FLAGS_CABLE_TYPE_DETECTION))
 		return 0;
 
+	if (tcpc->tcpc_flags & TCPC_FLAGS_FOREIGN_OBJECT_DETECTION) {
+		if ((cable_type == TCPC_CABLE_TYPE_C2C) &&
+		    (tcpc->typec_fod == TCPC_FOD_DISCHG_FAIL ||
+		     tcpc->typec_fod == TCPC_FOD_OV))
+			cable_type = TCPC_CABLE_TYPE_A2C;
+	}
+
 	/* Filter out initial no cable */
 	if (cable_type == TCPC_CABLE_TYPE_C2C) {
 		ret = tcpci_get_cc(tcpc);
@@ -2907,24 +3042,6 @@ int tcpc_typec_handle_ctd(struct tcpc_device *tcpc,
 		}
 	}
 
-	TCPC_INFO("%s: typec_state=%s, pre_ct=%d, ct=%d, typec_ct=%d\n",
-		  __func__, typec_state_name[tcpc->typec_state],
-		  tcpc->pre_typec_cable_type,
-		  cable_type,  tcpc->typec_cable_type);
-
-	if (tcpc->typec_state == typec_attachwait_snk) {
-		TCPC_INFO("%s during attachwait_snk\n", __func__);
-		tcpc->pre_typec_cable_type = cable_type;
-	} else if (tcpc->typec_state == typec_try_snk ||
-		   (tcpc->typec_state == typec_attached_snk &&
-			cable_type != TCPC_CABLE_TYPE_NONE)) {
-		if (tcpc->pre_typec_cable_type != TCPC_CABLE_TYPE_NONE) {
-			TCPC_INFO("%s try_snk cable(%d, %d)\n", __func__,
-				  tcpc->pre_typec_cable_type, cable_type);
-			cable_type = tcpc->pre_typec_cable_type;
-			tcpc->pre_typec_cable_type = TCPC_CABLE_TYPE_NONE;
-		}
-	}
 	TCPC_INFO("%s cable (%d, %d)\n", __func__, tcpc->typec_cable_type,
 		  cable_type);
 
@@ -2944,4 +3061,10 @@ int tcpc_typec_handle_ctd(struct tcpc_device *tcpc,
 	tcpci_notify_cable_type(tcpc);
 	return 0;
 }
+EXPORT_SYMBOL(tcpc_typec_handle_ctd);
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
+
+bool tcpc_typec_is_cc_attach(struct tcpc_device *tcpc)
+{
+	return typec_is_cc_attach(tcpc);
+}
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpm.c b/drivers/misc/mediatek/typec/tcpc/tcpm.c
index 9f68dab..b263eb2 100644
--- a/drivers/misc/mediatek/typec/tcpc/tcpm.c
+++ b/drivers/misc/mediatek/typec/tcpc/tcpm.c
@@ -1,23 +1,13 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016 MediaTek Inc.
- *
- * Power Delivery Managert Driver
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * Copyright (c) 2020 MediaTek Inc.
  */
 
 #include "inc/tcpm.h"
 #include "inc/tcpci.h"
 #include "inc/tcpci_typec.h"
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 #include "inc/pd_core.h"
 #include "inc/pd_dpm_core.h"
 #include "pd_dpm_prv.h"
@@ -36,8 +26,8 @@ static int tcpm_check_typec_attached(struct tcpc_device *tcpc)
 	return 0;
 }
 
-#ifdef CONFIG_USB_POWER_DELIVERY
-static int tcpm_check_pd_attached(struct tcpc_device *tcpc)
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
+int tcpm_check_pd_attached(struct tcpc_device *tcpc)
 {
 	int ret = TCPM_SUCCESS;
 	struct pd_port *pd_port = &tcpc->pd_port;
@@ -71,6 +61,7 @@ unlock_pd_out:
 	mutex_unlock(&pd_port->pd_lock);
 	return ret;
 }
+EXPORT_SYMBOL(tcpm_check_pd_attached);
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
 
@@ -78,7 +69,7 @@ unlock_pd_out:
 
 int tcpm_shutdown(struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_TCPC_SHUTDOWN_VBUS_DISABLE
+#if CONFIG_TCPC_SHUTDOWN_VBUS_DISABLE
 	if (tcpc->typec_power_ctrl)
 		tcpci_disable_vbus_control(tcpc);
 #endif	/* CONFIG_TCPC_SHUTDOWN_VBUS_DISABLE */
@@ -88,6 +79,7 @@ int tcpm_shutdown(struct tcpc_device *tcpc)
 
 	return 0;
 }
+EXPORT_SYMBOL(tcpm_shutdown);
 
 int tcpm_inquire_remote_cc(struct tcpc_device *tcpc,
 	uint8_t *cc1, uint8_t *cc2, bool from_ic)
@@ -107,6 +99,7 @@ out:
 	tcpci_unlock_typec(tcpc);
 	return rv;
 }
+EXPORT_SYMBOL(tcpm_inquire_remote_cc);
 
 int tcpm_inquire_typec_remote_rp_curr(struct tcpc_device *tcpc)
 {
@@ -132,8 +125,10 @@ int tcpm_inquire_typec_remote_rp_curr(struct tcpc_device *tcpc)
 
 	return ret;
 }
+EXPORT_SYMBOL(tcpm_inquire_typec_remote_rp_curr);
 
-int tcpm_inquire_vbus_level(struct tcpc_device *tcpc, bool from_ic)
+int tcpm_inquire_vbus_level(
+	struct tcpc_device *tcpc, bool from_ic)
 {
 	int rv = 0;
 	uint16_t power_status = 0;
@@ -146,28 +141,67 @@ int tcpm_inquire_vbus_level(struct tcpc_device *tcpc, bool from_ic)
 
 	return tcpc->vbus_level;
 }
+EXPORT_SYMBOL(tcpm_inquire_vbus_level);
 
-bool tcpm_inquire_cc_polarity(struct tcpc_device *tcpc)
+bool tcpm_inquire_cc_polarity(
+	struct tcpc_device *tcpc)
 {
 	return tcpc->typec_polarity;
 }
+EXPORT_SYMBOL(tcpm_inquire_cc_polarity);
 
-uint8_t tcpm_inquire_typec_attach_state(struct tcpc_device *tcpc)
+uint8_t tcpm_inquire_typec_attach_state(
+	struct tcpc_device *tcpc)
 {
 	return tcpc->typec_attach_new;
 }
+EXPORT_SYMBOL(tcpm_inquire_typec_attach_state);
 
-uint8_t tcpm_inquire_typec_role(struct tcpc_device *tcpc)
+atomic_t tcpm_inquire_pending_event(
+	struct tcpc_device *tcpc)
+{
+	return tcpc->pending_event;
+}
+EXPORT_SYMBOL(tcpm_inquire_pending_event);
+
+atomic_t tcpm_inquire_suspend_pending(
+	struct tcpc_device *tcpc)
+{
+	return tcpc->suspend_pending;
+}
+EXPORT_SYMBOL(tcpm_inquire_suspend_pending);
+
+uint8_t tcpm_inquire_typec_role(
+	struct tcpc_device *tcpc)
 {
 	return tcpc->typec_role;
 }
+EXPORT_SYMBOL(tcpm_inquire_typec_role);
 
-uint8_t tcpm_inquire_typec_local_rp(struct tcpc_device *tcpc)
+uint8_t tcpm_inquire_typec_local_rp(
+	struct tcpc_device *tcpc)
 {
-	return tcpc->typec_local_rp_level;
+	uint8_t level;
+
+	switch (tcpc->typec_local_rp_level) {
+	case TYPEC_CC_RP_1_5:
+		level = 1;
+		break;
+	case TYPEC_CC_RP_3_0:
+		level = 2;
+		break;
+	default:
+	case TYPEC_CC_RP_DFT:
+		level = 0;
+		break;
+	}
+
+	return level;
 }
+EXPORT_SYMBOL(tcpm_inquire_typec_local_rp);
 
-int tcpm_typec_set_wake_lock(struct tcpc_device *tcpc, bool user_lock)
+int tcpm_typec_set_wake_lock(
+	struct tcpc_device *tcpc, bool user_lock)
 {
 	int ret;
 
@@ -179,12 +213,14 @@ int tcpm_typec_set_wake_lock(struct tcpc_device *tcpc, bool user_lock)
 
 	return ret;
 }
+EXPORT_SYMBOL(tcpm_typec_set_wake_lock);
 
-int tcpm_typec_set_usb_sink_curr(struct tcpc_device *tcpc, int curr)
+int tcpm_typec_set_usb_sink_curr(
+	struct tcpc_device *tcpc, int curr)
 {
 	bool force_sink_vbus = true;
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 	struct pd_port *pd_port = &tcpc->pd_port;
 
 	if (pd_port->pe_data.pd_prev_connected)
@@ -205,21 +241,32 @@ int tcpm_typec_set_usb_sink_curr(struct tcpc_device *tcpc, int curr)
 
 	return 0;
 }
+EXPORT_SYMBOL(tcpm_typec_set_usb_sink_curr);
 
-int tcpm_typec_set_rp_level(struct tcpc_device *tcpc, uint8_t level)
+int tcpm_typec_set_rp_level(
+	struct tcpc_device *tcpc, uint8_t level)
 {
 	int ret = 0;
+	uint8_t res;
+
+	if (level == 2)
+		res = TYPEC_CC_RP_3_0;
+	else if (level == 1)
+		res = TYPEC_CC_RP_1_5;
+	else
+		res = TYPEC_CC_RP_DFT;
 
 	tcpci_lock_typec(tcpc);
-	ret = tcpc_typec_set_rp_level(tcpc, level);
+	ret = tcpc_typec_set_rp_level(tcpc, res);
 	tcpci_unlock_typec(tcpc);
 
 	return ret;
 }
+EXPORT_SYMBOL(tcpm_typec_set_rp_level);
 
 int tcpm_typec_set_custom_hv(struct tcpc_device *tcpc, bool en)
 {
-#ifdef CONFIG_TYPEC_CAP_CUSTOM_HV
+#if CONFIG_TYPEC_CAP_CUSTOM_HV
 	int ret = tcpm_check_typec_attached(tcpc);
 
 	if (ret != TCPM_SUCCESS)
@@ -234,10 +281,11 @@ int tcpm_typec_set_custom_hv(struct tcpc_device *tcpc, bool en)
 	return TCPM_ERROR_NO_SUPPORT;
 #endif	/* CONFIG_TYPEC_CAP_CUSTOM_HV */
 }
+EXPORT_SYMBOL(tcpm_typec_set_custom_hv);
 
 int tcpm_typec_role_swap(struct tcpc_device *tcpc)
 {
-#ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
+#if CONFIG_TYPEC_CAP_ROLE_SWAP
 	int ret = tcpm_check_typec_attached(tcpc);
 
 	if (ret != TCPM_SUCCESS)
@@ -252,6 +300,7 @@ int tcpm_typec_role_swap(struct tcpc_device *tcpc)
 	return TCPM_ERROR_NO_SUPPORT;
 #endif /* CONFIG_TYPEC_CAP_ROLE_SWAP */
 }
+EXPORT_SYMBOL(tcpm_typec_role_swap);
 
 int tcpm_typec_change_role(
 	struct tcpc_device *tcpc, uint8_t typec_role)
@@ -264,6 +313,7 @@ int tcpm_typec_change_role(
 
 	return ret;
 }
+EXPORT_SYMBOL(tcpm_typec_change_role);
 
 /* @postpone: whether to postpone Type-C role change until unattached */
 int tcpm_typec_change_role_postpone(
@@ -277,6 +327,7 @@ int tcpm_typec_change_role_postpone(
 
 	return ret;
 }
+EXPORT_SYMBOL(tcpm_typec_change_role_postpone);
 
 int tcpm_typec_error_recovery(struct tcpc_device *tcpc)
 {
@@ -288,8 +339,10 @@ int tcpm_typec_error_recovery(struct tcpc_device *tcpc)
 
 	return ret;
 }
+EXPORT_SYMBOL(tcpm_typec_error_recovery);
 
-int tcpm_typec_disable_function(struct tcpc_device *tcpc, bool disable)
+int tcpm_typec_disable_function(
+	struct tcpc_device *tcpc, bool disable)
 {
 	int ret = 0;
 
@@ -299,52 +352,74 @@ int tcpm_typec_disable_function(struct tcpc_device *tcpc, bool disable)
 
 	return ret;
 }
+EXPORT_SYMBOL(tcpm_typec_disable_function);
 
-#ifdef CONFIG_USB_POWER_DELIVERY
+#if IS_ENABLED(CONFIG_USB_POWER_DELIVERY)
 
-bool tcpm_inquire_pd_connected(struct tcpc_device *tcpc)
+bool tcpm_inquire_pd_connected(
+	struct tcpc_device *tcpc)
 {
 	struct pd_port *pd_port = &tcpc->pd_port;
 
 	return pd_port->pe_data.pd_connected;
 }
+EXPORT_SYMBOL(tcpm_inquire_pd_connected);
 
-bool tcpm_inquire_pd_prev_connected(struct tcpc_device *tcpc)
+bool tcpm_inquire_pd_prev_connected(
+	struct tcpc_device *tcpc)
 {
 	struct pd_port *pd_port = &tcpc->pd_port;
 
 	return pd_port->pe_data.pd_prev_connected;
 }
+EXPORT_SYMBOL(tcpm_inquire_pd_prev_connected);
 
-uint8_t tcpm_inquire_pd_data_role(struct tcpc_device *tcpc)
+uint8_t tcpm_inquire_pd_data_role(
+	struct tcpc_device *tcpc)
 {
 	struct pd_port *pd_port = &tcpc->pd_port;
 
 	return pd_port->data_role;
 }
+EXPORT_SYMBOL(tcpm_inquire_pd_data_role);
 
-uint8_t tcpm_inquire_pd_power_role(struct tcpc_device *tcpc)
+uint8_t tcpm_inquire_pd_power_role(
+	struct tcpc_device *tcpc)
 {
 	struct pd_port *pd_port = &tcpc->pd_port;
 
 	return pd_port->power_role;
 }
+EXPORT_SYMBOL(tcpm_inquire_pd_power_role);
+
+uint8_t tcpm_inquire_pd_state_curr(
+	struct tcpc_device *tcpc_dev)
+{
+	struct pd_port *pd_port = &tcpc_dev->pd_port;
+	return pd_port->pe_state_curr;
+}
+EXPORT_SYMBOL(tcpm_inquire_pd_state_curr);
 
-uint8_t tcpm_inquire_pd_vconn_role(struct tcpc_device *tcpc)
+uint8_t tcpm_inquire_pd_vconn_role(
+	struct tcpc_device *tcpc)
 {
 	struct pd_port *pd_port = &tcpc->pd_port;
 
 	return pd_port->vconn_role;
 }
+EXPORT_SYMBOL(tcpm_inquire_pd_vconn_role);
 
-uint8_t tcpm_inquire_pd_pe_ready(struct tcpc_device *tcpc)
+uint8_t tcpm_inquire_pd_pe_ready(
+	struct tcpc_device *tcpc)
 {
 	struct pd_port *pd_port = &tcpc->pd_port;
 
 	return pd_port->pe_data.pe_ready;
 }
+EXPORT_SYMBOL(tcpm_inquire_pd_pe_ready);
 
-uint8_t tcpm_inquire_cable_current(struct tcpc_device *tcpc)
+uint8_t tcpm_inquire_cable_current(
+	struct tcpc_device *tcpc)
 {
 	struct pd_port *pd_port = &tcpc->pd_port;
 
@@ -353,6 +428,7 @@ uint8_t tcpm_inquire_cable_current(struct tcpc_device *tcpc)
 
 	return PD_CABLE_CURR_UNKNOWN;
 }
+EXPORT_SYMBOL(tcpm_inquire_cable_current);
 
 uint32_t tcpm_inquire_dpm_flags(struct tcpc_device *tcpc)
 {
@@ -360,6 +436,7 @@ uint32_t tcpm_inquire_dpm_flags(struct tcpc_device *tcpc)
 
 	return pd_port->pe_data.dpm_flags;
 }
+EXPORT_SYMBOL(tcpm_inquire_dpm_flags);
 
 uint32_t tcpm_inquire_dpm_caps(struct tcpc_device *tcpc)
 {
@@ -367,6 +444,7 @@ uint32_t tcpm_inquire_dpm_caps(struct tcpc_device *tcpc)
 
 	return pd_port->dpm_caps;
 }
+EXPORT_SYMBOL(tcpm_inquire_dpm_caps);
 
 void tcpm_set_dpm_caps(struct tcpc_device *tcpc, uint32_t caps)
 {
@@ -376,10 +454,12 @@ void tcpm_set_dpm_caps(struct tcpc_device *tcpc, uint32_t caps)
 	pd_port->dpm_caps = caps;
 	mutex_unlock(&pd_port->pd_lock);
 }
+EXPORT_SYMBOL(tcpm_set_dpm_caps);
 
 /* Inquire TCPC to get PD Information */
 
-int tcpm_inquire_pd_contract(struct tcpc_device *tcpc, int *mv, int *ma)
+int tcpm_inquire_pd_contract(
+	struct tcpc_device *tcpc, int *mv, int *ma)
 {
 	int ret;
 	struct pd_port *pd_port = &tcpc->pd_port;
@@ -402,8 +482,10 @@ int tcpm_inquire_pd_contract(struct tcpc_device *tcpc, int *mv, int *ma)
 	return ret;
 
 }
+EXPORT_SYMBOL(tcpm_inquire_pd_contract);
 
-int tcpm_inquire_cable_inform(struct tcpc_device *tcpc, uint32_t *vdos)
+int tcpm_inquire_cable_inform(
+	struct tcpc_device *tcpc, uint32_t *vdos)
 {
 	int ret;
 	struct pd_port *pd_port = &tcpc->pd_port;
@@ -425,10 +507,12 @@ int tcpm_inquire_cable_inform(struct tcpc_device *tcpc, uint32_t *vdos)
 
 	return ret;
 }
+EXPORT_SYMBOL(tcpm_inquire_cable_inform);
 
-int tcpm_inquire_pd_partner_inform(struct tcpc_device *tcpc, uint32_t *vdos)
+int tcpm_inquire_pd_partner_inform(
+	struct tcpc_device *tcpc, uint32_t *vdos)
 {
-#ifdef CONFIG_USB_PD_KEEP_PARTNER_ID
+#if CONFIG_USB_PD_KEEP_PARTNER_ID
 	int ret;
 	struct pd_port *pd_port = &tcpc->pd_port;
 
@@ -452,11 +536,12 @@ int tcpm_inquire_pd_partner_inform(struct tcpc_device *tcpc, uint32_t *vdos)
 	return TCPM_ERROR_NO_SUPPORT;
 #endif	/* CONFIG_USB_PD_KEEP_PARTNER_ID */
 }
+EXPORT_SYMBOL(tcpm_inquire_pd_partner_inform);
 
 int tcpm_inquire_pd_partner_svids(
 	struct tcpc_device *tcpc, struct tcpm_svid_list *list)
 {
-#ifdef CONFIG_USB_PD_KEEP_SVIDS
+#if CONFIG_USB_PD_KEEP_SVIDS
 	int ret;
 	struct pd_port *pd_port = &tcpc->pd_port;
 	struct svdm_svid_list *svdm_list = &pd_port->pe_data.remote_svid_list;
@@ -482,11 +567,12 @@ int tcpm_inquire_pd_partner_svids(
 	return TCPM_ERROR_NO_SUPPORT;
 #endif	/* CONFIG_USB_PD_KEEP_SVIDS */
 }
+EXPORT_SYMBOL(tcpm_inquire_pd_partner_svids);
 
 int tcpm_inquire_pd_partner_modes(
 	struct tcpc_device *tcpc, uint16_t svid, struct tcpm_mode_list *list)
 {
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 	int ret = TCPM_SUCCESS;
 	struct svdm_svid_data *svid_data = NULL;
 	struct pd_port *pd_port = &tcpc->pd_port;
@@ -514,6 +600,7 @@ int tcpm_inquire_pd_partner_modes(
 	return TCPM_ERROR_NO_SUPPORT;
 #endif	/* CONFIG_USB_PD_KEEP_SVIDS */
 }
+EXPORT_SYMBOL(tcpm_inquire_pd_partner_modes);
 
 int tcpm_inquire_pd_source_cap(
 	struct tcpc_device *tcpc, struct tcpm_power_cap *cap)
@@ -539,6 +626,7 @@ int tcpm_inquire_pd_source_cap(
 
 	return ret;
 }
+EXPORT_SYMBOL(tcpm_inquire_pd_source_cap);
 
 int tcpm_inquire_pd_sink_cap(
 	struct tcpc_device *tcpc, struct tcpm_power_cap *cap)
@@ -564,8 +652,10 @@ int tcpm_inquire_pd_sink_cap(
 
 	return ret;
 }
+EXPORT_SYMBOL(tcpm_inquire_pd_sink_cap);
 
-bool tcpm_extract_power_cap_val(uint32_t pdo, struct tcpm_power_cap_val *cap)
+bool tcpm_extract_power_cap_val(
+	uint32_t pdo, struct tcpm_power_cap_val *cap)
 {
 	struct dpm_pdo_info_t info;
 
@@ -580,7 +670,7 @@ bool tcpm_extract_power_cap_val(uint32_t pdo, struct tcpm_power_cap_val *cap)
 	else
 		cap->ma = info.ma;
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 	if (info.type == DPM_PDO_TYPE_APDO) {
 		cap->apdo_type = info.apdo_type;
 		cap->pwr_limit = info.pwr_limit;
@@ -589,8 +679,9 @@ bool tcpm_extract_power_cap_val(uint32_t pdo, struct tcpm_power_cap_val *cap)
 
 	return cap->type != TCPM_POWER_CAP_VAL_TYPE_UNKNOWN;
 }
+EXPORT_SYMBOL(tcpm_extract_power_cap_val);
 
-extern bool tcpm_extract_power_cap_list(
+bool tcpm_extract_power_cap_list(
 	struct tcpm_power_cap *cap, struct tcpm_power_cap_list *cap_list)
 {
 	uint8_t i;
@@ -604,6 +695,7 @@ extern bool tcpm_extract_power_cap_list(
 
 	return true;
 }
+EXPORT_SYMBOL(tcpm_extract_power_cap_list);
 
 int tcpm_get_remote_power_cap(struct tcpc_device *tcpc,
 		struct tcpm_remote_power_cap *remote_cap)
@@ -630,11 +722,14 @@ int tcpm_get_remote_power_cap(struct tcpc_device *tcpc,
 
 	return TCPM_SUCCESS;
 }
+EXPORT_SYMBOL(tcpm_get_remote_power_cap);
 
-int tcpm_set_remote_power_cap(struct tcpc_device *tcpc, int mv, int ma)
+int tcpm_set_remote_power_cap(struct tcpc_device *tcpc,
+				int mv, int ma)
 {
 	return tcpm_dpm_pd_request(tcpc, mv, ma, NULL);
 }
+EXPORT_SYMBOL(tcpm_set_remote_power_cap);
 
 static inline int __tcpm_inquire_select_source_cap(
 	struct pd_port *pd_port, struct tcpm_power_cap_val *cap_val)
@@ -675,11 +770,12 @@ int tcpm_inquire_select_source_cap(
 
 	return ret;
 }
+EXPORT_SYMBOL(tcpm_inquire_select_source_cap);
 
 
 /* Request TCPC to send PD Request */
 
-#ifdef CONFIG_USB_PD_BLOCK_TCPM
+#if CONFIG_USB_PD_BLOCK_TCPM
 
 #define TCPM_BK_PD_CMD_TOUT	500
 
@@ -709,7 +805,7 @@ static int tcpm_put_tcp_dpm_event_cbk1(struct tcpc_device *tcpc,
 	struct tcp_dpm_event *event,
 	const struct tcp_dpm_event_cb_data *cb_data, uint32_t tout_ms)
 {
-#ifdef CONFIG_USB_PD_BLOCK_TCPM
+#if CONFIG_USB_PD_BLOCK_TCPM
 	if (cb_data == NULL) {
 		return tcpm_put_tcp_dpm_event_bk(
 			tcpc, event, tout_ms, NULL, 0);
@@ -729,6 +825,7 @@ int tcpm_dpm_pd_power_swap(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_PR_SWAP_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_power_swap);
 
 int tcpm_dpm_pd_data_swap(struct tcpc_device *tcpc,
 	uint8_t role, const struct tcp_dpm_event_cb_data *cb_data)
@@ -740,6 +837,7 @@ int tcpm_dpm_pd_data_swap(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_data_swap);
 
 int tcpm_dpm_pd_vconn_swap(struct tcpc_device *tcpc,
 	uint8_t role, const struct tcp_dpm_event_cb_data *cb_data)
@@ -751,6 +849,7 @@ int tcpm_dpm_pd_vconn_swap(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_vconn_swap);
 
 int tcpm_dpm_pd_goto_min(struct tcpc_device *tcpc,
 	const struct tcp_dpm_event_cb_data *cb_data)
@@ -762,6 +861,7 @@ int tcpm_dpm_pd_goto_min(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_goto_min);
 
 int tcpm_dpm_pd_soft_reset(struct tcpc_device *tcpc,
 	const struct tcp_dpm_event_cb_data *cb_data)
@@ -773,6 +873,7 @@ int tcpm_dpm_pd_soft_reset(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_REQUEST_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_soft_reset);
 
 int tcpm_dpm_pd_get_source_cap(struct tcpc_device *tcpc,
 	const struct tcp_dpm_event_cb_data *cb_data)
@@ -784,6 +885,7 @@ int tcpm_dpm_pd_get_source_cap(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_REQUEST_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_get_source_cap);
 
 int tcpm_dpm_pd_get_sink_cap(struct tcpc_device *tcpc,
 	const struct tcp_dpm_event_cb_data *cb_data)
@@ -795,6 +897,7 @@ int tcpm_dpm_pd_get_sink_cap(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_get_sink_cap);
 
 int tcpm_dpm_pd_request(struct tcpc_device *tcpc,
 	int mv, int ma, const struct tcp_dpm_event_cb_data *cb_data)
@@ -808,6 +911,7 @@ int tcpm_dpm_pd_request(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_REQUEST_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_request);
 
 int tcpm_dpm_pd_request_ex(struct tcpc_device *tcpc,
 	uint8_t pos, uint32_t max, uint32_t oper,
@@ -826,6 +930,7 @@ int tcpm_dpm_pd_request_ex(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_REQUEST_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_request_ex);
 
 int tcpm_dpm_pd_bist_cm2(struct tcpc_device *tcpc,
 	const struct tcp_dpm_event_cb_data *cb_data)
@@ -837,15 +942,16 @@ int tcpm_dpm_pd_bist_cm2(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_bist_cm2);
 
-#ifdef CONFIG_USB_PD_REV30
+#if CONFIG_USB_PD_REV30
 
 static int tcpm_put_tcp_dpm_event_cbk2(struct tcpc_device *tcpc,
 	struct tcp_dpm_event *event,
 	const struct tcp_dpm_event_cb_data *cb_data,
 	uint32_t tout_ms, uint8_t *data, uint8_t size)
 {
-#ifdef CONFIG_USB_PD_BLOCK_TCPM
+#if CONFIG_USB_PD_BLOCK_TCPM
 	if (cb_data == NULL) {
 		return tcpm_put_tcp_dpm_event_bk(
 			tcpc, event, tout_ms, data, size);
@@ -867,12 +973,14 @@ int tcpm_dpm_pd_get_source_cap_ext(struct tcpc_device *tcpc,
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT,
 		(uint8_t *) src_cap_ext, PD_SCEDB_SIZE);
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_get_source_cap_ext);
 
 int tcpm_dpm_pd_fast_swap(struct tcpc_device *tcpc,
 	uint8_t role, const struct tcp_dpm_event_cb_data *cb_data)
 {
 	return TCPM_ERROR_NO_SUPPORT;
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_fast_swap);
 
 int tcpm_dpm_pd_get_status(struct tcpc_device *tcpc,
 	const struct tcp_dpm_event_cb_data *cb_data, struct pd_status *status)
@@ -885,6 +993,7 @@ int tcpm_dpm_pd_get_status(struct tcpc_device *tcpc,
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT,
 		(uint8_t *) status, PD_SDB_SIZE);
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_get_status);
 
 int tcpm_dpm_pd_get_pps_status_raw(struct tcpc_device *tcpc,
 	const struct tcp_dpm_event_cb_data *cb_data,
@@ -898,6 +1007,7 @@ int tcpm_dpm_pd_get_pps_status_raw(struct tcpc_device *tcpc,
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT,
 		(uint8_t *) pps_status, PD_PPSSDB_SIZE);
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_get_pps_status_raw);
 
 int tcpm_dpm_pd_get_pps_status(struct tcpc_device *tcpc,
 	const struct tcp_dpm_event_cb_data *cb_data,
@@ -927,6 +1037,7 @@ int tcpm_dpm_pd_get_pps_status(struct tcpc_device *tcpc,
 	pps_status->real_time_flags = pps_status_raw.real_time_flags;
 	return ret;
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_get_pps_status);
 
 int tcpm_dpm_pd_get_country_code(struct tcpc_device *tcpc,
 	const struct tcp_dpm_event_cb_data *cb_data,
@@ -940,6 +1051,7 @@ int tcpm_dpm_pd_get_country_code(struct tcpc_device *tcpc,
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT,
 		(uint8_t *) ccdb, PD_CCDB_MAX_SIZE);
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_get_country_code);
 
 int tcpm_dpm_pd_get_country_info(struct tcpc_device *tcpc, uint32_t ccdo,
 	const struct tcp_dpm_event_cb_data *cb_data,
@@ -954,6 +1066,7 @@ int tcpm_dpm_pd_get_country_info(struct tcpc_device *tcpc, uint32_t ccdo,
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT,
 		(uint8_t *) cidb, PD_CIDB_MAX_SIZE);
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_get_country_info);
 
 int tcpm_dpm_pd_get_bat_cap(struct tcpc_device *tcpc,
 	struct pd_get_battery_capabilities *gbcdb,
@@ -969,6 +1082,7 @@ int tcpm_dpm_pd_get_bat_cap(struct tcpc_device *tcpc,
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT,
 		(uint8_t *) bcdb, PD_BCDB_SIZE);
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_get_bat_cap);
 
 int tcpm_dpm_pd_get_bat_status(struct tcpc_device *tcpc,
 	struct pd_get_battery_status *gbsdb,
@@ -984,6 +1098,7 @@ int tcpm_dpm_pd_get_bat_status(struct tcpc_device *tcpc,
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT,
 		(uint8_t *) bsdo, sizeof(uint32_t) * PD_BSDO_SIZE);
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_get_bat_status);
 
 int tcpm_dpm_pd_get_mfrs_info(struct tcpc_device *tcpc,
 	struct pd_get_manufacturer_info *gmidb,
@@ -999,6 +1114,7 @@ int tcpm_dpm_pd_get_mfrs_info(struct tcpc_device *tcpc,
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT,
 		(uint8_t *) midb, PD_MIDB_MAX_SIZE);
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_get_mfrs_info);
 
 int tcpm_dpm_pd_alert(struct tcpc_device *tcpc,
 	uint32_t ado, const struct tcp_dpm_event_cb_data *cb_data)
@@ -1011,6 +1127,7 @@ int tcpm_dpm_pd_alert(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_alert);
 
 #endif	/* CONFIG_USB_PD_REV30 */
 
@@ -1025,6 +1142,7 @@ int tcpm_dpm_pd_hard_reset(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_HARD_RESET_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_hard_reset);
 
 int tcpm_dpm_pd_error_recovery(struct tcpc_device *tcpc)
 {
@@ -1037,6 +1155,7 @@ int tcpm_dpm_pd_error_recovery(struct tcpc_device *tcpc)
 
 	return TCPM_SUCCESS;
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_error_recovery);
 
 int tcpm_dpm_pd_cable_soft_reset(struct tcpc_device *tcpc,
 	const struct tcp_dpm_event_cb_data *cb_data)
@@ -1048,6 +1167,7 @@ int tcpm_dpm_pd_cable_soft_reset(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_pd_cable_soft_reset);
 
 int tcpm_dpm_vdm_discover_cable(struct tcpc_device *tcpc,
 	const struct tcp_dpm_event_cb_data *cb_data)
@@ -1059,6 +1179,7 @@ int tcpm_dpm_vdm_discover_cable(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_vdm_discover_cable);
 
 int tcpm_dpm_vdm_discover_id(struct tcpc_device *tcpc,
 	const struct tcp_dpm_event_cb_data *cb_data)
@@ -1070,6 +1191,7 @@ int tcpm_dpm_vdm_discover_id(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_vdm_discover_id);
 
 int tcpm_dpm_vdm_discover_svid(struct tcpc_device *tcpc,
 	const struct tcp_dpm_event_cb_data *cb_data)
@@ -1081,6 +1203,7 @@ int tcpm_dpm_vdm_discover_svid(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_vdm_discover_svid);
 
 int tcpm_dpm_vdm_discover_mode(struct tcpc_device *tcpc,
 	uint16_t svid, const struct tcp_dpm_event_cb_data *cb_data)
@@ -1093,6 +1216,7 @@ int tcpm_dpm_vdm_discover_mode(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_vdm_discover_mode);
 
 int tcpm_dpm_vdm_enter_mode(struct tcpc_device *tcpc,
 	uint16_t svid, uint8_t ops,
@@ -1107,6 +1231,7 @@ int tcpm_dpm_vdm_enter_mode(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_vdm_enter_mode);
 
 int tcpm_dpm_vdm_exit_mode(struct tcpc_device *tcpc,
 	uint16_t svid, uint8_t ops,
@@ -1121,6 +1246,7 @@ int tcpm_dpm_vdm_exit_mode(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_vdm_exit_mode);
 
 int tcpm_dpm_vdm_attention(struct tcpc_device *tcpc,
 	uint16_t svid, uint8_t ops,
@@ -1135,10 +1261,12 @@ int tcpm_dpm_vdm_attention(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_vdm_attention);
 
-#ifdef CONFIG_USB_PD_ALT_MODE
+#if CONFIG_USB_PD_ALT_MODE
 
-int tcpm_inquire_dp_ufp_u_state(struct tcpc_device *tcpc, uint8_t *state)
+int tcpm_inquire_dp_ufp_u_state(
+	struct tcpc_device *tcpc, uint8_t *state)
 {
 	int ret;
 	struct pd_port *pd_port = &tcpc->pd_port;
@@ -1156,6 +1284,7 @@ int tcpm_inquire_dp_ufp_u_state(struct tcpc_device *tcpc, uint8_t *state)
 
 	return ret;
 }
+EXPORT_SYMBOL(tcpm_inquire_dp_ufp_u_state);
 
 int tcpm_dpm_dp_attention(struct tcpc_device *tcpc,
 	uint32_t dp_status, uint32_t mask,
@@ -1170,10 +1299,12 @@ int tcpm_dpm_dp_attention(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_dp_attention);
 
-#ifdef CONFIG_USB_PD_ALT_MODE_DFP
+#if CONFIG_USB_PD_ALT_MODE_DFP
 
-int tcpm_inquire_dp_dfp_u_state(struct tcpc_device *tcpc, uint8_t *state)
+int tcpm_inquire_dp_dfp_u_state(
+	struct tcpc_device *tcpc, uint8_t *state)
 {
 	int ret;
 	struct pd_port *pd_port = &tcpc->pd_port;
@@ -1191,6 +1322,7 @@ int tcpm_inquire_dp_dfp_u_state(struct tcpc_device *tcpc, uint8_t *state)
 
 	return ret;
 }
+EXPORT_SYMBOL(tcpm_inquire_dp_dfp_u_state);
 
 int tcpm_dpm_dp_status_update(struct tcpc_device *tcpc,
 	uint32_t dp_status, uint32_t mask,
@@ -1205,6 +1337,7 @@ int tcpm_dpm_dp_status_update(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_dp_status_update);
 
 int tcpm_dpm_dp_config(struct tcpc_device *tcpc,
 	uint32_t dp_config, uint32_t mask,
@@ -1219,11 +1352,12 @@ int tcpm_dpm_dp_config(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT);
 }
+EXPORT_SYMBOL(tcpm_dpm_dp_config);
 
 #endif	/* CONFIG_USB_PD_ALT_MODE_DFP */
 #endif	/* CONFIG_USB_PD_ALT_MODE */
 
-#ifdef CONFIG_USB_PD_CUSTOM_VDM
+#if CONFIG_USB_PD_CUSTOM_VDM
 
 int tcpm_dpm_send_custom_vdm(
 	struct tcpc_device *tcpc,
@@ -1246,7 +1380,7 @@ int tcpm_dpm_send_custom_vdm(
 	ret = tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT);
 
-#ifdef CONFIG_USB_PD_TCPM_CB_2ND
+#if CONFIG_USB_PD_TCPM_CB_2ND
 	if ((ret == TCP_DPM_RET_SUCCESS)
 		&& (cb_data == NULL) && vdm_data->wait_resp) {
 		mutex_lock(&pd_port->pd_lock);
@@ -1260,9 +1394,10 @@ int tcpm_dpm_send_custom_vdm(
 
 	return ret;
 }
+EXPORT_SYMBOL(tcpm_dpm_send_custom_vdm);
 #endif	/* CONFIG_USB_PD_CUSTOM_VDM */
 
-#ifdef CONFIG_USB_PD_TCPM_CB_2ND
+#if CONFIG_USB_PD_TCPM_CB_2ND
 void tcpm_replace_curr_tcp_event(
 	struct pd_port *pd_port, struct tcp_dpm_event *event)
 {
@@ -1284,6 +1419,7 @@ void tcpm_replace_curr_tcp_event(
 	memcpy(&pd_port->tcp_event, event, sizeof(struct tcp_dpm_event));
 	mutex_unlock(&pd_port->pd_lock);
 }
+EXPORT_SYMBOL(tcpm_replace_curr_tcp_event);
 #endif	/* CONFIG_USB_PD_TCPM_CB_2ND */
 
 int tcpm_put_tcp_dpm_event(
@@ -1302,7 +1438,7 @@ int tcpm_put_tcp_dpm_event(
 		ret = pd_put_tcp_pd_event(pd_port, event->event_id,
 					  PD_TCP_FROM_TCPM);
 
-#ifdef CONFIG_USB_PD_TCPM_CB_2ND
+#if CONFIG_USB_PD_TCPM_CB_2ND
 		if (ret)
 			tcpm_replace_curr_tcp_event(pd_port, event);
 #endif	/* CONFIG_USB_PD_TCPM_CB_2ND */
@@ -1314,8 +1450,10 @@ int tcpm_put_tcp_dpm_event(
 
 	return TCPM_SUCCESS;
 }
+EXPORT_SYMBOL(tcpm_put_tcp_dpm_event);
 
-int tcpm_notify_vbus_stable(struct tcpc_device *tcpc)
+int tcpm_notify_vbus_stable(
+	struct tcpc_device *tcpc)
 {
 #if CONFIG_USB_PD_VBUS_STABLE_TOUT
 	tcpc_disable_timer(tcpc, PD_TIMER_VBUS_STABLE);
@@ -1324,6 +1462,7 @@ int tcpm_notify_vbus_stable(struct tcpc_device *tcpc)
 	pd_put_vbus_stable_event(tcpc);
 	return TCPM_SUCCESS;
 }
+EXPORT_SYMBOL(tcpm_notify_vbus_stable);
 
 uint8_t tcpm_inquire_pd_charging_policy(struct tcpc_device *tcpc)
 {
@@ -1331,6 +1470,7 @@ uint8_t tcpm_inquire_pd_charging_policy(struct tcpc_device *tcpc)
 
 	return pd_port->dpm_charging_policy;
 }
+EXPORT_SYMBOL(tcpm_inquire_pd_charging_policy);
 
 uint8_t tcpm_inquire_pd_charging_policy_default(struct tcpc_device *tcpc)
 {
@@ -1338,6 +1478,7 @@ uint8_t tcpm_inquire_pd_charging_policy_default(struct tcpc_device *tcpc)
 
 	return pd_port->dpm_charging_policy_default;
 }
+EXPORT_SYMBOL(tcpm_inquire_pd_charging_policy_default);
 
 int tcpm_reset_pd_charging_policy(struct tcpc_device *tcpc,
 	const struct tcp_dpm_event_cb_data *cb_data)
@@ -1345,6 +1486,7 @@ int tcpm_reset_pd_charging_policy(struct tcpc_device *tcpc,
 	return tcpm_set_pd_charging_policy(
 		tcpc, tcpc->pd_port.dpm_charging_policy_default, cb_data);
 }
+EXPORT_SYMBOL(tcpm_reset_pd_charging_policy);
 
 int tcpm_set_pd_charging_policy_default(
 	struct tcpc_device *tcpc, uint8_t policy)
@@ -1361,6 +1503,7 @@ int tcpm_set_pd_charging_policy_default(
 
 	return TCPM_SUCCESS;
 }
+EXPORT_SYMBOL(tcpm_set_pd_charging_policy_default);
 
 int tcpm_set_pd_charging_policy(struct tcpc_device *tcpc,
 	uint8_t policy, const struct tcp_dpm_event_cb_data *cb_data)
@@ -1387,8 +1530,9 @@ int tcpm_set_pd_charging_policy(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_REQUEST_TOUT);
 }
+EXPORT_SYMBOL(tcpm_set_pd_charging_policy);
 
-#ifdef CONFIG_USB_PD_DIRECT_CHARGE
+#if CONFIG_USB_PD_DIRECT_CHARGE
 int tcpm_set_direct_charge_en(struct tcpc_device *tcpc, bool en)
 {
 	struct pd_port *pd_port = &tcpc->pd_port;
@@ -1399,11 +1543,13 @@ int tcpm_set_direct_charge_en(struct tcpc_device *tcpc, bool en)
 
 	return 0;
 }
+EXPORT_SYMBOL(tcpm_set_direct_charge_en);
 
 bool tcpm_inquire_during_direct_charge(struct tcpc_device *tcpc)
 {
 	return tcpc->pd_during_direct_charge;
 }
+EXPORT_SYMBOL(tcpm_inquire_during_direct_charge);
 #endif	/* CONFIG_USB_PD_DIRECT_CHARGE */
 
 static int tcpm_put_tcp_dummy_event(struct tcpc_device *tcpc)
@@ -1415,7 +1561,7 @@ static int tcpm_put_tcp_dummy_event(struct tcpc_device *tcpc)
 	return tcpm_put_tcp_dpm_event(tcpc, &tcp_event);
 }
 
-#ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
+#if CONFIG_TCPC_VCONN_SUPPLY_MODE
 
 int tcpm_dpm_set_vconn_supply_mode(struct tcpc_device *tcpc, uint8_t mode)
 {
@@ -1430,10 +1576,11 @@ int tcpm_dpm_set_vconn_supply_mode(struct tcpc_device *tcpc, uint8_t mode)
 
 	return tcpm_put_tcp_dummy_event(tcpc);
 }
+EXPORT_SYMBOL(tcpm_dpm_set_vconn_supply_mode);
 
 #endif	/* CONFIG_TCPC_VCONN_SUPPLY_MODE */
 
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
+#if CONFIG_USB_PD_REV30_PPS_SINK
 
 int tcpm_set_apdo_charging_policy(struct tcpc_device *tcpc,
 	uint8_t policy, int mv, int ma,
@@ -1470,6 +1617,7 @@ int tcpm_set_apdo_charging_policy(struct tcpc_device *tcpc,
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_REQUEST_TOUT);
 }
+EXPORT_SYMBOL(tcpm_set_apdo_charging_policy);
 
 int tcpm_inquire_pd_source_apdo(struct tcpc_device *tcpc,
 	uint8_t apdo_type, uint8_t *cap_i, struct tcpm_power_cap_val *cap_val)
@@ -1498,6 +1646,7 @@ int tcpm_inquire_pd_source_apdo(struct tcpc_device *tcpc,
 
 	return TCPM_ERROR_NOT_FOUND;
 }
+EXPORT_SYMBOL(tcpm_inquire_pd_source_apdo);
 
 bool tcpm_inquire_during_pps_charge(struct tcpc_device *tcpc)
 {
@@ -1510,15 +1659,16 @@ bool tcpm_inquire_during_pps_charge(struct tcpc_device *tcpc)
 
 	return (cap.type == TCPM_POWER_CAP_VAL_TYPE_AUGMENT);
 }
+EXPORT_SYMBOL(tcpm_inquire_during_pps_charge);
 
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 
-#ifdef CONFIG_USB_PD_REV30_BAT_INFO
+#if CONFIG_USB_PD_REV30_BAT_INFO
 
 static void tcpm_alert_bat_changed(
 	struct pd_port *pd_port, enum pd_battery_reference ref)
 {
-#ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
+#if CONFIG_USB_PD_REV30_ALERT_LOCAL
 	uint8_t fixed = 0, swap = 0;
 
 	if (ref >= PD_BAT_REF_SWAP0)
@@ -1578,6 +1728,7 @@ static int tcpm_update_bsdo(
 	return TCPM_SUCCESS;
 }
 
+#if CONFIG_USB_PD_REV30_BAT_INFO
 int tcpm_update_bat_status_wh(struct tcpc_device *tcpc,
 	enum pd_battery_reference ref, uint8_t status, uint16_t wh)
 {
@@ -1594,12 +1745,14 @@ int tcpm_update_bat_status_wh(struct tcpc_device *tcpc,
 
 	return ret;
 }
+EXPORT_SYMBOL(tcpm_update_bat_status_wh);
 
 int tcpm_update_bat_status_wh_no_mutex(struct tcpc_device *tcpc,
 	enum pd_battery_reference ref, uint8_t status, uint16_t wh)
 {
 	return tcpm_update_bsdo(&tcpc->pd_port, ref, 0, wh, status);
 }
+EXPORT_SYMBOL(tcpm_update_bat_status_wh_no_mutex);
 
 int tcpm_update_bat_status_soc(struct tcpc_device *tcpc,
 	enum pd_battery_reference ref, uint8_t status, uint16_t soc)
@@ -1617,12 +1770,15 @@ int tcpm_update_bat_status_soc(struct tcpc_device *tcpc,
 
 	return ret;
 }
+EXPORT_SYMBOL(tcpm_update_bat_status_soc);
 
 int tcpm_update_bat_status_soc_no_mutex(struct tcpc_device *tcpc,
 	enum pd_battery_reference ref, uint8_t status, uint16_t soc)
 {
 	return tcpm_update_bsdo(&tcpc->pd_port, ref, soc, 0, status);
 }
+EXPORT_SYMBOL(tcpm_update_bat_status_soc_no_mutex);
+#endif
 
 int tcpm_update_bat_last_full(struct tcpc_device *tcpc,
 	enum pd_battery_reference ref, uint16_t wh)
@@ -1635,6 +1791,7 @@ int tcpm_update_bat_last_full(struct tcpc_device *tcpc,
 
 	return ret;
 }
+EXPORT_SYMBOL(tcpm_update_bat_last_full);
 
 int tcpm_update_bat_last_full_no_mutex(struct tcpc_device *tcpc,
 	enum pd_battery_reference ref, uint16_t wh)
@@ -1648,15 +1805,16 @@ int tcpm_update_bat_last_full_no_mutex(struct tcpc_device *tcpc,
 	battery_info->bat_cap.bat_last_full_cap = wh;
 	return TCPM_SUCCESS;
 }
+EXPORT_SYMBOL(tcpm_update_bat_last_full_no_mutex);
 
 #endif	/* CONFIG_USB_PD_REV30_BAT_INFO */
 
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL
 
 static void tcpm_alert_status_changed(
 	struct tcpc_device *tcpc, uint8_t ado_type)
 {
-#ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
+#if CONFIG_USB_PD_REV30_ALERT_LOCAL
 	tcpc->pd_port.pe_data.local_alert |= ADO(ado_type, 0, 0);
 #endif	/* CONFIG_USB_PD_REV30_ALERT_LOCAL */
 }
@@ -1664,7 +1822,7 @@ static void tcpm_alert_status_changed(
 int tcpm_update_pd_status_temp(struct tcpc_device *tcpc,
 	enum pd_present_temperature_flag ptf_new, uint8_t temperature)
 {
-#ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL_TEMP
+#if CONFIG_USB_PD_REV30_STATUS_LOCAL_TEMP
 	uint8_t ado_type = 0;
 	enum pd_present_temperature_flag ptf_now;
 	struct pd_port *pd_port = &tcpc->pd_port;
@@ -1699,6 +1857,7 @@ int tcpm_update_pd_status_temp(struct tcpc_device *tcpc,
 	return TCPM_ERROR_NO_IMPLEMENT;
 #endif /* CONFIG_USB_PD_REV30_STATUS_LOCAL_TEMP */
 }
+EXPORT_SYMBOL(tcpm_update_pd_status_temp);
 
 int tcpm_update_pd_status_input(
 	struct tcpc_device *tcpc, uint8_t input_new, uint8_t mask)
@@ -1725,6 +1884,7 @@ int tcpm_update_pd_status_input(
 
 	return TCPM_SUCCESS;
 }
+EXPORT_SYMBOL(tcpm_update_pd_status_input);
 
 int tcpm_update_pd_status_bat_input(
 	struct tcpc_device *tcpc, uint8_t bat_input, uint8_t bat_mask)
@@ -1756,8 +1916,10 @@ int tcpm_update_pd_status_bat_input(
 
 	return TCPM_SUCCESS;
 }
+EXPORT_SYMBOL(tcpm_update_pd_status_bat_input);
 
-int tcpm_update_pd_status_event(struct tcpc_device *tcpc, uint8_t evt)
+int tcpm_update_pd_status_event(
+	struct tcpc_device *tcpc, uint8_t evt)
 {
 	uint8_t ado_type = 0;
 	struct pd_port *pd_port = &tcpc->pd_port;
@@ -1783,12 +1945,12 @@ int tcpm_update_pd_status_event(struct tcpc_device *tcpc, uint8_t evt)
 
 	return TCPM_SUCCESS;
 }
+EXPORT_SYMBOL(tcpm_update_pd_status_event);
 
 #endif	/* CONFIG_USB_PD_REV30_STATUS_LOCAL */
 
-#ifdef CONFIG_USB_PD_BLOCK_TCPM
+#if CONFIG_USB_PD_BLOCK_TCPM
 
-#if TCPM_DBG_ENABLE
 static const char * const bk_event_ret_name[] = {
 	"OK",
 	"Unknown",	/* or not support by TCPM */
@@ -1821,9 +1983,8 @@ static const char * const bk_event_ret_name[] = {
 	"BKTOUT",
 	"NoResponse",
 };
-#endif /* TCPM_DBG_ENABLE */
 
-#ifdef CONFIG_USB_PD_TCPM_CB_2ND
+#if CONFIG_USB_PD_TCPM_CB_2ND
 static inline void tcpm_dpm_bk_copy_data(struct pd_port *pd_port)
 {
 	uint8_t size = pd_port->tcpm_bk_cb_data_max;
@@ -1852,7 +2013,7 @@ int tcpm_dpm_bk_event_cb(
 	pd_port->tcpm_bk_ret = ret;
 	pd_port->tcpm_bk_done = true;
 
-#ifdef CONFIG_USB_PD_TCPM_CB_2ND
+#if CONFIG_USB_PD_TCPM_CB_2ND
 	if (ret == TCP_DPM_RET_SUCCESS)
 		tcpm_dpm_bk_copy_data(pd_port);
 #endif	/* CONFIG_USB_PD_TCPM_CB_2ND */
@@ -1860,6 +2021,7 @@ int tcpm_dpm_bk_event_cb(
 	wake_up(&pd_port->tcpm_bk_wait_que);
 	return 0;
 }
+EXPORT_SYMBOL(tcpm_dpm_bk_event_cb);
 
 static inline int __tcpm_dpm_wait_bk_event(
 	struct pd_port *pd_port, uint32_t tout_ms)
@@ -1875,7 +2037,7 @@ static inline int __tcpm_dpm_wait_bk_event(
 
 	pd_port->tcpm_bk_event_id = TCP_DPM_EVT_UNKONW;
 
-#ifdef CONFIG_USB_PD_TCPM_CB_2ND
+#if CONFIG_USB_PD_TCPM_CB_2ND
 	pd_port->tcpm_bk_cb_data = NULL;
 #endif	/* CONFIG_USB_PD_TCPM_CB_2ND */
 
@@ -1897,8 +2059,9 @@ int tcpm_dpm_wait_bk_event(struct pd_port *pd_port, uint32_t tout_ms)
 
 	return ret;
 }
+EXPORT_SYMBOL(tcpm_dpm_wait_bk_event);
 
-#ifdef CONFIG_MTK_HANDLE_PPS_TIMEOUT
+#if CONFIG_MTK_HANDLE_PPS_TIMEOUT
 static void mtk_handle_tcp_event_result(
 	struct tcpc_device *tcpc, struct tcp_dpm_event *event, int ret)
 {
@@ -1926,7 +2089,7 @@ static int __tcpm_put_tcp_dpm_event_bk(
 	pd_port->tcpm_bk_done = false;
 	pd_port->tcpm_bk_event_id = event->event_id;
 
-#ifdef CONFIG_USB_PD_TCPM_CB_2ND
+#if CONFIG_USB_PD_TCPM_CB_2ND
 	pd_port->tcpm_bk_cb_data = data;
 	pd_port->tcpm_bk_cb_data_max = size;
 #endif	/* CONFIG_USB_PD_TCPM_CB_2ND */
@@ -1965,7 +2128,7 @@ static int tcpm_put_tcp_dpm_event_bk(
 
 	mutex_unlock(&pd_port->tcpm_bk_lock);
 
-#ifndef CONFIG_USB_PD_TCPM_CB_2ND
+#if !CONFIG_USB_PD_TCPM_CB_2ND
 	if ((data != NULL) && (ret == TCPM_SUCCESS))
 		return TCPM_ERROR_EXPECT_CB2;
 #endif	/* CONFIG_USB_PD_TCPM_CB_2ND */
@@ -1973,7 +2136,7 @@ static int tcpm_put_tcp_dpm_event_bk(
 	if (ret == TCP_DPM_RET_DENIED_REPEAT_REQUEST)
 		ret = TCPM_SUCCESS;
 
-#ifdef CONFIG_MTK_HANDLE_PPS_TIMEOUT
+#if CONFIG_MTK_HANDLE_PPS_TIMEOUT
 	mtk_handle_tcp_event_result(tcpc, event, ret);
 #endif /* CONFIG_MTK_HANDLE_PPS_TIMEOUT */
 
