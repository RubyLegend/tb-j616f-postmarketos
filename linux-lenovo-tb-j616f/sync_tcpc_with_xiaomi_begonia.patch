diff --git a/drivers/misc/mediatek/typec/tcpc/Kconfig b/drivers/misc/mediatek/typec/tcpc/Kconfig
index 755702d..af9a8c0 100644
--- a/drivers/misc/mediatek/typec/tcpc/Kconfig
+++ b/drivers/misc/mediatek/typec/tcpc/Kconfig
@@ -5,7 +5,6 @@
 config TCPC_CLASS
 	bool "TypeC Port Controller Device Class"
 	select MTK_USB_TYPEC
-	select TYPEC
 	help
 	  Say Y to enable
 	  Typec Port
@@ -42,17 +41,6 @@ config TCPC_RT5081
 	  Also Support Power Delivery
 	  Say N to disable
 
-config TCPC_MT6362
-	tristate "MT6362 SPMI TCPC driver"
-	depends on TCPC_CLASS
-	depends on MFD_MT6362
-	help
-	  Say yes here to have support for the MT6362 TCPC
-	  Support TypeC port Controller and Power Delivery
-
-	  The driver can also be build as a module.
-	  If so, the module will be called tcpci_mt6362
-
 config TCPC_MT6370
 	bool "MediaTek MT6370 TypeC port Controller Driver"
 	depends on TCPC_CLASS
diff --git a/drivers/misc/mediatek/typec/tcpc/Makefile b/drivers/misc/mediatek/typec/tcpc/Makefile
index 3c920da..038e89a 100644
--- a/drivers/misc/mediatek/typec/tcpc/Makefile
+++ b/drivers/misc/mediatek/typec/tcpc/Makefile
@@ -1,11 +1,14 @@
-subdir-ccflags-y += -Wall -Werror
 obj-$(CONFIG_DUAL_ROLE_USB_INTF)	+= tcpci_dual_role.o
 obj-$(CONFIG_TCPC_MT6360)		+= tcpc_mt6360.o
-obj-$(CONFIG_TCPC_MT6362)		+= tcpc_mt6362.o
 obj-$(CONFIG_TCPC_MT6370)		+= tcpc_mt6370.o
 obj-$(CONFIG_TCPC_RT1711H)		+= tcpc_rt1711h.o
 obj-$(CONFIG_TCPC_CLASS)		+= tcpci_core.o tcpci_typec.o tcpci_timer.o \
-		tcpm.o tcpci.o pd_dbg_info.o tcpci_alert.o rt_pd_manager.o
+		tcpm.o tcpci.o pd_dbg_info.o
+ifeq ($(CONFIG_TCPC_ALERT_V20), y)
+obj-$(CONFIG_TCPC_CLASS)		+= tcpci_alert_v20.o
+else
+obj-$(CONFIG_TCPC_CLASS)		+= tcpci_alert.o
+endif
 
 obj-$(CONFIG_USB_POWER_DELIVERY)	+= tcpci_event.o \
 		pd_core.o pd_policy_engine.o pd_process_evt.o \
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/mt6360.h b/drivers/misc/mediatek/typec/tcpc/inc/mt6360.h
index ca91316..37aeaab 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/mt6360.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/mt6360.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2018 MediaTek Inc.
+ * Copyright (C) 2019 XiaoMi, Inc.
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -210,6 +211,7 @@ enum mt6360_id_rupsel {
  */
 
 #define MT6360_M_VCONN_SHT_GND			BIT(3)
+#define MT6360_M_OTD				BIT(2)
 #define MT6360_M_VBUS_SAFE0V			BIT(1)
 #define MT6360_M_WAKEUP				BIT(0)
 
@@ -238,15 +240,20 @@ enum mt6360_id_rupsel {
 #define MT6360_M_HIDET_CC1			BIT(4)
 #define MT6360_M_LODET_CC2			BIT(3)
 #define MT6360_M_LODET_CC1			BIT(2)
+#define MT6360_M_RADET_CC2			BIT(1)
+#define MT6360_M_RADET_CC1			BIT(0)
 #define MT6360_M_HIDET_CC \
 	(MT6360_M_HIDET_CC2 | MT6360_M_HIDET_CC1)
 #define MT6360_M_LODET_CC \
 	(MT6360_M_LODET_CC2 | MT6360_M_LODET_CC1)
+#define MT6360_M_RADET_CC \
+	(MT6360_M_RADET_CC2 | MT6360_M_RADET_CC1)
 
 /*
  * MT6360_REG_MT_INT1				(0x96)
  */
 
+#define MT6360_INT_OTD				BIT(2)
 #define MT6360_INT_VBUS_80			BIT(1)
 #define MT6360_INT_WAKEUP			BIT(0)
 
@@ -262,6 +269,7 @@ enum mt6360_id_rupsel {
  */
 
 #define MT6360_ST_VCONN_SHT_GND			BIT(3)
+#define MT6360_ST_OTD				BIT(2)
 #define MT6360_ST_VBUS_SAFE0V			BIT(1)
 
 /*
@@ -290,10 +298,14 @@ enum mt6360_id_rupsel {
 #define MT6360_ST_HIDET_CC1			BIT(4)
 #define MT6360_ST_LODET_CC2			BIT(3)
 #define MT6360_ST_LODET_CC1			BIT(2)
+#define MT6360_ST_RADET_CC2			BIT(1)
+#define MT6360_ST_RADET_CC1			BIT(0)
 #define MT6360_ST_HIDET_CC \
 	(MT6360_ST_HIDET_CC2 | MT6360_ST_HIDET_CC1)
 #define MT6360_ST_LODET_CC \
 	(MT6360_ST_LODET_CC2 | MT6360_ST_LODET_CC1)
+#define MT6360_ST_RADET_CC \
+	(MT6360_ST_RADET_CC2 | MT6360_ST_RADET_CC1)
 
 /*
  * MT6360_REG_WATCHDOG_CTRL			(0xBE)
@@ -385,6 +397,7 @@ enum mt6360_id_rupsel {
  */
 #define MT6360_DIS_RPDET			BIT(7)
 #define MT6360_RPDET_ONESHOT			BIT(6)
+#define MT6360_OT_CCOPEN_EN			BIT(5)
 
 #if ENABLE_MT6360_DBG
 #define MT6360_INFO(format, args...) \
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/mt6370.h b/drivers/misc/mediatek/typec/tcpc/inc/mt6370.h
index ec88e99..716a448 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/mt6370.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/mt6370.h
@@ -23,7 +23,6 @@
 /* MT6370 Private RegMap */
 
 #define MT6370_REG_PHY_CTRL1				(0x80)
-#define MT6370_REG_PHY_CTRL2				(0x81)
 #define MT6370_REG_PHY_CTRL3				(0x82)
 #define MT6370_REG_CLK_CTRL2				(0x87)
 #define MT6370_REG_CLK_CTRL3				(0x88)
@@ -49,9 +48,6 @@
 #define MT6370_REG_DRP_TOGGLE_CYCLE		(0xA2)
 #define MT6370_REG_DRP_DUTY_CTRL			(0xA3)
 
-#define MT6370_REG_PHY_CTRL11				(0xBA)
-#define MT6370_REG_PHY_CTRL12				(0xBB)
-
 /*
  * Device ID
  */
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/pd_core.h b/drivers/misc/mediatek/typec/tcpc/inc/pd_core.h
index 10b2388..9b7c4e6 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/pd_core.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/pd_core.h
@@ -84,12 +84,12 @@
 #define PDO_TYPE_APDO	(3 << 30)
 #define PDO_TYPE_MASK     (3 << 30)
 
-#define PDO_FIXED_DUAL_ROLE	(1 << 29) /* Dual role device */
-#define PDO_FIXED_SUSPEND	(1 << 28) /* USB Suspend supported (SRC) */
-#define PDO_FIXED_HIGH_CAP	(1 << 28) /* Higher Capability (SNK) */
-#define PDO_FIXED_EXTERNAL	(1 << 27) /* Externally powered */
-#define PDO_FIXED_COMM_CAP	(1 << 26) /* USB Communications Capable */
-#define PDO_FIXED_DATA_SWAP	(1 << 25) /* Data role swap command supported */
+#define PDO_FIXED_DUAL_ROLE (1 << 29) /* Dual role device */
+#define PDO_FIXED_SUSPEND   (1 << 28) /* USB Suspend supported (SRC)*/
+#define PDO_FIXED_HIGH_CAP	(1 << 28) /* Higher Capability (SNK )*/
+#define PDO_FIXED_EXTERNAL  (1 << 27) /* Externally powered */
+#define PDO_FIXED_COMM_CAP  (1 << 26) /* USB Communications Capable */
+#define PDO_FIXED_DATA_SWAP (1 << 25) /* Data role swap command supported */
 
 #define PDO_FIXED_PEAK_CURR(i) \
 	((i & 0x03) << 20) /* [21..20] Peak current */
@@ -244,8 +244,8 @@
 #define SVID_DISCOVERY_MAX 16
 
 /* Protocol revision */
-#define PD_REV10	0
-#define PD_REV20	1
+#define PD_REV10 0
+#define PD_REV20 1
 #define PD_REV30	2
 
 #define MAX_EXTENDED_MSG_CHUNK_LEN	26
@@ -402,7 +402,7 @@
 	| ((ptype_dfp) & 0x07) << 23 \
 	 | (is_modal) << 26 | ((vid) & 0xffff))
 
-#define VDO_IDH_PD20(idh)	(idh & (~(0x1f << 21)))
+#define VDO_IDH_PD20(idh)	(idh & (~(0x07 << 23)))
 
 #define PD_IDH_PTYPE(vdo) (((vdo) >> 27) & 0x7)
 #define PD_IDH_PTYPE_DFP(vdo) (((vdo) >> 23) & 0x7)
@@ -665,12 +665,11 @@
 
 #define PD_DP_CFG_PIN(x) (((x) >> 8) & 0xff)
 
-/* USB-IF SVIDs */
+/* USB-IF SIDs */
 #define USB_SID_PD		0xff00	/* power delivery */
 #define USB_SID_DISPLAYPORT	0xff01	/* display port */
-#define USB_VID_RICHTEK		0x29cf  /* demo uvdm */
-#define USB_VID_DIRECTCHARGE	0x29cf  /* direct charge */
-#define USB_VID_MQP		0x1748
+#define USB_SID_RICHTEK	0x29cf  /* demo uvdm */
+#define USB_SID_DIRECTCHARGE	0x29cf  /* direct charge */
 
 /* PD counter definitions */
 #define PD_MESSAGE_ID_COUNT	7
@@ -749,7 +748,6 @@ struct pe_data {		/* reset after detached */
 
 #ifdef CONFIG_USB_PD_VCONN_SAFE5V_ONLY
 	bool vconn_highv_prot;
-	uint8_t vconn_highv_prot_role;
 #endif	/* CONFIG_USB_PD_VCONN_SAFE5V_ONLY */
 
 	uint8_t cap_counter;
@@ -774,8 +772,8 @@ struct pe_data {		/* reset after detached */
 	uint8_t pe_state_flags;
 	uint8_t pe_state_flags2;
 	uint8_t vdm_state_flags;
-	uint32_t pe_state_timer;
-	uint32_t vdm_state_timer;
+	uint8_t pe_state_timer;
+	uint8_t vdm_state_timer;
 
 #ifdef CONFIG_USB_PD_RECV_HRESET_COUNTER
 	uint8_t recv_hard_reset_count;
@@ -832,12 +830,6 @@ struct pe_data {		/* reset after detached */
 #ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
 	uint8_t pd_status_event;
 #endif	/* CONFIG_USB_PD_REV30_STATUS_LOCAL */
-
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
-	bool pd_sent_ams_init_cmd;
-	bool pd_unexpected_event_pending;
-	struct pd_event pd_unexpected_event;
-#endif	/* CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG */
 };
 
 #ifdef CONFIG_USB_PD_REV30_BAT_INFO
@@ -857,7 +849,7 @@ struct pd_country_authority {
 #endif /* CONFIG_USB_PD_REV30_COUNTRY_AUTHORITY */
 
 struct pd_port {
-	struct tcpc_device *tcpc;
+	struct tcpc_device *tcpc_dev;
 	struct mutex pd_lock;
 
 	/* PD */
@@ -883,10 +875,11 @@ struct pd_port {
 #endif	/* CONFIG_USB_PD_ERROR_RECOVERY_ONCE */
 
 #ifdef CONFIG_USB_PD_REV30
-	struct wakeup_source *pps_request_wake_lock;
-	wait_queue_head_t pps_request_wait_que;
-	atomic_t pps_request;
+	wait_queue_head_t pps_request_event_queue;
+	atomic_t pps_request_event;
 	struct task_struct *pps_request_task;
+	struct wakeup_source pps_request_wake_lock;
+	bool pps_request_stop;
 #ifdef CONFIG_USB_PD_REV30_SYNC_SPEC_REV
 	uint8_t pd_revision[2];
 #endif	/* CONFIG_USB_PD_REV30_SYNC_SPEC_REV */
@@ -901,7 +894,9 @@ struct pd_port {
 	uint8_t id_vdo_nr;
 	uint32_t id_vdos[VDO_MAX_NR];
 
+#ifdef CONFIG_USB_PD_REV30
 	uint32_t id_header;
+#endif	/* CONFIG_USB_PD_REV30 */
 
 	uint8_t svid_data_cnt;
 	struct svdm_svid_data *svid_data;
@@ -1043,14 +1038,12 @@ struct pd_port {
 	uint8_t cap_miss_match; /* For src_cap miss match */
 };
 
-#ifdef CONFIG_USB_PD_ALT_MODE
 static inline struct dp_data *pd_get_dp_data(struct pd_port *pd_port)
 {
 	return &pd_port->pe_data.dp_data;
 }
-#endif	/* CONFIG_USB_PD_ALT_MODE */
 
-extern int pd_core_init(struct tcpc_device *tcpc);
+extern int pd_core_init(struct tcpc_device *tcpc_dev);
 
 static inline void *pd_get_msg_data_payload(struct pd_port *pd_port)
 {
@@ -1140,6 +1133,19 @@ static inline bool pd_check_timer_msg_event(
 		pd_get_curr_pd_event(pd_port), msg);
 }
 
+#ifdef CONFIG_USB_PD_REV30
+
+static inline bool pd_check_rev30(struct pd_port *pd_port)
+{
+#ifdef CONFIG_USB_PD_REV30_SYNC_SPEC_REV
+	return pd_port->pd_revision[0] >= PD_REV30;
+#else
+	return false;
+#endif /* CONFIG_USB_PD_REV30_SYNC_SPEC_REV */
+}
+
+#endif	/* CONFIG_USB_PD_REV30 */
+
 extern bool pd_is_reset_cable(struct pd_port *pd_port);
 extern bool pd_is_discover_cable(struct pd_port *pd_port);
 
@@ -1196,7 +1202,6 @@ enum {
 };
 
 void pd_reset_svid_data(struct pd_port *pd_port);
-void pd_free_unexpected_event(struct pd_port *pd_port);
 int pd_reset_protocol_layer(struct pd_port *pd_port, bool sop_only);
 
 int pd_set_rx_enable(struct pd_port *pd_port, uint8_t enable);
@@ -1205,8 +1210,7 @@ int pd_enable_vbus_valid_detection(struct pd_port *pd_port, bool wait_valid);
 int pd_enable_vbus_safe0v_detection(struct pd_port *pd_port);
 int pd_enable_vbus_stable_detection(struct pd_port *pd_port);
 
-uint32_t pd_reset_pdo_power(struct tcpc_device *tcpc,
-			uint32_t pdo, uint32_t imax);
+uint32_t pd_reset_pdo_power(uint32_t pdo, uint32_t imax);
 
 void pd_extract_rdo_power(
 	uint32_t rdo, uint32_t pdo, uint32_t *op_curr, uint32_t *max_curr);
@@ -1266,18 +1270,16 @@ extern void pd_notify_tcp_event_2nd_result(struct pd_port *pd_port, int ret);
 extern void pd_notify_tcp_vdm_event_2nd_result(
 		struct pd_port *pd_port, uint8_t ret);
 
-extern bool pd_is_pe_wait_pd_transmit_done(struct pd_port *pd_port);
-
 /* ---- pd_timer ---- */
 
 static inline void pd_restart_timer(struct pd_port *pd_port, uint32_t timer_id)
 {
-	return tcpc_restart_timer(pd_port->tcpc, timer_id);
+	return tcpc_restart_timer(pd_port->tcpc_dev, timer_id);
 }
 
 static inline void pd_enable_timer(struct pd_port *pd_port, uint32_t timer_id)
 {
-	return tcpc_enable_timer(pd_port->tcpc, timer_id);
+	return tcpc_enable_timer(pd_port->tcpc_dev, timer_id);
 }
 
 static inline void pd_enable_pe_state_timer(
@@ -1294,19 +1296,12 @@ static inline void pd_enable_vdm_state_timer(
 	struct pd_port *pd_port, uint32_t timer_id)
 {
 	pd_port->pe_data.vdm_state_timer = timer_id;
+	return pd_enable_timer(pd_port, timer_id);
 }
 
 static inline void pd_disable_timer(struct pd_port *pd_port, uint32_t timer_id)
 {
-	return tcpc_disable_timer(pd_port->tcpc, timer_id);
-}
-
-static inline void pd_disable_pe_state_timer(struct pd_port *pd_port)
-{
-	struct pe_data *pe_data = &pd_port->pe_data;
-
-	pd_disable_timer(pd_port, pe_data->pe_state_timer);
-	pe_data->pe_state_timer = 0;
+	return tcpc_disable_timer(pd_port->tcpc_dev, timer_id);
 }
 
 void pd_reset_pe_timer(struct pd_port *pd_port);
@@ -1321,7 +1316,7 @@ static inline bool pd_put_pe_event(struct pd_port *pd_port, uint8_t pe_event)
 		.pd_msg = NULL,
 	};
 
-	return pd_put_event(pd_port->tcpc, &evt, false);
+	return pd_put_event(pd_port->tcpc_dev, &evt, false);
 }
 
 static inline bool pd_put_dpm_notify_event(
@@ -1334,7 +1329,7 @@ static inline bool pd_put_dpm_notify_event(
 		.pd_msg = NULL,
 	};
 
-	return pd_put_event(pd_port->tcpc, &evt, false);
+	return pd_put_event(pd_port->tcpc_dev, &evt, false);
 }
 
 static inline bool pd_put_dpm_ack_event(struct pd_port *pd_port)
@@ -1345,7 +1340,7 @@ static inline bool pd_put_dpm_ack_event(struct pd_port *pd_port)
 		.pd_msg = NULL,
 	};
 
-	return pd_put_event(pd_port->tcpc, &evt, false);
+	return pd_put_event(pd_port->tcpc_dev, &evt, false);
 }
 
 static inline bool pd_put_dpm_nak_event(struct pd_port *pd_port, uint8_t notify)
@@ -1357,7 +1352,7 @@ static inline bool pd_put_dpm_nak_event(struct pd_port *pd_port, uint8_t notify)
 		.pd_msg = NULL,
 	};
 
-	return pd_put_event(pd_port->tcpc, &evt, false);
+	return pd_put_event(pd_port->tcpc_dev, &evt, false);
 }
 
 static inline bool pd_put_dpm_event(struct pd_port *pd_port, uint8_t msg)
@@ -1368,20 +1363,19 @@ static inline bool pd_put_dpm_event(struct pd_port *pd_port, uint8_t msg)
 		.pd_msg = NULL,
 	};
 
-	return pd_put_event(pd_port->tcpc, &evt, false);
+	return pd_put_event(pd_port->tcpc_dev, &evt, false);
 }
 
-static inline bool pd_put_tcp_pd_event(struct pd_port *pd_port, uint8_t event,
-				       uint8_t from)
+static inline bool pd_put_tcp_pd_event(struct pd_port *pd_port, uint8_t event)
 {
 	struct pd_event evt = {
 		.event_type = PD_EVT_TCP_MSG,
 		.msg = event,
-		.msg_sec = from,
+		.msg_sec = PD_TCP_FROM_PE,
 		.pd_msg = NULL,
 	};
 
-	return pd_put_event(pd_port->tcpc, &evt, false);
+	return pd_put_event(pd_port->tcpc_dev, &evt, false);
 };
 
 static inline bool pd_put_tcp_vdm_event(struct pd_port *pd_port, uint8_t event)
@@ -1393,11 +1387,11 @@ static inline bool pd_put_tcp_vdm_event(struct pd_port *pd_port, uint8_t event)
 		.pd_msg = NULL,
 	};
 
-	return pd_put_vdm_event(pd_port->tcpc, &evt, false);
+	return pd_put_vdm_event(pd_port->tcpc_dev, &evt, false);
 };
 
 static inline bool vdm_put_hw_event(
-	struct tcpc_device *tcpc, uint8_t hw_event)
+	struct tcpc_device *tcpc_dev, uint8_t hw_event)
 {
 	struct pd_event evt = {
 		.event_type = PD_EVT_HW_MSG,
@@ -1405,11 +1399,11 @@ static inline bool vdm_put_hw_event(
 		.pd_msg = NULL,
 	};
 
-	return pd_put_vdm_event(tcpc, &evt, false);
+	return pd_put_vdm_event(tcpc_dev, &evt, false);
 }
 
 static inline bool vdm_put_pe_event(
-	struct tcpc_device *tcpc, uint8_t pe_event)
+	struct tcpc_device *tcpc_dev, uint8_t pe_event)
 {
 	struct pd_event evt = {
 		.event_type = PD_EVT_PE_MSG,
@@ -1417,7 +1411,7 @@ static inline bool vdm_put_pe_event(
 		.pd_msg = NULL,
 	};
 
-	return pd_put_vdm_event(tcpc, &evt, false);
+	return pd_put_vdm_event(tcpc_dev, &evt, false);
 }
 
 static inline bool vdm_put_dpm_discover_cable_event(struct pd_port *pd_port)
@@ -1427,7 +1421,7 @@ static inline bool vdm_put_dpm_discover_cable_event(struct pd_port *pd_port)
 }
 
 static inline bool pd_put_hw_event(
-	struct tcpc_device *tcpc, uint8_t hw_event)
+	struct tcpc_device *tcpc_dev, uint8_t hw_event)
 {
 	struct pd_event evt = {
 		.event_type = PD_EVT_HW_MSG,
@@ -1435,11 +1429,11 @@ static inline bool pd_put_hw_event(
 		.pd_msg = NULL,
 	};
 
-	return pd_put_event(tcpc, &evt, false);
+	return pd_put_event(tcpc_dev, &evt, false);
 }
 
 static inline bool pd_put_sink_tx_event(
-		struct tcpc_device *tcpc, uint8_t cc_res)
+		struct tcpc_device *tcpc_dev, uint8_t cc_res)
 {
 #ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
 	struct pd_event evt = {
@@ -1449,7 +1443,7 @@ static inline bool pd_put_sink_tx_event(
 	};
 
 	evt.msg_sec = cc_res == TYPEC_CC_VOLT_SNK_3_0;
-	return pd_put_event(tcpc, &evt, false);
+	return pd_put_event(tcpc_dev, &evt, false);
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
 
 	return true;
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/pd_dpm_core.h b/drivers/misc/mediatek/typec/tcpc/inc/pd_dpm_core.h
index aed811f..8d3b8ee 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/pd_dpm_core.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/pd_dpm_core.h
@@ -32,6 +32,7 @@ void pd_dpm_dynamic_disable_vconn(struct pd_port *pd_port);
 /* ---- SNK ---- */
 
 #ifdef CONFIG_USB_PD_REV30_PPS_SINK
+void dpm_repeat_pps_request(struct pd_port *pd_port);
 void pd_dpm_start_pps_request_thread(struct pd_port *pd_port, bool en);
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 
@@ -99,8 +100,6 @@ void pd_dpm_dfp_inform_uvdm(struct pd_port *pd_port, bool ack);
 
 #endif     /* CONFIG_USB_PD_CUSTOM_VDM */
 
-void pd_dpm_ufp_send_svdm_nak(struct pd_port *pd_port);
-
 /* ---- DRP : Inform PowerCap ---- */
 
 void pd_dpm_dr_inform_sink_cap(struct pd_port *pd_port);
@@ -211,14 +210,14 @@ int pd_dpm_notify_pe_hardreset(struct pd_port *pd_port);
 
 static inline int pd_dpm_check_vbus_valid(struct pd_port *pd_port)
 {
-	return tcpci_check_vbus_valid(pd_port->tcpc);
+	return tcpci_check_vbus_valid(pd_port->tcpc_dev);
 }
 
 static inline int pd_dpm_sink_vbus(struct pd_port *pd_port, bool en)
 {
 	int mv = en ? TCPC_VBUS_SINK_5V : TCPC_VBUS_SINK_0V;
 
-	return tcpci_sink_vbus(pd_port->tcpc,
+	return tcpci_sink_vbus(pd_port->tcpc_dev,
 				TCP_VBUS_CTRL_REQUEST, mv, -1);
 }
 
@@ -226,7 +225,7 @@ static inline int pd_dpm_source_vbus(struct pd_port *pd_port, bool en)
 {
 	int mv = en ? TCPC_VBUS_SOURCE_5V : TCPC_VBUS_SOURCE_0V;
 
-	return tcpci_source_vbus(pd_port->tcpc,
+	return tcpci_source_vbus(pd_port->tcpc_dev,
 				TCP_VBUS_CTRL_REQUEST, mv, -1);
 }
 
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/pd_dpm_pdo_select.h b/drivers/misc/mediatek/typec/tcpc/inc/pd_dpm_pdo_select.h
index 3c1d00d..2c5a280 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/pd_dpm_pdo_select.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/pd_dpm_pdo_select.h
@@ -57,7 +57,7 @@ extern void dpm_extract_pdo_info(
 			uint32_t pdo, struct dpm_pdo_info_t *info);
 
 extern bool dpm_find_match_req_info(struct dpm_rdo_info_t *req_info,
-	struct dpm_pdo_info_t *sink, int cnt, uint32_t *src_pdos,
+	uint32_t snk_pdo, int cnt, uint32_t *src_pdos,
 	int min_uw, uint32_t select_rule);
 
 #endif	/* PD_DPM_PDO_SELECT_H */
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/pd_policy_engine.h b/drivers/misc/mediatek/typec/tcpc/inc/pd_policy_engine.h
index 88a889a..e6e7e14 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/pd_policy_engine.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/pd_policy_engine.h
@@ -26,20 +26,15 @@ enum pd_pe_state_machine {
 	PE_STATE_MACHINE_VCONN_SWAP,
 };
 
-#define PE_STATE_DISCARD_AND_UNEXPECTED(pd_port) {\
-	pd_port->pe_data.pe_state_flags = \
-	PE_STATE_FLAG_HRESET_IF_SR_TIMEOUT |\
-	PE_STATE_FLAG_IGNORE_UNKNOWN_EVENT; }
-
 /* ---- Policy Engine Runtime Flags ---- */
 
 #define PE_STATE_FLAG_BACK_READY_IF_RECV_WAIT		(1<<0)
 #define PE_STATE_FLAG_BACK_READY_IF_RECV_REJECT		(1<<1)
 #define PE_STATE_FLAG_BACK_READY_IF_SR_TIMER_TOUT	(1<<2)
-#define PE_STATE_FLAG_BACK_READY_IF_TX_FAILED		(1<<3)
-#define PE_STATE_FLAG_HRESET_IF_SR_TIMEOUT		(1<<4)
-#define PE_STATE_FLAG_HRESET_IF_TX_FAILED		(1<<5)
-#define PE_STATE_FLAG_IGNORE_UNKNOWN_EVENT		(1<<6)
+#define PE_STATE_FLAG_BACK_READY_IF_TX_FAILED			(1<<3)
+#define PE_STATE_FLAG_HRESET_IF_SR_TIMEOUT			(1<<4)
+#define PE_STATE_FLAG_HRESET_IF_TX_FAILED				(1<<5)
+#define PE_STATE_FLAG_IGNORE_UNKNOWN_EVENT			(1<<6)
 #define PE_STATE_FLAG_ENABLE_SENDER_RESPONSE_TIMER	(1<<7)
 
 #define PE_STATE_WAIT_RESPONSE(pd_port) {\
@@ -96,8 +91,8 @@ enum pd_pe_state_machine {
 	PE_STATE_FLAG_ENABLE_SENDER_RESPONSE_TIMER; }
 
 #define PE_STATE_FLAG_BACK_READY_IF_RECV_GOOD_CRC	(1<<0)
-#define PE_STATE_FLAG_BACK_READY_IF_DPM_ACK		(1<<1)
-#define PE_STATE_FLAG_DPM_ACK_IMMEDIATELY		(1<<7)
+#define PE_STATE_FLAG_BACK_READY_IF_DPM_ACK			(1<<1)
+#define PE_STATE_FLAG_DPM_ACK_IMMEDIATELY				(1<<7)
 
 #define PE_STATE_WAIT_TX_SUCCESS(pd_port)	{\
 	pd_port->pe_data.pe_state_flags2 = \
@@ -116,8 +111,7 @@ enum pd_pe_state_machine {
 	pd_port->pe_data.pe_state_flags2 |= \
 	PE_STATE_FLAG_DPM_ACK_IMMEDIATELY; }
 
-#define VDM_STATE_FLAG_ENABLE_VDM_RESPONSE_TIMER	(1<<0)
-#define VDM_STATE_FLAG_DPM_ACK_IMMEDIATELY		(1<<4)
+#define VDM_STATE_FLAG_DPM_ACK_IMMEDIATELY	(1<<4)
 #define VDM_STATE_FLAG_BACK_READY_IF_DPM_ACK		(1<<6)
 #define VDM_STATE_FLAG_BACK_READY_IF_RECV_GOOD_CRC	(1<<7)
 
@@ -134,14 +128,9 @@ enum pd_pe_state_machine {
 	pd_port->pe_data.vdm_state_flags = \
 		VDM_STATE_FLAG_BACK_READY_IF_RECV_GOOD_CRC; }
 
-#define VDM_STATE_RESPONSE_CMD(pd_port, timer_id)	{\
-	pd_port->pe_data.vdm_state_flags = \
-		VDM_STATE_FLAG_ENABLE_VDM_RESPONSE_TIMER; \
-	pd_port->pe_data.vdm_state_timer = timer_id; }
-
 static inline bool pd_check_pe_during_hard_reset(struct pd_port *pd_port)
 {
-	return pd_port->tcpc->pd_wait_hard_reset_complete;
+	return pd_port->tcpc_dev->pd_wait_hard_reset_complete;
 }
 
 enum pd_pe_state {
@@ -368,8 +357,6 @@ enum pd_pe_state {
 	PE_DFP_UVDM_NAKED,
 #endif/* CONFIG_USB_PD_CUSTOM_VDM */
 
-	PE_UFP_VDM_SEND_NAK,
-
 /******************* PD30 Common *******************/
 #ifdef CONFIG_USB_PD_REV30
 #ifdef CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
@@ -421,14 +408,6 @@ enum pd_pe_state {
 #endif	/* CONFIG_USB_PD_ERROR_RECOVERY_ONCE */
 	PE_BIST_TEST_DATA,
 	PE_BIST_CARRIER_MODE_2,
-
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
-	PE_UNEXPECTED_TX_WAIT,
-	PE_SEND_SOFT_RESET_TX_WAIT,
-	PE_RECV_SOFT_RESET_TX_WAIT,
-	PE_SEND_SOFT_RESET_STANDBY,
-#endif	/* CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG */
-
 /* Wait tx finished */
 	PE_IDLE1,
 	PE_IDLE2,
@@ -446,7 +425,7 @@ enum pd_pe_state {
  * Returns Negative Value if an error occurs.
  */
 
-int pd_policy_engine_run(struct tcpc_device *tcpc);
+int pd_policy_engine_run(struct tcpc_device *tcpc_dev);
 
 
 /* ---- Policy Engine (General) ---- */
@@ -857,8 +836,6 @@ void pe_dfp_uvdm_acked_entry(
 void pe_dfp_uvdm_naked_entry(
 	struct pd_port *pd_port);
 #endif/* CONFIG_USB_PD_CUSTOM_VDM */
-void pe_ufp_vdm_send_nak_entry(
-	struct pd_port *pd_port);
 
 /******************* PD30 Common *******************/
 #ifdef CONFIG_USB_PD_REV30
@@ -941,17 +918,6 @@ void pe_bist_carrier_mode_2_entry(
 	struct pd_port *pd_port);
 void pe_bist_carrier_mode_2_exit(
 	struct pd_port *pd_port);
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
-void pe_unexpected_tx_wait_entry(
-	struct pd_port *pd_port);
-void pe_send_soft_reset_tx_wait_entry(
-	struct pd_port *pd_port);
-void pe_recv_soft_reset_tx_wait_entry(
-	struct pd_port *pd_port);
-void pe_send_soft_reset_standby_entry(
-	struct pd_port *pd_port);
-#endif	/* CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG */
-
 /* Wait tx finished */
 void pe_idle1_entry(
 	struct pd_port *pd_port);
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/pd_process_evt.h b/drivers/misc/mediatek/typec/tcpc/inc/pd_process_evt.h
index d8d377f..1f8fe9c 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/pd_process_evt.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/pd_process_evt.h
@@ -46,7 +46,7 @@ struct pe_state_reaction {
 bool pd_process_protocol_error(
 	struct pd_port *pd_port, struct pd_event *pd_event);
 
-bool pd_process_tx_failed_discard(struct pd_port *pd_port, uint8_t msg);
+bool pd_process_tx_failed(struct pd_port *pd_port);
 
 /*---------------------------------------------------------------------------*/
 
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/rt1711h.h b/drivers/misc/mediatek/typec/tcpc/inc/rt1711h.h
index 19bec15..295494c 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/rt1711h.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/rt1711h.h
@@ -1,6 +1,8 @@
 /*
  * Copyright (C) 2016 MediaTek Inc.
  *
+ * Power Delivery Process Event For VDM
+ *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
@@ -22,8 +24,6 @@
 
 /* RT1711H Private RegMap */
 
-#define RT1711H_REG_CONFIG_GPIO0			(0x71)
-
 #define RT1711H_REG_PHY_CTRL1				(0x80)
 
 #define RT1711H_REG_CLK_CTRL2				(0x87)
@@ -50,10 +50,6 @@
 #define RT1711H_REG_DRP_DUTY_CTRL			(0xA3)
 #define RT1711H_REG_BMCIO_RXDZEN			(0xAF)
 
-#define RT1711H_REG_UNLOCK_PW_2				(0xF0)
-#define RT1711H_REG_UNLOCK_PW_1				(0xF1)
-#define RT1711H_REG_EFUSE5				(0xF6)
-
 /*
  * Device ID
  */
@@ -144,14 +140,6 @@
 #define RT1711H_REG_ENEXTMSG				(1<<4)
 #define RT1711H_REG_AUTOIDLE_EN				(1<<3)
 
-/*
- * RT1711H_REG_EFUSE5					(0xF6)
- */
-
-#define RT1711H_REG_M_VBUS_CAL				GENMASK(7, 5)
-#define RT1711H_REG_S_VBUS_CAL				5
-#define RT1711H_REG_MIN_VBUS_CAL			-4
-
 /* timeout = (tout*2+1) * 6.4ms */
 
 #ifdef CONFIG_USB_PD_REV30
@@ -194,7 +182,7 @@
 	((en << 7) | (tout & 0x0f))
 
 #if ENABLE_RT1711_DBG
-#define RT1711_INFO(format, args...) \
+#define RT1711H_INFO(format, args...) \
 	pd_dbg_info("%s() line-%d: " format,\
 	__func__, __LINE__, ##args)
 #else
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/tcpci.h b/drivers/misc/mediatek/typec/tcpc/inc/tcpci.h
index 3aa92db..1b83e2a 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/tcpci.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/tcpci.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2016 MediaTek Inc.
+ * Copyright (C) 2019 XiaoMi, Inc.
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -76,7 +77,6 @@ int tcpci_check_vbus_valid_from_ic(struct tcpc_device *tcpc);
 int tcpci_check_vsafe0v(struct tcpc_device *tcpc, bool detect_en);
 int tcpci_alert_status_clear(struct tcpc_device *tcpc, uint32_t mask);
 int tcpci_fault_status_clear(struct tcpc_device *tcpc, uint8_t status);
-int tcpci_set_alert_mask(struct tcpc_device *tcpc, uint32_t mask);
 int tcpci_get_alert_mask(struct tcpc_device *tcpc, uint32_t *mask);
 int tcpci_get_alert_status(struct tcpc_device *tcpc, uint32_t *alert);
 int tcpci_get_fault_status(struct tcpc_device *tcpc, uint8_t *fault);
@@ -86,19 +86,6 @@ int tcpci_init_alert_mask(struct tcpc_device *tcpc);
 
 int tcpci_get_cc(struct tcpc_device *tcpc);
 int tcpci_set_cc(struct tcpc_device *tcpc, int pull);
-static inline int __tcpci_set_cc(struct tcpc_device *tcpc, int pull)
-{
-	PD_BUG_ON(tcpc->ops->set_cc == NULL);
-
-	if (pull & TYPEC_CC_DRP) {
-		tcpc->typec_remote_cc[0] =
-		tcpc->typec_remote_cc[1] =
-			TYPEC_CC_DRP_TOGGLING;
-	}
-
-	tcpc->typec_local_cc = pull;
-	return tcpc->ops->set_cc(tcpc, pull);
-}
 int tcpci_set_polarity(struct tcpc_device *tcpc, int polarity);
 int tcpci_set_low_rp_duty(struct tcpc_device *tcpc, bool low_rp);
 int tcpci_set_vconn(struct tcpc_device *tcpc, int enable);
@@ -119,10 +106,16 @@ int tcpci_set_usbid_polling(struct tcpc_device *tcpc, bool en);
 int tcpci_notify_wd_status(struct tcpc_device *tcpc, bool water_detected);
 #endif /* CONFIG_WATER_DETECTION */
 
+#ifdef CONFIG_TYPEC_OTP
+int tcpci_notify_typec_otp(struct tcpc_device *tcpc);
+#endif /* CONFIG_TYPEC_OTP */
+
 #ifdef CONFIG_CABLE_TYPE_DETECTION
 int tcpci_notify_cable_type(struct tcpc_device *tcpc);
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
 
+int tcpci_notify_ra_detect(struct tcpc_device *tcpc);
+
 #ifdef CONFIG_USB_POWER_DELIVERY
 
 int tcpci_set_msg_header(struct tcpc_device *tcpc,
@@ -160,8 +153,10 @@ int tcpci_source_vbus(struct tcpc_device *tcpc, uint8_t type, int mv, int ma);
 int tcpci_sink_vbus(struct tcpc_device *tcpc, uint8_t type, int mv, int ma);
 int tcpci_disable_vbus_control(struct tcpc_device *tcpc);
 int tcpci_notify_attachwait_state(struct tcpc_device *tcpc, bool as_sink);
+int tcpci_enable_ext_discharge(struct tcpc_device *tcpc, bool en);
 int tcpci_enable_auto_discharge(struct tcpc_device *tcpc, bool en);
-int tcpci_enable_force_discharge(struct tcpc_device *tcpc, bool en, int mv);
+int tcpci_enable_force_discharge(struct tcpc_device *tcpc, int mv);
+int tcpci_disable_force_discharge(struct tcpc_device *tcpc);
 
 #ifdef CONFIG_USB_POWER_DELIVERY
 
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/tcpci_config.h b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_config.h
index 08b13ca..79e08ec 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/tcpci_config.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_config.h
@@ -23,11 +23,10 @@
 #define CONFIG_TYPEC_CAP_TRY_SOURCE
 #define CONFIG_TYPEC_CAP_TRY_SINK
 
-#define CONFIG_TYPEC_CAP_DBGACC
 /* #define CONFIG_TYPEC_CAP_DBGACC_SNK */
 #define CONFIG_TYPEC_CAP_CUSTOM_SRC
 #define CONFIG_TYPEC_CAP_NORP_SRC
-/* #define CONFIG_COMPATIBLE_APPLE_TA */
+#define CONFIG_COMPATIBLE_APPLE_TA
 
 #define CONFIG_RECV_BAT_ABSENT_NOTIFY
 
@@ -38,7 +37,6 @@
 #define CONFIG_TYPEC_CHECK_LEGACY_CABLE2
 #define CONFIG_TYPEC_LEGACY2_AUTO_RECYCLE
 /* #define CONFIG_TYPEC_CHECK_SRC_UNATTACH_OPEN */
-#define CONFIG_TYPEC_LEGACY3_ALWAYS_LOCAL_RP
 
 #define CONFIG_TYPEC_CAP_RA_DETACH
 #define CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
@@ -48,14 +46,10 @@
 #define CONFIG_TYPEC_CAP_ROLE_SWAP
 #define CONFIG_TYPEC_CAP_ROLE_SWAP_TOUT		1200
 
-#define CONFIG_TYPEC_CAP_DISCHARGE_TOUT		50
-
 #define CONFIG_TYPEC_CAP_AUTO_DISCHARGE
-/* #define CONFIG_TCPC_AUTO_DISCHARGE_IC */
+#define CONFIG_TYPEC_CAP_AUTO_DISCHARGE_TOUT	50
 
 #define CONFIG_TYPEC_CAP_FORCE_DISCHARGE
-/* #define CONFIG_TCPC_FORCE_DISCHARGE_IC */
-#define CONFIG_TCPC_FORCE_DISCHARGE_EXT
 
 #define CONFIG_TYPEC_CAP_AUDIO_ACC_SINK_VBUS
 
@@ -69,13 +63,7 @@
 
 #define CONFIG_TCPC_ATTACH_WAKE_LOCK_TOUT	5000
 
-/* #define CONFIG_TCPC_LOG_WITH_PORT_NAME */
-
-#ifdef CONFIG_TCPC_LOG_WITH_PORT_NAME
-#define CONFIG_TCPC_DBG_PRESTR		"{%s}TCPC-"
-#else
 #define CONFIG_TCPC_DBG_PRESTR		"TCPC-"
-#endif /* CONFIG_TCPC_LOG_WITH_PORT_NAME */
 
 /*
  * USB 2.0 & 3.0 current
@@ -84,13 +72,19 @@
  * http://www.testusb.com/power_issue.htm
  */
 
-#define CONFIG_TYPEC_SNK_CURR_DFT		100
+#define CONFIG_TYPEC_SNK_CURR_DFT		150
 #define CONFIG_TYPEC_SRC_CURR_DFT		500
 #define CONFIG_TYPEC_SNK_CURR_LIMIT		0
 
 #define CONFIG_TCPC_SOURCE_VCONN
 #define CONFIG_TCPC_VCONN_SUPPLY_MODE
 
+/* #define CONFIG_TCPC_FORCE_DISCHARGE_IC */
+#define CONFIG_TCPC_FORCE_DISCHARGE_EXT
+
+/* #define CONFIG_TCPC_AUTO_DISCHARGE_IC */
+#define CONFIG_TCPC_AUTO_DISCHARGE_EXT
+
 #define CONFIG_TCPC_VSAFE0V_DETECT
 /* #define CONFIG_TCPC_VSAFE0V_DETECT_EXT */
 #define CONFIG_TCPC_VSAFE0V_DETECT_IC
@@ -99,6 +93,7 @@
 #define CONFIG_TCPC_LPM_POSTPONE
 
 #define CONFIG_TCPC_LOW_POWER_MODE
+/* #define CONFIG_TCPC_IDLE_MODE */
 #define CONFIG_TCPC_CLOCK_GATING
 
 /* #define CONFIG_TCPC_WATCHDOG_EN */
@@ -110,8 +105,6 @@
 
 #define CONFIG_TCPC_NOTIFIER_LATE_SYNC
 
-#define CONFIG_TCPC_NOTIFICATION_NON_BLOCKING
-
 #ifdef CONFIG_USB_POWER_DELIVERY
 
 /* Experimental for CodeSize */
@@ -120,7 +113,7 @@
 #define CONFIG_USB_PD_VCONN_SWAP
 #define CONFIG_USB_PD_PE_SINK
 #define CONFIG_USB_PD_PE_SOURCE
-#define CONFIG_USB_PD_DISABLE_PE
+/* #define CONFIG_USB_PD_DISABLE_PE */
 
 #define CONFIG_USB_PD_TCPM_CB_RETRY		3
 #define CONFIG_USB_PD_TCPM_CB_2ND
@@ -139,10 +132,9 @@
 #define CONFIG_USB_PD_ATTEMP_ENTER_MODE
 
 #define CONFIG_USB_PD_ALT_MODE
-#ifdef CONFIG_USB_PD_ALT_MODE
 #define CONFIG_USB_PD_ALT_MODE_DFP
+
 #define CONFIG_USB_PD_ALT_MODE_RTDC
-#endif	/* CONFIG_USB_PD_ALT_MODE */
 
 /* #define CONFIG_USB_PD_DP_CHECK_CABLE */
 /* #define CONFIG_USB_PD_RTDC_CHECK_CABLE */
@@ -261,12 +253,10 @@
 #define CONFIG_USB_PD_RANDOM_FLOW_DELAY
 
 #define CONFIG_USB_PD_DFP_FLOW_DELAY
-#define CONFIG_USB_PD_DFP_FLOW_DELAY_STARTUP
+/* #define CONFIG_USB_PD_DFP_FLOW_DELAY_STARTUP */
 #define CONFIG_USB_PD_DFP_FLOW_DELAY_DRSWAP
 #define CONFIG_USB_PD_DFP_FLOW_DELAY_RESET
 
-#define CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
-
 /* Only in startup */
 #define CONFIG_USB_PD_UFP_FLOW_DELAY
 #define CONFIG_USB_PD_VCONN_STABLE_DELAY
@@ -278,7 +268,7 @@
 #define CONFIG_USB_PD_DISCOVER_CABLE_REQUEST_VCONN
 #define CONFIG_USB_PD_DISCOVER_CABLE_RETURN_VCONN
 
-#define CONFIG_USB_PD_PR_SWAP_ERROR_RECOVERY
+/* #define CONFIG_USB_PD_PR_SWAP_ERROR_RECOVERY */
 
 #define CONFIG_USB_PD_CUSTOM_VDM
 
@@ -287,22 +277,17 @@
 #define CONFIG_USB_PD_UVDM
 #endif	/* CONFIG_USB_PD_CUSTOM_VDM */
 
-#ifdef CONFIG_TYPEC_CAP_DBGACC_SNK
 /* #define CONFIG_USB_PD_CUSTOM_DBGACC */
-#endif	/* CONFIG_TYPEC_CAP_DBGACC_SNK */
 
-/* S/W patch for ESD issue: repeat HReset Alert */
+/* S/W Patch for Huawei ESD issue :repeat HReset Alert */
 /* #define CONFIG_USB_PD_RECV_HRESET_COUNTER */
 
 /* S/W patch for NoGoodCRC if SNK_DFT */
 #define CONFIG_USB_PD_SNK_DFT_NO_GOOD_CRC
 
-/* S/W patch for NoGoodCRC after PR_SWAP (repeat PS_RDY) */
+/* S/W patch for NoGoodCRC after PR_SWAP (repeat PS_RDY)*/
 #define CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP
 
-/* S/W patch for delayed ps_change related to PS_RDY during PR_SWAP */
-#define CONFIG_USB_PD_VBUS_DETECTION_DURING_PR_SWAP
-
 /*
  * S/W patch for INT handler was stuck by other task (system busy)
  *
@@ -397,9 +382,6 @@
 #define CONFIG_USB_PD_PPS_REQUEST_INTERVAL	7000
 #endif	/* CONFIG_USB_PD_PPS_REQUEST_INTERVAL */
 
-#ifdef CONFIG_MTK_CHARGER
-#define CONFIG_USB_PD_WAIT_BC12
-#endif /* CONFIG_MTK_CHARGER */
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
 /* debug config */
@@ -411,6 +393,8 @@
  * TypeC Shield Protection
  **********************************************************/
 
+#define CONFIG_TYPEC_OTP
+
 #ifdef CONFIG_MTK_TYPEC_WATER_DETECT
 #define CONFIG_WATER_DETECTION
 #endif /* CONFIG_MTK_TYPEC_WATER_DETECT */
@@ -420,10 +404,6 @@
 /* #define CONFIG_WATER_CALIBRATION */
 #define CONFIG_WD_SBU_CALIB_INIT	1800 /* mV */
 #define CONFIG_WD_SBU_PL_BOUND		200 /* mV */
-#define CONFIG_WD_SBU_PL_LBOUND_C2C	1100 /* mV */
-#define CONFIG_WD_SBU_PL_UBOUND_C2C	2600 /* mV */
-#define CONFIG_WD_SBU_PL_RETRY		2
-#define CONFIG_WD_SBU_PH_RETRY		2
 #define CONFIG_WD_SBU_PH_AUDDEV		200 /* mV */
 #define CONFIG_WD_SBU_PH_LBOUND		1180 /* mV */
 #define CONFIG_WD_SBU_PH_LBOUND1_C2C	2850 /* mV */
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/tcpci_core.h b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_core.h
index f1e791b..031a1c6 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/tcpci_core.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_core.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2016 MediaTek Inc.
+ * Copyright (C) 2019 XiaoMi, Inc.
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -29,9 +30,6 @@
 
 #ifdef CONFIG_USB_POWER_DELIVERY
 #include "pd_core.h"
-#ifdef CONFIG_USB_PD_WAIT_BC12
-#include <mt-plat/charger_type.h>
-#endif /* CONFIG_USB_PD_WAIT_BC12 */
 #endif
 
 /* The switch of log message */
@@ -56,12 +54,12 @@
 #define DP_INFO_ENABLE		1
 #define DP_DBG_ENABLE		1
 
-#define UVDM_INFO_ENABLE	1
+#define UVDM_INFO_ENABLE		1
 #define TCPM_DBG_ENABLE		1
 
 #ifdef CONFIG_USB_PD_ALT_MODE_RTDC
-#define DC_INFO_ENABLE		1
-#define DC_DBG_ENABLE		1
+#define DC_INFO_ENABLE			1
+#define DC_DBG_ENABLE			1
 #endif	/* CONFIG_USB_PD_ALT_MODE_RTDC */
 
 #define TCPC_ENABLE_ANYMSG	\
@@ -77,7 +75,7 @@
 
 /* Disable VDM DBG Msg */
 #define PE_STATE_INFO_VDM_DIS	0
-#define PE_EVT_INFO_VDM_DIS	0
+#define PE_EVT_INFO_VDM_DIS		0
 #define PE_DBG_RESET_VDM_DIS	1
 
 #define PD_BUG_ON(x)	WARN_ON(x)
@@ -90,18 +88,6 @@ struct tcpc_desc {
 	uint8_t vconn_supply;
 	int notifier_supply_num;
 	char *name;
-#ifdef CONFIG_WATER_DETECTION
-	u32 wd_sbu_calib_init;
-	u32 wd_sbu_pl_bound;
-	u32 wd_sbu_pl_lbound_c2c;
-	u32 wd_sbu_pl_ubound_c2c;
-	u32 wd_sbu_ph_auddev;
-	u32 wd_sbu_ph_lbound;
-	u32 wd_sbu_ph_lbound1_c2c;
-	u32 wd_sbu_ph_ubound1_c2c;
-	u32 wd_sbu_ph_ubound2_c2c;
-	u32 wd_sbu_aud_ubound;
-#endif /* CONFIG_WATER_DETECTION */
 };
 
 /*---------------------------------------------------------------------------*/
@@ -120,6 +106,11 @@ struct tcpc_desc {
 #define CONFIG_TCPC_EXT_DISCHARGE
 #endif	/* CONFIG_TCPC_FORCE_DISCHARGE_EXT */
 
+#ifdef CONFIG_TCPC_AUTO_DISCHARGE_EXT
+#undef CONFIG_TCPC_EXT_DISCHARGE
+#define CONFIG_TCPC_EXT_DISCHARGE
+#endif	/* CONFIG_TCPC_AUTO_DISCHARGE_EXT */
+
 /*---------------------------------------------------------------------------*/
 
 /* TCPC Power Register Define */
@@ -148,9 +139,6 @@ struct tcpc_desc {
 #define TCPC_REG_ALERT_RX_MASK	\
 	(TCPC_REG_ALERT_RX_STATUS | TCPC_REG_ALERT_RX_BUF_OVF)
 
-#define TCPC_REG_ALERT_RX_ALL_MASK	\
-	(TCPC_REG_ALERT_RX_MASK | TCPC_REG_ALERT_RX_HARD_RST)
-
 #define TCPC_REG_ALERT_HRESET_SUCCESS	\
 	(TCPC_REG_ALERT_TX_SUCCESS | TCPC_REG_ALERT_TX_FAILED)
 
@@ -174,35 +162,26 @@ struct tcpc_desc {
 #define TCPC_FLAGS_WATCHDOG_EN			(1<<8)
 #define TCPC_FLAGS_WATER_DETECTION		(1<<9)
 #define TCPC_FLAGS_CABLE_TYPE_DETECTION		(1<<10)
-#define TCPC_FLAGS_VCONN_SAFE5V_ONLY		(1<<11)
-#define TCPC_FLAGS_ALERT_V10			(1<<12)
-
-#define TYPEC_CC_PULL(rp_lvl, res)	((rp_lvl & 0x03) << 3 | (res & 0x07))
-
-enum tcpc_rp_lvl {
-	TYPEC_RP_DFT,
-	TYPEC_RP_1_5,
-	TYPEC_RP_3_0,
-	TYPEC_RP_RSV,
-};
+#define TCPC_FLAGS_TYPEC_OTP			(1<<11)
+#define TCPC_FLAGS_KPOC_BOOT			(1<<12)
 
 enum tcpc_cc_pull {
 	TYPEC_CC_RA = 0,
 	TYPEC_CC_RP = 1,
 	TYPEC_CC_RD = 2,
 	TYPEC_CC_OPEN = 3,
-	TYPEC_CC_DRP = 4,		/* from Rd */
+	TYPEC_CC_DRP = 4,	/* from Rd */
 
-	TYPEC_CC_RP_DFT = TYPEC_CC_PULL(TYPEC_RP_DFT, TYPEC_CC_RP),
-	TYPEC_CC_RP_1_5 = TYPEC_CC_PULL(TYPEC_RP_1_5, TYPEC_CC_RP),
-	TYPEC_CC_RP_3_0 = TYPEC_CC_PULL(TYPEC_RP_3_0, TYPEC_CC_RP),
+	TYPEC_CC_RP_DFT = 1,		/* 0x00 + 1 */
+	TYPEC_CC_RP_1_5 = 9,		/* 0x08 + 1*/
+	TYPEC_CC_RP_3_0 = 17,		/* 0x10 + 1 */
 
-	TYPEC_CC_DRP_DFT = TYPEC_CC_PULL(TYPEC_RP_DFT, TYPEC_CC_DRP),
-	TYPEC_CC_DRP_1_5 = TYPEC_CC_PULL(TYPEC_RP_1_5, TYPEC_CC_DRP),
-	TYPEC_CC_DRP_3_0 = TYPEC_CC_PULL(TYPEC_RP_3_0, TYPEC_CC_DRP),
+	TYPEC_CC_DRP_DFT = 4,		/* 0x00 + 4 */
+	TYPEC_CC_DRP_1_5 = 12,		/* 0x08 + 4 */
+	TYPEC_CC_DRP_3_0 = 20,		/* 0x10 + 4 */
 };
 
-#define TYPEC_CC_PULL_GET_RES(pull)	(pull & 0x07)
+#define TYPEC_CC_PULL_GET_RES(pull)		(pull & 0x07)
 #define TYPEC_CC_PULL_GET_RP_LVL(pull)	((pull & 0x18) >> 3)
 
 enum tcpm_rx_cap_type {
@@ -220,7 +199,6 @@ struct tcpc_ops {
 	int (*init_alert_mask)(struct tcpc_device *tcpc);
 	int (*alert_status_clear)(struct tcpc_device *tcpc, uint32_t mask);
 	int (*fault_status_clear)(struct tcpc_device *tcpc, uint8_t status);
-	int (*set_alert_mask)(struct tcpc_device *tcpc, uint32_t mask);
 	int (*get_alert_mask)(struct tcpc_device *tcpc, uint32_t *mask);
 	int (*get_alert_status)(struct tcpc_device *tcpc, uint32_t *alert);
 	int (*get_power_status)(struct tcpc_device *tcpc, uint16_t *pwr_status);
@@ -248,6 +226,10 @@ struct tcpc_ops {
 	int (*set_low_power_mode)(struct tcpc_device *tcpc, bool en, int pull);
 #endif /* CONFIG_TCPC_LOW_POWER_MODE */
 
+#ifdef CONFIG_TCPC_IDLE_MODE
+	int (*set_idle_mode)(struct tcpc_device *tcpc, bool en);
+#endif /* CONFIG_TCPC_IDLE_MODE */
+
 	int (*set_watchdog)(struct tcpc_device *tcpc, bool en);
 
 #ifdef CONFIG_TCPC_INTRST_EN
@@ -322,8 +304,8 @@ struct tcpc_device {
 	struct device dev;
 	bool wake_lock_user;
 	uint8_t wake_lock_pd;
-	struct wakeup_source *attach_wake_lock;
-	struct wakeup_source *detach_wake_lock;
+	struct wakeup_source attach_wake_lock;
+	struct wakeup_source dettach_temp_wake_lock;
 
 	/* For tcpc timer & event */
 	uint32_t timer_handle_index;
@@ -331,7 +313,7 @@ struct tcpc_device {
 
 	struct alarm wake_up_timer;
 	struct delayed_work wake_up_work;
-	struct wakeup_source *wakeup_wake_lock;
+	struct wakeup_source wakeup_wake_lock;
 
 	ktime_t last_expire[PD_TIMER_NR];
 	struct mutex access_lock;
@@ -342,14 +324,15 @@ struct tcpc_device {
 	atomic_t pending_event;
 	uint64_t timer_tick;
 	uint64_t timer_enable_mask;
-	wait_queue_head_t event_wait_que;
-	wait_queue_head_t timer_wait_que;
+	wait_queue_head_t event_loop_wait_que;
+	wait_queue_head_t  timer_wait_que;
 	struct task_struct *event_task;
 	struct task_struct *timer_task;
+	bool timer_thead_stop;
+	bool event_loop_thead_stop;
 
 	struct delayed_work	init_work;
 	struct delayed_work	event_init_work;
-	struct workqueue_struct *evt_wq;
 	struct srcu_notifier_head evt_nh[TCP_NOTIFY_IDX_NR];
 	struct tcpc_managed_res *mr_head;
 	struct mutex mr_lock;
@@ -357,7 +340,6 @@ struct tcpc_device {
 	/* For TCPC TypeC */
 	uint8_t typec_state;
 	uint8_t typec_role;
-	uint8_t typec_role_new;
 	uint8_t typec_attach_old;
 	uint8_t typec_attach_new;
 	uint8_t typec_local_cc;
@@ -372,7 +354,6 @@ struct tcpc_device {
 	bool typec_power_ctrl;
 	bool typec_watchdog;
 	bool typec_reach_vsafe0v;
-	bool typec_is_attached_src;
 
 	int typec_usb_sink_curr;
 
@@ -497,9 +478,6 @@ struct tcpc_device {
 	uint8_t charging_status;
 	int bat_soc;
 #endif /* CONFIG_USB_PD_REV30 */
-#ifdef CONFIG_USB_PD_WAIT_BC12
-	uint8_t pd_wait_bc12_count;
-#endif /* CONFIG_USB_PD_WAIT_BC12 */
 #endif /* CONFIG_USB_POWER_DELIVERY */
 	u8 vbus_level:2;
 	bool vbus_safe0v;
@@ -513,52 +491,22 @@ struct tcpc_device {
 #endif /* CONFIG_WATER_DETECTION */
 #ifdef CONFIG_CABLE_TYPE_DETECTION
 	enum tcpc_cable_type typec_cable_type;
-	enum tcpc_cable_type pre_typec_cable_type;
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
+	bool ra_detected;
+#ifdef CONFIG_TYPEC_OTP
+	bool typec_otp;
+#endif /* CONFIG_TYPEC_OTP */
 };
 
-#define to_tcpc_device(obj) container_of(obj, struct tcpc_device, dev)
 
-#ifdef CONFIG_USB_POWER_DELIVERY
-static inline uint8_t pd_get_rev(struct pd_port *pd_port, uint8_t sop_type)
-{
-	uint8_t pd_rev = PD_REV20;
-#ifdef CONFIG_USB_PD_REV30_SYNC_SPEC_REV
-	struct pe_data *pe_data = &pd_port->pe_data;
-	struct tcpc_device *tcpc = pd_port->tcpc;
-
-	if (sop_type == TCPC_TX_SOP) {
-		pd_rev = pd_port->pd_revision[0];
-	} else {
-		if (pe_data->explicit_contract || pe_data->cable_rev_discovered)
-			pd_rev = pd_port->pd_revision[1];
-		else if (tcpc->tcpc_flags & TCPC_FLAGS_PD_REV30)
-			pd_rev = PD_REV30;
-	}
-#endif	/* CONFIG_USB_PD_REV30_SYNC_SPEC_REV */
-
-	return pd_rev;
-}
-
-static inline bool pd_check_rev30(struct pd_port *pd_port)
-{
-	return pd_get_rev(pd_port, TCPC_TX_SOP) >= PD_REV30;
-}
-#endif /* CONFIG_USB_POWER_DELIVERY */
+#define to_tcpc_device(obj) container_of(obj, struct tcpc_device, dev)
 
 #ifdef CONFIG_PD_DBG_INFO
-#define __RT_DBG_INFO	pd_dbg_info
+#define RT_DBG_INFO	pd_dbg_info
 #else
-#define __RT_DBG_INFO	pr_info
+#define RT_DBG_INFO	pr_info
 #endif /* CONFIG_PD_DBG_INFO */
 
-#ifdef CONFIG_TCPC_LOG_WITH_PORT_NAME
-#define RT_DBG_INFO(format, args...)	__RT_DBG_INFO(format,	\
-						      tcpc->desc.name, ##args)
-#else
-#define RT_DBG_INFO(format, args...)	__RT_DBG_INFO(format, ##args)
-#endif /* CONFIG_TCPC_LOG_WITH_PORT_NAME */
-
 #if TYPEC_DBG_ENABLE
 #define TYPEC_DBG(format, args...)		\
 	RT_DBG_INFO(CONFIG_TCPC_DBG_PRESTR "TYPEC:" format, ##args)
@@ -679,14 +627,14 @@ static inline bool pd_check_rev30(struct pd_port *pd_port)
 
 #if UVDM_INFO_ENABLE
 #define UVDM_INFO(format, args...)	\
-	RT_DBG_INFO(CONFIG_TCPC_DBG_PRESTR "UVDM:" format, ##args)
+	RT_DBG_INFO(CONFIG_TCPC_DBG_PRESTR "UVDM:" format, ## args)
 #else
 #define UVDM_INFO(format, args...)
 #endif
 
 #if TCPM_DBG_ENABLE
 #define TCPM_DBG(format, args...)	\
-	RT_DBG_INFO(CONFIG_TCPC_DBG_PRESTR "TCPM:" format, ##args)
+	RT_DBG_INFO(CONFIG_TCPC_DBG_PRESTR "TCPM:" format, ## args)
 #else
 #define TCPM_DBG(format, args...)
 #endif
@@ -695,14 +643,14 @@ static inline bool pd_check_rev30(struct pd_port *pd_port)
 
 #if DC_INFO_ENABLE
 #define DC_INFO(format, args...)	\
-	RT_DBG_INFO(CONFIG_TCPC_DBG_PRESTR "DC> " format, ##args)
+	RT_DBG_INFO(CONFIG_TCPC_DBG_PRESTR "DC> " format, ## args)
 #else
 #define DC_INFO(format, args...)
 #endif
 
 #if DC_DBG_ENABLE
 #define DC_DBG(format, args...)	\
-	RT_DBG_INFO(CONFIG_TCPC_DBG_PRESTR "DC> " format, ##args)
+	RT_DBG_INFO(CONFIG_TCPC_DBG_PRESTR "DC> " format, ## args)
 #else
 #define DC_DBG(format, args...)
 #endif
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/tcpci_event.h b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_event.h
index 7fae448..67807f4 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/tcpci_event.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_event.h
@@ -28,6 +28,7 @@ struct pd_msg {
 	uint8_t frame_type;
 	uint16_t msg_hdr;
 	uint32_t payload[7];
+	unsigned long time_stamp;
 };
 
 struct pd_event {
@@ -37,41 +38,39 @@ struct pd_event {
 	struct pd_msg *pd_msg;
 };
 
-struct pd_msg *pd_alloc_msg(struct tcpc_device *tcpc);
-void pd_free_msg(struct tcpc_device *tcpc, struct pd_msg *pd_msg);
-bool pd_is_msg_empty(struct tcpc_device *tcpc);
+struct pd_msg *pd_alloc_msg(struct tcpc_device *tcpc_dev);
+void pd_free_msg(struct tcpc_device *tcpc_dev, struct pd_msg *pd_msg);
 
-bool pd_get_event(struct tcpc_device *tcpc, struct pd_event *pd_event);
-bool pd_put_event(struct tcpc_device *tcpc,
+bool pd_get_event(struct tcpc_device *tcpc_dev, struct pd_event *pd_event);
+bool pd_put_event(struct tcpc_device *tcpc_dev,
 		const struct pd_event *pd_event, bool from_port_partner);
-void pd_free_event(struct tcpc_device *tcpc, struct pd_event *pd_event);
+void pd_free_event(struct tcpc_device *tcpc_dev, struct pd_event *pd_event);
 
-bool pd_get_vdm_event(struct tcpc_device *tcpc, struct pd_event *pd_event);
-bool pd_put_vdm_event(struct tcpc_device *tcpc,
+bool pd_get_vdm_event(struct tcpc_device *tcpc_dev, struct pd_event *pd_event);
+bool pd_put_vdm_event(struct tcpc_device *tcpc_dev,
 			struct pd_event *pd_event, bool from_port_partner);
 
-bool pd_put_last_vdm_event(struct tcpc_device *tcpc);
+bool pd_put_last_vdm_event(struct tcpc_device *tcpc_dev);
 
 bool pd_get_deferred_tcp_event(
-	struct tcpc_device *tcpc, struct tcp_dpm_event *tcp_event);
+	struct tcpc_device *tcpc_dev, struct tcp_dpm_event *tcp_event);
 bool pd_put_deferred_tcp_event(
-	struct tcpc_device *tcpc, const struct tcp_dpm_event *tcp_event);
-
-extern int tcpci_event_init(struct tcpc_device *tcpc);
-extern int tcpci_event_deinit(struct tcpc_device *tcpc);
-extern void pd_event_buf_reset(struct tcpc_device *tcpc);
-
-bool __pd_put_cc_attached_event(struct tcpc_device *tcpc, uint8_t type);
-bool pd_put_cc_attached_event(struct tcpc_device *tcpc, uint8_t type);
-void pd_put_cc_detached_event(struct tcpc_device *tcpc);
-void pd_put_recv_hard_reset_event(struct tcpc_device *tcpc);
-void pd_put_sent_hard_reset_event(struct tcpc_device *tcpc);
-bool pd_put_pd_msg_event(struct tcpc_device *tcpc, struct pd_msg *pd_msg);
-void pd_put_hard_reset_completed_event(struct tcpc_device *tcpc);
-void pd_put_vbus_changed_event(struct tcpc_device *tcpc, bool from_ic);
-void pd_put_vbus_safe0v_event(struct tcpc_device *tcpc);
-void pd_put_vbus_stable_event(struct tcpc_device *tcpc);
-void pd_put_vbus_present_event(struct tcpc_device *tcpc);
+	struct tcpc_device *tcpc_dev, const struct tcp_dpm_event *tcp_event);
+
+extern int tcpci_event_init(struct tcpc_device *tcpc_dev);
+extern int tcpci_event_deinit(struct tcpc_device *tcpc_dev);
+extern void pd_event_buf_reset(struct tcpc_device *tcpc_dev);
+
+bool pd_put_cc_attached_event(struct tcpc_device *tcpc_dev, uint8_t type);
+void pd_put_cc_detached_event(struct tcpc_device *tcpc_dev);
+void pd_put_recv_hard_reset_event(struct tcpc_device *tcpc_dev);
+void pd_put_sent_hard_reset_event(struct tcpc_device *tcpc_dev);
+bool pd_put_pd_msg_event(struct tcpc_device *tcpc_dev, struct pd_msg *pd_msg);
+void pd_put_hard_reset_completed_event(struct tcpc_device *tcpc_dev);
+void pd_put_vbus_changed_event(struct tcpc_device *tcpc_dev, bool from_ic);
+void pd_put_vbus_safe0v_event(struct tcpc_device *tcpc_dev);
+void pd_put_vbus_stable_event(struct tcpc_device *tcpc_dev);
+void pd_put_vbus_present_event(struct tcpc_device *tcpc_dev);
 
 enum pd_event_type {
 	PD_EVT_PD_MSG = 0,	/* either ctrl msg or data msg */
@@ -163,8 +162,8 @@ enum pd_msg_type {
 	PD_HW_VBUS_ABSENT,
 	PD_HW_VBUS_SAFE0V,
 	PD_HW_VBUS_STABLE,
-	PD_HW_TX_FAILED,	/* no good crc */
-	PD_HW_TX_DISCARD,	/* discard msg */
+	PD_HW_TX_FAILED,	/* no good crc or discard */
+	PD_HW_TX_DISCARD,	/* discard vdm msg */
 	PD_HW_RETRY_VDM,	/* discard vdm msg (retry) */
 #ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
 	PD_HW_SINK_TX_CHANGE,
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/tcpci_timer.h b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_timer.h
index 70bd2bf..023feb6 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/tcpci_timer.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_timer.h
@@ -29,8 +29,10 @@ enum {
 	PD_TIMER_PS_SOURCE_ON,
 	PD_TIMER_PS_TRANSITION,
 	PD_TIMER_SENDER_RESPONSE,
+	PD_TIMER_SINK_ACTIVITY,
 	PD_TIMER_SINK_REQUEST,
 	PD_TIMER_SINK_WAIT_CAP,
+	PD_TIMER_SOURCE_ACTIVITY,
 	PD_TIMER_SOURCE_CAPABILITY,
 	PD_TIMER_SOURCE_START,
 	PD_TIMER_VCONN_ON,
@@ -43,7 +45,7 @@ enum {
 	PD_TIMER_SOURCE_TRANSITION,
 	PD_TIMER_SRC_RECOVER,
 #ifdef CONFIG_USB_PD_REV30
-	PD_TIMER_CK_NOT_SUPPORTED,
+	PD_TIMER_CK_NO_SUPPORT,
 #ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
 	PD_TIMER_SINK_TX,
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
@@ -92,14 +94,11 @@ enum {
 	TYPEC_RT_TIMER_NOT_LEGACY,
 	TYPEC_RT_TIMER_LEGACY_STABLE,
 	TYPEC_RT_TIMER_LEGACY_RECYCLE,
-	TYPEC_RT_TIMER_DISCHARGE,
+	TYPEC_RT_TIMER_AUTO_DISCHARGE,
 	TYPEC_RT_TIMER_LOW_POWER_MODE,
 
 #ifdef CONFIG_USB_POWER_DELIVERY
 	TYPEC_RT_TIMER_PE_IDLE,
-#ifdef CONFIG_USB_PD_WAIT_BC12
-	TYPEC_RT_TIMER_PD_WAIT_BC12,
-#endif /* CONFIG_USB_PD_WAIT_BC12 */
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 	TYPEC_TIMER_ERROR_RECOVERY,
 /* TYPEC-TRY-TIMER */
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/tcpci_typec.h b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_typec.h
index 8015030..da1f9ec 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/tcpci_typec.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/tcpci_typec.h
@@ -16,12 +16,11 @@
 #include "tcpci.h"
 
 struct tcpc_device;
-extern bool tcpc_typec_is_act_as_sink_role(struct tcpc_device *tcpc);
 enum CC_ORIENTATION{
 	POSITIVE = 0,
 	NEGATIVE,
 	ERR_STATUS
 };
 
 /******************************************************************************
  *  Call following function to trigger TYPEC Connection State Change
@@ -32,49 +26,46 @@ enum CC_ORIENTATION{
  *****************************************************************************/
 
 extern int power_supply_get_cc(void);
-extern int tcpc_typec_enter_lpm_again(struct tcpc_device *tcpc);
-extern int tcpc_typec_handle_cc_change(struct tcpc_device *tcpc);
+extern int tcpc_typec_enter_lpm_again(struct tcpc_device *tcpc_dev);
+extern int tcpc_typec_handle_cc_change(struct tcpc_device *tcpc_dev);
 
 extern int tcpc_typec_handle_ps_change(
-		struct tcpc_device *tcpc, int vbus_level);
+		struct tcpc_device *tcpc_dev, int vbus_level);
 
 extern int tcpc_typec_handle_timeout(
-		struct tcpc_device *tcpc, uint32_t timer_id);
+		struct tcpc_device *tcpc_dev, uint32_t timer_id);
 
-extern int tcpc_typec_handle_vsafe0v(struct tcpc_device *tcpc);
+extern int tcpc_typec_handle_vsafe0v(struct tcpc_device *tcpc_dev);
 
-extern int tcpc_typec_set_rp_level(struct tcpc_device *tcpc, uint8_t rp_lvl);
+extern int tcpc_typec_set_rp_level(struct tcpc_device *tcpc_dev, uint8_t res);
 
-extern int tcpc_typec_error_recovery(struct tcpc_device *tcpc);
+extern int tcpc_typec_error_recovery(struct tcpc_device *tcpc_dev);
 
-extern int tcpc_typec_disable(struct tcpc_device *tcpc);
-extern int tcpc_typec_enable(struct tcpc_device *tcpc);
+extern int tcpc_typec_disable(struct tcpc_device *tcpc_dev);
+extern int tcpc_typec_enable(struct tcpc_device *tcpc_dev);
 
 extern int tcpc_typec_change_role(
-	struct tcpc_device *tcpc, uint8_t typec_role, bool postpone);
+	struct tcpc_device *tcpc_dev, uint8_t typec_role);
 
 #ifdef CONFIG_USB_POWER_DELIVERY
-extern int tcpc_typec_handle_pe_pr_swap(struct tcpc_device *tcpc);
+extern int tcpc_typec_handle_pe_pr_swap(struct tcpc_device *tcpc_dev);
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
 #ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
-extern int tcpc_typec_swap_role(struct tcpc_device *tcpc);
+extern int tcpc_typec_swap_role(struct tcpc_device *tcpc_dev);
 #endif /* CONFIG_TYPEC_CAP_ROLE_SWAP */
 
 #ifdef CONFIG_WATER_DETECTION
-extern int tcpc_typec_handle_wd(struct tcpc_device *tcpc, bool wd);
+extern int tcpc_typec_handle_wd(struct tcpc_device *tcpc_dev, bool wd);
 #endif /* CONFIG_WATER_DETECTION */
 
+#ifdef CONFIG_TYPEC_OTP
+extern int tcpc_typec_handle_otp(struct tcpc_device *tcpc_dev, bool otp);
+#endif /* CONFIG_TYPEC_OTP */
+
 #ifdef CONFIG_CABLE_TYPE_DETECTION
-extern int tcpc_typec_handle_ctd(struct tcpc_device *tcpc,
+extern int tcpc_typec_handle_ctd(struct tcpc_device *tcpc_dev,
 				 enum tcpc_cable_type cable_type);
 #endif /* CONFIG_CABLE_TYPEC_DETECTION */
 
-#define typec_get_cc1()		\
-	tcpc->typec_remote_cc[0]
-#define typec_get_cc2()		\
-	tcpc->typec_remote_cc[1]
-#define typec_get_cc_res()	\
-	(tcpc->typec_polarity ? typec_get_cc2() : typec_get_cc1())
-
 #endif /* #ifndef __LINUX_TCPCI_TYPEC_H */
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/tcpm.h b/drivers/misc/mediatek/typec/tcpc/inc/tcpm.h
index d2972e3..5c0dded 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/tcpm.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/tcpm.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2016 MediaTek Inc.
+ * Copyright (C) 2019 XiaoMi, Inc.
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -145,7 +146,10 @@ enum {
 	TCP_NOTIFY_REQUEST_BAT_INFO,
 	TCP_NOTIFY_WD_STATUS,
 	TCP_NOTIFY_CABLE_TYPE,
-	TCP_NOTIFY_MISC_END = TCP_NOTIFY_CABLE_TYPE,
+	TCP_NOTIFY_RA_DETECT,
+	TCP_NOTIFY_TYPEC_OTP,
+	TCP_NOTIFY_PLUG_OUT,
+	TCP_NOTIFY_MISC_END = TCP_NOTIFY_PLUG_OUT,
 };
 
 struct tcp_ny_pd_state {
@@ -162,7 +166,6 @@ struct tcp_ny_enable_state {
 
 struct tcp_ny_typec_state {
 	uint8_t rp_level;
-	uint8_t local_rp_level;
 	uint8_t polarity;
 	uint8_t old_state;
 	uint8_t new_state;
@@ -304,6 +307,13 @@ struct tcp_ny_cable_type {
 	enum tcpc_cable_type type;
 };
 
+struct tcp_ny_ra_detect {
+	bool detected;
+};
+struct tcp_ny_typec_otp {
+	bool otp;
+};
+
 struct tcp_notify {
 	union {
 		struct tcp_ny_enable_state en_state;
@@ -322,6 +332,8 @@ struct tcp_notify {
 		struct tcp_ny_request_bat request_bat;
 		struct tcp_ny_wd_status wd_status;
 		struct tcp_ny_cable_type cable_type;
+		struct tcp_ny_ra_detect ra_detect;
+		struct tcp_ny_typec_otp typec_otp;
 	};
 };
 
@@ -404,17 +416,16 @@ enum pd_cable_current_limit {
 #define DPM_FLAGS_PARTNER_DR_DATA		(1<<1)
 #define DPM_FLAGS_PARTNER_EXTPOWER		(1<<2)
 #define DPM_FLAGS_PARTNER_USB_COMM		(1<<3)
-#define DPM_FLAGS_PARTNER_USB_SUSPEND		(1<<4)
+#define DPM_FLAGS_PARTNER_USB_SUSPEND	(1<<4)
 #define DPM_FLAGS_PARTNER_HIGH_CAP		(1<<5)
 
 #define DPM_FLAGS_PARTNER_MISMATCH		(1<<7)
 #define DPM_FLAGS_PARTNER_GIVE_BACK		(1<<8)
-#define DPM_FLAGS_PARTNER_NO_SUSPEND		(1<<9)
+#define DPM_FLAGS_PARTNER_NO_SUSPEND	(1<<9)
 
 #define DPM_FLAGS_RESET_PARTNER_MASK	\
-	(DPM_FLAGS_PARTNER_DR_POWER | DPM_FLAGS_PARTNER_DR_DATA |\
-	 DPM_FLAGS_PARTNER_EXTPOWER | DPM_FLAGS_PARTNER_USB_COMM |\
-	 DPM_FLAGS_PARTNER_USB_SUSPEND)
+	(DPM_FLAGS_PARTNER_DR_POWER | DPM_FLAGS_PARTNER_DR_DATA|\
+	DPM_FLAGS_PARTNER_EXTPOWER | DPM_FLAGS_PARTNER_USB_COMM)
 
 /* DPM_CAPS */
 
@@ -433,7 +444,6 @@ enum pd_cable_current_limit {
 #define DPM_CAP_ATTEMP_ENTER_DP_MODE		(1<<13)
 #define DPM_CAP_ATTEMP_DISCOVER_CABLE		(1<<14)
 #define DPM_CAP_ATTEMP_DISCOVER_ID		(1<<15)
-#define DPM_CAP_ATTEMP_DISCOVER_SVID		(1<<16)
 
 enum dpm_cap_pr_check_prefer {
 	DPM_CAP_PR_CHECK_DISABLE = 0,
@@ -441,12 +451,12 @@ enum dpm_cap_pr_check_prefer {
 	DPM_CAP_PR_CHECK_PREFER_SRC = 2,
 };
 
-#define DPM_CAP_PR_CHECK_PROP(cap)		((cap & 0x03) << 18)
-#define DPM_CAP_EXTRACT_PR_CHECK(raw)		((raw >> 18) & 0x03)
-#define DPM_CAP_PR_SWAP_REJECT_AS_SRC		(1<<20)
-#define DPM_CAP_PR_SWAP_REJECT_AS_SNK		(1<<21)
-#define DPM_CAP_PR_SWAP_CHECK_GP_SRC		(1<<22)
-#define DPM_CAP_PR_SWAP_CHECK_GP_SNK		(1<<23)
+#define DPM_CAP_PR_CHECK_PROP(cap)			((cap & 0x03) << 16)
+#define DPM_CAP_EXTRACT_PR_CHECK(raw)		((raw >> 16) & 0x03)
+#define DPM_CAP_PR_SWAP_REJECT_AS_SRC		(1<<18)
+#define DPM_CAP_PR_SWAP_REJECT_AS_SNK		(1<<19)
+#define DPM_CAP_PR_SWAP_CHECK_GP_SRC		(1<<20)
+#define DPM_CAP_PR_SWAP_CHECK_GP_SNK		(1<<21)
 #define DPM_CAP_PR_SWAP_CHECK_GOOD_POWER	\
 	(DPM_CAP_PR_SWAP_CHECK_GP_SRC | DPM_CAP_PR_SWAP_CHECK_GP_SNK)
 
@@ -546,8 +556,6 @@ enum tcp_dpm_return_code {
 	TCP_DPM_RET_DROP_ERROR_REOCVERY,
 	TCP_DPM_RET_DROP_SEND_BIST,
 	TCP_DPM_RET_DROP_PE_BUSY,	/* SinkTXNg*/
-	TCP_DPM_RET_DROP_DISCARD,
-	TCP_DPM_RET_DROP_UNEXPECTED,
 
 	TCP_DPM_RET_WAIT,
 	TCP_DPM_RET_REJECT,
@@ -847,74 +855,71 @@ extern int register_tcp_dev_notifier(struct tcpc_device *tcp_dev,
 extern int unregister_tcp_dev_notifier(struct tcpc_device *tcp_dev,
 				struct notifier_block *nb, uint8_t flags);
 
-extern int tcpm_shutdown(struct tcpc_device *tcpc);
+extern int tcpm_shutdown(struct tcpc_device *tcpc_dev);
 
-extern int tcpm_inquire_remote_cc(struct tcpc_device *tcpc,
+extern int tcpm_inquire_remote_cc(struct tcpc_device *tcpc_dev,
 	uint8_t *cc1, uint8_t *cc2, bool from_ic);
-extern int tcpm_inquire_vbus_level(struct tcpc_device *tcpc, bool from_ic);
-extern int tcpm_inquire_typec_remote_rp_curr(struct tcpc_device *tcpc);
-extern bool tcpm_inquire_cc_polarity(struct tcpc_device *tcpc);
-extern uint8_t tcpm_inquire_typec_attach_state(struct tcpc_device *tcpc);
-extern uint8_t tcpm_inquire_typec_role(struct tcpc_device *tcpc);
-extern uint8_t tcpm_inquire_typec_local_rp(struct tcpc_device *tcpc);
+extern int tcpm_inquire_vbus_level(struct tcpc_device *tcpc_dev, bool from_ic);
+extern int tcpm_inquire_typec_remote_rp_curr(struct tcpc_device *tcpc_dev);
+extern bool tcpm_inquire_cc_polarity(struct tcpc_device *tcpc_dev);
+extern uint8_t tcpm_inquire_typec_attach_state(struct tcpc_device *tcpc_dev);
+extern uint8_t tcpm_inquire_typec_role(struct tcpc_device *tcpc_dev);
+extern uint8_t tcpm_inquire_typec_local_rp(struct tcpc_device *tcpc_dev);
 
 extern int tcpm_typec_set_wake_lock(
 	struct tcpc_device *tcpc, bool user_lock);
 
 extern int tcpm_typec_set_usb_sink_curr(
-	struct tcpc_device *tcpc, int curr);
+	struct tcpc_device *tcpc_dev, int curr);
 
 extern int tcpm_typec_set_rp_level(
-	struct tcpc_device *tcpc, uint8_t level);
+	struct tcpc_device *tcpc_dev, uint8_t level);
 
 extern int tcpm_typec_set_custom_hv(
-	struct tcpc_device *tcpc, bool en);
+	struct tcpc_device *tcpc_dev, bool en);
 
 extern int tcpm_typec_role_swap(
-	struct tcpc_device *tcpc);
+	struct tcpc_device *tcpc_dev);
 
 extern int tcpm_typec_change_role(
-	struct tcpc_device *tcpc, uint8_t typec_role);
+	struct tcpc_device *tcpc_dev, uint8_t typec_role);
 
-extern int tcpm_typec_change_role_postpone(
-	struct tcpc_device *tcpc, uint8_t typec_role, bool postpone);
-
-extern int tcpm_typec_error_recovery(struct tcpc_device *tcpc);
+extern int tcpm_typec_error_recovery(struct tcpc_device *tcpc_dev);
 
 extern int tcpm_typec_disable_function(
-	struct tcpc_device *tcpc, bool disable);
+	struct tcpc_device *tcpc_dev, bool disable);
 
 #ifdef CONFIG_USB_POWER_DELIVERY
 
 extern bool tcpm_inquire_pd_connected(
-	struct tcpc_device *tcpc);
+	struct tcpc_device *tcpc_dev);
 
 extern bool tcpm_inquire_pd_prev_connected(
-	struct tcpc_device *tcpc);
+	struct tcpc_device *tcpc_dev);
 
 extern uint8_t tcpm_inquire_pd_data_role(
-	struct tcpc_device *tcpc);
+	struct tcpc_device *tcpc_dev);
 
 extern uint8_t tcpm_inquire_pd_power_role(
-	struct tcpc_device *tcpc);
+	struct tcpc_device *tcpc_dev);
 
 extern uint8_t tcpm_inquire_pd_vconn_role(
-	struct tcpc_device *tcpc);
+	struct tcpc_device *tcpc_dev);
 
 extern uint8_t tcpm_inquire_pd_pe_ready(
-	struct tcpc_device *tcpc);
+	struct tcpc_device *tcpc_dev);
 
 extern uint8_t tcpm_inquire_cable_current(
-	struct tcpc_device *tcpc);
+	struct tcpc_device *tcpc_dev);
 
 extern uint32_t tcpm_inquire_dpm_flags(
-	struct tcpc_device *tcpc);
+	struct tcpc_device *tcpc_dev);
 
 extern uint32_t tcpm_inquire_dpm_caps(
-	struct tcpc_device *tcpc);
+	struct tcpc_device *tcpc_dev);
 
 extern void tcpm_set_dpm_caps(
-	struct tcpc_device *tcpc, uint32_t caps);
+	struct tcpc_device *tcpc_dev, uint32_t caps);
 
 /* Request TCPM to send PD Request */
 
@@ -944,7 +949,7 @@ extern bool tcpm_extract_power_cap_val(
 extern bool tcpm_extract_power_cap_list(
 	struct tcpm_power_cap *cap, struct tcpm_power_cap_list *cap_list);
 
-extern int tcpm_get_remote_power_cap(struct tcpc_device *tcpc,
+extern int tcpm_get_remote_power_cap(struct tcpc_device *tcpc_dev,
 	struct tcpm_remote_power_cap *cap);
 
 extern int tcpm_inquire_select_source_cap(
@@ -982,9 +987,6 @@ extern int tcpm_dpm_pd_fast_swap(struct tcpc_device *tcpc,
 	uint8_t role, const struct tcp_dpm_event_cb_data *data);
 extern int tcpm_dpm_pd_get_status(struct tcpc_device *tcpc,
 	const struct tcp_dpm_event_cb_data *data, struct pd_status *status);
-extern int tcpm_dpm_pd_get_pps_status_raw(struct tcpc_device *tcpc,
-	const struct tcp_dpm_event_cb_data *cb_data,
-	struct pd_pps_status_raw *pps_status);
 extern int tcpm_dpm_pd_get_pps_status(struct tcpc_device *tcpc,
 	const struct tcp_dpm_event_cb_data *data,
 	struct pd_pps_status *pps_status);
@@ -1074,7 +1076,7 @@ extern int tcpm_dpm_send_custom_vdm(
 
 /* Notify TCPM */
 
-extern int tcpm_notify_vbus_stable(struct tcpc_device *tcpc);
+extern int tcpm_notify_vbus_stable(struct tcpc_device *tcpc_dev);
 
 /* Charging Policy: Select PDO */
 
@@ -1142,10 +1144,10 @@ extern int tcpm_update_bat_status_wh_no_mutex(struct tcpc_device *tcpc,
 	enum pd_battery_reference ref, uint8_t status, uint16_t wh);
 
 extern int tcpm_update_bat_status_soc(struct tcpc_device *tcpc,
-	enum pd_battery_reference ref, uint8_t status, uint16_t soc);
+	uint8_t status, uint16_t soc);
 
 extern int tcpm_update_bat_status_soc_no_mutex(struct tcpc_device *tcpc,
-	enum pd_battery_reference ref, uint8_t status, uint16_t soc);
+	uint8_t status, uint16_t soc);
 
 /**
  * tcpm_update_bat_last_full
@@ -1291,46 +1293,46 @@ static inline int unregister_tcp_dev_notifier(struct tcpc_device *tcp_dev,
 	return -ENODEV;
 }
 
-static inline int tcpm_shutdown(struct tcpc_device *tcpc)
+static inline int tcpm_shutdown(struct tcpc_device *tcpc_dev)
 {
 	return TCPM_ERROR_NO_IMPLEMENT;
 }
 
-static inline int tcpm_inquire_remote_cc(struct tcpc_device *tcpc,
+static inline int tcpm_inquire_remote_cc(struct tcpc_device *tcpc_dev,
 	uint8_t *cc1, uint8_t *cc2, bool from_ic)
 {
 	return TCPM_ERROR_NO_IMPLEMENT;
 }
 
 static inline int tcpm_inquire_vbus_level(
-	struct tcpc_device *tcpc, bool from_ic)
+	struct tcpc_device *tcpc_dev, bool from_ic)
 {
 	return TCPM_ERROR_NO_IMPLEMENT;
 }
 
 static inline int tcpm_inquire_typec_remote_rp_curr(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
 	return 0;
 }
 
-static inline bool tcpm_inquire_cc_polarity(struct tcpc_device *tcpc)
+static inline bool tcpm_inquire_cc_polarity(struct tcpc_device *tcpc_dev)
 {
 	return false;
 }
 
 static inline uint8_t tcpm_inquire_typec_attach_state(
-				struct tcpc_device *tcpc)
+				struct tcpc_device *tcpc_dev)
 {
 	return TYPEC_UNATTACHED;
 }
 
-static inline uint8_t tcpm_inquire_typec_role(struct tcpc_device *tcpc)
+static inline uint8_t tcpm_inquire_typec_role(struct tcpc_device *tcpc_dev)
 {
 	return TYPEC_ROLE_UNKNOWN;
 }
 
-static inline uint8_t tcpm_inquire_typec_local_rp(struct tcpc_device *tcpc)
+static inline uint8_t tcpm_inquire_typec_local_rp(struct tcpc_device *tcpc_dev)
 {
 	return 0;
 }
@@ -1342,42 +1344,36 @@ static inline int tcpm_typec_set_wake_lock(
 }
 
 static inline int tcpm_typec_set_usb_sink_curr(
-	struct tcpc_device *tcpc, int curr)
+	struct tcpc_device *tcpc_dev, int curr)
 {
 	return TCPM_ERROR_NO_IMPLEMENT;
 }
 
 static inline int tcpm_typec_set_rp_level(
-	struct tcpc_device *tcpc, uint8_t level)
+	struct tcpc_device *tcpc_dev, uint8_t level)
 {
 	return TCPM_ERROR_NO_IMPLEMENT;
 }
 
 static inline int tcpm_typec_set_custom_hv(
-	struct tcpc_device *tcpc, bool en)
+	struct tcpc_device *tcpc_dev, bool en)
 {
 	return TCPM_ERROR_NO_IMPLEMENT;
 }
 
 static inline int tcpm_typec_role_swap(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
 	return TCPM_ERROR_NO_IMPLEMENT;
 }
 
 static inline int tcpm_typec_change_role(
-	struct tcpc_device *tcpc, uint8_t typec_role)
-{
-	return TCPM_ERROR_NO_IMPLEMENT;
-}
-
-static inline int tcpm_typec_change_role_postpone(
-	struct tcpc_device *tcpc, uint8_t typec_role, bool postpone)
+	struct tcpc_device *tcpc_dev, uint8_t typec_role)
 {
 	return TCPM_ERROR_NO_IMPLEMENT;
 }
 
-static inline int tcpm_typec_error_recovery(struct tcpc_device *tcpc)
+static inline int tcpm_typec_error_recovery(struct tcpc_device *tcpc_dev)
 {
 	return TCPM_ERROR_NO_IMPLEMENT;
 }
@@ -1386,61 +1382,61 @@ static inline int tcpm_typec_error_recovery(struct tcpc_device *tcpc)
 #ifdef USB_POWER_DELIVERY_NA
 
 static inline bool tcpm_inquire_pd_connected(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
 	return false;
 }
 
 static inline bool tcpm_inquire_pd_prev_connected(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
 	return false;
 }
 
 static inline uint8_t tcpm_inquire_pd_data_role(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
 	return 0;
 }
 
 static inline uint8_t tcpm_inquire_pd_power_role(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
 	return 0;
 }
 
 static inline uint8_t tcpm_inquire_pd_vconn_role(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
 	return 0;
 }
 
 static inline uint8_t tcpm_inquire_pd_pe_ready(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
 	return 0;
 }
 
 static inline uint8_t tcpm_inquire_cable_current(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
 	return PD_CABLE_CURR_UNKNOWN;
 }
 
 static inline uint32_t tcpm_inquire_dpm_flags(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
 	return 0;
 }
 
 static inline uint32_t tcpm_inquire_dpm_caps(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
 	return 0;
 }
 
 static inline void tcpm_set_dpm_caps(
-	struct tcpc_device *tcpc, uint32_t caps)
+	struct tcpc_device *tcpc_dev, uint32_t caps)
 {
 }
 
@@ -1504,7 +1500,7 @@ static inline bool tcpm_extract_power_cap_list(
 	return false;
 }
 
-static inline int tcpm_get_remote_power_cap(struct tcpc_device *tcpc,
+static inline int tcpm_get_remote_power_cap(struct tcpc_device *tcpc_dev,
 	struct tcpm_remote_power_cap *cap)
 {
 	return TCPM_ERROR_NO_IMPLEMENT;
@@ -1763,7 +1759,7 @@ static inline int tcpm_dpm_send_custom_vdm(
 #endif	/* USB_PD_CUSTOM_VDM_NA */
 
 #ifdef USB_POWER_DELIVERY_NA
-static inline int tcpm_notify_vbus_stable(struct tcpc_device *tcpc)
+static inline int tcpm_notify_vbus_stable(struct tcpc_device *tcpc_dev)
 {
 	return TCPM_ERROR_NO_IMPLEMENT;
 }
diff --git a/drivers/misc/mediatek/typec/tcpc/inc/tcpm_pd.h b/drivers/misc/mediatek/typec/tcpc/inc/tcpm_pd.h
index ee2adc8..3933286 100644
--- a/drivers/misc/mediatek/typec/tcpc/inc/tcpm_pd.h
+++ b/drivers/misc/mediatek/typec/tcpc/inc/tcpm_pd.h
@@ -274,6 +274,8 @@ struct pd_country_info {
 
 /* SDB, Status */
 
+#define PD_SDB_SIZE	5
+
 #define PD_STATUS_INPUT_EXT_POWER	(1<<1)
 #define PD_STATUS_INPUT_EXT_POWER_FROM_AC	(1<<2)
 #define PD_STATUS_INPUT_INT_POWER_BAT		(1<<3)
@@ -297,15 +299,11 @@ struct pd_country_info {
 struct pd_status {
 	uint8_t internal_temp;	/* 0 means no support */
 	uint8_t present_input;	/* bit filed */
-	uint8_t present_battery_input;
+	uint8_t present_battey_input; /* bit filed */
 	uint8_t event_flags;	/* bit filed */
 	uint8_t temp_status;	/* bit filed */
-	uint8_t power_status;	/* bit filed */
-	uint8_t power_state_change;
 };
 
-#define PD_SDB_SIZE	sizeof(struct pd_status)
-
 /* PPSSDB, PPSStatus */
 
 #define PD_PPSSDB_SIZE	4	/* PPS_Status */
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_core.c b/drivers/misc/mediatek/typec/tcpc/pd_core.c
index b9be018..7b8b01f 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_core.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_core.c
@@ -62,12 +62,11 @@ static inline void pd_parse_pdata_bat_info(
 	ret = of_property_read_string(sub, "bat,mfrs", &mstring);
 	if (ret < 0) {
 		pr_err("%s get bat,mfrs fail\n", __func__);
-		mstring = "no_bat_mfrs_string";
-	}
-	ret = snprintf(mfrs_info->mfrs_string,
-		sizeof(mfrs_info->mfrs_string), "%s", mstring);
-	if (ret < 0 || ret >= sizeof(mfrs_info->mfrs_string))
-		pr_info("%s-%d snprintf fail\n", __func__, __LINE__);
+		snprintf(mfrs_info->mfrs_string,
+			PAGE_SIZE, "%s", "no_bat_mfrs_string");
+	} else
+		snprintf(mfrs_info->mfrs_string,
+			strlen(mstring)+1, "%s", mstring);
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL */
 
 	ret = of_property_read_u32(sub, "bat,design_cap", &design_cap);
@@ -105,7 +104,7 @@ static inline int pd_parse_pdata_bats(
 	pd_port->bat_nr = val;
 	pr_info("%s Battery NR = %d\n", __func__, pd_port->bat_nr);
 
-	pd_port->fix_bat_info = devm_kzalloc(&pd_port->tcpc->dev,
+	pd_port->fix_bat_info = devm_kzalloc(&pd_port->tcpc_dev->dev,
 		sizeof(struct pd_battery_info)*pd_port->bat_nr,
 		GFP_KERNEL);
 
@@ -166,7 +165,7 @@ static inline int pd_parse_pdata_country(
 	country_info->len = (uint16_t) val;
 
 	country_info->data = devm_kzalloc(
-		&pd_port->tcpc->dev,
+		&pd_port->tcpc_dev->dev,
 		sizeof(uint8_t)*country_info->len,
 		GFP_KERNEL);
 
@@ -176,7 +175,7 @@ static inline int pd_parse_pdata_country(
 		return -ENOMEM;
 	}
 
-	temp_u32 = devm_kzalloc(&pd_port->tcpc->dev,
+	temp_u32 = devm_kzalloc(&pd_port->tcpc_dev->dev,
 		sizeof(u32)*country_info->len, GFP_KERNEL);
 
 	ret = of_property_read_u32_array(sub, "pd,country_data",
@@ -188,7 +187,7 @@ static inline int pd_parse_pdata_country(
 	for (j = 0; j < country_info->len; j++)
 		country_info->data[j] = (uint8_t) temp_u32[j];
 
-	devm_kfree(&pd_port->tcpc->dev, temp_u32);
+	devm_kfree(&pd_port->tcpc_dev->dev, temp_u32);
 
 	return 0;
 }
@@ -210,7 +209,7 @@ static inline int pd_parse_pdata_countries(
 
 	pr_info("%s Country NR = %d\n", __func__, pd_port->country_nr);
 
-	pd_port->country_info = devm_kzalloc(&pd_port->tcpc->dev,
+	pd_port->country_info = devm_kzalloc(&pd_port->tcpc_dev->dev,
 		sizeof(struct pd_country_authority)*pd_port->country_nr,
 		GFP_KERNEL);
 
@@ -335,12 +334,11 @@ static inline void pd_parse_pdata_mfrs(
 	ret = of_property_read_string(np, "pd,mfrs", &mstring);
 	if (ret < 0) {
 		pr_err("%s get pd mfrs fail\n", __func__);
-		mstring = "no_pd_mfrs_string";
-	}
-	ret = snprintf(mfrs_info->mfrs_string,
-		sizeof(mfrs_info->mfrs_string), "%s", mstring);
-	if (ret < 0 || ret >= sizeof(mfrs_info->mfrs_string))
-		pr_info("%s-%d snprintf fail\n", __func__, __LINE__);
+		snprintf(mfrs_info->mfrs_string,
+			PAGE_SIZE, "%s", "no_mfrs_string");
+	} else
+		snprintf(mfrs_info->mfrs_string,
+			strlen(mstring)+1, "%s", mstring);
 
 	pr_info("%s PD mfrs_string = %s\n",
 		__func__, mfrs_info->mfrs_string);
@@ -357,7 +355,10 @@ static inline void pd_parse_pdata_mfrs(
 	pd_port->id_vdos[2] = VDO_PRODUCT(
 		pid, PD_PRODUCT_BCD(pd_port->id_vdos[2]));
 
+#ifdef CONFIG_USB_PD_REV30
 	pd_port->id_header = pd_port->id_vdos[0];
+#endif	/* CONFIG_USB_PD_REV30 */
+
 }
 
 static int pd_parse_pdata(struct pd_port *pd_port)
@@ -367,7 +368,7 @@ static int pd_parse_pdata(struct pd_port *pd_port)
 	int ret = 0, i;
 
 	pr_info("%s\n", __func__);
-	np = of_find_node_by_name(pd_port->tcpc->dev.of_node, "pd-data");
+	np = of_find_node_by_name(pd_port->tcpc_dev->dev.of_node, "pd-data");
 
 	if (np) {
 		ret = of_property_read_u32(np, "pd,source-pdo-size",
@@ -428,7 +429,9 @@ static int pd_parse_pdata(struct pd_port *pd_port)
 			pr_info("%s %d: 0x%08x\n", __func__, i,
 			pd_port->id_vdos[i]);
 
+#ifdef CONFIG_USB_PD_REV30
 		pd_port->id_header = pd_port->id_vdos[0];
+#endif	/* CONFIG_USB_PD_REV30 */
 
 		val = DPM_CHARGING_POLICY_MAX_POWER_LVIC;
 		if (of_property_read_u32(np, "pd,charging_policy", &val) < 0)
@@ -475,7 +478,6 @@ static const struct {
 	{"attemp_enter_dp_mode", DPM_CAP_ATTEMP_ENTER_DP_MODE},
 	{"attemp_discover_cable", DPM_CAP_ATTEMP_DISCOVER_CABLE},
 	{"attemp_discover_id", DPM_CAP_ATTEMP_DISCOVER_ID},
-	{"attemp_discover_svid", DPM_CAP_ATTEMP_DISCOVER_SVID},
 
 	{"pr_reject_as_source", DPM_CAP_PR_SWAP_REJECT_AS_SRC},
 	{"pr_reject_as_sink", DPM_CAP_PR_SWAP_REJECT_AS_SNK},
@@ -495,7 +497,7 @@ static void pd_core_power_flags_init(struct pd_port *pd_port)
 	struct pd_port_power_caps *src_cap =
 				&pd_port->local_src_cap_default;
 
-	np = of_find_node_by_name(pd_port->tcpc->dev.of_node, "dpm_caps");
+	np = of_find_node_by_name(pd_port->tcpc_dev->dev.of_node, "dpm_caps");
 
 	for (i = 0; i < ARRAY_SIZE(supported_dpm_caps); i++) {
 		if (of_property_read_bool(np,
@@ -516,6 +518,9 @@ static void pd_core_power_flags_init(struct pd_port *pd_port)
 	else
 		pr_err("%s get dr_check data fail\n", __func__);
 
+	if (pd_port->tcpc_dev->tcpc_flags & TCPC_FLAGS_KPOC_BOOT)
+		pd_port->dpm_caps |= DPM_CAP_DR_SWAP_REJECT_AS_DFP;
+
 	pr_info("dpm_caps = 0x%08x\n", pd_port->dpm_caps);
 
 	src_flag = 0;
@@ -531,11 +536,10 @@ static void pd_core_power_flags_init(struct pd_port *pd_port)
 	if (pd_port->dpm_caps & DPM_CAP_LOCAL_USB_COMM)
 		src_flag |= PDO_FIXED_COMM_CAP;
 
-	snk_flag = src_flag;
-
 	if (pd_port->dpm_caps & DPM_CAP_LOCAL_USB_SUSPEND)
 		src_flag |= PDO_FIXED_SUSPEND;
 
+	snk_flag = src_flag;
 	if (pd_port->dpm_caps & DPM_CAP_LOCAL_HIGH_CAP)
 		snk_flag |= PDO_FIXED_HIGH_CAP;
 
@@ -548,18 +552,18 @@ static void fg_bat_absent_work(struct work_struct *work)
 {
 	struct pd_port *pd_port = container_of(work, struct pd_port,
 					       fg_bat_work);
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 	int ret = 0;
 
-	ret = tcpm_shutdown(tcpc);
+	ret = tcpm_shutdown(tcpc_dev);
 	if (ret < 0)
 		pr_notice("%s: tcpm shutdown fail\n", __func__);
 }
 #endif /* ONFIG_RECV_BAT_ABSENT_NOTIFY */
 
-int pd_core_init(struct tcpc_device *tcpc)
+int pd_core_init(struct tcpc_device *tcpc_dev)
 {
-	struct pd_port *pd_port = &tcpc->pd_port;
+	struct pd_port *pd_port = &tcpc_dev->pd_port;
 	int ret;
 
 	mutex_init(&pd_port->pd_lock);
@@ -569,12 +573,12 @@ int pd_core_init(struct tcpc_device *tcpc)
 	init_waitqueue_head(&pd_port->tcpm_bk_wait_que);
 #endif	/* CONFIG_USB_PD_BLOCK_TCPM */
 
-	pd_port->tcpc = tcpc;
+	pd_port->tcpc_dev = tcpc_dev;
 	pd_port->pe_pd_state = PE_IDLE2;
 	pd_port->cap_miss_match = 0; /* For src_cap miss match */
 
 	ret = pd_parse_pdata(pd_port);
-	if (ret < 0)
+	if (ret)
 		return ret;
 
 	pd_core_power_flags_init(pd_port);
@@ -585,7 +589,7 @@ int pd_core_init(struct tcpc_device *tcpc)
 	INIT_WORK(&pd_port->fg_bat_work, fg_bat_absent_work);
 #endif /* CONFIG_RECV_BAT_ABSENT_NOTIFY */
 
-	PE_INFO("%s\n", __func__);
+	PE_INFO("%s\r\n", __func__);
 	return 0;
 }
 
@@ -623,8 +627,7 @@ void pd_extract_rdo_power(uint32_t rdo, uint32_t pdo,
 	}
 }
 
-uint32_t pd_reset_pdo_power(struct tcpc_device *tcpc,
-			uint32_t pdo, uint32_t imax)
+uint32_t pd_reset_pdo_power(uint32_t pdo, uint32_t imax)
 {
 	uint32_t ioper;
 
@@ -643,7 +646,7 @@ uint32_t pd_reset_pdo_power(struct tcpc_device *tcpc,
 
 	case PDO_TYPE_BATTERY:
 		/* TODO: check it later !! */
-		PD_ERR("No Support\n");
+		PD_ERR("No Support\r\n");
 		break;
 
 #ifdef CONFIG_USB_PD_REV30_PPS_SOURCE
@@ -730,19 +733,6 @@ void pd_reset_svid_data(struct pd_port *pd_port)
 	}
 }
 
-void pd_free_unexpected_event(struct pd_port *pd_port)
-{
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
-	struct pe_data *pe_data = &pd_port->pe_data;
-
-	if (!pe_data->pd_unexpected_event_pending)
-		return;
-
-	pe_data->pd_unexpected_event_pending = false;
-	pd_free_event(pd_port->tcpc, &pe_data->pd_unexpected_event);
-#endif	/* CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG */
-}
-
 #define PE_RESET_MSG_ID(pd_port, sop)	{ \
 	pd_port->pe_data.msg_id_tx[sop] = 0; \
 	pd_port->pe_data.msg_id_rx[sop] = PD_MSG_ID_MAX; \
@@ -760,7 +750,7 @@ int pd_reset_protocol_layer(struct pd_port *pd_port, bool sop_only)
 	pe_data->cap_counter = 0;
 #endif	/* CONFIG_USB_PD_PE_SOURCE */
 
-	pe_data->explicit_contract = false;
+	pe_data->explicit_contract = 0;
 	pe_data->local_selected_cap = 0;
 	pe_data->remote_selected_cap = 0;
 	pe_data->during_swap = 0;
@@ -793,24 +783,17 @@ int pd_reset_protocol_layer(struct pd_port *pd_port, bool sop_only)
 	pd_port->msg_id_pr_swap_last = 0xff;
 #endif	/* CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP */
 
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
-	pe_data->pd_sent_ams_init_cmd = true;
-	pd_free_unexpected_event(pd_port);
-#endif	/* CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG */
-
 	return 0;
 }
 
 int pd_set_rx_enable(struct pd_port *pd_port, uint8_t enable)
 {
-	return tcpci_set_rx_enable(pd_port->tcpc, enable);
+	return tcpci_set_rx_enable(pd_port->tcpc_dev, enable);
 }
 
 int pd_enable_vbus_valid_detection(struct pd_port *pd_port, bool wait_valid)
 {
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
-	PE_DBG("WaitVBUS=%d\n", wait_valid);
+	PE_DBG("WaitVBUS=%d\r\n", wait_valid);
 	pd_notify_pe_wait_vbus_once(pd_port,
 		wait_valid ? PD_WAIT_VBUS_VALID_ONCE :
 					PD_WAIT_VBUS_INVALID_ONCE);
@@ -819,80 +802,65 @@ int pd_enable_vbus_valid_detection(struct pd_port *pd_port, bool wait_valid)
 
 int pd_enable_vbus_safe0v_detection(struct pd_port *pd_port)
 {
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
-	PE_DBG("WaitVSafe0V\n");
+	PE_DBG("WaitVSafe0V\r\n");
 	pd_notify_pe_wait_vbus_once(pd_port, PD_WAIT_VBUS_SAFE0V_ONCE);
 	return 0;
 }
 
 int pd_enable_vbus_stable_detection(struct pd_port *pd_port)
 {
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
-	PE_DBG("WaitVStable\n");
+	PE_DBG("WaitVStable\r\n");
 	pd_notify_pe_wait_vbus_once(pd_port, PD_WAIT_VBUS_STABLE_ONCE);
 	return 0;
 }
 
 static inline int pd_update_msg_header(struct pd_port *pd_port)
 {
-	return tcpci_set_msg_header(pd_port->tcpc,
+	return tcpci_set_msg_header(pd_port->tcpc_dev,
 		pd_port->power_role, pd_port->data_role);
 }
 
 int pd_set_data_role(struct pd_port *pd_port, uint8_t dr)
 {
-	int ret = 0;
-
-	if (dr == pd_port->data_role)
-		return ret;
-
 	pd_port->data_role = dr;
 
 #ifdef CONFIG_DUAL_ROLE_USB_INTF
 	/* dual role usb--> 0:ufp, 1:dfp */
-	pd_port->tcpc->dual_role_mode = pd_port->data_role;
+	pd_port->tcpc_dev->dual_role_mode = pd_port->data_role;
 	/* dual role usb --> 0: Device, 1: Host */
-	pd_port->tcpc->dual_role_dr = !(pd_port->data_role);
-	dual_role_instance_changed(pd_port->tcpc->dr_usb);
+	pd_port->tcpc_dev->dual_role_dr = !(pd_port->data_role);
+	dual_role_instance_changed(pd_port->tcpc_dev->dr_usb);
 #endif /* CONFIG_DUAL_ROLE_USB_INTF */
 
-	ret = pd_update_msg_header(pd_port);
-	if (ret < 0)
-		return ret;
-
-	tcpci_notify_role_swap(pd_port->tcpc, TCP_NOTIFY_DR_SWAP, dr);
-	return ret;
+	tcpci_notify_role_swap(pd_port->tcpc_dev, TCP_NOTIFY_DR_SWAP, dr);
+	return pd_update_msg_header(pd_port);
 }
 
 int pd_set_power_role(struct pd_port *pd_port, uint8_t pr)
 {
-	int ret = 0;
-
-	if (pr == pd_port->power_role)
-		return ret;
+	int ret;
 
 	pd_port->power_role = pr;
 	ret = pd_update_msg_header(pd_port);
-	if (ret < 0)
+	if (ret)
 		return ret;
 
 	pd_notify_pe_pr_changed(pd_port);
 
 #ifdef CONFIG_DUAL_ROLE_USB_INTF
 	/* 0:sink, 1: source */
-	pd_port->tcpc->dual_role_pr = !(pd_port->power_role);
-	dual_role_instance_changed(pd_port->tcpc->dr_usb);
+	pd_port->tcpc_dev->dual_role_pr = !(pd_port->power_role);
+	dual_role_instance_changed(pd_port->tcpc_dev->dr_usb);
 #endif /* CONFIG_DUAL_ROLE_USB_INTF */
-	tcpci_notify_role_swap(pd_port->tcpc, TCP_NOTIFY_PR_SWAP, pr);
+
+	tcpci_notify_role_swap(pd_port->tcpc_dev, TCP_NOTIFY_PR_SWAP, pr);
 	return ret;
 }
 
 static void pd_init_spec_revision(struct pd_port *pd_port)
 {
 #ifdef CONFIG_USB_PD_REV30_SYNC_SPEC_REV
-	if (pd_port->tcpc->tcpc_flags & TCPC_FLAGS_PD_REV30) {
+	if (pd_port->tcpc_dev->tcpc_flags & TCPC_FLAGS_PD_REV30) {
 		pd_port->pd_revision[0] = PD_REV30;
 		pd_port->pd_revision[1] = PD_REV30;
 	} else {
@@ -920,32 +888,32 @@ int pd_init_message_hdr(struct pd_port *pd_port, bool act_as_sink)
 
 int pd_set_vconn(struct pd_port *pd_port, uint8_t role)
 {
-	int ret = 0;
-	bool enable = !!(role & PD_ROLE_VCONN_ON);
+	bool enable;
 	bool en_role = role != PD_ROLE_VCONN_OFF;
-	bool en_role_old = pd_port->vconn_role != PD_ROLE_VCONN_OFF;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
-	PE_DBG("%s:%d\n", __func__, role);
+	PE_DBG("%s:%d\r\n", __func__, role);
+
+#ifdef CONFIG_DUAL_ROLE_USB_INTF
+	pd_port->tcpc_dev->dual_role_vconn = en_role;
+	dual_role_instance_changed(pd_port->tcpc_dev->dr_usb);
+#endif /* CONFIG_DUAL_ROLE_USB_INTF */
+
+	pd_port->vconn_role = role;
+	tcpci_notify_role_swap(pd_port->tcpc_dev,
+		TCP_NOTIFY_VCONN_SWAP, en_role);
+
+	if ((role & PD_ROLE_VCONN_ON))
+		enable = true;
+	else
+		enable = false;
 
 #ifdef CONFIG_USB_PD_VCONN_SAFE5V_ONLY
-	if (pd_port->pe_data.vconn_highv_prot) {
-		PE_DBG("VC_OVER5V\n");
-		return -EPERM;
+	if (pd_port->pe_data.vconn_highv_prot && enable) {
+		PE_DBG("VC_OVER5V\r\n");
+		return 0;
 	}
 #endif	/* CONFIG_USB_PD_VCONN_SAFE5V_ONLY */
 
-	if (role == pd_port->vconn_role)
-		goto out;
-
-	pd_port->vconn_role = role;
-	ret = tcpci_set_vconn(tcpc, enable);
-	if (ret < 0)
-		return ret;
-
-	if (en_role != en_role_old)
-		tcpci_notify_role_swap(tcpc, TCP_NOTIFY_VCONN_SWAP, en_role);
-out:
 #ifdef CONFIG_USB_PD_VCONN_STABLE_DELAY
 	if (role == PD_ROLE_VCONN_DYNAMIC_ON)
 		pd_restart_timer(pd_port, PD_TIMER_VCONN_STABLE);
@@ -954,7 +922,7 @@ out:
 	if (!enable)
 		PE_RESET_MSG_ID(pd_port, TCPC_TX_SOP_PRIME);
 
-	return ret;
+	return tcpci_set_vconn(pd_port->tcpc_dev, enable);
 }
 
 static inline int pd_reset_modal_operation(struct pd_port *pd_port)
@@ -967,7 +935,7 @@ static inline int pd_reset_modal_operation(struct pd_port *pd_port)
 
 		if (svid_data->active_mode) {
 			svid_data->active_mode = 0;
-			tcpci_exit_mode(pd_port->tcpc, svid_data->svid);
+			tcpci_exit_mode(pd_port->tcpc_dev, svid_data->svid);
 		}
 	}
 
@@ -978,7 +946,6 @@ static inline int pd_reset_modal_operation(struct pd_port *pd_port)
 int pd_reset_local_hw(struct pd_port *pd_port)
 {
 	uint8_t dr;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	pd_notify_pe_transit_to_default(pd_port);
 	pd_unlock_msg_output(pd_port);
@@ -992,7 +959,6 @@ int pd_reset_local_hw(struct pd_port *pd_port)
 
 #ifdef CONFIG_USB_PD_VCONN_SAFE5V_ONLY
 	pd_port->pe_data.vconn_highv_prot = false;
-	pd_port->pe_data.vconn_highv_prot_role = PD_ROLE_VCONN_OFF;
 #endif	/* CONFIG_USB_PD_VCONN_SAFE5V_ONLY */
 
 #ifdef CONFIG_USB_PD_RESET_CABLE
@@ -1011,19 +977,16 @@ int pd_reset_local_hw(struct pd_port *pd_port)
 	pd_port->state_machine = PE_STATE_MACHINE_NORMAL;
 
 	pd_set_data_role(pd_port, dr);
-	pd_init_spec_revision(pd_port);
 	pd_dpm_notify_pe_hardreset(pd_port);
-	PE_DBG("reset_local_hw\n");
+	PE_DBG("reset_local_hw\r\n");
 
 	return 0;
 }
 
 int pd_enable_bist_test_mode(struct pd_port *pd_port, bool en)
 {
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
-	PE_DBG("bist_test_mode=%d\n", en);
-	return tcpci_set_bist_test_mode(tcpc, en);
+	PE_DBG("bist_test_mode=%d\r\n", en);
+	return tcpci_set_bist_test_mode(pd_port->tcpc_dev, en);
 }
 
 /* ---- Handle PD Message ----*/
@@ -1043,8 +1006,8 @@ void pd_handle_first_pd_command(struct pd_port *pd_port)
 	pd_sync_sop_spec_revision(pd_port);
 #endif	/* CONFIG_USB_PD_REV30 */
 
-	pd_port->pe_data.pd_connected = true;
-	pd_port->pe_data.pd_prev_connected = true;
+	pd_port->pe_data.pd_connected = 1;
+	pd_port->pe_data.pd_prev_connected = 1;
 }
 
 void pd_handle_hard_reset_recovery(struct pd_port *pd_port)
@@ -1073,32 +1036,44 @@ int pd_send_message(struct pd_port *pd_port, uint8_t sop_type,
 	uint8_t msg_id;
 	uint16_t msg_hdr;
 	uint16_t msg_hdr_private;
-	uint8_t pd_rev = pd_get_rev(pd_port, sop_type);
+	uint8_t pd_rev = PD_REV20;
 	uint8_t type = PD_TX_STATE_WAIT_CRC_PD;
 	struct pe_data *pe_data = &pd_port->pe_data;
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
-	if (tcpc->typec_attach_old == 0) {
-		PE_DBG("[SendMsg] Unattached\n");
+	if (tcpc_dev->typec_attach_old == 0) {
+		PE_DBG("[SendMsg] Unattached\r\n");
 		return 0;
 	}
 
-	if (tcpc->pd_hard_reset_event_pending) {
+	if (tcpc_dev->pd_hard_reset_event_pending) {
 		PE_DBG("[SendMsg] HardReset Pending");
 		return 0;
 	}
 
-	if (sop_type == TCPC_TX_SOP)
+	if (sop_type == TCPC_TX_SOP) {
+#ifdef CONFIG_USB_PD_REV30_SYNC_SPEC_REV
+		pd_rev = pd_port->pd_revision[0];
+#endif	/* CONFIG_USB_PD_REV30_SYNC_SPEC_REV */
+
 		msg_hdr_private = PD_HEADER_ROLE(
 			pd_port->power_role, pd_port->data_role);
-	else
+	} else {
+#ifdef CONFIG_USB_PD_REV30_SYNC_SPEC_REV
+		if (pe_data->explicit_contract || pe_data->cable_rev_discovered)
+			pd_rev = pd_port->pd_revision[1];
+		else if (tcpc_dev->tcpc_flags & TCPC_FLAGS_PD_REV30)
+			pd_rev = PD_REV30;
+#endif	/* CONFIG_USB_PD_REV30_SYNC_SPEC_REV */
+
 		msg_hdr_private = 0;
+	}
 
 #ifdef CONFIG_USB_PD_REV30
 	if (pd_rev >= PD_REV30)
-		tcpc->pd_retry_count = PD30_RETRY_COUNT;
+		tcpc_dev->pd_retry_count = PD30_RETRY_COUNT;
 	else
-		tcpc->pd_retry_count = PD_RETRY_COUNT;
+		tcpc_dev->pd_retry_count = PD_RETRY_COUNT;
 #endif	/* CONFIG_USB_PD_REV30 */
 
 	msg_id = pe_data->msg_id_tx[sop_type];
@@ -1112,9 +1087,9 @@ int pd_send_message(struct pd_port *pd_port, uint8_t sop_type,
 	pe_data->msg_id_tx[sop_type] = (msg_id+1) % PD_MSG_ID_MAX;
 
 	pd_notify_pe_transmit_msg(pd_port, type);
-	ret = tcpci_transmit(pd_port->tcpc, sop_type, msg_hdr, data);
+	ret = tcpci_transmit(pd_port->tcpc_dev, sop_type, msg_hdr, data);
 	if (ret < 0)
-		PD_ERR("[SendMsg] Failed, %d\n", ret);
+		PD_ERR("[SendMsg] Failed, %d\r\n", ret);
 
 	return ret;
 }
@@ -1203,29 +1178,30 @@ int pd_send_soft_reset(struct pd_port *pd_port)
 
 int pd_send_hard_reset(struct pd_port *pd_port)
 {
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
-	PE_DBG("Send HARD Reset\n");
-	__pm_wakeup_event(tcpc->attach_wake_lock, 6000);
+	PE_DBG("Send HARD Reset\r\n");
+	__pm_wakeup_event(&tcpc_dev->attach_wake_lock, 6000);
 
 	pd_port->pe_data.hard_reset_counter++;
 	pd_notify_pe_send_hard_reset(pd_port);
 
-	return tcpci_transmit(tcpc, TCPC_TX_HARD_RESET, 0, NULL);
+	return tcpci_transmit(tcpc_dev, TCPC_TX_HARD_RESET, 0, NULL);
 }
 
 int pd_send_bist_mode2(struct pd_port *pd_port)
 {
 	int ret = 0;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	pd_notify_tcp_event_buf_reset(pd_port, TCP_DPM_RET_DROP_SEND_BIST);
 
 #ifdef CONFIG_USB_PD_TRANSMIT_BIST2
-	TCPC_DBG("BIST_MODE_2\n");
-	ret = tcpci_transmit(tcpc, TCPC_TX_BIST_MODE_2, 0, NULL);
+	TCPC_DBG("BIST_MODE_2\r\n");
+	ret = tcpci_transmit(
+		pd_port->tcpc_dev, TCPC_TX_BIST_MODE_2, 0, NULL);
 #else
-	ret = tcpci_set_bist_carrier_mode(tcpc, 1 << 2);
+	ret = tcpci_set_bist_carrier_mode(
+		pd_port->tcpc_dev, 1 << 2);
 #endif
 
 	return ret;
@@ -1235,7 +1211,7 @@ int pd_disable_bist_mode2(struct pd_port *pd_port)
 {
 #ifndef CONFIG_USB_PD_TRANSMIT_BIST2
 	return tcpci_set_bist_carrier_mode(
-		pd_port->tcpc, 0);
+		pd_port->tcpc_dev, 0);
 #else
 	return 0;
 #endif
@@ -1262,19 +1238,21 @@ int pd_send_svdm_request(struct pd_port *pd_port,
 		return -EINVAL;
 	}
 
-	if (pd_get_rev(pd_port, sop_type) >= PD_REV30)
+#ifdef CONFIG_USB_PD_REV30
+	if (pd_check_rev30(pd_port))
 		ver = SVDM_REV20;
+#endif	/* CONFIG_USB_PD_REV30 */
 
 	payload[0] = VDO_S(svid, ver, CMDT_INIT, vdm_cmd, obj_pos);
 	memcpy(&payload[1], data_obj, sizeof(uint32_t) * cnt);
 
 #ifdef CONFIG_USB_PD_STOP_SEND_VDM_IF_RX_BUSY
-	rv = tcpci_get_alert_status(pd_port->tcpc, &alert_status);
+	rv = tcpci_get_alert_status(pd_port->tcpc_dev, &alert_status);
 	if (rv)
 		return rv;
 
 	if (alert_status & TCPC_REG_ALERT_RX_STATUS) {
-		PE_DBG("RX Busy, stop send VDM\n");
+		PE_DBG("RX Busy, stop send VDM\r\n");
 		return 0;
 	}
 #endif	/* CONFIG_USB_PD_STOP_SEND_VDM_IF_RX_BUSY */
@@ -1283,7 +1261,7 @@ int pd_send_svdm_request(struct pd_port *pd_port,
 			pd_port, sop_type, PD_DATA_VENDOR_DEF, 1+cnt, payload);
 
 	if (ret == 0 && timer_id != 0)
-		VDM_STATE_RESPONSE_CMD(pd_port, timer_id);
+		pd_enable_vdm_state_timer(pd_port, timer_id);
 
 	return ret;
 }
@@ -1295,14 +1273,16 @@ int pd_reply_svdm_request(struct pd_port *pd_port,
 	int rv;
 	uint32_t alert_status;
 #endif	/* CONFIG_USB_PD_STOP_REPLY_VDM_IF_RX_BUSY */
+
 	uint8_t ver = SVDM_REV10;
 	uint32_t payload[PD_DATA_OBJ_SIZE];
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	PD_BUG_ON(cnt > VDO_MAX_NR);
 
+#ifdef CONFIG_USB_PD_REV30
 	if (pd_check_rev30(pd_port))
 		ver = SVDM_REV20;
+#endif	/* CONFIG_USB_PD_REV30 */
 
 	payload[0] = VDO_REPLY(ver, reply, pd_get_msg_vdm_hdr(pd_port));
 
@@ -1312,20 +1292,20 @@ int pd_reply_svdm_request(struct pd_port *pd_port,
 	}
 
 #ifdef CONFIG_USB_PD_STOP_REPLY_VDM_IF_RX_BUSY
-	rv = tcpci_get_alert_status(tcpc, &alert_status);
+	rv = tcpci_get_alert_status(pd_port->tcpc_dev, &alert_status);
 	if (rv)
 		return rv;
 
 	if (alert_status & TCPC_REG_ALERT_RX_STATUS) {
-		PE_DBG("RX Busy, stop reply VDM\n");
+		PE_DBG("RX Busy, stop reply VDM\r\n");
 		return 0;
 	}
 #endif	/* CONFIG_USB_PD_STOP_REPLY_VDM_IF_RX_BUSY */
 
 	if (reply != CMDT_RSP_ACK)
-		PE_INFO("VDM_NAK_BUSY\n");
+		PE_INFO("VDM_NAK_BUSY\r\n");
 	else
-		PE_INFO("VDM_ACK\n");
+		PE_INFO("VDM_ACK\r\n");
 
 	VDM_STATE_REPLY_SVDM_REQUEST(pd_port);
 
@@ -1355,7 +1335,7 @@ int pd_reply_custom_vdm(struct pd_port *pd_port, uint8_t sop_type,
 
 void pd_reset_pe_timer(struct pd_port *pd_port)
 {
-	tcpc_reset_pe_timer(pd_port->tcpc);
+	tcpc_reset_pe_timer(pd_port->tcpc_dev);
 
 #ifdef CONFIG_USB_PD_REV30_PPS_SINK
 	if (pd_port->request_apdo) {
@@ -1385,14 +1365,12 @@ void pd_unlock_msg_output(struct pd_port *pd_port)
 
 int pd_update_connect_state(struct pd_port *pd_port, uint8_t state)
 {
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
 	if (pd_port->pd_connect_state == state)
 		return 0;
 
 	pd_port->pd_connect_state = state;
-	PE_INFO("pd_state=%d\n", state);
-	return tcpci_notify_pd_state(tcpc, state);
+	PE_INFO("pd_state=%d\r\n", state);
+	return tcpci_notify_pd_state(pd_port->tcpc_dev, state);
 }
 
 #ifdef CONFIG_USB_PD_REV30
@@ -1408,22 +1386,16 @@ int pd_update_connect_state(struct pd_port *pd_port, uint8_t state)
 void pd_set_sink_tx(struct pd_port *pd_port, uint8_t cc)
 {
 #ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
 	if (cc == PD30_SINK_TX_OK &&
 		pd_port->pe_data.pd_traffic_control != PD_SINK_TX_OK) {
-		PE_INFO("sink_tx_ok\n");
-		tcpci_lock_typec(tcpc);
-		tcpci_set_cc(tcpc, cc);
-		tcpci_unlock_typec(tcpc);
+		PE_INFO("sink_tx_ok\r\n");
+		tcpci_set_cc(pd_port->tcpc_dev, cc);
 		pd_port->pe_data.pd_traffic_control = PD_SINK_TX_OK;
 		pd_disable_timer(pd_port, PD_TIMER_SINK_TX);
 	} else if (cc == PD30_SINK_TX_NG &&
 		pd_port->pe_data.pd_traffic_control == PD_SINK_TX_OK) {
-		PE_INFO("sink_tx_ng\n");
-		tcpci_lock_typec(tcpc);
-		tcpci_set_cc(tcpc, cc);
-		tcpci_unlock_typec(tcpc);
+		PE_INFO("sink_tx_ng\r\n");
+		tcpci_set_cc(pd_port->tcpc_dev, cc);
 		pd_port->pe_data.pd_traffic_control = PD_SINK_TX_NG;
 		pd_enable_timer(pd_port, PD_TIMER_SINK_TX);
 	}
@@ -1434,13 +1406,12 @@ void pd_sync_sop_spec_revision(struct pd_port *pd_port)
 {
 #ifdef CONFIG_USB_PD_REV30_SYNC_SPEC_REV
 	uint8_t rev = pd_get_msg_hdr_rev(pd_port);
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
-	if (!pd_port->pe_data.pd_connected) {
+	if (!pd_port->pe_data.pd_prev_connected) {
 		pd_port->pd_revision[0] = MIN(PD_REV30, rev);
 		pd_port->pd_revision[1] = MIN(pd_port->pd_revision[1], rev);
 
-		PE_INFO("pd_rev=%d\n", pd_port->pd_revision[0]);
+		PE_INFO("pd_rev=%d\r\n", pd_port->pd_revision[0]);
 	}
 #endif /* CONFIG_USB_PD_REV30_SYNC_SPEC_REV */
 }
@@ -1449,12 +1420,11 @@ void pd_sync_sop_prime_spec_revision(struct pd_port *pd_port, uint8_t rev)
 {
 #ifdef CONFIG_USB_PD_REV30_SYNC_SPEC_REV
 	struct pe_data *pe_data = &pd_port->pe_data;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (!pe_data->cable_rev_discovered) {
 		pe_data->cable_rev_discovered = true;
 		pd_port->pd_revision[1] = MIN(pd_port->pd_revision[1], rev);
-		PE_INFO("cable_rev=%d\n", pd_port->pd_revision[1]);
+		PE_INFO("cable_rev=%d\r\n", pd_port->pd_revision[1]);
 	}
 #endif /* CONFIG_USB_PD_REV30_SYNC_SPEC_REV */
 }
@@ -1462,12 +1432,11 @@ void pd_sync_sop_prime_spec_revision(struct pd_port *pd_port, uint8_t rev)
 bool pd_is_multi_chunk_msg(struct pd_port *pd_port)
 {
 	uint16_t size;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (pd_get_msg_hdr_ext(pd_port)) {
 		size = pd_get_msg_data_size(pd_port);
 		if (size > MAX_EXTENDED_MSG_CHUNK_LEN) {
-			PE_INFO("multi_chunk_msg = TRUE (%d)\n", size);
+			PE_INFO("multi_chunk_msg = TRUE (%d)\r\n", size);
 			return true;
 		}
 	}
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_dbg_info.c b/drivers/misc/mediatek/typec/tcpc/pd_dbg_info.c
index d0455cd..3e70fb5 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_dbg_info.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_dbg_info.c
@@ -35,9 +35,10 @@ static struct {
 
 static struct mutex buff_lock;
 static unsigned int using_buf;
-static wait_queue_head_t print_out_wait_que;
-static atomic_t pending_print_out;
+static bool event_loop_thead_stop;
+static wait_queue_head_t event_loop_wait_que;
 static atomic_t busy = ATOMIC_INIT(0);
+static atomic_t pending_event = ATOMIC_INIT(0);
 
 void pd_dbg_info_lock(void)
 {
@@ -62,11 +63,10 @@ static inline bool pd_dbg_print_out(void)
 
 	used = pd_dbg_buffer[index].used;
 
-	if (used <= 0)
+	if (used == 0)
 		return false;
 
-	if (used < (PD_INFO_BUF_SIZE + 1 + OUT_BUF_MAX))
-		pd_dbg_buffer[index].buf[used] = '\0';
+	pd_dbg_buffer[index].buf[used] = '\0';
 
 	pr_info("///PD dbg info %ud\n", used);
 
@@ -77,7 +77,7 @@ static inline bool pd_dbg_print_out(void)
 		while (atomic_read(&busy))
 			usleep_range(1000, 2000);
 
-		pr_notice("%s", pd_dbg_buffer[index].buf + i);
+		printk(pd_dbg_buffer[index].buf + i);
 		pd_dbg_buffer[index].buf[OUT_BUF_MAX + i] = temp;
 	}
 
@@ -87,21 +87,17 @@ static inline bool pd_dbg_print_out(void)
 	return true;
 }
 
-static int print_out_thread_fn(void *data)
+static int print_out_thread_fn(void *arg)
 {
-	int ret = 0;
-
 	while (true) {
-		ret = wait_event_interruptible(print_out_wait_que,
-				atomic_read(&pending_print_out) ||
-				kthread_should_stop());
-		if (kthread_should_stop() || ret) {
-			pr_notice("%s exits(%d)\n", __func__, ret);
+		wait_event_interruptible(event_loop_wait_que,
+				atomic_read(&pending_event) |
+				event_loop_thead_stop);
+		if (kthread_should_stop() || event_loop_thead_stop)
 			break;
-		}
 		do {
-			atomic_dec_if_positive(&pending_print_out);
-		} while (pd_dbg_print_out() && !kthread_should_stop());
+			atomic_dec_if_positive(&pending_event);
+		} while (pd_dbg_print_out());
 	}
 
 	return 0;
@@ -133,8 +129,8 @@ int pd_dbg_info(const char *fmt, ...)
 		used += r;
 
 	if (pd_dbg_buffer[index].used == 0) {
-		atomic_inc(&pending_print_out);
-		wake_up(&print_out_wait_que);
+		atomic_inc(&pending_event);
+		wake_up_interruptible(&event_loop_wait_que);
 	}
 
 	pd_dbg_buffer[index].used = used;
@@ -143,22 +139,25 @@ int pd_dbg_info(const char *fmt, ...)
 	return r;
 }
 
-static struct task_struct *print_out_task;
+static struct task_struct *print_out_tsk;
 
 int pd_dbg_info_init(void)
 {
 	pr_info("%s\n", __func__);
 	mutex_init(&buff_lock);
-	init_waitqueue_head(&print_out_wait_que);
-	atomic_set(&pending_print_out, 0);
-	print_out_task = kthread_run(print_out_thread_fn, NULL, "pd_dbg_info");
-
+	print_out_tsk = kthread_create(
+			print_out_thread_fn, NULL, "pd_dbg_info");
+	init_waitqueue_head(&event_loop_wait_que);
+	atomic_set(&pending_event, 0);
+	wake_up_process(print_out_tsk);
 	return 0;
 }
 
 void pd_dbg_info_exit(void)
 {
-	kthread_stop(print_out_task);
+	event_loop_thead_stop = true;
+	wake_up_interruptible(&event_loop_wait_que);
+	kthread_stop(print_out_tsk);
 	mutex_destroy(&buff_lock);
 }
 
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_dpm_alt_mode_dc.c b/drivers/misc/mediatek/typec/tcpc/pd_dpm_alt_mode_dc.c
index 3f33271..97a9552 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_dpm_alt_mode_dc.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_dpm_alt_mode_dc.c
@@ -81,14 +81,14 @@ static inline bool dc_dfp_send_en_unlock(struct pd_port *pd_port,
 	pd_port->uvdm_cnt = 3;
 	pd_port->uvdm_wait_resp = true;
 
-	pd_port->uvdm_data[0] = PD_UVDM_HDR(USB_VID_DIRECTCHARGE, cmd);
+	pd_port->uvdm_data[0] = PD_UVDM_HDR(USB_SID_DIRECTCHARGE, cmd);
 	pd_port->uvdm_data[1] = data0;
 	pd_port->uvdm_data[2] = data1;
 
 #ifdef CONFIG_USB_PD_REV30_PPS_SINK
 	if (pd_port->pe_data.dc_pps_mode) {
 		pd_port->uvdm_data[0] = VDO_S(
-			USB_VID_DIRECTCHARGE,
+			USB_SID_DIRECTCHARGE,
 			SVDM_REV20,
 			CMDT_INIT,
 			RTDC_SVDM_PPS_AUTHORIZATION,
@@ -168,27 +168,24 @@ static const char * const dc_dfp_state_name[] = {
 
 void dc_dfp_set_state(struct pd_port *pd_port, uint8_t state)
 {
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
 	pd_port->dc_dfp_state = state;
 
 	if (pd_port->dc_dfp_state < DC_DFP_STATE_NR)
-		DC_DBG("%s\n", dc_dfp_state_name[state]);
+		DC_DBG("%s\r\n", dc_dfp_state_name[state]);
 	else
-		DC_DBG("dc_dfp_stop (%d)\n", state);
+		DC_DBG("dc_dfp_stop (%d)\r\n", state);
 }
 
 bool dc_dfp_start_en_unlock1(struct pd_port *pd_port)
 {
 	uint32_t rn_code[2];
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	rn_code[0] = dc_get_random_code();
 	rn_code[1] = dc_get_random_code();
 	pd_port->dc_pass_code = dc_get_authorization_code(
 			(rn_code[0] & 0xffff) | (rn_code[1] & 0xffff0000));
 
-	DC_DBG("en_unlock1: 0x%x, 0x%x\n", rn_code[0], rn_code[1]);
+	DC_DBG("en_unlock1: 0x%x, 0x%x\r\n", rn_code[0], rn_code[1]);
 
 	dc_dfp_send_en_unlock(
 			pd_port, RTDC_UVDM_EN_UNLOCK, rn_code[0], rn_code[1]);
@@ -205,7 +202,6 @@ bool dc_dfp_start_en_unlock1(struct pd_port *pd_port)
 bool dc_dfp_verify_en_unlock1(struct pd_port *pd_port)
 {
 	uint32_t resp_cmd, expect_resp;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	expect_resp = RTDC_UVDM_RECV_EN_UNLOCK;
 	resp_cmd = PD_UVDM_HDR_CMD(pd_port->uvdm_data[0]);
@@ -219,13 +215,13 @@ bool dc_dfp_verify_en_unlock1(struct pd_port *pd_port)
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 
 	if (resp_cmd != expect_resp) {
-		DC_INFO("en_unlock1: unexpect resp (0x%x)\n", resp_cmd);
+		DC_INFO("en_unlock1: unexpect resp (0x%x)\r\n", resp_cmd);
 		dc_dfp_set_state(pd_port, DC_DFP_ERR_EN_UNLOCK1_FAILED);
 		return false;
 	}
 
 	if (pd_port->dc_pass_code != pd_port->uvdm_data[1]) {
-		DC_INFO("en_unlock1: pass wrong 0x%x 0x%x\n",
+		DC_INFO("en_unlock1: pass wrong 0x%x 0x%x\r\n",
 				pd_port->dc_pass_code, pd_port->uvdm_data[1]);
 		dc_dfp_set_state(pd_port, DC_DFP_ERR_EN_UNLOCK1_FAILED);
 		return false;
@@ -238,12 +234,11 @@ bool dc_dfp_verify_en_unlock1(struct pd_port *pd_port)
 bool dc_dfp_start_en_unlock2(struct pd_port *pd_port)
 {
 	uint32_t rn_code = dc_get_random_code();
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	pd_port->dc_pass_code =
 		dc_get_authorization_code(pd_port->uvdm_data[2]);
 
-	DC_DBG("en_unlock2: 0x%x, 0x%x\n", pd_port->dc_pass_code, rn_code);
+	DC_DBG("en_unlock2: 0x%x, 0x%x\r\n", pd_port->dc_pass_code, rn_code);
 
 	dc_dfp_send_en_unlock(pd_port, RTDC_UVDM_EN_UNLOCK,
 			pd_port->dc_pass_code, rn_code);
@@ -256,7 +251,6 @@ bool dc_dfp_start_en_unlock2(struct pd_port *pd_port)
 bool dc_dfp_verify_en_unlock2(struct pd_port *pd_port)
 {
 	uint32_t resp_cmd, expect_resp;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	expect_resp = RTDC_UVDM_RECV_EN_UNLOCK;
 	resp_cmd = PD_UVDM_HDR_CMD(pd_port->uvdm_data[0]);
@@ -270,13 +264,13 @@ bool dc_dfp_verify_en_unlock2(struct pd_port *pd_port)
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 
 	if (resp_cmd != expect_resp) {
-		DC_INFO("en_unlock2: unexpect resp (0x%x)\n", resp_cmd);
+		DC_INFO("en_unlock2: unexpect resp (0x%x)\r\n", resp_cmd);
 		dc_dfp_set_state(pd_port, DC_DFP_ERR_EN_UNLOCK2_FAILED);
 		return false;
 	}
 
 	if (pd_port->uvdm_data[1] != RTDC_UVDM_EN_UNLOCK_SUCCESS) {
-		DC_INFO("en_unlock2: failed\n");
+		DC_INFO("en_unlock2: failed\r\n");
 		dc_dfp_set_state(pd_port, DC_DFP_ERR_EN_UNLOCK2_FAILED);
 		return false;
 	}
@@ -303,10 +297,6 @@ bool dc_dfp_notify_pe_startup(
 int dc_dfp_notify_pe_ready(struct pd_port *pd_port,
 		struct svdm_svid_data *svid_data)
 {
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-#endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
-
 #ifdef RTDC_TA_EMULATE
 	if (pd_port->data_role == PD_ROLE_DFP && svid_data->exist) {
 		pd_put_tcp_pd_event(pd_port, TCP_DPM_EVT_DR_SWAP_AS_UFP);
@@ -342,13 +332,13 @@ int dc_dfp_notify_pe_ready(struct pd_port *pd_port,
 	}
 
 	if (pd_is_source_support_apdo(pd_port)) {
-		DC_INFO("pps_mode\n");
+		DC_INFO("pps_mode\r\n");
 		pd_port->pe_data.dc_pps_mode = true;
 		return dc_dfp_start_en_unlock1(pd_port);
 	}
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 
-	pd_port->mode_svid = USB_VID_DIRECTCHARGE;
+	pd_port->mode_svid = USB_SID_DIRECTCHARGE;
 	pd_put_tcp_vdm_event(pd_port, TCP_DPM_EVT_DISCOVER_MODES);
 	return 1;
 }
@@ -444,7 +434,7 @@ bool dc_dfp_notify_exit_mode(struct pd_port *pd_port,
 	if (pd_port->dc_dfp_state <= DC_DFP_ENTER_MODE)
 		return false;
 
-	if (svid_data->svid != USB_VID_DIRECTCHARGE)
+	if (svid_data->svid != USB_SID_DIRECTCHARGE)
 		return false;
 
 	dc_dfp_set_state(pd_port, DC_DFP_NONE);
@@ -497,7 +487,7 @@ static inline bool dc_dfp_notify_en_unlock2(struct pd_port *pd_port,
 		return true;
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 
-	tcpci_dc_notify_en_unlock(pd_port->tcpc);
+	tcpci_dc_notify_en_unlock(pd_port->tcpc_dev);
 	return true;
 }
 
@@ -537,7 +527,7 @@ bool dc_ufp_notify_uvdm(struct pd_port *pd_port,
 		{
 			recv_code[0] = pd_port->uvdm_data[1];
 			recv_code[1] = pd_port->uvdm_data[2];
-			DC_INFO("T0: recv_code: 0x%x, 0x%x\n",
+			DC_INFO("T0: recv_code: 0x%x, 0x%x\r\n",
 						recv_code[0], recv_code[1]);
 
 			pass_code = dc_get_authorization_code(
@@ -549,7 +539,7 @@ bool dc_ufp_notify_uvdm(struct pd_port *pd_port,
 			pd_port->dc_pass_code =
 				dc_get_authorization_code(rn_code);
 
-			DC_INFO("T0: reply: 0x%x, 0x%x\n",
+			DC_INFO("T0: reply: 0x%x, 0x%x\r\n",
 				rn_code, pd_port->dc_pass_code);
 
 			reply_cmd[1] = pass_code;
@@ -564,14 +554,14 @@ bool dc_ufp_notify_uvdm(struct pd_port *pd_port,
 		{
 			recv_code[0] = pd_port->uvdm_data[1];
 			recv_code[1] = pd_port->uvdm_data[2];
-			DC_INFO("T1: recv_code: 0x%x, 0x%x\n",
+			DC_INFO("T1: recv_code: 0x%x, 0x%x\r\n",
 				recv_code[0], recv_code[1]);
 
 			if (recv_code[0] != pd_port->dc_pass_code) {
-				DC_INFO("T1: pass_code error\n");
+				DC_INFO("T1: pass_code error\r\n");
 				reply_cmd[1] = 0;
 			} else {
-				DC_INFO("T1: pass_code success\n");
+				DC_INFO("T1: pass_code success\r\n");
 				reply_cmd[1] = 1;
 			}
 
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_dpm_alt_mode_dp.c b/drivers/misc/mediatek/typec/tcpc/pd_dpm_alt_mode_dp.c
index ffac605..38553f3 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_dpm_alt_mode_dp.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_dpm_alt_mode_dp.c
@@ -49,10 +49,10 @@ static inline bool dp_update_dp_connected_one(struct pd_port *pd_port,
 
 	if (dp_local_connected != DPSTS_BOTH_CONNECTED) {
 		valid_connected = DP_CHECK_DP_CONNECTED_MATCH(
-			dp_connected, dp_local_connected);
+			dp_local_connected, dp_connected);
 	} else {
 		valid_connected = true;
-		dp_data->local_status = DP_SELECT_CONNECTED(dp_connected);
+		dp_data->local_status =  DP_SELECT_CONNECTED(dp_connected);
 	}
 
 	return valid_connected;
@@ -60,25 +60,17 @@ static inline bool dp_update_dp_connected_one(struct pd_port *pd_port,
 
 /*
  * If we support ufp_d & dfp_d both, we should decide to use which role.
- * For dfp_u, the dp_connected is invalid, and re-send dp_status.
- * For ufp_u, the dp_connected is valid, and wait for dp_status from dfp_u
- *
- * If we don't support both, the dp_connected always is valid
- *
  */
 
 static inline bool dp_update_dp_connected_both(struct pd_port *pd_port,
-			uint32_t dp_local_connected, bool both_connected_valid)
+			uint32_t dp_connected, uint32_t dp_local_connected)
 {
 	struct dp_data *dp_data = pd_get_dp_data(pd_port);
-	bool valid_connected = true;
 
-	if (dp_local_connected == DPSTS_BOTH_CONNECTED) {
+	if (dp_local_connected == DPSTS_BOTH_CONNECTED)
 		dp_data->local_status = pd_port->dp_second_connected;
-		valid_connected = both_connected_valid;
-	}
 
-	return valid_connected;
+	return true;
 }
 
 /* DP : DFP_U */
@@ -100,14 +92,13 @@ static const char * const dp_dfp_u_state_name[] = {
 void dp_dfp_u_set_state(struct pd_port *pd_port, uint8_t state)
 {
 	struct dp_data *dp_data = pd_get_dp_data(pd_port);
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	dp_data->dfp_u_state = state;
 
 	if (dp_data->dfp_u_state < DP_DFP_U_STATE_NR)
-		DP_DBG("%s\n", dp_dfp_u_state_name[state]);
+		DP_DBG("%s\r\n", dp_dfp_u_state_name[state]);
 	else
-		DP_DBG("dp_dfp_u_stop (%d)\n", state);
+		DP_DBG("dp_dfp_u_stop (%d)\r\n", state);
 }
 
 bool dp_dfp_u_notify_pe_startup(
@@ -126,9 +117,8 @@ int dp_dfp_u_notify_pe_ready(
 	struct pd_port *pd_port, struct svdm_svid_data *svid_data)
 {
 	struct dp_data *dp_data = pd_get_dp_data(pd_port);
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
-	DPM_DBG("%s\n", __func__);
+	DPM_DBG("%s\r\n", __func__);
 
 	if (pd_port->data_role != PD_ROLE_DFP)
 		return 0;
@@ -341,7 +331,7 @@ static inline int eval_dp_match_score(uint32_t local_mode,
 	return score;
 }
 
-static inline uint8_t dp_dfp_u_select_mode(struct pd_port *pd_port,
+static inline uint8_t dp_dfp_u_select_mode(
 	struct dp_data *dp_data, struct svdm_svid_data *svid_data)
 {
 	uint32_t dp_local_mode, dp_remote_mode,
@@ -350,7 +340,6 @@ static inline uint8_t dp_dfp_u_select_mode(struct pd_port *pd_port,
 	int i, j;
 	int match_score, best_match_score = 0;
 	int local_index = -1, remote_index = -1;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	local = &svid_data->local_mode;
 	remote = &svid_data->remote_mode;
@@ -378,11 +367,11 @@ static inline uint8_t dp_dfp_u_select_mode(struct pd_port *pd_port,
 
 #if DP_INFO_ENABLE
 	for (i = 0; i < svid_data->remote_mode.mode_cnt; i++) {
-		DP_INFO("Mode%d=0x%08x\n", i,
+		DP_INFO("Mode%d=0x%08x\r\n", i,
 			svid_data->remote_mode.mode_vdo[i]);
 	}
 
-	DP_INFO("SelectMode:%d\n", remote_index);
+	DP_INFO("SelectMode:%d\r\n", remote_index);
 #endif	/* DP_INFO_ENABLE */
 
 	/*
@@ -398,7 +387,6 @@ bool dp_dfp_u_notify_discover_modes(
 	struct pd_port *pd_port, struct svdm_svid_data *svid_data, bool ack)
 {
 	struct dp_data *dp_data = pd_get_dp_data(pd_port);
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (dp_data->dfp_u_state != DP_DFP_U_DISCOVER_MODES)
 		return false;
@@ -414,11 +402,10 @@ bool dp_dfp_u_notify_discover_modes(
 		return false;
 	}
 
-	pd_port->mode_obj_pos = dp_dfp_u_select_mode(
-		pd_port, dp_data, svid_data);
+	pd_port->mode_obj_pos = dp_dfp_u_select_mode(dp_data, svid_data);
 
 	if (pd_port->mode_obj_pos == 0) {
-		DPM_DBG("Can't find match mode\n");
+		DPM_DBG("Can't find match mode\r\n");
 		dp_dfp_u_set_state(pd_port, DP_DFP_U_ERR_DISCOVER_MODE_CAP);
 		return false;
 	}
@@ -488,11 +475,13 @@ static inline bool dp_dfp_u_select_pin_mode(struct pd_port *pd_port)
 {
 	uint32_t dp_local_connected;
 	uint32_t dp_mode[2], pin_cap[2];
+
 	uint32_t pin_caps, signal;
+
 	struct dp_data *dp_data = pd_get_dp_data(pd_port);
+
 	struct svdm_svid_data *svid_data =
 		dpm_get_svdm_svid_data(pd_port, USB_SID_DISPLAYPORT);
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (svid_data == NULL)
 		return false;
@@ -518,8 +507,8 @@ static inline bool dp_dfp_u_select_pin_mode(struct pd_port *pd_port)
 		return false;
 	}
 
-	PE_DBG("modes=0x%x 0x%x\n", dp_mode[0], dp_mode[1]);
-	PE_DBG("pins=0x%x 0x%x\n", pin_cap[0], pin_cap[1]);
+	PE_DBG("modes=0x%x 0x%x\r\n", dp_mode[0], dp_mode[1]);
+	PE_DBG("pins=0x%x 0x%x\r\n", pin_cap[0], pin_cap[1]);
 
 	pin_caps = pin_cap[0] & pin_cap[1];
 
@@ -565,7 +554,7 @@ void dp_dfp_u_request_dp_configuration(struct pd_port *pd_port)
 		return;
 	}
 
-	tcpci_dp_notify_config_start(pd_port->tcpc);
+	tcpci_dp_notify_config_start(pd_port->tcpc_dev);
 
 	dp_dfp_u_set_state(pd_port, DP_DFP_U_CONFIGURE);
 	pd_put_tcp_vdm_event(pd_port, TCP_DPM_EVT_DP_CONFIG);
@@ -576,7 +565,6 @@ static inline bool dp_dfp_u_update_dp_connected(struct pd_port *pd_port)
 	bool valid_connected = false;
 	uint32_t dp_connected, dp_local_connected;
 	struct dp_data *dp_data = pd_get_dp_data(pd_port);
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	dp_connected = PD_VDO_DPSTS_CONNECT(dp_data->remote_status);
 	dp_local_connected = PD_VDO_DPSTS_CONNECT(dp_data->local_status);
@@ -598,13 +586,15 @@ static inline bool dp_dfp_u_update_dp_connected(struct pd_port *pd_port)
 		break;
 
 	case DPSTS_BOTH_CONNECTED:
-		valid_connected = dp_update_dp_connected_both(
-			pd_port, dp_local_connected, false);
+		dp_update_dp_connected_both(pd_port,
+				dp_connected, dp_local_connected);
 
-		if (!valid_connected) {
-			DP_INFO("BOTH_SEL_ONE\n");
+		if (dp_data->dfp_u_state == DP_DFP_U_STATUS_UPDATE) {
+			DP_INFO("BOTH_SEL_ONE\r\n");
 			pd_put_tcp_vdm_event(pd_port,
 				TCP_DPM_EVT_DP_STATUS_UPDATE);
+		} else {
+			valid_connected = true;
 		}
 		break;
 	}
@@ -616,9 +606,8 @@ bool dp_dfp_u_notify_dp_status_update(struct pd_port *pd_port, bool ack)
 {
 	bool oper_mode = false;
 	bool valid_connected;
-	uint32_t *ptr;
+
 	struct dp_data *dp_data = pd_get_dp_data(pd_port);
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	switch (dp_data->dfp_u_state) {
 	case DP_DFP_U_OPERATION:
@@ -631,7 +620,7 @@ bool dp_dfp_u_notify_dp_status_update(struct pd_port *pd_port, bool ack)
 	}
 
 	if (!ack) {
-		tcpci_dp_notify_status_update_done(tcpc, 0, false);
+		tcpci_dp_notify_status_update_done(pd_port->tcpc_dev, 0, false);
 		dp_dfp_u_set_state(pd_port,
 				DP_DFP_U_ERR_STATUS_UPDATE_NAK_TIMEOUT);
 		return false;
@@ -642,16 +631,12 @@ bool dp_dfp_u_notify_dp_status_update(struct pd_port *pd_port, bool ack)
 		return true;
 	}
 
-	ptr = pd_get_msg_vdm_data_payload(pd_port);
-	if (!ptr)
-		dp_data->remote_status = 0;
-	else
-		dp_data->remote_status = ptr[0];
-	DP_INFO("dp_status: 0x%x\n", dp_data->remote_status);
+	dp_data->remote_status = pd_get_msg_vdm_data_payload(pd_port)[0];
+	DP_INFO("dp_status: 0x%x\r\n", dp_data->remote_status);
 
 	if (oper_mode) {
 		tcpci_dp_notify_status_update_done(
-				tcpc, dp_data->remote_status, ack);
+				pd_port->tcpc_dev, dp_data->remote_status, ack);
 	} else {
 		valid_connected =
 			dp_dfp_u_update_dp_connected(pd_port);
@@ -678,15 +663,14 @@ static inline void dp_ufp_u_auto_update(struct pd_port *pd_port)
 bool dp_dfp_u_notify_dp_configuration(struct pd_port *pd_port, bool ack)
 {
 	struct dp_data *dp_data = pd_get_dp_data(pd_port);
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (ack) {
 		dp_ufp_u_auto_update(pd_port);
 		dp_dfp_u_set_state(pd_port, DP_DFP_U_OPERATION);
 	} else
-		DP_ERR("config failed: 0x%0x\n", dp_data->remote_config);
+		DP_ERR("config failed: 0x%0x\r\n", dp_data->remote_config);
 
-	tcpci_dp_notify_config_done(tcpc,
+	tcpci_dp_notify_config_done(pd_port->tcpc_dev,
 		dp_data->local_config, dp_data->remote_config, ack);
 
 	return true;
@@ -697,16 +681,10 @@ bool dp_dfp_u_notify_attention(struct pd_port *pd_port,
 {
 	bool valid_connected;
 	struct dp_data *dp_data = pd_get_dp_data(pd_port);
-	uint32_t *ptr;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
-	ptr = pd_get_msg_vdm_data_payload(pd_port);
-	if (!ptr)
-		dp_data->remote_status = 0;
-	else
-		dp_data->remote_status = ptr[0];
+	dp_data->remote_status = pd_get_msg_vdm_data_payload(pd_port)[0];
 
-	DP_INFO("dp_status: 0x%x\n", dp_data->remote_status);
+	DP_INFO("dp_status: 0x%x\r\n", dp_data->remote_status);
 
 	switch (dp_data->dfp_u_state) {
 	case DP_DFP_U_WAIT_ATTENTION:
@@ -717,7 +695,7 @@ bool dp_dfp_u_notify_attention(struct pd_port *pd_port,
 		break;
 
 	case DP_DFP_U_OPERATION:
-		tcpci_dp_attention(tcpc, dp_data->remote_status);
+		tcpci_dp_attention(pd_port->tcpc_dev, dp_data->remote_status);
 		break;
 	}
 
@@ -740,14 +718,13 @@ static const char * const dp_ufp_u_state_name[] = {
 static void dp_ufp_u_set_state(struct pd_port *pd_port, uint8_t state)
 {
 	struct dp_data *dp_data = pd_get_dp_data(pd_port);
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	dp_data->ufp_u_state = state;
 
 	if (dp_data->ufp_u_state < DP_UFP_U_STATE_NR)
-		DPM_DBG("%s\n", dp_ufp_u_state_name[state]);
+		DPM_DBG("%s\r\n", dp_ufp_u_state_name[state]);
 	else
-		DPM_DBG("dp_ufp_u_stop\n");
+		DPM_DBG("dp_ufp_u_stop\r\n");
 }
 
 void dp_ufp_u_request_enter_mode(
@@ -777,7 +754,7 @@ void dp_ufp_u_request_exit_mode(
 
 static inline bool dp_ufp_u_update_dp_connected(struct pd_port *pd_port)
 {
-	bool valid_connected = false;
+	bool valid_connected;
 	uint32_t dp_connected, dp_local_connected;
 	struct dp_data *dp_data = pd_get_dp_data(pd_port);
 
@@ -793,10 +770,11 @@ static inline bool dp_ufp_u_update_dp_connected(struct pd_port *pd_port)
 
 	case DPSTS_BOTH_CONNECTED:
 		valid_connected = dp_update_dp_connected_both(
-			pd_port, dp_local_connected, true);
+			pd_port, dp_connected, dp_local_connected);
 		break;
 
 	default:
+		valid_connected = false;
 		break;
 	}
 
@@ -807,13 +785,8 @@ static inline int dp_ufp_u_request_dp_status(struct pd_port *pd_port)
 {
 	bool ack;
 	struct dp_data *dp_data = pd_get_dp_data(pd_port);
-	uint32_t *ptr;
 
-	ptr = pd_get_msg_vdm_data_payload(pd_port);
-	if (!ptr)
-		dp_data->remote_status = 0;
-	else
-		dp_data->remote_status = ptr[0];
+	dp_data->remote_status = pd_get_msg_vdm_data_payload(pd_port)[0];
 
 	switch (dp_data->ufp_u_state) {
 	case DP_UFP_U_WAIT:
@@ -824,7 +797,7 @@ static inline int dp_ufp_u_request_dp_status(struct pd_port *pd_port)
 	case DP_UFP_U_OPERATION:
 		ack = true;
 		tcpci_dp_status_update(
-			pd_port->tcpc, dp_data->remote_status);
+			pd_port->tcpc_dev, dp_data->remote_status);
 		break;
 
 	default:
@@ -836,7 +809,7 @@ static inline int dp_ufp_u_request_dp_status(struct pd_port *pd_port)
 		return pd_reply_svdm_request(pd_port,
 			CMDT_RSP_ACK, 1, &dp_data->local_status);
 	} else {
-		return dpm_vdm_reply_svdm_nak(pd_port);
+		return pd_reply_svdm_request_simply(pd_port, CMDT_RSP_NAK);
 	}
 }
 
@@ -887,16 +860,11 @@ static inline void dp_ufp_u_auto_attention(struct pd_port *pd_port)
 static inline int dp_ufp_u_request_dp_config(struct pd_port *pd_port)
 {
 	bool ack = false;
-	uint32_t dp_config, *ptr;
+	uint32_t dp_config;
 	struct dp_data *dp_data = pd_get_dp_data(pd_port);
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
-	ptr = pd_get_msg_vdm_data_payload(pd_port);
-	if (!ptr)
-		dp_config = 0;
-	else
-		dp_config = ptr[0];
-	DPM_DBG("dp_config: 0x%x\n", dp_config);
+	dp_config = pd_get_msg_vdm_data_payload(pd_port)[0];
+	DPM_DBG("dp_config: 0x%x\r\n", dp_config);
 
 	switch (dp_data->ufp_u_state) {
 	case DP_UFP_U_STARTUP:
@@ -906,14 +874,15 @@ static inline int dp_ufp_u_request_dp_config(struct pd_port *pd_port)
 
 		if (ack) {
 			dp_data->local_config = dp_config;
-			tcpci_dp_configure(tcpc, dp_config);
+			tcpci_dp_configure(pd_port->tcpc_dev, dp_config);
 			dp_ufp_u_auto_attention(pd_port);
 			dp_ufp_u_set_state(pd_port, DP_UFP_U_OPERATION);
 		}
 		break;
 	}
 
-	return dpm_vdm_reply_svdm_request(pd_port, ack);
+	return pd_reply_svdm_request_simply(
+		pd_port, ack ? CMDT_RSP_ACK : CMDT_RSP_NAK);
 }
 
 static inline void dp_ufp_u_send_dp_attention(struct pd_port *pd_port)
@@ -1040,20 +1009,21 @@ bool dp_parse_svid_data(
 	int i = 0;
 
 	np = of_find_node_by_name(
-		pd_port->tcpc->dev.of_node, "displayport");
+		pd_port->tcpc_dev->dev.of_node, "displayport");
 	if (np == NULL) {
+		pd_port->svid_data_cnt = 0;
 		pr_err("%s get displayport data fail\n", __func__);
 		return false;
 	}
 
-	pr_info("dp, svid\n");
+	pr_info("dp, svid\r\n");
 	svid_data->svid = USB_SID_DISPLAYPORT;
 	ufp_np = of_find_node_by_name(np, "ufp_d");
 	dfp_np = of_find_node_by_name(np, "dfp_d");
 
 	if (ufp_np) {
 		pr_info("dp, ufp_np\n");
-		for (i = 0; i < ARRAY_SIZE(supported_dp_pin_modes); i++) {
+		for (i = 0; i < ARRAY_SIZE(supported_dp_pin_modes) - 1; i++) {
 			if (of_property_read_bool(ufp_np,
 				supported_dp_pin_modes[i].prop_name))
 				ufp_d_pin_cap |=
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_dpm_core.c b/drivers/misc/mediatek/typec/tcpc/pd_dpm_core.c
index b95a885..21c4c5a 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_dpm_core.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_dpm_core.c
@@ -61,7 +61,7 @@ static const struct svdm_svid_ops svdm_svid_ops[] = {
 #ifdef CONFIG_USB_PD_RICHTEK_UVDM
 	{
 		.name = "Richtek",
-		.svid = USB_VID_RICHTEK,
+		.svid = USB_SID_RICHTEK,
 
 		.dfp_notify_uvdm = richtek_dfp_notify_uvdm,
 		.ufp_notify_uvdm = richtek_ufp_notify_uvdm,
@@ -74,7 +74,7 @@ static const struct svdm_svid_ops svdm_svid_ops[] = {
 #ifdef CONFIG_USB_PD_ALT_MODE_RTDC
 	{
 		.name = "Direct Charge",
-		.svid = USB_VID_DIRECTCHARGE,
+		.svid = USB_SID_DIRECTCHARGE,
 
 		.dfp_inform_id = dc_dfp_notify_discover_id,
 		.dfp_inform_svids = dc_dfp_notify_discover_svid,
@@ -138,9 +138,6 @@ static void pd_dpm_update_pdos_flags(struct pd_port *pd_port, uint32_t pdo)
 
 		if (pdo & PDO_FIXED_COMM_CAP)
 			dpm_flags |= DPM_FLAGS_PARTNER_USB_COMM;
-
-		if (pdo & PDO_FIXED_SUSPEND)
-			dpm_flags |= DPM_FLAGS_PARTNER_USB_SUSPEND;
 	}
 
 	pd_port->pe_data.dpm_flags = dpm_flags;
@@ -166,20 +163,19 @@ int pd_dpm_send_source_caps(struct pd_port *pd_port)
 {
 	uint8_t i;
 	uint32_t cable_curr = 3000;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	struct pd_port_power_caps *src_cap0 = &pd_port->local_src_cap_default;
 	struct pd_port_power_caps *src_cap1 = &pd_port->local_src_cap;
 
 	if (pd_port->pe_data.power_cable_present) {
 		cable_curr = pd_get_cable_current_limit(pd_port);
-		DPM_DBG("cable_limit: %dmA\n", cable_curr);
+		DPM_DBG("cable_limit: %dmA\r\n", cable_curr);
 	}
 
 	src_cap1->nr = src_cap0->nr;
 	for (i = 0; i < src_cap0->nr; i++) {
 		src_cap1->pdos[i] =
-			pd_reset_pdo_power(tcpc, src_cap0->pdos[i], cable_curr);
+			pd_reset_pdo_power(src_cap0->pdos[i], cable_curr);
 	}
 
 	return pd_send_sop_data_msg(pd_port, PD_DATA_SOURCE_CAP,
@@ -192,13 +188,12 @@ void pd_dpm_inform_cable_id(struct pd_port *pd_port, bool src_startup)
 	struct pe_data *pe_data = &pd_port->pe_data;
 #endif /* CONFIG_USB_PD_REV30 */
 	uint32_t *payload = pd_get_msg_vdm_data_payload(pd_port);
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (payload) {
 		memcpy(pd_port->pe_data.cable_vdos, payload,
 			pd_get_msg_data_size(pd_port));
 
-		DPM_DBG("InformCable, 0x%02x, 0x%02x, 0x%02x, 0x%02x\n",
+		DPM_DBG("InformCable, 0x%02x, 0x%02x, 0x%02x, 0x%02x\r\n",
 				payload[0], payload[1], payload[2], payload[3]);
 
 		dpm_reaction_clear(pd_port, DPM_REACTION_DISCOVER_CABLE);
@@ -225,66 +220,45 @@ static bool dpm_response_request(struct pd_port *pd_port, bool accept)
 
 /* ---- SNK ---- */
 
-static void dpm_build_sink_pdo_info(struct dpm_pdo_info_t *sink_pdo_info,
-		uint8_t type, int request_v, int request_i)
-{
-	sink_pdo_info->type = type;
-
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
-	if (type == DPM_PDO_TYPE_APDO) {
-		request_v = (request_v / 20) * 20;
-		request_i = (request_i / 50) * 50;
-	} else
-#endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
-		request_i = (request_i / 10) * 10;
-
-	sink_pdo_info->vmin = sink_pdo_info->vmax = request_v;
-	sink_pdo_info->ma = request_i;
-	sink_pdo_info->uw = request_v * request_i;
-}
-
 #ifdef CONFIG_USB_PD_REV30_PPS_SINK
-static int pps_request_thread_fn(void *data)
+static int pps_request_thread_fn(void *param)
 {
-	struct tcpc_device *tcpc = data;
-	struct pd_port *pd_port = &tcpc->pd_port;
-	int ret = 0;
 	struct tcp_dpm_event tcp_event = {
 		.event_id = TCP_DPM_EVT_REQUEST_AGAIN,
 	};
+	struct tcpc_device *tcpc = param;
 
 	while (true) {
-		ret = wait_event_interruptible(pd_port->pps_request_wait_que,
-				atomic_read(&pd_port->pps_request) ||
-				kthread_should_stop());
-		if (kthread_should_stop() || ret) {
-			dev_notice(&tcpc->dev, "%s exits(%d)\n", __func__, ret);
+		wait_event_interruptible(
+			tcpc->pd_port.pps_request_event_queue,
+			atomic_read(&tcpc->pd_port.pps_request_event));
+
+		if (kthread_should_stop())
 			break;
-		}
-		while (!wait_event_timeout(pd_port->pps_request_wait_que,
-					!atomic_read(&pd_port->pps_request) ||
-					kthread_should_stop(),
-					msecs_to_jiffies(7*1000))) {
+
+		atomic_set(&tcpc->pd_port.pps_request_event, 0);
+		do {
+			msleep(7*1000);
 			pd_put_deferred_tcp_event(tcpc, &tcp_event);
-		}
+		} while (tcpc->pd_port.pps_request_stop != true);
 	}
-
 	return 0;
 }
 
 void pd_dpm_start_pps_request_thread(struct pd_port *pd_port, bool en)
 {
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
+	/* There are different versions in the linxu driver */
 
 	DPM_INFO("pps_thread (%s)\n", en ? "start" : "end");
 	if (en) {
-		__pm_stay_awake(pd_port->pps_request_wake_lock);
-		atomic_set(&pd_port->pps_request, true);
-		wake_up(&pd_port->pps_request_wait_que);
+		__pm_stay_awake(&pd_port->pps_request_wake_lock);
+		pd_port->pps_request_stop = false;
+		atomic_set(&pd_port->pps_request_event, 1);
+		wake_up_interruptible(&pd_port->pps_request_event_queue);
 	} else {
-		atomic_set(&pd_port->pps_request, false);
-		wake_up(&pd_port->pps_request_wait_que);
-		__pm_relax(pd_port->pps_request_wake_lock);
+		pd_port->pps_request_stop = true;
+		atomic_set(&pd_port->pps_request_event, 1);
+		__pm_relax(&pd_port->pps_request_wake_lock);
 	}
 }
 
@@ -292,13 +266,11 @@ static bool dpm_build_request_info_apdo(
 		struct pd_port *pd_port, struct dpm_rdo_info_t *req_info,
 		struct pd_port_power_caps *src_cap, uint8_t charging_policy)
 {
-	struct dpm_pdo_info_t sink_pdo_info;
-
-	dpm_build_sink_pdo_info(&sink_pdo_info, DPM_PDO_TYPE_APDO,
-			pd_port->request_v_apdo, pd_port->request_i_apdo);
+	uint32_t snk_pdo = PDO_FIXED(
+			pd_port->request_v_apdo, pd_port->request_i_apdo, 0);
 
 	return dpm_find_match_req_info(req_info,
-			&sink_pdo_info, src_cap->nr, src_cap->pdos,
+			snk_pdo, src_cap->nr, src_cap->pdos,
 			-1, charging_policy);
 }
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
@@ -309,16 +281,14 @@ static bool dpm_build_request_info_pdo(
 {
 	bool find_cap = false;
 	int i, max_uw = -1;
-	struct dpm_pdo_info_t sink_pdo_info;
+
 	struct pd_port_power_caps *snk_cap = &pd_port->local_snk_cap;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	for (i = 0; i < snk_cap->nr; i++) {
-		DPM_DBG("EvaSinkCap%d\n", i+1);
-		dpm_extract_pdo_info(snk_cap->pdos[i], &sink_pdo_info);
+		DPM_DBG("EvaSinkCap%d\r\n", i+1);
 
 		find_cap = dpm_find_match_req_info(req_info,
-				&sink_pdo_info, src_cap->nr, src_cap->pdos,
+				snk_cap->pdos[i], src_cap->nr, src_cap->pdos,
 				max_uw, charging_policy);
 
 		if (find_cap) {
@@ -327,7 +297,7 @@ static bool dpm_build_request_info_pdo(
 			else
 				max_uw = req_info->vmax * req_info->oper_ma;
 
-			DPM_DBG("Find SrcCap%d(%s):%d mw\n",
+			DPM_DBG("Find SrcCap%d(%s):%d mw\r\n",
 					req_info->pos, req_info->mismatch ?
 					"Mismatch" : "Match", max_uw/1000);
 			pd_port->pe_data.local_selected_cap = i + 1;
@@ -343,14 +313,13 @@ static bool dpm_build_request_info(
 	int i;
 	uint8_t charging_policy = pd_port->dpm_charging_policy;
 	struct pd_port_power_caps *src_cap = &pd_port->pe_data.remote_src_cap;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	memset(req_info, 0, sizeof(struct dpm_rdo_info_t));
 
-	DPM_INFO("Policy=0x%X\n", charging_policy);
+	DPM_INFO("Policy=0x%X\r\n", charging_policy);
 
 	for (i = 0; i < src_cap->nr; i++)
-		DPM_DBG("SrcCap%d: 0x%08x\n", i+1, src_cap->pdos[i]);
+		DPM_DBG("SrcCap%d: 0x%08x\r\n", i+1, src_cap->pdos[i]);
 
 #ifdef CONFIG_USB_PD_REV30_PPS_SINK
 	if ((charging_policy & DPM_CHARGING_POLICY_MASK)
@@ -456,7 +425,6 @@ static inline void dpm_update_request(
 	struct pd_port *pd_port, struct dpm_rdo_info_t *req_info)
 {
 	uint32_t flags = 0;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 #ifdef CONFIG_USB_PD_REV30_PPS_SINK
 	pd_port->request_apdo_new = false;
@@ -474,7 +442,7 @@ static inline void dpm_update_request(
 	if (req_info->mismatch) {
 		flags |= RDO_CAP_MISMATCH;
 		pd_port->cap_miss_match |= 0x1;
-		DPM_INFO("cap miss match case\n");
+		DPM_INFO("cap miss match case\r\n");
 	}
 
 	pd_port->request_v_new = req_info->vmax;
@@ -494,46 +462,36 @@ int pd_dpm_update_tcp_request(struct pd_port *pd_port,
 		struct tcp_dpm_pd_request *pd_req)
 {
 	bool find_cap = false;
-	uint8_t type = DPM_PDO_TYPE_FIXED;
 	struct dpm_rdo_info_t req_info;
-	struct dpm_pdo_info_t sink_pdo_info;
 	uint8_t charging_policy = pd_port->dpm_charging_policy;
 	struct pd_port_power_caps *src_cap = &pd_port->pe_data.remote_src_cap;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
+	uint32_t snk_pdo = PDO_FIXED(pd_req->mv, pd_req->ma, 0);
 
 	memset(&req_info, 0, sizeof(struct dpm_rdo_info_t));
 
-	DPM_DBG("charging_policy=0x%X\n", charging_policy);
-
-#ifdef CONFIG_USB_PD_REV30_PPS_SINK
-	if ((charging_policy & DPM_CHARGING_POLICY_MASK)
-		== DPM_CHARGING_POLICY_PPS)
-		type = DPM_PDO_TYPE_APDO;
-#endif	/*CONFIG_USB_PD_REV30_PPS_SINK */
-
-	dpm_build_sink_pdo_info(&sink_pdo_info, type, pd_req->mv, pd_req->ma);
+	DPM_DBG("charging_policy=0x%X\r\n", charging_policy);
 
 #ifdef CONFIG_USB_PD_REV30_PPS_SINK
 	if (pd_port->request_apdo &&
-		(sink_pdo_info.vmin == pd_port->request_v) &&
-		(sink_pdo_info.ma == pd_port->request_i))
+		(pd_req->mv == pd_port->request_v) &&
+		(pd_req->ma == pd_port->request_i))
 		return TCP_DPM_RET_DENIED_REPEAT_REQUEST;
 #endif	/*CONFIG_USB_PD_REV30_PPS_SINK */
 
 	find_cap = dpm_find_match_req_info(&req_info,
-			&sink_pdo_info, src_cap->nr, src_cap->pdos,
+			snk_pdo, src_cap->nr, src_cap->pdos,
 			-1, charging_policy);
 
 	if (!find_cap) {
-		DPM_INFO("Can't find match_cap\n");
+		DPM_INFO("Can't find match_cap\r\n");
 		return TCP_DPM_RET_DENIED_INVALID_REQUEST;
 	}
 
 #ifdef CONFIG_USB_PD_REV30_PPS_SINK
 	if ((charging_policy & DPM_CHARGING_POLICY_MASK)
 		== DPM_CHARGING_POLICY_PPS) {
-		pd_port->request_v_apdo = sink_pdo_info.vmin;
-		pd_port->request_i_apdo = sink_pdo_info.ma;
+		pd_port->request_v_apdo = pd_req->mv;
+		pd_port->request_i_apdo = pd_req->ma;
 	}
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 
@@ -547,14 +505,13 @@ int pd_dpm_update_tcp_request_ex(struct pd_port *pd_port,
 	struct dpm_pdo_info_t source;
 	struct dpm_rdo_info_t req_info;
 	struct pd_port_power_caps *src_cap = &pd_port->pe_data.remote_src_cap;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (pd_req->pos > src_cap->nr)
 		return false;
 
 #ifdef CONFIG_USB_PD_REV30_PPS_SINK
 	if (pd_port->dpm_charging_policy == DPM_CHARGING_POLICY_PPS) {
-		DPM_INFO("Reject tcp_rqeuest_ex if charging_policy=pps\n");
+		DPM_INFO("Reject tcp_rqeuest_ex if charging_policy=pps\r\n");
 		return TCP_DPM_RET_DENIED_INVALID_REQUEST;
 	}
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
@@ -587,16 +544,16 @@ int pd_dpm_update_tcp_request_again(struct pd_port *pd_port)
 {
 	bool find_cap = false;
 	int sink_nr, source_nr;
+
 	struct dpm_rdo_info_t req_info;
 	struct pd_port_power_caps *snk_cap = &pd_port->local_snk_cap;
 	struct pd_port_power_caps *src_cap = &pd_port->pe_data.remote_src_cap;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	sink_nr = snk_cap->nr;
 	source_nr = src_cap->nr;
 
 	if ((source_nr <= 0) || (sink_nr <= 0)) {
-		DPM_INFO("SrcNR or SnkNR = 0\n");
+		DPM_INFO("SrcNR or SnkNR = 0\r\n");
 		return TCP_DPM_RET_DENIED_INVALID_REQUEST;
 	}
 
@@ -604,10 +561,10 @@ int pd_dpm_update_tcp_request_again(struct pd_port *pd_port)
 
 	/* If we can't find any cap to use, choose default setting */
 	if (!find_cap) {
-		DPM_INFO("Can't find any SrcCap\n");
+		DPM_INFO("Can't find any SrcCap\r\n");
 		dpm_build_default_request_info(pd_port, &req_info);
 	} else
-		DPM_INFO("Select SrcCap%d\n", req_info.pos);
+		DPM_INFO("Select SrcCap%d\r\n", req_info.pos);
 
 	dpm_update_request(pd_port, &req_info);
 	return TCP_DPM_RET_SUCCESS;
@@ -619,14 +576,13 @@ void pd_dpm_snk_evaluate_caps(struct pd_port *pd_port)
 	struct dpm_rdo_info_t req_info;
 	struct pd_port_power_caps *snk_cap = &pd_port->local_snk_cap;
 	struct pd_port_power_caps *src_cap = &pd_port->pe_data.remote_src_cap;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	PD_BUG_ON(pd_get_msg_data_payload(pd_port) == NULL);
 
 	pd_dpm_dr_inform_source_cap(pd_port);
 
 	if ((src_cap->nr <= 0) || (snk_cap->nr <= 0)) {
-		DPM_INFO("SrcNR or SnkNR = 0\n");
+		DPM_INFO("SrcNR or SnkNR = 0\r\n");
 		return;
 	}
 
@@ -634,10 +590,10 @@ void pd_dpm_snk_evaluate_caps(struct pd_port *pd_port)
 
 	/* If we can't find any cap to use, choose default setting */
 	if (!find_cap) {
-		DPM_INFO("Can't find any SrcCap\n");
+		DPM_INFO("Can't find any SrcCap\r\n");
 		dpm_build_default_request_info(pd_port, &req_info);
 	} else
-		DPM_INFO("Select SrcCap%d\n", req_info.pos);
+		DPM_INFO("Select SrcCap%d\r\n", req_info.pos);
 
 	dpm_update_request(pd_port, &req_info);
 
@@ -661,20 +617,18 @@ void pd_dpm_snk_standby_power(struct pd_port *pd_port)
 
 	uint8_t type;
 	int ma = -1;
-	int standby_curr = 2500000 / max(pd_port->request_v,
-					 pd_port->request_v_new);
+	int standby_curr = 2500000 / pd_port->request_v;
 
 #ifdef CONFIG_USB_PD_VCONN_SAFE5V_ONLY
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	bool vconn_highv_prot;
 	struct pe_data *pe_data = &pd_port->pe_data;
-	bool vconn_highv_prot = pd_port->request_v_new > 5000;
 
-	if (!pe_data->vconn_highv_prot && vconn_highv_prot &&
-		tcpc->tcpc_flags & TCPC_FLAGS_VCONN_SAFE5V_ONLY) {
-		PE_INFO("VC_HIGHV_PROT: %d\n", vconn_highv_prot);
-		pe_data->vconn_highv_prot_role = pd_port->vconn_role;
-		pd_set_vconn(pd_port, PD_ROLE_VCONN_OFF);
-		pe_data->vconn_highv_prot = vconn_highv_prot;
+	vconn_highv_prot = pd_port->request_v_new > 5000;
+	if (vconn_highv_prot != pe_data->vconn_highv_prot) {
+		PE_INFO("VC_HIGHV_PROT: %d\r\n", vconn_highv_prot);
+
+		if (vconn_highv_prot)
+			tcpci_set_vconn(pd_port->tcpc_dev, false);
 	}
 #endif	/* CONFIG_USB_PD_VCONN_SAFE5V_ONLY */
 
@@ -708,11 +662,11 @@ void pd_dpm_snk_standby_power(struct pd_port *pd_port)
 
 	if (ma >= 0) {
 		tcpci_sink_vbus(
-			pd_port->tcpc, type, pd_port->request_v_new, ma);
+			pd_port->tcpc_dev, type, pd_port->request_v, ma);
 	}
 #else
 #ifdef CONFIG_USB_PD_SNK_GOTOMIN
-	tcpci_sink_vbus(pd_port->tcpc, TCP_VBUS_CTRL_REQUEST,
+	tcpci_sink_vbus(pd_port->tcpc_dev, TCP_VBUS_CTRL_REQUEST,
 		pd_port->request_v, pd_port->request_i_new);
 #endif	/* CONFIG_USB_PD_SNK_GOTOMIN */
 #endif	/* CONFIG_USB_PD_SNK_STANDBY_POWER */
@@ -720,7 +674,7 @@ void pd_dpm_snk_standby_power(struct pd_port *pd_port)
 
 void pd_dpm_snk_transition_power(struct pd_port *pd_port)
 {
-	tcpci_sink_vbus(pd_port->tcpc, TCP_VBUS_CTRL_REQUEST,
+	tcpci_sink_vbus(pd_port->tcpc_dev, TCP_VBUS_CTRL_REQUEST,
 		pd_port->request_v_new, pd_port->request_i_new);
 
 	pd_port->request_v = pd_port->request_v_new;
@@ -759,10 +713,8 @@ void pd_dpm_snk_hard_reset(struct pd_port *pd_port)
 
 	if (!ignore_hreset) {
 		tcpci_sink_vbus(
-			pd_port->tcpc, TCP_VBUS_CTRL_HRESET, mv, ma);
+			pd_port->tcpc_dev, TCP_VBUS_CTRL_HRESET, mv, ma);
 	}
-
-	pd_put_pe_event(pd_port, PD_PE_POWER_ROLE_AT_DEFAULT);
 }
 
 /* ---- SRC ---- */
@@ -775,12 +727,11 @@ static inline bool dpm_evaluate_request(
 	uint32_t op_curr, max_curr;
 	struct dpm_pdo_info_t src_info;
 	struct pd_port_power_caps *src_cap = &pd_port->local_src_cap;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	pd_port->pe_data.dpm_flags &= (~DPM_FLAGS_PARTNER_MISMATCH);
 
 	if ((rdo_pos == 0) || (rdo_pos > src_cap->nr)) {
-		DPM_INFO("RequestPos Wrong (%d)\n", rdo_pos);
+		DPM_INFO("RequestPos Wrong (%d)\r\n", rdo_pos);
 		return false;
 	}
 
@@ -790,16 +741,16 @@ static inline bool dpm_evaluate_request(
 	pd_extract_rdo_power(rdo, pdo, &op_curr, &max_curr);
 
 	if (src_info.ma < op_curr) {
-		DPM_INFO("src_i (%d) < op_i (%d)\n", src_info.ma, op_curr);
+		DPM_INFO("src_i (%d) < op_i (%d)\r\n", src_info.ma, op_curr);
 		return false;
 	}
 
 	if (rdo & RDO_CAP_MISMATCH) {
 		/* TODO: handle it later */
-		DPM_INFO("CAP_MISMATCH\n");
+		DPM_INFO("CAP_MISMATCH\r\n");
 		pd_port->pe_data.dpm_flags |= DPM_FLAGS_PARTNER_MISMATCH;
 	} else if (src_info.ma < max_curr) {
-		DPM_INFO("src_i (%d) < max_i (%d)\n", src_info.ma, max_curr);
+		DPM_INFO("src_i (%d) < max_i (%d)\r\n", src_info.ma, max_curr);
 		return false;
 	}
 
@@ -810,7 +761,7 @@ static inline bool dpm_evaluate_request(
 		sink_v = RDO_APDO_EXTRACT_OP_MV(rdo);
 
 		if ((sink_v < src_info.vmin) || (sink_v > src_info.vmax)) {
-			DPM_INFO("sink_v (%d) not in src_v (%d~%d)\n",
+			DPM_INFO("sink_v (%d) not in src_v (%d~%d)\r\n",
 				sink_v, src_info.vmin, src_info.vmax);
 			return false;
 		}
@@ -835,16 +786,16 @@ void pd_dpm_src_evaluate_request(struct pd_port *pd_port)
 {
 	uint32_t rdo;
 	uint8_t rdo_pos;
+
 	struct pe_data *pe_data;
 	uint32_t *payload = pd_get_msg_data_payload(pd_port);
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	PD_BUG_ON(payload == NULL);
 
 	rdo = payload[0];
 	rdo_pos = RDO_POS(rdo);
 
-	DPM_INFO("RequestCap%d\n", rdo_pos);
+	DPM_INFO("RequestCap%d\r\n", rdo_pos);
 
 	pe_data = &pd_port->pe_data;
 
@@ -872,19 +823,16 @@ void pd_dpm_src_transition_power(struct pd_port *pd_port)
 	pd_enable_vbus_stable_detection(pd_port);
 
 #ifdef CONFIG_USB_PD_SRC_HIGHCAP_POWER
-	if (pd_port->request_v > pd_port->request_v_new) {
-		mutex_lock(&pd_port->tcpc->access_lock);
+	if (pd_port->request_v > pd_port->request_v_new)
 		tcpci_enable_force_discharge(
-			pd_port->tcpc, true, pd_port->request_v_new);
-		mutex_unlock(&pd_port->tcpc->access_lock);
-	}
+			pd_port->tcpc_dev, pd_port->request_v_new);
 #endif	/* CONFIG_USB_PD_SRC_HIGHCAP_POWER */
 
-	tcpci_source_vbus(pd_port->tcpc, TCP_VBUS_CTRL_REQUEST,
+	tcpci_source_vbus(pd_port->tcpc_dev, TCP_VBUS_CTRL_REQUEST,
 		pd_port->request_v_new, pd_port->request_i_new);
 
 	if (pd_port->request_v == pd_port->request_v_new)
-		pd_put_vbus_stable_event(pd_port->tcpc);
+		pd_put_vbus_stable_event(pd_port->tcpc_dev);
 #if CONFIG_USB_PD_VBUS_STABLE_TOUT
 	else
 		pd_enable_timer(pd_port, PD_TIMER_VBUS_STABLE);
@@ -896,7 +844,7 @@ void pd_dpm_src_transition_power(struct pd_port *pd_port)
 
 void pd_dpm_src_hard_reset(struct pd_port *pd_port)
 {
-	tcpci_source_vbus(pd_port->tcpc,
+	tcpci_source_vbus(pd_port->tcpc_dev,
 		TCP_VBUS_CTRL_HRESET, TCPC_VBUS_SOURCE_0V, 0);
 	pd_enable_vbus_safe0v_detection(pd_port);
 }
@@ -907,9 +855,8 @@ static inline bool dpm_ufp_update_svid_data_enter_mode(
 	struct pd_port *pd_port, uint16_t svid, uint8_t ops)
 {
 	struct svdm_svid_data *svid_data;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
-	DPM_DBG("EnterMode (svid0x%04x, ops:%d)\n", svid, ops);
+	DPM_DBG("EnterMode (svid0x%04x, ops:%d)\r\n", svid, ops);
 
 	svid_data = dpm_get_svdm_svid_data(pd_port, svid);
 
@@ -928,7 +875,8 @@ static inline bool dpm_ufp_update_svid_data_enter_mode(
 
 	svdm_ufp_request_enter_mode(pd_port, svid, ops);
 
-	tcpci_enter_mode(tcpc, svid, ops, svid_data->local_mode.mode_vdo[ops]);
+	tcpci_enter_mode(pd_port->tcpc_dev,
+		svid, ops, svid_data->local_mode.mode_vdo[ops]);
 	return true;
 }
 
@@ -938,9 +886,8 @@ static inline bool dpm_ufp_update_svid_data_exit_mode(
 	uint8_t i;
 	bool modal_operation;
 	struct svdm_svid_data *svid_data;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
-	DPM_DBG("ExitMode (svid0x%04x, mode:%d)\n", svid, ops);
+	DPM_DBG("ExitMode (svid0x%04x, mode:%d)\r\n", svid, ops);
 
 	svid_data = dpm_get_svdm_svid_data(pd_port, svid);
 
@@ -966,7 +913,7 @@ static inline bool dpm_ufp_update_svid_data_exit_mode(
 		pd_port->pe_data.modal_operation = modal_operation;
 
 		svdm_ufp_request_exit_mode(pd_port, svid, ops);
-		tcpci_exit_mode(pd_port->tcpc, svid);
+		tcpci_exit_mode(pd_port->tcpc_dev, svid);
 		return true;
 	}
 
@@ -978,14 +925,15 @@ static inline bool dpm_ufp_update_svid_data_exit_mode(
 
 static int dpm_vdm_ufp_response_id(struct pd_port *pd_port)
 {
+#ifdef CONFIG_USB_PD_REV30
 	if (pd_check_rev30(pd_port))
 		pd_port->id_vdos[0] = pd_port->id_header;
 	else
 		pd_port->id_vdos[0] = VDO_IDH_PD20(pd_port->id_header);
+#endif	/* CONFIG_USB_PD_REV30 */
 
-	return pd_reply_svdm_request(pd_port, CMDT_RSP_ACK,
-		pd_check_rev30(pd_port) ? pd_port->id_vdo_nr : 3,
-		pd_port->id_vdos);
+	return pd_reply_svdm_request(pd_port,
+		CMDT_RSP_ACK, pd_port->id_vdo_nr, pd_port->id_vdos);
 }
 
 static int dpm_ufp_response_svids(struct pd_port *pd_port)
@@ -1107,14 +1055,14 @@ static inline void dpm_dfp_update_svid_data_exist(
 {
 	uint8_t k;
 	struct svdm_svid_data *svid_data;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
+
 #ifdef CONFIG_USB_PD_KEEP_SVIDS
 	struct svdm_svid_list *list = &pd_port->pe_data.remote_svid_list;
 
 	if (list->cnt < VDO_MAX_SVID_NR)
 		list->svids[list->cnt++] = svid;
 	else
-		DPM_INFO("ERR:SVIDCNT\n");
+		DPM_INFO("ERR:SVIDCNT\r\n");
 #endif	/* CONFIG_USB_PD_KEEP_SVIDS */
 
 	for (k = 0; k < pd_port->svid_data_cnt; k++) {
@@ -1131,11 +1079,10 @@ static inline void dpm_dfp_update_svid_data_modes(struct pd_port *pd_port,
 {
 	uint8_t i;
 	struct svdm_svid_data *svid_data;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
-	DPM_DBG("InformMode (0x%04x:%d):\n", svid, count);
+	DPM_DBG("InformMode (0x%04x:%d): \r\n", svid, count);
 	for (i = 0; i < count; i++)
-		DPM_DBG("Mode[%d]: 0x%08x\n", i, mode_list[i]);
+		DPM_DBG("Mode[%d]: 0x%08x\r\n", i, mode_list[i]);
 
 	svid_data = dpm_get_svdm_svid_data(pd_port, svid);
 	if (svid_data == NULL)
@@ -1153,9 +1100,8 @@ static inline void dpm_dfp_update_svid_enter_mode(
 	struct pd_port *pd_port, uint16_t svid, uint8_t ops)
 {
 	struct svdm_svid_data *svid_data;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
-	DPM_DBG("EnterMode (svid0x%04x, mode:%d)\n", svid, ops);
+	DPM_DBG("EnterMode (svid0x%04x, mode:%d)\r\n", svid, ops);
 
 	svid_data = dpm_get_svdm_svid_data(pd_port, svid);
 	if (svid_data == NULL)
@@ -1164,7 +1110,7 @@ static inline void dpm_dfp_update_svid_enter_mode(
 	svid_data->active_mode = ops;
 	pd_port->pe_data.modal_operation = true;
 
-	tcpci_enter_mode(tcpc,
+	tcpci_enter_mode(pd_port->tcpc_dev,
 		svid_data->svid, ops, svid_data->remote_mode.mode_vdo[ops]);
 }
 
@@ -1174,9 +1120,8 @@ static inline void dpm_dfp_update_svid_data_exit_mode(
 	uint8_t i;
 	bool modal_operation;
 	struct svdm_svid_data *svid_data;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
-	DPM_DBG("ExitMode (svid0x%04x, mode:%d)\n", svid, ops);
+	DPM_DBG("ExitMode (svid0x%04x, mode:%d)\r\n", svid, ops);
 
 	svid_data = dpm_get_svdm_svid_data(pd_port, svid);
 	if (svid_data == NULL)
@@ -1197,7 +1142,7 @@ static inline void dpm_dfp_update_svid_data_exit_mode(
 		}
 
 		pd_port->pe_data.modal_operation = modal_operation;
-		tcpci_exit_mode(tcpc, svid);
+		tcpci_exit_mode(pd_port->tcpc_dev, svid);
 	}
 }
 
@@ -1207,18 +1152,9 @@ static inline void dpm_dfp_update_svid_data_exit_mode(
 void pd_dpm_dfp_inform_id(struct pd_port *pd_port, bool ack)
 {
 	uint32_t *payload = pd_get_msg_vdm_data_payload(pd_port);
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
-	VDM_STATE_DPM_INFORMED(pd_port);
-
-	if (!payload) {
-		dpm_reaction_clear(pd_port, DPM_REACTION_DISCOVER_ID |
-					    DPM_REACTION_DISCOVER_SVID);
-		return;
-	}
 
 	if (ack) {
-		DPM_DBG("InformID, 0x%02x, 0x%02x, 0x%02x, 0x%02x\n",
+		DPM_DBG("InformID, 0x%02x, 0x%02x, 0x%02x, 0x%02x\r\n",
 				payload[0], payload[1], payload[2], payload[3]);
 
 		dpm_dfp_update_partner_id(pd_port, payload);
@@ -1227,30 +1163,28 @@ void pd_dpm_dfp_inform_id(struct pd_port *pd_port, bool ack)
 	if (!pd_port->pe_data.vdm_discard_retry_flag) {
 		/*
 		 * For PD compliance test,
-		 * If device doesn't reply discoverID
-		 * or doesn't support modal operation,
+		 * If device doesn't reply discoverID,
 		 * then don't send discoverSVID
 		 */
-		if (!ack || !(payload[0] & PD_IDH_MODAL_SUPPORT))
+		if (!ack)
 			dpm_reaction_clear(pd_port, DPM_REACTION_DISCOVER_SVID);
-		else
-			dpm_reaction_set(pd_port, DPM_REACTION_DISCOVER_SVID);
 
 		svdm_dfp_inform_id(pd_port, ack);
 		dpm_reaction_clear(pd_port, DPM_REACTION_DISCOVER_ID);
 	}
+
+	VDM_STATE_DPM_INFORMED(pd_port);
 }
 
 static inline int dpm_dfp_consume_svids(
 	struct pd_port *pd_port, uint32_t *svid_list, uint8_t count)
 {
 	bool discover_again = true;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	uint8_t i, j;
 	uint16_t svid[2];
 
-	DPM_DBG("InformSVID (%d):\n", count);
+	DPM_DBG("InformSVID (%d): \r\n", count);
 
 	if (count < 6)
 		discover_again = false;
@@ -1259,7 +1193,7 @@ static inline int dpm_dfp_consume_svids(
 		svid[0] = PD_VDO_SVID_SVID0(svid_list[i]);
 		svid[1] = PD_VDO_SVID_SVID1(svid_list[i]);
 
-		DPM_DBG("svid[%d]: 0x%04x 0x%04x\n", i, svid[0], svid[1]);
+		DPM_DBG("svid[%d]: 0x%04x 0x%04x\r\n", i, svid[0], svid[1]);
 
 		for (j = 0; j < 2; j++) {
 			if (svid[j] == 0) {
@@ -1272,7 +1206,7 @@ static inline int dpm_dfp_consume_svids(
 	}
 
 	if (discover_again) {
-		DPM_DBG("DiscoverSVID Again\n");
+		DPM_DBG("DiscoverSVID Again\r\n");
 		pd_put_tcp_vdm_event(pd_port, TCP_DPM_EVT_DISCOVER_SVIDS);
 		return 1;
 	}
@@ -1285,13 +1219,10 @@ void pd_dpm_dfp_inform_svids(struct pd_port *pd_port, bool ack)
 	uint8_t count;
 	uint32_t *svid_list;
 
-	VDM_STATE_DPM_INFORMED(pd_port);
-
 	if (ack) {
 		count = pd_get_msg_vdm_data_count(pd_port);
 		svid_list = pd_get_msg_vdm_data_payload(pd_port);
-		if (!svid_list)
-			return;
+
 		if (dpm_dfp_consume_svids(pd_port, svid_list, count))
 			return;
 	}
@@ -1300,6 +1231,8 @@ void pd_dpm_dfp_inform_svids(struct pd_port *pd_port, bool ack)
 		svdm_dfp_inform_svids(pd_port, ack);
 		dpm_reaction_clear(pd_port, DPM_REACTION_DISCOVER_SVID);
 	}
+
+	VDM_STATE_DPM_INFORMED(pd_port);
 }
 
 void pd_dpm_dfp_inform_modes(struct pd_port *pd_port, bool ack)
@@ -1308,21 +1241,19 @@ void pd_dpm_dfp_inform_modes(struct pd_port *pd_port, bool ack)
 	uint16_t svid = 0;
 	uint32_t *payload;
 	uint16_t expected_svid = pd_port->mode_svid;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (ack) {
 		svid = dpm_vdm_get_svid(pd_port);
 
 		if (svid != expected_svid) {
 			ack = false;
-			DPM_INFO("Not expected SVID (0x%04x, 0x%04x)\n",
+			DPM_INFO("Not expected SVID (0x%04x, 0x%04x)\r\n",
 				svid, expected_svid);
 		} else {
 			count = pd_get_msg_vdm_data_count(pd_port);
 			payload = pd_get_msg_vdm_data_payload(pd_port);
-			if (payload)
-				dpm_dfp_update_svid_data_modes(
-					pd_port, svid, payload, count);
+			dpm_dfp_update_svid_data_modes(
+				pd_port, svid, payload, count);
 		}
 	}
 
@@ -1335,7 +1266,6 @@ void pd_dpm_dfp_inform_enter_mode(struct pd_port *pd_port, bool ack)
 	uint8_t ops = 0;
 	uint16_t svid = 0;
 	uint16_t expected_svid = pd_port->mode_svid;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (ack) {
 		ops = dpm_vdm_get_ops(pd_port);
@@ -1344,7 +1274,7 @@ void pd_dpm_dfp_inform_enter_mode(struct pd_port *pd_port, bool ack)
 		/* TODO: check ops later ?! */
 		if (svid != expected_svid) {
 			ack = false;
-			DPM_INFO("Not expected SVID (0x%04x, 0x%04x)\n",
+			DPM_INFO("Not expected SVID (0x%04x, 0x%04x)\r\n",
 				svid, expected_svid);
 		} else {
 			dpm_dfp_update_svid_enter_mode(pd_port, svid, ops);
@@ -1359,12 +1289,12 @@ void pd_dpm_dfp_inform_exit_mode(struct pd_port *pd_port)
 {
 	uint8_t ops = dpm_vdm_get_ops(pd_port);
 	uint16_t svid = dpm_vdm_get_svid(pd_port);
+
 	uint8_t expected_ops = pd_port->mode_obj_pos;
 	uint16_t expected_svid = pd_port->mode_svid;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if ((expected_svid != svid) || (expected_ops != ops))
-		DPM_DBG("expected_svid & ops wrong\n");
+		DPM_DBG("expected_svid & ops wrong\r\n");
 
 	dpm_dfp_update_svid_data_exit_mode(
 		pd_port, expected_svid, expected_ops);
@@ -1378,10 +1308,10 @@ void pd_dpm_dfp_inform_attention(struct pd_port *pd_port)
 #if DPM_DBG_ENABLE
 	uint8_t ops = dpm_vdm_get_ops(pd_port);
 #endif
+
 	uint16_t svid = dpm_vdm_get_svid(pd_port);
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
-	DPM_DBG("Attention (svid0x%04x, mode:%d)\n", svid, ops);
+	DPM_DBG("Attention (svid0x%04x, mode:%d)\r\n", svid, ops);
 
 	svdm_dfp_inform_attention(pd_port, svid);
 	VDM_STATE_DPM_INFORMED(pd_port);
@@ -1411,7 +1341,7 @@ void pd_dpm_ufp_recv_uvdm(struct pd_port *pd_port)
 		else
 			VDM_STATE_DPM_INFORMED(pd_port);
 
-		tcpci_notify_uvdm(pd_port->tcpc, true);
+		tcpci_notify_uvdm(pd_port->tcpc_dev, true);
 	} else {
 		pd_put_dpm_event(pd_port, PD_DPM_NOT_SUPPORT);
 		VDM_STATE_DPM_INFORMED(pd_port);
@@ -1424,7 +1354,7 @@ void pd_dpm_dfp_send_uvdm(struct pd_port *pd_port)
 	pd_port->uvdm_svid = PD_VDO_VID(pd_port->uvdm_data[0]);
 
 	if (pd_port->uvdm_wait_resp)
-		VDM_STATE_RESPONSE_CMD(pd_port, PD_TIMER_UVDM_RESPONSE);
+		pd_enable_vdm_state_timer(pd_port, PD_TIMER_UVDM_RESPONSE);
 }
 
 void pd_dpm_dfp_inform_uvdm(struct pd_port *pd_port, bool ack)
@@ -1433,14 +1363,13 @@ void pd_dpm_dfp_inform_uvdm(struct pd_port *pd_port, bool ack)
 	uint16_t expected_svid = pd_port->uvdm_svid;
 	struct svdm_svid_data *svid_data =
 		dpm_get_svdm_svid_data(pd_port, expected_svid);
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (ack && pd_port->uvdm_wait_resp) {
 		svid = dpm_vdm_get_svid(pd_port);
 
 		if (svid != expected_svid) {
 			ack = false;
-			DPM_INFO("Not expected SVID (0x%04x, 0x%04x)\n",
+			DPM_INFO("Not expected SVID (0x%04x, 0x%04x)\r\n",
 				svid, expected_svid);
 		} else {
 			pd_port->uvdm_cnt = pd_get_msg_data_count(pd_port);
@@ -1456,7 +1385,7 @@ void pd_dpm_dfp_inform_uvdm(struct pd_port *pd_port, bool ack)
 				pd_port, svid_data, ack);
 	}
 
-	tcpci_notify_uvdm(tcpc, ack);
+	tcpci_notify_uvdm(pd_port->tcpc_dev, ack);
 	pd_notify_tcp_vdm_event_2nd_result(pd_port,
 		ack ? TCP_DPM_RET_VDM_ACK : TCP_DPM_RET_VDM_NAK);
 	VDM_STATE_DPM_INFORMED(pd_port);
@@ -1464,10 +1393,6 @@ void pd_dpm_dfp_inform_uvdm(struct pd_port *pd_port, bool ack)
 
 #endif	/* CONFIG_USB_PD_CUSTOM_VDM */
 
-void pd_dpm_ufp_send_svdm_nak(struct pd_port *pd_port)
-{
-	dpm_vdm_reply_svdm_nak(pd_port);
-}
 
 /*
  * DRP : Inform Source/Sink Cap
@@ -1620,14 +1545,14 @@ void pd_dpm_prs_evaluate_swap(struct pd_port *pd_port, uint8_t role)
 	int good_power;
 	bool sink, accept = true;
 
-	bool check_src = (pd_port->dpm_caps & DPM_CAP_PR_SWAP_CHECK_GP_SRC) ?
-		true : false;
-	bool check_snk = (pd_port->dpm_caps & DPM_CAP_PR_SWAP_CHECK_GP_SNK) ?
-		true : false;
+	bool check_src =
+		(pd_port->dpm_caps & DPM_CAP_PR_SWAP_CHECK_GP_SRC) ? 1 : 0;
+	bool check_snk =
+		(pd_port->dpm_caps & DPM_CAP_PR_SWAP_CHECK_GP_SNK) ? 1 : 0;
 
 #ifdef CONFIG_USB_PD_SRC_REJECT_PR_SWAP_IF_GOOD_PW
 	bool check_ext =
-		(pd_port->dpm_caps & DPM_CAP_CHECK_EXT_POWER) ? true : false;
+		(pd_port->dpm_caps & DPM_CAP_CHECK_EXT_POWER) ? 1 : 0;
 
 	if (check_ext)
 		check_src = true;
@@ -1660,7 +1585,7 @@ void pd_dpm_prs_evaluate_swap(struct pd_port *pd_port, uint8_t role)
 void pd_dpm_prs_turn_off_power_sink(struct pd_port *pd_port)
 {
 	/* iSnkSwapStdby : 2.5mA */
-	tcpci_sink_vbus(pd_port->tcpc,
+	tcpci_sink_vbus(pd_port->tcpc_dev,
 		TCP_VBUS_CTRL_PR_SWAP, TCPC_VBUS_SINK_0V, 0);
 }
 
@@ -1668,7 +1593,7 @@ void pd_dpm_prs_enable_power_source(struct pd_port *pd_port, bool en)
 {
 	int vbus_level = en ? TCPC_VBUS_SOURCE_5V : TCPC_VBUS_SOURCE_0V;
 
-	tcpci_source_vbus(pd_port->tcpc,
+	tcpci_source_vbus(pd_port->tcpc_dev,
 		TCP_VBUS_CTRL_PR_SWAP, vbus_level, -1);
 
 	if (en)
@@ -1701,7 +1626,7 @@ void pd_dpm_vcs_evaluate_swap(struct pd_port *pd_port)
 	bool accept = true;
 
 #ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc = pd_port->tcpc_dev;
 
 	/* Reject it if we don't want supply vconn */
 	if ((!pd_port->vconn_role) &&
@@ -1743,12 +1668,11 @@ void pd_dpm_vcs_enable_vconn(struct pd_port *pd_port, uint8_t role)
 void pd_dpm_inform_source_cap_ext(struct pd_port *pd_port)
 {
 	struct pd_source_cap_ext *scedb;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (dpm_check_ext_msg_event(pd_port, PD_EXT_SOURCE_CAP_EXT)) {
 		scedb = pd_get_msg_data_payload(pd_port);
-		DPM_INFO2("vid=0x%04x, pid=0x%04x\n", scedb->vid, scedb->pid);
-		DPM_INFO2("fw_ver=0x%02x, hw_ver=0x%02x\n",
+		DPM_INFO2("vid=0x%04x, pid=0x%04x\r\n", scedb->vid, scedb->pid);
+		DPM_INFO2("fw_ver=0x%02x, hw_ver=0x%02x\r\n",
 			scedb->fw_ver, scedb->hw_ver);
 
 		dpm_reaction_clear(pd_port,
@@ -1767,7 +1691,7 @@ int pd_dpm_send_source_cap_ext(struct pd_port *pd_port)
 
 #ifdef CONFIG_USB_PD_REV30_BAT_CAP_LOCAL
 
-static const struct pd_battery_capabilities c_invalid_bcdb = {
+const struct pd_battery_capabilities c_invalid_bcdb = {
 	0, 0, 0, 0, PD_BCDB_BAT_TYPE_INVALID
 };
 
@@ -1775,23 +1699,23 @@ int pd_dpm_send_battery_cap(struct pd_port *pd_port)
 {
 	struct pd_battery_info *bat_info;
 	const struct pd_battery_capabilities *bcdb;
+
 	struct pd_get_battery_capabilities *gbcdb =
 		pd_get_msg_data_payload(pd_port);
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
-	DPM_INFO2("bat_ref=%d\n", gbcdb->bat_cap_ref);
+	DPM_INFO2("bat_ref=%d\r\n", gbcdb->bat_cap_ref);
 
 	bat_info = pd_get_battery_info(pd_port, gbcdb->bat_cap_ref);
 
 	if (bat_info != NULL) {
 		tcpci_notify_request_bat_info(
-			tcpc, gbcdb->bat_cap_ref);
+			pd_port->tcpc_dev, gbcdb->bat_cap_ref);
 		bcdb = &bat_info->bat_cap;
 	} else
 		bcdb = &c_invalid_bcdb;
 
 	return pd_send_sop_ext_msg(pd_port, PD_EXT_BAT_CAP,
-		PD_BCDB_SIZE, bcdb);
+		PD_BCDB_SIZE,  bcdb);
 }
 #endif	/* CONFIG_USB_PD_REV30_BAT_CAP_LOCAL */
 
@@ -1799,11 +1723,10 @@ int pd_dpm_send_battery_cap(struct pd_port *pd_port)
 void pd_dpm_inform_battery_cap(struct pd_port *pd_port)
 {
 	struct pd_battery_capabilities *bcdb;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (dpm_check_ext_msg_event(pd_port, PD_EXT_BAT_CAP)) {
 		bcdb = pd_get_msg_data_payload(pd_port);
-		DPM_INFO2("vid=0x%04x, pid=0x%04x\n",
+		DPM_INFO2("vid=0x%04x, pid=0x%04x\r\n",
 			bcdb->vid, bcdb->pid);
 	}
 }
@@ -1811,24 +1734,24 @@ void pd_dpm_inform_battery_cap(struct pd_port *pd_port)
 
 #ifdef CONFIG_USB_PD_REV30_BAT_STATUS_LOCAL
 
-static const uint32_t c_invalid_bsdo =
+const uint32_t c_invalid_bsdo =
 	BSDO(0xffff, BSDO_BAT_INFO_INVALID_REF);
 
 int pd_dpm_send_battery_status(struct pd_port *pd_port)
 {
 	const uint32_t *bsdo;
 	struct pd_battery_info *bat_info;
+
 	struct pd_get_battery_status *gbsdb =
 		pd_get_msg_data_payload(pd_port);
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
-	DPM_INFO2("bat_ref=%d\n", gbsdb->bat_status_ref);
+	DPM_INFO2("bat_ref=%d\r\n", gbsdb->bat_status_ref);
 
 	bat_info = pd_get_battery_info(pd_port, gbsdb->bat_status_ref);
 
 	if (bat_info != NULL) {
 		tcpci_notify_request_bat_info(
-			tcpc, gbsdb->bat_status_ref);
+			pd_port->tcpc_dev, gbsdb->bat_status_ref);
 		bsdo = &bat_info->bat_status;
 	} else
 		bsdo = &c_invalid_bsdo;
@@ -1847,20 +1770,19 @@ int pd_dpm_send_battery_status(struct pd_port *pd_port)
 void pd_dpm_inform_battery_status(struct pd_port *pd_port)
 {
 	uint32_t *payload;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (dpm_check_data_msg_event(pd_port, PD_DATA_BAT_STATUS)) {
 		payload = pd_get_msg_data_payload(pd_port);
-		DPM_INFO2("0x%08x\n", payload[0]);
+		DPM_INFO2("0x%08x\r\n", payload[0]);
 	}
 }
 #endif	/* CONFIG_USB_PD_REV30_BAT_STATUS_REMOTE */
 
-static const struct pd_manufacturer_info c_invalid_mfrs = {
-	.vid = 0xFFFF, .pid = 0, .mfrs_string = "Not Supported",
-};
 
 #ifdef CONFIG_USB_PD_REV30_MFRS_INFO_LOCAL
+
+const struct pd_manufacturer_info c_invalid_mfrs = {0};
+
 int pd_dpm_send_mfrs_info(struct pd_port *pd_port)
 {
 	uint8_t len = 0;
@@ -1882,9 +1804,7 @@ int pd_dpm_send_mfrs_info(struct pd_port *pd_port)
 	if (midb == NULL)
 		midb = &c_invalid_mfrs;
 
-	len = strnlen((char *)midb->mfrs_string, sizeof(midb->mfrs_string));
-	if (len < sizeof(midb->mfrs_string))
-		len++;
+	len = strlen((char *)midb->mfrs_string);
 	return pd_send_sop_ext_msg(pd_port, PD_EXT_MFR_INFO,
 		PD_MIDB_MIN_SIZE + len, midb);
 }
@@ -1894,11 +1814,10 @@ int pd_dpm_send_mfrs_info(struct pd_port *pd_port)
 void pd_dpm_inform_mfrs_info(struct pd_port *pd_port)
 {
 	struct pd_manufacturer_info *midb;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (dpm_check_ext_msg_event(pd_port, PD_EXT_MFR_INFO)) {
 		midb = pd_get_msg_data_payload(pd_port);
-		DPM_INFO2("vid=0x%x, pid=0x%x\n", midb->vid, midb->pid);
+		DPM_INFO2("vid=0x%x, pid=0x%x\r\n", midb->vid, midb->pid);
 	}
 }
 #endif	/* CONFIG_USB_PD_REV30_MFRS_INFO_REMOTE */
@@ -1908,11 +1827,10 @@ void pd_dpm_inform_mfrs_info(struct pd_port *pd_port)
 void pd_dpm_inform_country_codes(struct pd_port *pd_port)
 {
 	struct pd_country_codes *ccdb;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (dpm_check_ext_msg_event(pd_port, PD_EXT_COUNTRY_CODES)) {
 		ccdb = pd_get_msg_data_payload(pd_port);
-		DPM_INFO2("len=%d, country_code[0]=0x%04x\n",
+		DPM_INFO2("len=%d, country_code[0]=0x%04x\r\n",
 			ccdb->length, ccdb->country_code[0]);
 	}
 }
@@ -1940,11 +1858,10 @@ int pd_dpm_send_country_codes(struct pd_port *pd_port)
 void pd_dpm_inform_country_info(struct pd_port *pd_port)
 {
 	struct pd_country_info *cidb;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (dpm_check_ext_msg_event(pd_port, PD_EXT_COUNTRY_INFO)) {
 		cidb = pd_get_msg_data_payload(pd_port);
-		DPM_INFO2("cc=0x%04x, ci=%d\n",
+		DPM_INFO2("cc=0x%04x, ci=%d\r\n",
 			cidb->country_code, cidb->country_special_data[0]);
 	}
 }
@@ -1982,13 +1899,12 @@ int pd_dpm_send_country_info(struct pd_port *pd_port)
 void pd_dpm_inform_alert(struct pd_port *pd_port)
 {
 	uint32_t *data = pd_get_msg_data_payload(pd_port);
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
-	DPM_INFO("inform_alert:0x%08x\n", data[0]);
+	DPM_INFO("inform_alert:0x%08x\r\n", data[0]);
 
 	pd_port->pe_data.pd_traffic_idle = false;
 	pd_port->pe_data.remote_alert = data[0];
-	tcpci_notify_alert(pd_port->tcpc, data[0]);
+	tcpci_notify_alert(pd_port->tcpc_dev, data[0]);
 }
 #endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
 
@@ -1996,10 +1912,9 @@ void pd_dpm_inform_alert(struct pd_port *pd_port)
 int pd_dpm_send_alert(struct pd_port *pd_port)
 {
 	uint32_t ado = pd_port->pe_data.local_alert;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	pd_port->pe_data.local_alert = 0;
-	DPM_INFO("send_alert:0x%08x\n", ado);
+	DPM_INFO("send_alert:0x%08x\r\n", ado);
 
 	return pd_send_sop_data_msg(pd_port, PD_DATA_ALERT,
 		PD_ADO_SIZE, &ado);
@@ -2010,16 +1925,15 @@ int pd_dpm_send_alert(struct pd_port *pd_port)
 void pd_dpm_inform_status(struct pd_port *pd_port)
 {
 	struct pd_status *sdb;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (dpm_check_ext_msg_event(pd_port, PD_EXT_STATUS)) {
 		sdb = pd_get_msg_data_payload(pd_port);
 		DPM_INFO2("Temp=%d, IN=0x%x, BAT_IN=0x%x, EVT=0x%x, PTF=0x%x\n",
 			sdb->internal_temp, sdb->present_input,
-			sdb->present_battery_input, sdb->event_flags,
+			sdb->present_battey_input, sdb->event_flags,
 			PD_STATUS_TEMP_PTF(sdb->temp_status));
 
-		tcpci_notify_status(tcpc, sdb);
+		tcpci_notify_status(pd_port->tcpc_dev, sdb);
 	}
 }
 #endif /* CONFIG_USB_PD_REV30_STATUS_REMOTE */
@@ -2030,14 +1944,14 @@ int pd_dpm_send_status(struct pd_port *pd_port)
 	struct pd_status sdb;
 	struct pe_data *pe_data = &pd_port->pe_data;
 
-	memset(&sdb, 0, PD_SDB_SIZE);
+	memset(&sdb, 0, sizeof(struct pd_status));
 
 	sdb.present_input = pd_port->pd_status_present_in;
 
 #ifdef CONFIG_USB_PD_REV30_BAT_INFO
 	if (sdb.present_input &
 		PD_STATUS_INPUT_INT_POWER_BAT) {
-		sdb.present_battery_input = pd_port->pd_status_bat_in;
+		sdb.present_battey_input = pd_port->pd_status_bat_in;
 	}
 #endif	/* CONFIG_USB_PD_REV30_BAT_INFO */
 
@@ -2072,11 +1986,10 @@ int pd_dpm_send_status(struct pd_port *pd_port)
 void pd_dpm_inform_pps_status(struct pd_port *pd_port)
 {
 	struct pd_pps_status_raw *ppssdb;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (dpm_check_ext_msg_event(pd_port, PD_EXT_PPS_STATUS)) {
 		ppssdb = pd_get_msg_data_payload(pd_port);
-		DPM_INFO2("mv=%d, ma=%d\n",
+		DPM_INFO2("mv=%d, ma=%d\r\n",
 			PD_PPS_GET_OUTPUT_MV(ppssdb->output_vol_raw),
 			PD_PPS_GET_OUTPUT_MA(ppssdb->output_curr_raw));
 	}
@@ -2097,13 +2010,13 @@ void pd_dpm_inform_not_support(struct pd_port *pd_port)
 void pd_dpm_dynamic_enable_vconn(struct pd_port *pd_port)
 {
 #ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
-	if (tcpc->tcpc_vconn_supply <= TCPC_VCONN_SUPPLY_ALWAYS)
+	if (tcpc_dev->tcpc_vconn_supply <= TCPC_VCONN_SUPPLY_ALWAYS)
 		return;
 
 	if (pd_port->vconn_role == PD_ROLE_VCONN_DYNAMIC_OFF) {
-		DPM_INFO2("DynamicVCEn\n");
+		DPM_INFO2("DynamicVCEn\r\n");
 		pd_set_vconn(pd_port, PD_ROLE_VCONN_DYNAMIC_ON);
 	}
 #endif	/* CONFIG_TCPC_VCONN_SUPPLY_MODE */
@@ -2113,7 +2026,7 @@ void pd_dpm_dynamic_disable_vconn(struct pd_port *pd_port)
 {
 #ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
 	bool keep_vconn;
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc = pd_port->tcpc_dev;
 
 	if (!pd_port->vconn_role)
 		return;
@@ -2137,7 +2050,7 @@ void pd_dpm_dynamic_disable_vconn(struct pd_port *pd_port)
 		return;
 
 	if (pd_port->vconn_role != PD_ROLE_VCONN_DYNAMIC_OFF) {
-		DPM_INFO2("DynamicVCDis\n");
+		DPM_INFO2("DynamicVCDis\r\n");
 		pd_set_vconn(pd_port, PD_ROLE_VCONN_DYNAMIC_OFF);
 	}
 #endif	/* CONFIG_TCPC_VCONN_SUPPLY_MODE */
@@ -2193,8 +2106,6 @@ int pd_dpm_notify_pe_startup(struct pd_port *pd_port)
 #else
 	if (pd_port->dpm_caps & DPM_CAP_ATTEMP_DISCOVER_ID)
 		reactions |= DPM_REACTION_DISCOVER_ID;
-	if (pd_port->dpm_caps & DPM_CAP_ATTEMP_DISCOVER_SVID)
-		reactions |= DPM_REACTION_DISCOVER_SVID;
 #endif	/* CONFIG_USB_PD_ATTEMP_ENTER_MODE */
 
 #ifdef CONFIG_USB_PD_REV30
@@ -2229,8 +2140,9 @@ int pd_dpm_notify_pe_hardreset(struct pd_port *pd_port)
 	pe_data->dpm_svdm_retry_cnt++;
 
 #ifdef CONFIG_USB_PD_ATTEMP_ENTER_MODE
-	dpm_reaction_set(pd_port, DPM_REACTION_DISCOVER_ID |
-		DPM_REACTION_DISCOVER_SVID);
+		dpm_reaction_set(pd_port,
+			DPM_REACTION_DISCOVER_ID |
+			DPM_REACTION_DISCOVER_SVID);
 #endif	/* CONFIG_USB_PD_ATTEMP_ENTER_MODE */
 
 	svdm_notify_pe_startup(pd_port);
@@ -2245,7 +2157,6 @@ static inline bool dpm_register_svdm_ops(struct pd_port *pd_port,
 	struct svdm_svid_data *svid_data, const struct svdm_svid_ops *ops)
 {
 	bool ret = true;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (ops->parse_svid_data)
 		ret = ops->parse_svid_data(pd_port, svid_data);
@@ -2253,7 +2164,7 @@ static inline bool dpm_register_svdm_ops(struct pd_port *pd_port,
 	if (ret) {
 		svid_data->ops = ops;
 		svid_data->svid = ops->svid;
-		DPM_DBG("register_svdm: 0x%x\n", ops->svid);
+		DPM_DBG("register_svdm: 0x%x\r\n", ops->svid);
 	}
 
 	return ret;
@@ -2265,6 +2176,9 @@ struct svdm_svid_data *dpm_get_svdm_svid_data(
 	uint8_t i;
 	struct svdm_svid_data *svid_data;
 
+	if (!(pd_port->id_vdos[0] & PD_IDH_MODAL_SUPPORT))
+		return NULL;
+
 	for (i = 0; i < pd_port->svid_data_cnt; i++) {
 		svid_data = &pd_port->svid_data[i];
 		if (svid_data->svid == svid)
@@ -2313,9 +2227,8 @@ int pd_dpm_core_init(struct pd_port *pd_port)
 	int i, j;
 	bool ret;
 	uint8_t svid_ops_nr = ARRAY_SIZE(svdm_svid_ops);
-	struct tcpc_device *tcpc = pd_port->tcpc;
 
-	pd_port->svid_data = devm_kzalloc(&tcpc->dev,
+	pd_port->svid_data = devm_kzalloc(&pd_port->tcpc_dev->dev,
 		sizeof(struct svdm_svid_data) * svid_ops_nr, GFP_KERNEL);
 
 	if (!pd_port->svid_data)
@@ -2332,13 +2245,16 @@ int pd_dpm_core_init(struct pd_port *pd_port)
 	pd_port->svid_data_cnt = j;
 
 #ifdef CONFIG_USB_PD_REV30
-	pd_port->pps_request_wake_lock =
-		wakeup_source_register(&tcpc->dev, "pd_pps_request_wake_lock");
-	init_waitqueue_head(&pd_port->pps_request_wait_que);
-	atomic_set(&pd_port->pps_request, false);
-	pd_port->pps_request_task = kthread_run(pps_request_thread_fn, tcpc,
-						"pps_request_%s",
-						tcpc->desc.name);
+	wakeup_source_init(&pd_port->pps_request_wake_lock,
+		"pd_pps_request_wakelock");
+
+	pd_port->pps_request_task = kthread_create(pps_request_thread_fn,
+		pd_port->tcpc_dev, "pps_request_task_%s",
+		dev_name(&pd_port->tcpc_dev->dev));
+	init_waitqueue_head(&pd_port->pps_request_event_queue);
+	pd_port->pps_request_stop = true;
+	atomic_set(&pd_port->pps_request_event, 0);
+	wake_up_process(pd_port->pps_request_task);
 #endif /* CONFIG_USB_PD_REV30 */
 
 	return 0;
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_dpm_pdo_select.c b/drivers/misc/mediatek/typec/tcpc/pd_dpm_pdo_select.c
index aa5ce10..dae2f2b 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_dpm_pdo_select.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_dpm_pdo_select.c
@@ -195,9 +195,9 @@ static inline bool dpm_is_valid_pdo_pair(struct dpm_pdo_info_t *sink,
 		return false;
 
 	if (policy & DPM_CHARGING_POLICY_IGNORE_MISMATCH_CURR)
-		return true;
+		return sink->ma <= source->ma;
 
-	return sink->ma <= source->ma;
+	return true;
 }
 
 static bool dpm_select_pdo_from_max_power(
@@ -228,10 +228,10 @@ static bool dpm_select_pdo_from_max_power(
 	if ((!overload) && (uw == select_info->max_uw)) {
 		if (select_info->policy &
 			DPM_CHARGING_POLICY_PREFER_LOW_VOLTAGE)
-			overload = (source->vmax < select_info->cur_mv);
+			overload |= (source->vmax < select_info->cur_mv);
 		else if (select_info->policy &
 			DPM_CHARGING_POLICY_PREFER_HIGH_VOLTAGE)
-			overload = (source->vmax > select_info->cur_mv);
+			overload |= (source->vmax > select_info->cur_mv);
 	}
 
 	if (overload) {
@@ -256,7 +256,7 @@ static bool dpm_select_pdo_from_pps(
 	int uw, diff_mv;
 	const int tolerance = 300;	/* 5900 * 5% */
 
-	if (sink->type != DPM_PDO_TYPE_APDO ||
+	if (sink->type != DPM_PDO_TYPE_FIXED ||
 			source->type != DPM_PDO_TYPE_APDO)
 		return false;
 
@@ -269,7 +269,7 @@ static bool dpm_select_pdo_from_pps(
 	if (sink->vmin < source->vmin)
 		return false;
 
-	if (!(select_info->policy & DPM_CHARGING_POLICY_IGNORE_MISMATCH_CURR)) {
+	if (select_info->policy & DPM_CHARGING_POLICY_IGNORE_MISMATCH_CURR) {
 		if (source->ma < sink->ma)
 			return false;
 	}
@@ -291,8 +291,8 @@ static bool dpm_select_pdo_from_pps(
 	if (overload) {
 		select_info->max_uw = uw;
 		select_info->cur_mv = diff_mv;
-		return true;
-	}
+	return true;
+}
 
 	return false;
 }
@@ -307,14 +307,16 @@ typedef bool (*dpm_select_pdo_fun)(
 	struct dpm_pdo_info_t *sink, struct dpm_pdo_info_t *source);
 
 bool dpm_find_match_req_info(struct dpm_rdo_info_t *req_info,
-		struct dpm_pdo_info_t *sink, int cnt, uint32_t *src_pdos,
+		uint32_t snk_pdo, int cnt, uint32_t *src_pdos,
 		int min_uw, uint32_t policy)
 {
 	int i;
 	struct dpm_select_info_t select;
-	struct dpm_pdo_info_t source;
+	struct dpm_pdo_info_t sink, source;
 	dpm_select_pdo_fun select_pdo_fun;
 
+	dpm_extract_pdo_info(snk_pdo, &sink);
+
 	select.pos = 0;
 	select.cur_mv = 0;
 	select.max_uw = min_uw;
@@ -349,7 +351,7 @@ bool dpm_find_match_req_info(struct dpm_rdo_info_t *req_info,
 	for (i = 0; i < cnt; i++) {
 		dpm_extract_pdo_info(src_pdos[i], &source);
 
-		if (select_pdo_fun(&select, sink, &source))
+		if (select_pdo_fun(&select, &sink, &source))
 			select.pos = i+1;
 	}
 
@@ -361,23 +363,23 @@ bool dpm_find_match_req_info(struct dpm_rdo_info_t *req_info,
 		req_info->vmax = source.vmax;
 		req_info->vmin = source.vmin;
 
-		if (sink->type == DPM_PDO_TYPE_BAT)
-			req_info->mismatch = select.max_uw < sink->uw;
+		if (sink.type == DPM_PDO_TYPE_BAT)
+			req_info->mismatch = select.max_uw < sink.uw;
 		else
-			req_info->mismatch = source.ma < sink->ma;
+			req_info->mismatch = source.ma < sink.ma;
 
 		if (source.type == DPM_PDO_TYPE_BAT) {
-			req_info->max_uw = sink->uw;
+			req_info->max_uw = sink.uw;
 			req_info->oper_uw = select.max_uw;
 		} else {
-			req_info->max_ma = sink->ma;
-			req_info->oper_ma = MIN(sink->ma, source.ma);
+			req_info->max_ma = sink.ma;
+			req_info->oper_ma = MIN(sink.ma, source.ma);
 		}
 
 #ifdef CONFIG_USB_PD_REV30_PPS_SINK
 		if (source.type == DPM_PDO_TYPE_APDO) {
-			req_info->vmax = sink->vmax;
-			req_info->vmin = sink->vmin;
+			req_info->vmax = sink.vmax;
+			req_info->vmin = sink.vmin;
 		}
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_dpm_reaction.c b/drivers/misc/mediatek/typec/tcpc/pd_dpm_reaction.c
index 77b35cb..5eea65b 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_dpm_reaction.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_dpm_reaction.c
@@ -41,9 +41,7 @@
 #ifdef CONFIG_USB_PD_UFP_FLOW_DELAY
 static uint8_t dpm_reaction_ufp_flow_delay(struct pd_port *pd_port)
 {
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
-	DPM_INFO("UFP Delay\n");
+	DPM_INFO("UFP Delay\r\n");
 	pd_restart_timer(pd_port, PD_TIMER_UFP_FLOW_DELAY);
 	return DPM_READY_REACTION_BUSY;
 }
@@ -52,9 +50,7 @@ static uint8_t dpm_reaction_ufp_flow_delay(struct pd_port *pd_port)
 #ifdef CONFIG_USB_PD_DFP_FLOW_DELAY
 static uint8_t dpm_reaction_dfp_flow_delay(struct pd_port *pd_port)
 {
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
-	DPM_INFO("DFP Delay\n");
+	DPM_INFO("DFP Delay\r\n");
 	pd_restart_timer(pd_port, PD_TIMER_DFP_FLOW_DELAY);
 	return DPM_READY_REACTION_BUSY;
 }
@@ -63,10 +59,8 @@ static uint8_t dpm_reaction_dfp_flow_delay(struct pd_port *pd_port)
 #ifdef CONFIG_USB_PD_VCONN_STABLE_DELAY
 static uint8_t dpm_reaction_vconn_stable_delay(struct pd_port *pd_port)
 {
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
 	if (pd_port->vconn_role == PD_ROLE_VCONN_DYNAMIC_ON) {
-		DPM_INFO("VStable Delay\n");
+		DPM_INFO("VStable Delay\r\n");
 		return DPM_READY_REACTION_BUSY;
 	}
 
@@ -179,12 +173,14 @@ static uint8_t dpm_reaction_request_vconn_source(struct pd_port *pd_port)
 		return 0;
 
 #ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
-	if (pd_port->tcpc->tcpc_vconn_supply == TCPC_VCONN_SUPPLY_STARTUP)
+	if (pd_port->tcpc_dev->tcpc_vconn_supply == TCPC_VCONN_SUPPLY_STARTUP)
 		return_vconn = false;
 #endif	/* CONFIG_TCPC_VCONN_SUPPLY_MODE */
 
+#ifdef CONFIG_USB_PD_REV30
 	if (pd_check_rev30(pd_port))
 		return_vconn = false;
+#endif	/* CONFIG_USB_PD_REV30 */
 
 	if (return_vconn)
 		dpm_reaction_set(pd_port, DPM_REACTION_RETURN_VCONN_SRC);
@@ -213,10 +209,8 @@ static uint8_t pd_dpm_reaction_discover_cable(struct pd_port *pd_port)
 #ifdef CONFIG_USB_PD_DISCOVER_CABLE_RETURN_VCONN
 static uint8_t dpm_reaction_return_vconn_source(struct pd_port *pd_port)
 {
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
 	if (pd_port->vconn_role) {
-		DPM_DBG("VconnReturn\n");
+		DPM_DBG("VconnReturn\r\n");
 		return TCP_DPM_EVT_VCONN_SWAP_OFF;
 	}
 
@@ -365,18 +359,22 @@ static uint8_t dpm_reaction_handle_alert(struct pd_port *pd_port)
 static inline uint8_t dpm_get_pd_connect_state(struct pd_port *pd_port)
 {
 	if (pd_port->power_role == PD_ROLE_SOURCE) {
+#ifdef CONFIG_USB_PD_REV30
 		if (pd_check_rev30(pd_port))
 			return PD_CONNECT_PE_READY_SRC_PD30;
+#endif     /* CONFIG_USB_PD_REV30 */
 
 		return PD_CONNECT_PE_READY_SRC;
 	}
 
+#ifdef CONFIG_USB_PD_REV30
 	if (pd_check_rev30(pd_port)) {
 		if (pd_is_source_support_apdo(pd_port))
 			return PD_CONNECT_PE_READY_SNK_APDO;
 
 		return PD_CONNECT_PE_READY_SNK_PD30;
 	}
+#endif     /* CONFIG_USB_PD_REV30 */
 
 	return PD_CONNECT_PE_READY_SNK;
 }
@@ -384,15 +382,17 @@ static inline uint8_t dpm_get_pd_connect_state(struct pd_port *pd_port)
 static inline void dpm_check_vconn_highv_prot(struct pd_port *pd_port)
 {
 #ifdef CONFIG_USB_PD_VCONN_SAFE5V_ONLY
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	bool vconn_highv_prot;
 	struct pe_data *pe_data = &pd_port->pe_data;
-	bool vconn_highv_prot = pd_port->request_v_new > 5000;
 
-	if (pe_data->vconn_highv_prot && !vconn_highv_prot &&
-		tcpc->tcpc_flags & TCPC_FLAGS_VCONN_SAFE5V_ONLY) {
-		DPM_INFO("VC_HIGHV_PROT: %d\n", vconn_highv_prot);
+	vconn_highv_prot = pd_port->request_v_new > 5000;
+	if (vconn_highv_prot != pe_data->vconn_highv_prot) {
+		DPM_INFO("VC_HIGHV_PROT: %d\r\n", vconn_highv_prot);
+
 		pe_data->vconn_highv_prot = vconn_highv_prot;
-		pd_set_vconn(pd_port, pe_data->vconn_highv_prot_role);
+
+		if (!vconn_highv_prot)
+			pd_set_vconn(pd_port, pd_port->vconn_role);
 	}
 #endif	/* CONFIG_USB_PD_VCONN_SAFE5V_ONLY */
 }
@@ -400,13 +400,12 @@ static inline void dpm_check_vconn_highv_prot(struct pd_port *pd_port)
 static uint8_t dpm_reaction_update_pe_ready(struct pd_port *pd_port)
 {
 	uint8_t state;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (!pd_port->pe_data.pe_ready) {
-		DPM_INFO("PE_READY\n");
+		DPM_INFO("PE_READY\r\n");
 		pd_port->pe_data.pe_ready = true;
 #ifdef CONFIG_DUAL_ROLE_USB_INTF
-		dual_role_instance_changed(pd_port->tcpc->dr_usb);
+		dual_role_instance_changed(pd_port->tcpc_dev->dr_usb);
 #endif /* CONFIG_DUAL_ROLE_USB_INTF */
 	}
 
@@ -538,12 +537,6 @@ static const struct dpm_ready_reaction dpm_reactions[] = {
 #endif	/* CONFIG_USB_PD_DPM_AUTO_GET_STATUS */
 #endif	/* CONFIG_USB_PD_REV30 */
 
-#ifdef CONFIG_USB_PD_DFP_FLOW_DELAY
-	DECL_DPM_REACTION_DFP(
-		DPM_REACTION_DFP_FLOW_DELAY,
-		dpm_reaction_dfp_flow_delay),
-#endif	/* CONFIG_USB_PD_DFP_FLOW_DELAY */
-
 #ifdef CONFIG_USB_PD_UFP_FLOW_DELAY
 	DECL_DPM_REACTION_UFP(
 		DPM_REACTION_UFP_FLOW_DELAY,
@@ -580,6 +573,12 @@ static const struct dpm_ready_reaction dpm_reactions[] = {
 		dpm_reaction_request_dr_swap),
 #endif	/* CONFIG_USB_PD_DR_SWAP */
 
+#ifdef CONFIG_USB_PD_DFP_FLOW_DELAY
+	DECL_DPM_REACTION_DFP(
+		DPM_REACTION_DFP_FLOW_DELAY,
+		dpm_reaction_dfp_flow_delay),
+#endif	/* CONFIG_USB_PD_DFP_FLOW_DELAY */
+
 #ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
 	DECL_DPM_REACTION_DFP_PD30_CHECK_ONCE(
 		DPM_REACTION_DYNAMIC_VCONN,
@@ -648,8 +647,10 @@ static inline uint8_t dpm_get_reaction_env(struct pd_port *pd_port)
 	else
 		conditions = DPM_REACCOND_UFP;
 
+#ifdef CONFIG_USB_PD_REV30
 	if (pd_check_rev30(pd_port))
 		conditions |= DPM_REACTION_COND_PD30;
+#endif	/* CONFIG_USB_PD_REV30 */
 
 	return conditions;
 }
@@ -749,10 +750,10 @@ uint8_t pd_dpm_get_ready_reaction(struct pd_port *pd_port)
 	uint8_t evt;
 	uint8_t env;
 	uint32_t clear_reaction = DPM_REACTION_CAP_READY_ONCE;
+
 	const struct dpm_ready_reaction *reaction = dpm_reactions;
 	const struct dpm_ready_reaction *reaction_last =
 			dpm_reactions + ARRAY_SIZE(dpm_reactions);
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	env = dpm_get_reaction_env(pd_port);
 
@@ -762,7 +763,7 @@ uint8_t pd_dpm_get_ready_reaction(struct pd_port *pd_port)
 
 	if (evt > 0 && dpm_check_clear_reaction(pd_port, reaction)) {
 		clear_reaction |= reaction->bit_mask;
-		DPM_DBG("clear_reaction=%d\n", evt);
+		DPM_DBG("clear_reaction=%d\r\n", evt);
 	}
 
 	dpm_reaction_clear(pd_port, clear_reaction);
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_dpm_uvdm.c b/drivers/misc/mediatek/typec/tcpc/pd_dpm_uvdm.c
index af67e52..0b70947 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_dpm_uvdm.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_dpm_uvdm.c
@@ -23,7 +23,7 @@
 bool richtek_dfp_notify_pe_startup(
 		struct pd_port *pd_port, struct svdm_svid_data *svid_data)
 {
-	UVDM_INFO("%s\n", __func__);
+	UVDM_INFO("%s\r\n", __func__);
 	pd_port->richtek_init_done = false;
 	return true;
 }
@@ -38,13 +38,13 @@ int richtek_dfp_notify_pe_ready(
 		return 0;
 
 	pd_port->richtek_init_done = true;
-	UVDM_INFO("%s\n", __func__);
+	UVDM_INFO("%s\r\n", __func__);
 
 #if 0
 	pd_port->uvdm_cnt = 3;
 	pd_port->uvdm_wait_resp = true;
 
-	pd_port->uvdm_data[0] = PD_UVDM_HDR(USB_VID_RICHTEK, 0x4321);
+	pd_port->uvdm_data[0] = PD_UVDM_HDR(USB_SID_RICHTEK, 0x4321);
 	pd_port->uvdm_data[1] = 0x11223344;
 	pd_port->uvdm_data[2] = 0x44332211;
 
@@ -63,9 +63,9 @@ bool richtek_dfp_notify_uvdm(struct pd_port *pd_port,
 		if (pd_port->uvdm_wait_resp)
 			resp_cmd = PD_UVDM_HDR_CMD(pd_port->uvdm_data[0]);
 
-		UVDM_INFO("dfp_notify: ACK (0x%x)\n", resp_cmd);
+		UVDM_INFO("dfp_notify: ACK (0x%x)\r\n", resp_cmd);
 	} else
-		UVDM_INFO("dfp_notify: NAK\n");
+		UVDM_INFO("dfp_notify: NAK\r\n");
 
 	return true;
 }
@@ -77,15 +77,15 @@ bool richtek_ufp_notify_uvdm(struct pd_port *pd_port,
 	uint32_t reply_cmd[VDO_MAX_NR];
 	uint16_t cmd = (uint16_t) PD_UVDM_HDR_CMD(pd_port->uvdm_data[0]);
 
-	UVDM_INFO("ufp_notify: 0x%x\n", cmd);
+	UVDM_INFO("ufp_notify: 0x%x\r\n", cmd);
 
 	if (cmd >= 0x1000) {
-		UVDM_INFO("uvdm_no_reply\n");
+		UVDM_INFO("uvdm_no_reply\r\n");
 		VDM_STATE_DPM_INFORMED(pd_port);
 		return true;
 	}
 
-	reply_cmd[0] = PD_UVDM_HDR(USB_VID_RICHTEK, cmd+1);
+	reply_cmd[0] = PD_UVDM_HDR(USB_SID_RICHTEK, cmd+1);
 
 	for (i = 1; i < pd_port->uvdm_cnt; i++)
 		reply_cmd[i] = ~pd_port->uvdm_data[i];
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine.c b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine.c
index f738361..320a6c8 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine.c
@@ -21,7 +21,6 @@
 
 /* ---- Policy Engine State ---- */
 
-#if PE_DBG_ENABLE | PE_STATE_INFO_ENABLE
 #if PE_STATE_FULL_NAME
 
 static const char *const pe_state_name[] = {
@@ -226,7 +225,6 @@ static const char *const pe_state_name[] = {
 	"PE_DFP_UVDM_ACKED",
 	"PE_DFP_UVDM_NAKED",
 #endif/* CONFIG_USB_PD_CUSTOM_VDM */
-	"PE_UFP_VDM_SEND_NAK",
 /******************* PD30 Common *******************/
 #ifdef CONFIG_USB_PD_REV30
 #ifdef CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
@@ -276,14 +274,6 @@ static const char *const pe_state_name[] = {
 #endif	/* CONFIG_USB_PD_ERROR_RECOVERY_ONCE */
 	"PE_BIST_TEST_DATA",
 	"PE_BIST_CARRIER_MODE_2",
-
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
-	"PE_UNEXPECTED_TX_WAIT",
-	"PE_SEND_SOFT_RESET_TX_WAIT",
-	"PE_RECV_SOFT_RESET_TX_WAIT",
-	"PE_SEND_SOFT_RESET_STANDBY",
-#endif	/* CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG */
-
 /* Wait tx finished */
 	"PE_IDLE1",
 	"PE_IDLE2",
@@ -494,7 +484,6 @@ static const char *const pe_state_name[] = {
 	"D_UVDM_ACKED",
 	"D_UVDM_NAKED",
 #endif/* CONFIG_USB_PD_CUSTOM_VDM */
-	"U_SEND_NAK",
 /******************* PD30 Common *******************/
 #ifdef CONFIG_USB_PD_REV30
 #ifdef CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
@@ -544,20 +533,11 @@ static const char *const pe_state_name[] = {
 #endif	/* CONFIG_USB_PD_ERROR_RECOVERY_ONCE */
 	"BIST_TD",
 	"BIST_C2",
-
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
-	"UNEXPECTED_TX",
-	"SEND_SRESET_TX",
-	"RECV_SRESET_TX",
-	"SEND_SRESET_STANDBY",
-#endif	/* CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG */
-
 /* Wait tx finished */
 	"IDLE1",
 	"IDLE2",
 };
 #endif	/* PE_STATE_FULL_NAME */
-#endif /* PE_DBG_ENABLE | PE_STATE_INFO_ENABLE */
 
 struct pe_state_actions {
 	void (*entry_action)
@@ -772,7 +752,6 @@ static const struct pe_state_actions pe_state_actions[] = {
 	PE_STATE_ACTIONS(pe_dfp_uvdm_acked),
 	PE_STATE_ACTIONS(pe_dfp_uvdm_naked),
 #endif/* CONFIG_USB_PD_CUSTOM_VDM */
-	PE_STATE_ACTIONS(pe_ufp_vdm_send_nak),
 /******************* PD30 Common *******************/
 #ifdef CONFIG_USB_PD_REV30
 #ifdef CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
@@ -821,14 +800,6 @@ static const struct pe_state_actions pe_state_actions[] = {
 #endif	/* CONFIG_USB_PD_ERROR_RECOVERY_ONCE */
 	PE_STATE_ACTIONS(pe_bist_test_data),
 	PE_STATE_ACTIONS(pe_bist_carrier_mode_2),
-
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
-	PE_STATE_ACTIONS(pe_unexpected_tx_wait),
-	PE_STATE_ACTIONS(pe_send_soft_reset_tx_wait),
-	PE_STATE_ACTIONS(pe_recv_soft_reset_tx_wait),
-	PE_STATE_ACTIONS(pe_send_soft_reset_standby),
-#endif	/* CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG */
-
 /* Wait tx finished */
 	PE_STATE_ACTIONS(pe_idle1),
 	PE_STATE_ACTIONS(pe_idle2),
@@ -857,8 +828,8 @@ void (*pe_get_exit_action(uint8_t pe_state))
 #endif	/* CONFIG_USB_PD_REV30_STATUS_REMOTE */
 #endif	/* CONFIG_USB_PD_REV30 */
 #endif	/* CONFIG_USB_PD_PE_SOURCE */
-
 /******************* Sink *******************/
+		/* fall-through */
 #ifdef CONFIG_USB_PD_PE_SINK
 	case PE_SNK_SELECT_CAPABILITY:
 		retval = pe_snk_select_capability_exit;
@@ -887,6 +858,7 @@ void (*pe_get_exit_action(uint8_t pe_state))
 #endif	/* CONFIG_USB_PD_PE_SINK */
 
 /******************* PR_SWAP *******************/
+		/* fall-through */
 #ifdef CONFIG_USB_PD_PR_SWAP
 	case PE_DR_SRC_GET_SOURCE_CAP:
 		retval = pe_dr_src_get_source_cap_exit;
@@ -907,6 +879,7 @@ void (*pe_get_exit_action(uint8_t pe_state))
 #endif	/* CONFIG_USB_PD_PR_SWAP */
 
 /******************* PD30 Common *******************/
+		/* fall-through */
 #ifdef CONFIG_USB_PD_REV30
 #ifdef CONFIG_USB_PD_REV30_BAT_CAP_REMOTE
 	case PE_GET_BATTERY_CAP:
@@ -961,17 +934,17 @@ static inline void print_state(
 	 * DFP (D), UFP (U)
 	 * Vconn Source (Y/N)
 	 */
-	bool __maybe_unused vdm_evt = pd_curr_is_vdm_evt(pd_port);
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
+
+	bool vdm_evt = pd_curr_is_vdm_evt(pd_port);
 
 #if PE_DBG_ENABLE
-	PE_DBG("%s -> %s (%c%c%c)\n",
+	PE_DBG("%s -> %s (%c%c%c)\r\n",
 		vdm_evt ? "VDM" : "PD", pe_state_name[state],
 		pd_port->power_role ? 'P' : 'C',
 		pd_port->data_role ? 'D' : 'U',
 		pd_port->vconn_role ? 'Y' : 'N');
 #else
-	PE_STATE_INFO("%s-> %s\n",
+	PE_STATE_INFO("%s-> %s\r\n",
 		vdm_evt ? "VDM" : "PD", pe_state_name[state]);
 #endif	/* PE_DBG_ENABLE */
 }
@@ -1070,7 +1043,7 @@ static int pd_handle_event(
 	if (pd_process_event(pd_port, pd_event))
 		pd_pe_state_change(pd_port, pd_event);
 
-	pd_free_event(pd_port->tcpc, pd_event);
+	pd_free_event(pd_port->tcpc_dev, pd_event);
 	return 1;
 }
 
@@ -1085,43 +1058,43 @@ enum PE_NEW_EVT_TYPE {
 };
 
 static inline bool pd_try_get_vdm_event(
-	struct tcpc_device *tcpc, struct pd_event *pd_event)
+	struct tcpc_device *tcpc_dev, struct pd_event *pd_event)
 {
 	bool ret = false;
-	struct pd_port *pd_port = &tcpc->pd_port;
+	struct pd_port *pd_port = &tcpc_dev->pd_port;
 
 	switch (pd_port->pe_pd_state) {
 #ifdef CONFIG_USB_PD_PE_SINK
 	case PE_SNK_READY:
-		ret = pd_get_vdm_event(tcpc, pd_event);
+		ret = pd_get_vdm_event(tcpc_dev, pd_event);
 		break;
 #endif	/* CONFIG_USB_PD_PE_SINK */
 
 #ifdef CONFIG_USB_PD_PE_SOURCE
 	case PE_SRC_READY:
-		ret = pd_get_vdm_event(tcpc, pd_event);
+		ret = pd_get_vdm_event(tcpc_dev, pd_event);
 		break;
 	case PE_SRC_STARTUP:
-		ret = pd_get_vdm_event(tcpc, pd_event);
+		ret = pd_get_vdm_event(tcpc_dev, pd_event);
 		break;
 	case PE_SRC_DISCOVERY:
-		ret = pd_get_vdm_event(tcpc, pd_event);
+		ret = pd_get_vdm_event(tcpc_dev, pd_event);
 		break;
 
 #ifdef CONFIG_PD_SRC_RESET_CABLE
 	case PE_SRC_CBL_SEND_SOFT_RESET:
-		ret = pd_get_vdm_event(tcpc, pd_event);
+		ret = pd_get_vdm_event(tcpc_dev, pd_event);
 		break;
 #endif	/* CONFIG_PD_SRC_RESET_CABLE */
 #endif	/* CONFIG_USB_PD_PE_SOURCE */
-
+		/* fall-through */
 #ifdef CONFIG_USB_PD_CUSTOM_DBGACC
 	case PE_DBG_READY:
-		ret = pd_get_vdm_event(tcpc, pd_event);
+		ret = pd_get_vdm_event(tcpc_dev, pd_event);
 		break;
 #endif	/* CONFIG_USB_PD_CUSTOM_DBGACC */
 	case PE_IDLE1:
-		ret = pd_get_vdm_event(tcpc, pd_event);
+		ret = pd_get_vdm_event(tcpc_dev, pd_event);
 		break;
 	default:
 		break;
@@ -1243,7 +1216,7 @@ static inline bool pd_check_tx_ready(struct pd_port *pd_port)
 static inline uint8_t pd_try_get_deferred_tcp_event(struct pd_port *pd_port)
 {
 	if (!pd_get_deferred_tcp_event(
-		pd_port->tcpc, &pd_port->tcp_event))
+		pd_port->tcpc_dev, &pd_port->tcp_event))
 		return DPM_READY_REACTION_BUSY;
 
 #ifdef CONFIG_USB_PD_TCPM_CB_2ND
@@ -1266,26 +1239,15 @@ static inline uint8_t pd_try_get_deferred_tcp_event(struct pd_port *pd_port)
  */
 
 static inline uint8_t pd_try_get_active_event(
-	struct tcpc_device *tcpc, struct pd_event *pd_event)
+	struct tcpc_device *tcpc_dev, struct pd_event *pd_event)
 {
 	uint8_t ret;
 	uint8_t from_pe = PD_TCP_FROM_PE;
-	struct pd_port *pd_port = &tcpc->pd_port;
+	struct pd_port *pd_port = &tcpc_dev->pd_port;
 
 	if (!pd_check_tx_ready(pd_port))
 		return PE_NEW_EVT_NULL;
 
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
-	if (pd_port->pe_data.pd_unexpected_event_pending) {
-		pd_port->pe_data.pd_unexpected_event_pending = false;
-		*pd_event = pd_port->pe_data.pd_unexpected_event;
-		pd_port->pe_data.pd_unexpected_event.pd_msg = NULL;
-		PE_INFO("##$$120\n");
-		DPM_INFO("Re-Run Unexpected Msg");
-		return PE_NEW_EVT_PD;
-	}
-#endif	/* CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG */
-
 	ret = pd_dpm_get_ready_reaction(pd_port);
 
 	if (ret == 0) {
@@ -1295,7 +1257,7 @@ static inline uint8_t pd_try_get_active_event(
 
 #if DPM_DBG_ENABLE
 	if ((ret != 0) && (ret != DPM_READY_REACTION_BUSY)) {
-		DPM_DBG("from_pe: %d, evt:%d, reaction:0x%x\n",
+		DPM_DBG("from_pe: %d, evt:%d, reaction:0x%x\r\n",
 			from_pe, ret, pd_port->pe_data.dpm_reaction_id);
 	}
 #endif	/* DPM_DBG_ENABLE */
@@ -1311,10 +1273,6 @@ static inline uint8_t pd_try_get_active_event(
 	if (ret >= TCP_DPM_EVT_VDM_COMMAND)
 		return PE_NEW_EVT_VDM;
 
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
-	pd_port->pe_data.pd_sent_ams_init_cmd = false;
-#endif	/* CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG */
-
 	return PE_NEW_EVT_PD;
 }
 
@@ -1331,22 +1289,15 @@ static inline uint8_t pd_try_get_active_event(
  */
 
 static inline uint8_t pd_try_get_next_event(
-	struct tcpc_device *tcpc, struct pd_event *pd_event)
+	struct tcpc_device *tcpc_dev, struct pd_event *pd_event)
 {
-	uint8_t ret = 0;
-	struct pd_port *pd_port = &tcpc->pd_port;
-
-	if (pd_get_event(tcpc, pd_event))
+	if (pd_get_event(tcpc_dev, pd_event))
 		return PE_NEW_EVT_PD;
 
-	if (pd_try_get_vdm_event(tcpc, pd_event))
+	if (pd_try_get_vdm_event(tcpc_dev, pd_event))
 		return PE_NEW_EVT_VDM;
 
-	mutex_lock(&pd_port->pd_lock);
-	ret = pd_try_get_active_event(tcpc, pd_event);
-	mutex_unlock(&pd_port->pd_lock);
-
-	return ret;
+	return pd_try_get_active_event(tcpc_dev, pd_event);
 }
 
 /*
@@ -1357,7 +1308,6 @@ static inline int pd_handle_dpm_immediately(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
 	bool dpm_immediately;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (pd_curr_is_vdm_evt(pd_port)) {
 		dpm_immediately = pd_port->pe_data.vdm_state_flags
@@ -1368,7 +1318,7 @@ static inline int pd_handle_dpm_immediately(
 	}
 
 	if (dpm_immediately) {
-		PE_DBG("DPM_Immediately\n");
+		PE_DBG("DPM_Immediately\r\n");
 		pd_event->event_type = PD_EVT_DPM_MSG;
 		pd_event->msg = PD_DPM_ACK;
 		return pd_handle_event(pd_port, pd_event);
@@ -1377,27 +1327,33 @@ static inline int pd_handle_dpm_immediately(
 	return false;
 }
 
-int pd_policy_engine_run(struct tcpc_device *tcpc)
+int pd_policy_engine_run(struct tcpc_device *tcpc_dev)
 {
-	bool loop = true;
 	uint8_t ret;
-	struct pd_port *pd_port = &tcpc->pd_port;
+	struct pd_port *pd_port = &tcpc_dev->pd_port;
 	struct pd_event *pd_event = pd_get_curr_pd_event(pd_port);
 
-	ret = pd_try_get_next_event(tcpc, pd_event);
-	if (ret == PE_NEW_EVT_NULL) {
-		loop = false;
-		goto out;
-	}
+	ret = pd_try_get_next_event(tcpc_dev, pd_event);
 
-	mutex_lock(&pd_port->pd_lock);
+	if (ret == PE_NEW_EVT_NULL)
+		return false;
 
 	pd_port->curr_is_vdm_evt = (ret == PE_NEW_EVT_VDM);
 
+#ifdef CONFIG_TCPC_IDLE_MODE
+	tcpci_idle_poll_ctrl(tcpc_dev, true, 1);
+#endif
+
+	mutex_lock(&pd_port->pd_lock);
+
 	pd_handle_event(pd_port, pd_event);
 	pd_handle_dpm_immediately(pd_port, pd_event);
 
 	mutex_unlock(&pd_port->pd_lock);
-out:
-	return loop;
+
+#ifdef CONFIG_TCPC_IDLE_MODE
+	tcpci_idle_poll_ctrl(tcpc_dev, false, 1);
+#endif
+
+	return 1;
 }
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_com.c b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_com.c
index 4954cc9..918a0d6 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_com.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_com.c
@@ -58,7 +58,6 @@ void pe_idle1_entry(struct pd_port *pd_port)
 
 void pe_idle2_entry(struct pd_port *pd_port)
 {
-	pd_free_unexpected_event(pd_port);
 	memset(&pd_port->pe_data, 0, sizeof(struct pe_data));
 	pd_set_rx_enable(pd_port, PD_RX_CAP_PE_IDLE);
 	pd_disable_timer(pd_port, PD_TIMER_PE_IDLE_TOUT);
@@ -103,10 +102,10 @@ void pe_error_recovery_once_entry(struct pd_port *pd_port)
 #ifdef CONFIG_USB_PD_RECV_HRESET_COUNTER
 void pe_over_recv_hreset_limit_entry(struct pd_port *pd_port)
 {
-	PE_INFO("OverHResetLimit++\n");
+	PE_INFO("OverHResetLimit++\r\n");
 	pe_idle_reset_data(pd_port);
 	pd_notify_pe_over_recv_hreset(pd_port);
-	PE_INFO("OverHResetLimit--\n");
+	PE_INFO("OverHResetLimit--\r\n");
 }
 #endif	/* CONFIG_USB_PD_RECV_HRESET_COUNTER */
 
@@ -133,48 +132,11 @@ void pe_bist_carrier_mode_2_exit(struct pd_port *pd_port)
 	pd_disable_bist_mode2(pd_port);
 }
 
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
-void pe_unexpected_tx_wait_entry(struct pd_port *pd_port)
-{
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
-	PE_INFO("##$$123\n");
-	PE_STATE_DISCARD_AND_UNEXPECTED(pd_port);
-	pd_enable_timer(pd_port, PD_TIMER_SENDER_RESPONSE);
-}
-
-void pe_send_soft_reset_tx_wait_entry(struct pd_port *pd_port)
-{
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
-	PE_INFO("##$$124\n");
-	PE_STATE_DISCARD_AND_UNEXPECTED(pd_port);
-	pd_enable_timer(pd_port, PD_TIMER_SENDER_RESPONSE);
-}
-
-void pe_recv_soft_reset_tx_wait_entry(struct pd_port *pd_port)
-{
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
-	PE_INFO("##$$125\n");
-	PE_STATE_DISCARD_AND_UNEXPECTED(pd_port);
-	pd_enable_timer(pd_port, PD_TIMER_SENDER_RESPONSE);
-}
-
-void pe_send_soft_reset_standby_entry(struct pd_port *pd_port)
-{
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
-	PE_INFO("##$$126\n");
-	PE_STATE_DISCARD_AND_UNEXPECTED(pd_port);
-	pd_put_dpm_ack_event(pd_port);
-}
-#endif	/* CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG */
-
 /*
  * Policy Engine Share State Activity
  */
 
+#ifdef CONFIG_USB_PD_REV30
 static inline uint8_t pe30_power_ready_entry(struct pd_port *pd_port)
 {
 	uint8_t rx_cap = PD_RX_CAP_PE_READY_UFP;
@@ -190,6 +152,7 @@ static inline uint8_t pe30_power_ready_entry(struct pd_port *pd_port)
 
 	return rx_cap;
 }
+#endif	/* CONFIG_USB_PD_REV30 */
 
 static inline uint8_t pe20_power_ready_entry(struct pd_port *pd_port)
 {
@@ -198,6 +161,9 @@ static inline uint8_t pe20_power_ready_entry(struct pd_port *pd_port)
 	if (pd_port->data_role == PD_ROLE_DFP)
 		rx_cap = PD_RX_CAP_PE_READY_DFP;
 
+	pd_port->pe_data.pe_state_flags |=
+		PE_STATE_FLAG_IGNORE_UNKNOWN_EVENT;
+
 	return rx_cap;
 }
 
@@ -214,13 +180,11 @@ void pe_power_ready_entry(struct pd_port *pd_port)
 	pd_port->pe_data.renegotiation_count = 0;
 #endif	/* CONFIG_USB_PD_RENEGOTIATION_COUNTER */
 
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
-	pd_port->pe_data.pd_sent_ams_init_cmd = true;
-#endif /* CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG */
-
+#ifdef CONFIG_USB_PD_REV30
 	if (pd_check_rev30(pd_port))
 		rx_cap = pe30_power_ready_entry(pd_port);
 	else
+#endif	/* CONFIG_USB_PD_REV30 */
 		rx_cap = pe20_power_ready_entry(pd_port);
 
 	pd_set_rx_enable(pd_port, rx_cap);
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_dbg.c b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_dbg.c
index 768599b..94dadab 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_dbg.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_dbg.c
@@ -31,11 +31,11 @@ void pe_dbg_ready_entry(struct pd_port *pd_port)
 	pd_reset_protocol_layer(pd_port, false);
 
 	if (pd_port->data_role == PD_ROLE_UFP) {
-		PE_INFO("Custom_DBGACC : UFP\n");
+		PE_INFO("Custom_DBGACC : UFP\r\n");
 		state = PD_CONNECT_PE_READY_DBGACC_UFP;
 		pd_set_rx_enable(pd_port, PD_RX_CAP_PE_READY_UFP);
 	} else {
-		PE_INFO("Custom_DBGACC : DFP\n");
+		PE_INFO("Custom_DBGACC : DFP\r\n");
 		state = PD_CONNECT_PE_READY_DBGACC_DFP;
 		pd_set_rx_enable(pd_port, PD_RX_CAP_PE_READY_DFP);
 	}
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_prs.c b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_prs.c
index a888d68..68a554f 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_prs.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_prs.c
@@ -50,6 +50,7 @@ void pe_prs_src_snk_assert_rd_entry(struct pd_port *pd_port)
 
 void pe_prs_src_snk_wait_source_on_entry(struct pd_port *pd_port)
 {
+	PE_STATE_HRESET_IF_TX_FAILED(pd_port);
 	pd_send_sop_ctrl_msg(pd_port, PD_CTRL_PS_RDY);
 }
 
@@ -104,6 +105,7 @@ void pe_prs_snk_src_source_on_entry(struct pd_port *pd_port)
 	dpm_reaction_set(pd_port, DPM_REACTION_CAP_RESET_CABLE);
 #endif	/* CONFIG_USB_PD_RESET_CABLE */
 
+	PE_STATE_HRESET_IF_TX_FAILED(pd_port);
 	pd_dpm_dynamic_enable_vconn(pd_port);
 	pd_dpm_prs_enable_power_source(pd_port, true);
 
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_snk.c b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_snk.c
index cab1839..cee2968 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_snk.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_snk.c
@@ -45,19 +45,21 @@ void pe_snk_startup_entry(struct pd_port *pd_port)
 #endif	/* CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP */
 	}
 
+#ifdef CONFIG_USB_PD_SNK_HRESET_KEEP_DRAW
+	/* iSafe0mA: Maximum current a Sink
+	 * is allowed to draw when VBUS is driven to vSafe0V
+	 */
+	if (pd_check_pe_during_hard_reset(pd_port))
+		pd_dpm_sink_vbus(pd_port, false);
+#endif	/* CONFIG_USB_PD_SNK_HRESET_KEEP_DRAW */
+
 	pd_set_rx_enable(pd_port, rx_cap);
 	pd_put_pe_event(pd_port, PD_PE_RESET_PRL_COMPLETED);
 }
 
 void pe_snk_discovery_entry(struct pd_port *pd_port)
 {
-	bool wait_valid = true;
-
-	if (pd_check_pe_during_hard_reset(pd_port)) {
-		wait_valid = false;
-		pd_enable_pe_state_timer(pd_port, PD_TIMER_PS_TRANSITION);
-	}
-	pd_enable_vbus_valid_detection(pd_port, wait_valid);
+	pd_enable_vbus_valid_detection(pd_port, true);
 }
 
 void pe_snk_wait_for_capabilities_entry(
@@ -90,17 +92,16 @@ void pe_snk_evaluate_capability_entry(struct pd_port *pd_port)
 void pe_snk_select_capability_entry(struct pd_port *pd_port)
 {
 	struct pd_event *pd_event = pd_get_curr_pd_event(pd_port);
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	PE_STATE_WAIT_MSG_HRESET_IF_TOUT(pd_port);
 
 	if (pd_event->event_type == PD_EVT_DPM_MSG) {
-		PE_DBG("SelectCap%d, rdo:0x%08x\n",
+		PE_DBG("SelectCap%d, rdo:0x%08x\r\n",
 			pd_event->msg_sec, pd_port->last_rdo);
 	} else {
 		/* new request, for debug only */
 		/* pd_dpm_sink_vbus(pd_port, false); */
-		PE_DBG("NewReq, rdo:0x%08x\n", pd_port->last_rdo);
+		PE_DBG("NewReq, rdo:0x%08x\r\n", pd_port->last_rdo);
 	}
 
 	/* Disable UART output for Sink SenderResponse */
@@ -112,10 +113,6 @@ void pe_snk_select_capability_entry(struct pd_port *pd_port)
 
 void pe_snk_select_capability_exit(struct pd_port *pd_port)
 {
-#ifdef CONFIG_USB_PD_RENEGOTIATION_COUNTER
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-#endif /* CONFIG_USB_PD_RENEGOTIATION_COUNTER */
-
 	if (pd_check_ctrl_msg_event(pd_port, PD_CTRL_ACCEPT)) {
 		pd_port->pe_data.remote_selected_cap =
 					RDO_POS(pd_port->last_rdo);
@@ -123,7 +120,7 @@ void pe_snk_select_capability_exit(struct pd_port *pd_port)
 	} else if (pd_check_ctrl_msg_event(pd_port, PD_CTRL_REJECT)) {
 #ifdef CONFIG_USB_PD_RENEGOTIATION_COUNTER
 		if (pd_port->cap_miss_match == 0x01) {
-			PE_INFO("reset renegotiation cnt by cap mismatch\n");
+			PE_INFO("reset renegotiation cnt by cap mismatch\r\n");
 			pd_port->pe_data.renegotiation_count = 0;
 		}
 #endif /* CONFIG_USB_PD_RENEGOTIATION_COUNTER */
@@ -168,6 +165,15 @@ void pe_snk_transition_to_default_entry(struct pd_port *pd_port)
 {
 	pd_reset_local_hw(pd_port);
 	pd_dpm_snk_hard_reset(pd_port);
+
+	/*
+	 * Sink PE will wait vSafe0v in this state,
+	 * So original exit action be executed in here too.
+	 */
+
+	pd_enable_timer(pd_port, PD_TIMER_NO_RESPONSE);
+	pd_set_rx_enable(pd_port, PD_RX_CAP_PE_STARTUP);
+	pd_enable_vbus_valid_detection(pd_port, false);
 }
 
 void pe_snk_give_sink_cap_entry(struct pd_port *pd_port)
@@ -222,7 +228,7 @@ void pe_snk_not_supported_received_entry(struct pd_port *pd_port)
 
 void pe_snk_chunk_received_entry(struct pd_port *pd_port)
 {
-	pd_enable_timer(pd_port, PD_TIMER_CK_NOT_SUPPORTED);
+	pd_enable_timer(pd_port, PD_TIMER_CK_NO_SUPPORT);
 }
 
 /*
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_src.c b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_src.c
index 2e1157d..f64f9c1 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_src.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_src.c
@@ -38,18 +38,23 @@ void pe_src_startup_entry(struct pd_port *pd_port)
 
 void pe_src_discovery_entry(struct pd_port *pd_port)
 {
+	/* MessageID Should be 0 for First SourceCap (Ellisys)... */
+
 	/* The SourceCapabilitiesTimer continues to run during the states
 	 * defined in Source Startup Structured VDM Discover Identity State
 	 * Diagram
 	 */
 
+	pd_port->pe_data.msg_id_tx[TCPC_TX_SOP] = 0;
 	pd_port->pe_data.pd_connected = false;
 
 	pd_enable_timer(pd_port, PD_TIMER_SOURCE_CAPABILITY);
 
 #ifdef CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
-	if (pd_is_discover_cable(pd_port))
+	if (pd_is_discover_cable(pd_port)) {
+		pd_port->pe_data.msg_id_tx[TCPC_TX_SOP_PRIME] = 0;
 		pd_enable_timer(pd_port, PD_TIMER_DISCOVER_ID);
+	}
 #endif
 }
 
@@ -115,13 +120,11 @@ void pe_src_hard_reset_entry(struct pd_port *pd_port)
 {
 	pd_send_hard_reset(pd_port);
 	pd_enable_timer(pd_port, PD_TIMER_PS_HARD_RESET);
-	pd_enable_timer(pd_port, PD_TIMER_NO_RESPONSE);
 }
 
 void pe_src_hard_reset_received_entry(struct pd_port *pd_port)
 {
 	pd_enable_timer(pd_port, PD_TIMER_PS_HARD_RESET);
-	pd_enable_timer(pd_port, PD_TIMER_NO_RESPONSE);
 }
 
 void pe_src_transition_to_default_entry(struct pd_port *pd_port)
@@ -133,6 +136,7 @@ void pe_src_transition_to_default_entry(struct pd_port *pd_port)
 void pe_src_transition_to_default_exit(struct pd_port *pd_port)
 {
 	pd_set_vconn(pd_port, PD_ROLE_VCONN_ON);
+	pd_enable_timer(pd_port, PD_TIMER_NO_RESPONSE);
 }
 
 void pe_src_get_sink_cap_entry(struct pd_port *pd_port)
@@ -224,7 +228,7 @@ void pe_src_not_supported_received_entry(struct pd_port *pd_port)
 
 void pe_src_chunk_received_entry(struct pd_port *pd_port)
 {
-	pd_enable_timer(pd_port, PD_TIMER_CK_NOT_SUPPORTED);
+	pd_enable_timer(pd_port, PD_TIMER_CK_NO_SUPPORT);
 }
 
 /*
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_ufp.c b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_ufp.c
index d1699ba..89737e4 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_ufp.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_policy_engine_ufp.c
@@ -116,9 +116,3 @@ void pe_ufp_uvdm_recv_entry(struct pd_port *pd_port)
 }
 
 #endif	/* CONFIG_USB_PD_CUSTOM_VDM */
-
-void pe_ufp_vdm_send_nak_entry(struct pd_port *pd_port)
-{
-	pd_dpm_ufp_send_svdm_nak(pd_port);
-	VDM_STATE_DPM_INFORMED(pd_port);
-}
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_process_evt.c b/drivers/misc/mediatek/typec/tcpc/pd_process_evt.c
index fccad95..bd384f8 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_process_evt.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_process_evt.c
@@ -50,10 +50,10 @@ static const char * const pd_ctrl_msg_name[] = {
 #endif	/* CONFIG_USB_PD_REV30 */
 };
 
-static inline void print_ctrl_msg_event(struct tcpc_device *tcpc, uint8_t msg)
+static inline void print_ctrl_msg_event(uint8_t msg)
 {
 	if (msg < PD_CTRL_MSG_NR)
-		PE_EVT_INFO("%s\n", pd_ctrl_msg_name[msg]);
+		PE_EVT_INFO("%s\r\n", pd_ctrl_msg_name[msg]);
 }
 
 static const char * const pd_data_msg_name[] = {
@@ -81,10 +81,10 @@ static const char * const pd_data_msg_name[] = {
 	"vdm",
 };
 
-static inline void print_data_msg_event(struct tcpc_device *tcpc, uint8_t msg)
+static inline void print_data_msg_event(uint8_t msg)
 {
 	if (msg < PD_DATA_MSG_NR)
-		PE_EVT_INFO("%s\n", pd_data_msg_name[msg]);
+		PE_EVT_INFO("%s\r\n", pd_data_msg_name[msg]);
 }
 
 #ifdef CONFIG_USB_PD_REV30
@@ -107,10 +107,10 @@ static const char *const pd_ext_msg_name[] = {
 	"cc",
 };
 
-static inline void print_ext_msg_event(struct tcpc_device *tcpc, uint8_t msg)
+static inline void print_ext_msg_event(uint8_t msg)
 {
 	if (msg < PD_EXT_MSG_NR)
-		PE_EVT_INFO("%s\n", pd_ext_msg_name[msg]);
+		PE_EVT_INFO("%s\r\n", pd_ext_msg_name[msg]);
 }
 
 #endif	/* CONFIG_USB_PD_REV30 */
@@ -132,10 +132,10 @@ static const char *const pd_hw_msg_name[] = {
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
 };
 
-static inline void print_hw_msg_event(struct tcpc_device *tcpc, uint8_t msg)
+static inline void print_hw_msg_event(uint8_t msg)
 {
 	if (msg < PD_HW_MSG_NR)
-		PE_EVT_INFO("%s\n", pd_hw_msg_name[msg]);
+		PE_EVT_INFO("%s\r\n", pd_hw_msg_name[msg]);
 }
 
 static const char *const pd_pe_msg_name[] = {
@@ -147,10 +147,10 @@ static const char *const pd_pe_msg_name[] = {
 	"vdm_not_support",
 };
 
-static inline void print_pe_msg_event(struct tcpc_device *tcpc, uint8_t msg)
+static inline void print_pe_msg_event(uint8_t msg)
 {
 	if (msg < PD_PE_MSG_NR)
-		PE_EVT_INFO("%s\n", pd_pe_msg_name[msg]);
+		PE_EVT_INFO("%s\r\n", pd_pe_msg_name[msg]);
 }
 
 static const char * const pd_dpm_msg_name[] = {
@@ -160,10 +160,10 @@ static const char * const pd_dpm_msg_name[] = {
 	"not_support",
 };
 
-static inline void print_dpm_msg_event(struct tcpc_device *tcpc, uint8_t msg)
+static inline void print_dpm_msg_event(uint8_t msg)
 {
 	if (msg < PD_DPM_MSG_NR)
-		PE_EVT_INFO("dpm_%s\n", pd_dpm_msg_name[msg]);
+		PE_EVT_INFO("dpm_%s\r\n", pd_dpm_msg_name[msg]);
 }
 
 static const char *const tcp_dpm_evt_name[] = {
@@ -229,12 +229,11 @@ static const char *const tcp_dpm_evt_name[] = {
 	"error_recovery",
 };
 
-static inline void print_tcp_event(struct tcpc_device *tcpc,
-	uint8_t msg, uint8_t from)
+static inline void print_tcp_event(uint8_t msg)
 {
 	if (msg < TCP_DPM_EVT_NR)
-		PE_EVT_INFO("tcp_event(%s), %d, %d\n",
-			    tcp_dpm_evt_name[msg], msg, from);
+		PE_EVT_INFO("tcp_event(%s), %d\r\n",
+			tcp_dpm_evt_name[msg], msg);
 }
 #endif
 
@@ -242,41 +241,39 @@ static inline void print_event(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
 #if PE_EVENT_DBG_ENABLE
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
 	switch (pd_event->event_type) {
 	case PD_EVT_CTRL_MSG:
-		print_ctrl_msg_event(tcpc, pd_event->msg);
+		print_ctrl_msg_event(pd_event->msg);
 		break;
 
 	case PD_EVT_DATA_MSG:
-		print_data_msg_event(tcpc, pd_event->msg);
+		print_data_msg_event(pd_event->msg);
 		break;
 
 #ifdef CONFIG_USB_PD_REV30
 	case PD_EVT_EXT_MSG:
-		print_ext_msg_event(tcpc, pd_event->msg);
+		print_ext_msg_event(pd_event->msg);
 		break;
 #endif	/* CONFIG_USB_PD_REV30 */
 
 	case PD_EVT_DPM_MSG:
-		print_dpm_msg_event(tcpc, pd_event->msg);
+		print_dpm_msg_event(pd_event->msg);
 		break;
 
 	case PD_EVT_HW_MSG:
-		print_hw_msg_event(tcpc, pd_event->msg);
+		print_hw_msg_event(pd_event->msg);
 		break;
 
 	case PD_EVT_PE_MSG:
-		print_pe_msg_event(tcpc, pd_event->msg);
+		print_pe_msg_event(pd_event->msg);
 		break;
 
 	case PD_EVT_TIMER_MSG:
-		PE_EVT_INFO("timer\n");
+		PE_EVT_INFO("timer\r\n");
 		break;
 
 	case PD_EVT_TCP_MSG:
-		print_tcp_event(tcpc, pd_event->msg, pd_event->msg_sec);
+		print_tcp_event(pd_event->msg);
 		break;
 	}
 #endif
@@ -304,23 +301,19 @@ bool pd_make_pe_state_transit(struct pd_port *pd_port,
 
 /*---------------------------------------------------------------------------*/
 
-static inline bool pd_process_ready_protocol_error(struct pd_port *pd_port)
-{
 #ifdef CONFIG_USB_PD_REV30
+static inline bool pd30_process_ready_protocol_error(struct pd_port *pd_port)
+{
 	bool multi_chunk;
-#endif	/* CONFIG_USB_PD_REV30 */
+
+	if (!pd_check_rev30(pd_port))
+		return false;
 
 	if (!pd_port->curr_unsupported_msg) {
 		pe_transit_soft_reset_state(pd_port);
 		return true;
 	}
 
-	if (!pd_check_rev30(pd_port)) {
-		PE_TRANSIT_STATE(pd_port, PE_REJECT);
-		return true;
-	}
-
-#ifdef CONFIG_USB_PD_REV30
 	multi_chunk = pd_is_multi_chunk_msg(pd_port);
 
 	if (pd_port->power_role == PD_ROLE_SINK) {
@@ -332,95 +325,20 @@ static inline bool pd_process_ready_protocol_error(struct pd_port *pd_port)
 	PE_TRANSIT_STATE(pd_port, multi_chunk ?
 		PE_SRC_CHUNK_RECEIVED : PE_SRC_SEND_NOT_SUPPORTED);
 	return true;
-#else
-	return false;
-#endif	/* CONFIG_USB_PD_REV30 */
 }
+#endif	/* CONFIG_USB_PD_REV30 */
 
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
-
-static inline bool pd_process_unexpected_alert(
-	struct pd_port *pd_port, struct pd_event *pd_event)
-{
-#ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
-	if (pd_event->event_type == PD_EVT_DATA_MSG ||
-		pd_event->msg == PD_DATA_ALERT) {
-		PE_INFO("unexpected_alert\n");
-
-		pd_dpm_inform_alert(pd_port);
-		pd_free_unexpected_event(pd_port);
-		return true;
-	}
-#endif	/* CONFIG_USB_PD_REV30_ALERT_REMOTE */
-
-	return false;
-}
-
-static inline bool pd_process_unexpected_message(
-	struct pd_port *pd_port, struct pd_event *pd_event)
-{
-	struct pe_data *pe_data = &pd_port->pe_data;
-
-
-	// For 1711 series : IC will auto reties discard message ...
-	if (!(pd_port->tcpc->tcpc_flags & TCPC_FLAGS_RETRY_CRC_DISCARD)) {
-		pe_transit_soft_reset_state(pd_port);
-		return true;
-	}
-
-	/* Save Unexpected Msg */
-	if (pe_data->pd_unexpected_event_pending)
-		pd_free_event(pd_port->tcpc, &pe_data->pd_unexpected_event);
-
-	pe_data->pd_unexpected_event = *pd_event;
-	pd_event->pd_msg = NULL;
-	pe_data->pd_unexpected_event_pending = true;
-
-	if (pd_is_pe_wait_pd_transmit_done(pd_port)) {
-		if (pe_data->pd_sent_ams_init_cmd)
-			PE_TRANSIT_STATE(pd_port, PE_SEND_SOFT_RESET_TX_WAIT);
-		else {
-			if (pd_process_unexpected_alert(pd_port, pd_event))
-				return false;
-
-			PE_TRANSIT_STATE(pd_port, PE_UNEXPECTED_TX_WAIT);
-		}
-	} else {
-		if (pe_data->pd_sent_ams_init_cmd)
-			pe_transit_soft_reset_state(pd_port);
-		else
-			pe_transit_ready_state(pd_port);
-	}
-
-	pd_notify_tcp_event_buf_reset(pd_port, TCP_DPM_RET_DROP_UNEXPECTED);
-	return true;
-}
-#endif	/* CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG */
 
 bool pd_process_protocol_error(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
-	bool ret = false;
 	bool power_change = false;
+
 #if PE_INFO_ENABLE
 	uint8_t event_type = pd_event->event_type;
-	uint8_t msg_type = pd_event->msg;
 	uint8_t msg_id = pd_get_msg_hdr_id(pd_port);
+	uint8_t msg_type = pd_event->msg;
 #endif
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
-	if (pd_port->pe_data.pe_state_flags &
-			PE_STATE_FLAG_IGNORE_UNKNOWN_EVENT) {
-		PE_INFO("Ignore Unknown Event\n");
-		goto out;
-	}
-
-	if (pd_check_pe_during_hard_reset(pd_port)) {
-		PE_INFO("Ignore Event during HReset\n");
-		goto out;
-	}
 
 	switch (pd_port->pe_state_curr) {
 	case PE_SNK_TRANSITION_SINK:
@@ -431,8 +349,8 @@ bool pd_process_protocol_error(
 		power_change = true;
 		if (pd_event_msg_match(pd_event,
 				PD_EVT_CTRL_MSG, PD_CTRL_PING)) {
-			PE_INFO("Ignore Ping\n");
-			goto out;
+			PE_DBG("Ignore Ping\r\n");
+			return false;
 		}
 		break;
 
@@ -441,21 +359,36 @@ bool pd_process_protocol_error(
 #endif	/* CONFIG_USB_PD_PR_SWAP */
 		if (pd_event_msg_match(pd_event,
 				PD_EVT_CTRL_MSG, PD_CTRL_PING)) {
-			PE_INFO("Ignore Ping\n");
-			goto out;
+			PE_DBG("Ignore Ping\r\n");
+			return false;
 		}
 		break;
 
+#ifdef CONFIG_USB_PD_REV30
 	case PE_SNK_READY:
 	case PE_SRC_READY:
-		if (pd_process_ready_protocol_error(pd_port)) {
-			ret = true;
-			goto out;
-		}
+		if (pd30_process_ready_protocol_error(pd_port))
+			return true;
 		break;
+#endif	/* CONFIG_USB_PD_REV30 */
 	};
 
-	ret = true;
+	if (pd_port->pe_data.pe_state_flags &
+			PE_STATE_FLAG_IGNORE_UNKNOWN_EVENT) {
+		PE_DBG("Ignore Unknown Event\r\n");
+		return false;
+	}
+
+	if (pd_check_pe_during_hard_reset(pd_port)) {
+		PE_DBG("Ignore Event during HReset\r\n");
+		return false;
+	}
+
+	/*
+	 * msg_type: PD_EVT_CTRL_MSG (1), PD_EVT_DATA_MSG (2)
+	 */
+
+	PE_INFO("PRL_ERR: %d-%d-%d\r\n", event_type, msg_type, msg_id);
 
 	if (pd_port->pe_data.during_swap) {
 #ifdef CONFIG_USB_PD_PR_SWAP_ERROR_RECOVERY
@@ -465,50 +398,20 @@ bool pd_process_protocol_error(
 #endif
 	} else if (power_change)
 		pe_transit_hard_reset_state(pd_port);
-	else {
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
-		if (!pd_process_unexpected_message(pd_port, pd_event))
-			return false;
-#else
+	else
 		pe_transit_soft_reset_state(pd_port);
-#endif	/* CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG */
-	}
 
-	/*
-	 * event_type: PD_EVT_CTRL_MSG (1), PD_EVT_DATA_MSG (2)
-	 */
-out:
-	PE_INFO("PRL_ERR: %d-%d-%d\n", event_type, msg_type, msg_id);
-
-	return ret;
+	return true;
 }
 
-bool pd_process_tx_failed_discard(struct pd_port *pd_port, uint8_t msg)
+bool pd_process_tx_failed(struct pd_port *pd_port)
 {
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
 	if (pd_check_pe_state_ready(pd_port) ||
 		pd_check_pe_during_hard_reset(pd_port)) {
-		PE_DBG("Ignore tx_failed\n");
+		PE_DBG("Ignore tx_failed\r\n");
 		return false;
 	}
 
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
-	if (msg == PD_HW_TX_DISCARD &&
-		(tcpc->tcpc_flags & TCPC_FLAGS_RETRY_CRC_DISCARD)) {
-
-		pd_notify_tcp_event_buf_reset(pd_port,
-					      TCP_DPM_RET_DROP_DISCARD);
-
-		if (pd_port->pe_data.pd_sent_ams_init_cmd)
-			PE_TRANSIT_STATE(pd_port, PE_SEND_SOFT_RESET_STANDBY);
-		else
-			pe_transit_ready_state(pd_port);
-
-		return true;
-	}
-#endif	/* CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG */
-
 	pe_transit_soft_reset_state(pd_port);
 	return true;
 }
@@ -541,7 +444,6 @@ static inline bool pd_process_event_cable(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
 	bool ret = false;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 #ifdef CONFIG_USB_PD_RESET_CABLE
 	if (pd_event->msg == PD_CTRL_ACCEPT)
@@ -549,7 +451,7 @@ static inline bool pd_process_event_cable(
 #endif	/* CONFIG_USB_PD_RESET_CABLE */
 
 	if (!ret)
-		PE_DBG("Ignore not SOP Ctrl Msg\n");
+		PE_DBG("Ignore not SOP Ctrl Msg\r\n");
 
 	return ret;
 }
@@ -617,7 +519,6 @@ static inline bool pe_is_valid_pd_msg_id(struct pd_port *pd_port,
 {
 	uint8_t sop_type = pd_msg->frame_type;
 	uint8_t msg_id = pd_get_msg_hdr_id(pd_port);
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (pd_port->pe_state_curr == PE_BIST_TEST_DATA)
 		return false;
@@ -627,19 +528,19 @@ static inline bool pe_is_valid_pd_msg_id(struct pd_port *pd_port,
 		/* SofReset always has a MessageID value of zero */
 		case PD_CTRL_SOFT_RESET:
 			if (msg_id != 0) {
-				PE_INFO("Repeat soft_reset\n");
+				PE_INFO("Repeat soft_reset\r\n");
 				return false;
 			}
 			return true;
 
 		case PD_CTRL_GOOD_CRC:
-			PE_DBG("Discard_CRC\n");
+			PE_DBG("Discard_CRC\r\n");
 			return true;
 
 #ifdef CONFIG_USB_PD_IGNORE_PS_RDY_AFTER_PR_SWAP
 		case PD_CTRL_PS_RDY:
 			if (pd_port->msg_id_pr_swap_last == msg_id) {
-				PE_INFO("Repeat ps_rdy\n");
+				PE_INFO("Repeat ps_rdy\r\n");
 				return false;
 			}
 			break;
@@ -648,7 +549,7 @@ static inline bool pe_is_valid_pd_msg_id(struct pd_port *pd_port,
 	}
 
 	if (pd_port->pe_data.msg_id_rx[sop_type] == msg_id) {
-		PE_INFO("Repeat msg: %c:%d:%d\n",
+		PE_INFO("Repeat msg: %c:%d:%d\r\n",
 			(pd_event->event_type == PD_EVT_CTRL_MSG) ? 'C' : 'D',
 			pd_event->msg, msg_id);
 		return false;
@@ -663,7 +564,6 @@ static inline bool pe_is_valid_pd_msg_role(struct pd_port *pd_port,
 {
 	bool ret = true;
 	uint8_t msg_pr, msg_dr;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (pd_msg == NULL)	/* Good-CRC */
 		return true;
@@ -681,7 +581,7 @@ static inline bool pe_is_valid_pd_msg_role(struct pd_port *pd_port,
 	 */
 
 	if (msg_pr == pd_port->power_role)
-		PE_DBG("Wrong PR:%d\n", msg_pr);
+		PE_DBG("Wrong PR:%d\r\n", msg_pr);
 
 	/*
 	 * Should a Type-C Port receive a Message with the Port Data Role field
@@ -695,7 +595,7 @@ static inline bool pe_is_valid_pd_msg_role(struct pd_port *pd_port,
 #ifdef CONFIG_USB_PD_CHECK_DATA_ROLE
 		ret = false;
 #endif
-		PE_INFO("Wrong DR:%d\n", msg_dr);
+		PE_INFO("Wrong DR:%d\r\n", msg_dr);
 	}
 
 	return ret;
@@ -739,12 +639,6 @@ static inline uint8_t pe_get_startup_state(
 #endif	/* CONFIG_USB_PD_CUSTOM_DBGACC */
 
 	switch (pd_event->msg_sec) {
-	case TYPEC_ATTACHED_DBGACC_SNK:
-#ifdef CONFIG_USB_PD_CUSTOM_DBGACC
-		pd_port->custom_dbgacc = true;
-		startup_state = PE_DBG_READY;
-		break;
-#endif	/* CONFIG_USB_PD_CUSTOM_DBGACC */
 	case TYPEC_ATTACHED_SNK:
 		startup_state = PE_SNK_STARTUP;
 		break;
@@ -753,11 +647,18 @@ static inline uint8_t pe_get_startup_state(
 		act_as_sink = false;
 		startup_state = PE_SRC_STARTUP;
 		break;
+
+#ifdef CONFIG_USB_PD_CUSTOM_DBGACC
+	case TYPEC_ATTACHED_DBGACC_SNK:
+		pd_port->custom_dbgacc = true;
+		startup_state = PE_DBG_READY;
+		break;
+#endif	/* CONFIG_USB_PD_CUSTOM_DBGACC */
 	}
 
-	/* At least > 4 for Ellisys VNDI PR_SWAP */
+	/* At least > 2 for Ellisys VNDI PR_SWAP */
 #ifdef CONFIG_USB_PD_ERROR_RECOVERY_ONCE
-	if (pd_port->error_recovery_once > 4)
+	if (pd_port->error_recovery_once > 2)
 		startup_state = PE_ERROR_RECOVERY_ONCE;
 #endif	/* CONFIG_USB_PD_ERROR_RECOVERY_ONCE */
 
@@ -789,8 +690,6 @@ enum {
 static inline uint8_t pe_check_trap_in_idle_state(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
 	switch (pd_port->pe_pd_state) {
 	case PE_IDLE1:
 	case PE_ERROR_RECOVERY:
@@ -821,7 +720,7 @@ static inline uint8_t pe_check_trap_in_idle_state(
 		return TII_PE_RUNNING;
 	}
 
-	PE_DBG("Trap in idle state, Ignore All MSG (%d:%d)\n",
+	PE_DBG("Trap in idle state, Ignore All MSG (%d:%d)\r\n",
 		pd_event->event_type, pd_event->msg);
 	return TII_TRAP_IN_IDLE;
 }
@@ -862,7 +761,7 @@ bool pd_process_event(
 		pe_translate_pd_msg_event(pd_port, pd_event, pd_msg);
 
 #if PE_EVT_INFO_VDM_DIS
-	if (!pd_curr_is_vdm_evt(pd_port))
+	if (!vdm_evt)
 #endif
 		print_event(pd_port, pd_event);
 
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_com.c b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_com.c
index ea70dea..98ac422 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_com.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_com.c
@@ -53,6 +53,9 @@ static inline bool pd_evaluate_reject_pr_swap(struct pd_port *pd_port)
 #ifdef CONFIG_USB_PD_VCONN_SWAP
 static inline bool pd_evaluate_accept_vconn_swap(struct pd_port *pd_port)
 {
+	if (pd_port->vconn_role)
+		return true;
+
 	if (pd_port->dpm_caps & DPM_CAP_LOCAL_VCONN_SUPPLY)
 		return true;
 
@@ -117,12 +120,8 @@ static inline bool pd_process_ctrl_msg_vconn_swap(
 	}
 #endif	/* CONFIG_USB_PD_VCONN_SWAP */
 
-	if (!pd_check_rev30(pd_port)) {
-		PE_TRANSIT_STATE(pd_port, PE_REJECT);
-		return true;
-	}
-
-	return false;
+	PE_TRANSIT_STATE(pd_port, PE_REJECT);
+	return true;
 }
 
 /*
@@ -132,22 +131,20 @@ static inline bool pd_process_ctrl_msg_vconn_swap(
 static inline bool pd_process_data_msg_bist(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
 	if (pd_port->request_v > 5000) {
-		PE_INFO("bist_not_vsafe5v\n");
+		PE_INFO("bist_not_vsafe5v\r\n");
 		return false;
 	}
 
 	switch (BDO_MODE(pd_event->pd_msg->payload[0])) {
 	case BDO_MODE_TEST_DATA:
-		PE_DBG("bist_test\n");
+		PE_DBG("bist_test\r\n");
 		PE_TRANSIT_STATE(pd_port, PE_BIST_TEST_DATA);
 		pd_noitfy_pe_bist_mode(pd_port, PD_BIST_MODE_TEST_DATA);
 		return true;
 
 	case BDO_MODE_CARRIER2:
-		PE_DBG("bist_cm2\n");
+		PE_DBG("bist_cm2\r\n");
 		PE_TRANSIT_STATE(pd_port, PE_BIST_CARRIER_MODE_2);
 		pd_noitfy_pe_bist_mode(pd_port, PD_BIST_MODE_DISABLE);
 		return true;
@@ -162,7 +159,7 @@ static inline bool pd_process_data_msg_bist(
 	case BDO_MODE_CARRIER3:
 	case BDO_MODE_EYE:
 #endif
-		PE_DBG("Unsupport BIST\n");
+		PE_DBG("Unsupport BIST\r\n");
 		pd_noitfy_pe_bist_mode(pd_port, PD_BIST_MODE_DISABLE);
 		return false;
 	}
@@ -197,49 +194,6 @@ static inline bool pd_process_ctrl_msg_wait(struct pd_port *pd_port)
 	return pd_process_ctrl_msg_wait_reject(pd_port);
 }
 
-static bool pd_process_tx_msg(struct pd_port *pd_port, uint8_t msg)
-{
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
-	if (msg != PD_HW_TX_DISCARD)
-		pd_port->pe_data.pd_sent_ams_init_cmd = true;
-
-	if (pd_port->pe_state_curr == PE_SEND_SOFT_RESET_TX_WAIT) {
-		pe_transit_soft_reset_state(pd_port);
-		return true;
-	} else if (pd_port->pe_state_curr == PE_RECV_SOFT_RESET_TX_WAIT) {
-		pe_transit_soft_reset_recv_state(pd_port);
-		return true;
-	} else if (pd_port->pe_state_curr == PE_UNEXPECTED_TX_WAIT) {
-		if (msg == PD_HW_TX_DISCARD)
-			pe_transit_ready_state(pd_port);
-		else
-			pe_transit_soft_reset_state(pd_port);
-		return true;
-	}
-#endif	/* CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG */
-
-	return false;
-}
-
-static inline bool pd_process_ctrl_msg_good_crc(
-	struct pd_port *pd_port, struct pd_event *pd_event)
-{
-	if (pd_process_tx_msg(pd_port, PD_CTRL_GOOD_CRC))
-		return true;
-
-	if (pd_port->pe_data.pe_state_flags2 &
-		PE_STATE_FLAG_BACK_READY_IF_RECV_GOOD_CRC) {
-		pe_transit_ready_state(pd_port);
-		return true;
-	}
-
-	if (pd_port->pe_data.pe_state_flags &
-		PE_STATE_FLAG_ENABLE_SENDER_RESPONSE_TIMER)
-		pd_enable_timer(pd_port, PD_TIMER_SENDER_RESPONSE);
-
-	return false;
-}
-
 static inline bool pd_process_ctrl_msg(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
@@ -255,7 +209,15 @@ static inline bool pd_process_ctrl_msg(
 
 	switch (pd_event->msg) {
 	case PD_CTRL_GOOD_CRC:
-		ret = pd_process_ctrl_msg_good_crc(pd_port, pd_event);
+		if (pd_port->pe_data.pe_state_flags &
+			PE_STATE_FLAG_ENABLE_SENDER_RESPONSE_TIMER)
+			pd_enable_timer(pd_port, PD_TIMER_SENDER_RESPONSE);
+
+		if (pd_port->pe_data.pe_state_flags2 &
+			PE_STATE_FLAG_BACK_READY_IF_RECV_GOOD_CRC) {
+			pe_transit_ready_state(pd_port);
+			return true;
+		}
 		break;
 
 	case PD_CTRL_REJECT:
@@ -278,15 +240,6 @@ static inline bool pd_process_ctrl_msg(
 	case PD_CTRL_SOFT_RESET:
 		if (!pd_port->pe_data.during_swap &&
 			!pd_check_pe_during_hard_reset(pd_port)) {
-
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
-			if (pd_is_pe_wait_pd_transmit_done(pd_port)) {
-				PE_TRANSIT_STATE(pd_port,
-						 PE_RECV_SOFT_RESET_TX_WAIT);
-				return true;
-			}
-#endif	/* CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG */
-
 			pe_transit_soft_reset_recv_state(pd_port);
 			return true;
 		}
@@ -328,7 +281,7 @@ static inline bool pd_process_ctrl_msg(
 			return true;
 		} else if (pd_port->pe_data.vdm_state_timer) {
 			vdm_put_pe_event(
-				pd_port->tcpc, PD_PE_VDM_NOT_SUPPORT);
+				pd_port->tcpc_dev, PD_PE_VDM_NOT_SUPPORT);
 		}
 		break;
 #endif	/* CONFIG_USB_PD_REV30 */
@@ -356,6 +309,7 @@ static inline bool pd_process_data_msg(
 #endif	/* CONFIG_USB_PD_REV30 */
 
 	switch (pd_event->msg) {
+
 	case PD_DATA_BIST:
 		if (pd_port->pe_state_curr == ready_state)
 			ret = pd_process_data_msg_bist(pd_port, pd_event);
@@ -394,18 +348,23 @@ static inline bool pd_process_ext_msg(
 	bool ret = false;
 	uint8_t ready_state = pe_get_curr_ready_state(pd_port);
 
+#ifdef CONFIG_USB_PD_REV30
 	if (!pd_check_rev30(pd_port)) {
 		pd_event->msg = PD_DATA_MSG_NR;
 		return false;
 	}
+#endif	/* CONFIG_USB_PD_REV30 */
 
+#ifdef CONFIG_USB_PD_REV30
 #ifndef CONFIG_USB_PD_REV30_CHUNKING_BY_PE
 	if (pd_port->pe_state_curr == ready_state &&
+		pd_check_rev30(pd_port) &&
 		pd_is_multi_chunk_msg(pd_port)) {
 		pd_port->curr_unsupported_msg = true;
 		return pd_process_protocol_error(pd_port, pd_event);
 	}
 #endif	/* CONFIG_USB_PD_REV30_CHUNKING_BY_PE */
+#endif	/* CONFIG_USB_PD_REV30 */
 
 	switch (pd_event->msg) {
 
@@ -478,13 +437,6 @@ static inline bool pd_process_dpm_msg(
 
 	switch (pd_event->msg) {
 	case PD_DPM_ACK:
-#ifdef CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG
-		if (pd_port->pe_state_curr == PE_SEND_SOFT_RESET_STANDBY) {
-			pe_transit_soft_reset_state(pd_port);
-			return true;
-		}
-#endif	/* CONFIG_USB_PD_DISCARD_AND_UNEXPECT_MSG */
-
 		if (pd_port->pe_data.pe_state_flags2 &
 			PE_STATE_FLAG_BACK_READY_IF_DPM_ACK) {
 			pe_transit_ready_state(pd_port);
@@ -530,22 +482,18 @@ static inline bool pd_process_recv_hard_reset(
 	return true;
 }
 
-static bool pd_process_hw_msg_tx_failed_discard(
+static inline bool pd_process_hw_msg_tx_failed(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
 #ifdef CONFIG_USB_PD_RENEGOTIATION_COUNTER
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
 	if (pd_port->pe_data.renegotiation_count > PD_HARD_RESET_COUNT) {
-		PE_INFO("renegotiation failed\n");
+		PE_INFO("renegotiation failed\r\n");
 		PE_TRANSIT_STATE(pd_port, PE_ERROR_RECOVERY);
 		return true;
 	}
 #endif	/* CONFIG_USB_PD_RENEGOTIATION_COUNTER */
 
-	if (pd_process_tx_msg(pd_port, pd_event->msg))
-		return true;
-	else if (pd_port->pe_data.pe_state_flags &
+	if (pd_port->pe_data.pe_state_flags &
 		PE_STATE_FLAG_BACK_READY_IF_TX_FAILED) {
 		pd_notify_tcp_event_2nd_result(
 			pd_port, TCP_DPM_RET_NO_RESPONSE);
@@ -568,8 +516,7 @@ static inline bool pd_process_hw_msg(
 		return pd_process_recv_hard_reset(pd_port, pd_event);
 
 	case PD_HW_TX_FAILED:
-	case PD_HW_TX_DISCARD:
-		return pd_process_hw_msg_tx_failed_discard(pd_port, pd_event);
+		return pd_process_hw_msg_tx_failed(pd_port, pd_event);
 
 	default:
 		return false;
@@ -580,33 +527,25 @@ static inline bool pd_process_hw_msg(
  * [BLOCK] Porcess Timer MSG
  */
 
+#ifdef CONFIG_USB_PD_CHECK_RX_PENDING_IF_SRTOUT
 static inline bool pd_check_rx_pending(struct pd_port *pd_port)
 {
-	bool pending = false;
-
-#ifdef CONFIG_USB_PD_CHECK_RX_PENDING_IF_SRTOUT
 	uint32_t alert;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
-	if (tcpci_get_alert_status(tcpc, &alert))
+	if (tcpci_get_alert_status(pd_port->tcpc_dev, &alert))
 		return false;
 
 	if (alert & TCPC_REG_ALERT_RX_STATUS) {
-		PE_INFO("rx_pending\n");
-		pending = true;
-	} else if (!pd_is_msg_empty(tcpc)) {
-		PE_INFO("rx_pending2\n");
-		pending = true;
-	}
-
+		PE_INFO("rx_pending\r\n");
 #ifndef CONFIG_USB_PD_ONLY_PRINT_SYSTEM_BUSY
-	if (pending)
 		pd_enable_timer(pd_port, PD_TIMER_SENDER_RESPONSE);
-#endif /* CONFIG_USB_PD_ONLY_PRINT_SYSTEM_BUSY */
-#endif	/* CONFIG_USB_PD_CHECK_RX_PENDING_IF_SRTOUT */
+#endif
+		return true;
+	}
 
-	return pending;
+	return false;
 }
+#endif	/* CONFIG_USB_PD_CHECK_RX_PENDING_IF_SRTOUT */
 
 static inline bool pd_process_timer_msg(
 	struct pd_port *pd_port, struct pd_event *pd_event)
@@ -674,7 +613,7 @@ static inline bool pd_process_timer_msg(
 #ifdef CONFIG_USB_PD_VCONN_STABLE_DELAY
 	case PD_TIMER_VCONN_STABLE:
 		if (pd_port->vconn_role == PD_ROLE_VCONN_DYNAMIC_ON) {
-			pd_set_vconn(pd_port, PD_ROLE_VCONN_ON);
+			pd_port->vconn_role = PD_ROLE_VCONN_ON;
 			dpm_reaction_set_clear(pd_port,
 				DPM_REACTION_CAP_READY_ONCE,
 				DPM_REACTION_VCONN_STABLE_DELAY);
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_prs.c b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_prs.c
index 23e34de..aac15d1 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_prs.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_prs.c
@@ -68,26 +68,13 @@ DECL_PE_STATE_REACTION(PD_DPM_MSG_NAK);
 
 /* HW Event reactions */
 
-DECL_PE_STATE_TRANSITION(PD_HW_VBUS_PRESENT) = {
-#ifdef CONFIG_USB_PD_VBUS_DETECTION_DURING_PR_SWAP
-	{ PE_PRS_SRC_SNK_WAIT_SOURCE_ON, PE_SNK_STARTUP },
-#endif /* CONFIG_USB_PD_VBUS_DETECTION_DURING_PR_SWAP */
-};
-DECL_PE_STATE_REACTION(PD_HW_VBUS_PRESENT);
-
+#ifdef CONFIG_USB_PD_PR_SWAP_ERROR_RECOVERY
 DECL_PE_STATE_TRANSITION(PD_HW_TX_FAILED) = {
-	{ PE_PRS_SRC_SNK_WAIT_SOURCE_ON, PE_PRS_SNK_HARD_RESET },
-	{ PE_PRS_SNK_SRC_SOURCE_ON, PE_PRS_SRC_HARD_RESET },
+	{ PE_PRS_SRC_SNK_WAIT_SOURCE_ON, PE_ERROR_RECOVERY },
+	{ PE_PRS_SNK_SRC_SOURCE_ON, PE_ERROR_RECOVERY },
 };
 DECL_PE_STATE_REACTION(PD_HW_TX_FAILED);
-
-DECL_PE_STATE_TRANSITION(PD_HW_VBUS_SAFE0V) = {
-	{ PE_PRS_SRC_SNK_TRANSITION_TO_OFF, PE_PRS_SRC_SNK_ASSERT_RD },
-#ifdef CONFIG_USB_PD_VBUS_DETECTION_DURING_PR_SWAP
-	{ PE_PRS_SNK_SRC_TRANSITION_TO_OFF, PE_PRS_SNK_SRC_ASSERT_RP },
-#endif /* CONFIG_USB_PD_VBUS_DETECTION_DURING_PR_SWAP */
-};
-DECL_PE_STATE_REACTION(PD_HW_VBUS_SAFE0V);
+#endif	/* CONFIG_USB_PD_PR_SWAP_ERROR_RECOVERY */
 
 /*
  * [BLOCK] Porcess PD Ctrl MSG
@@ -107,25 +94,6 @@ static inline bool pd_process_ctrl_msg_good_crc(
 	}
 }
 
-static inline bool pd_process_ctrl_msg_ps_rdy(
-	struct pd_port *pd_port, struct pd_event *pd_event)
-{
-	switch (pd_port->pe_state_curr) {
-#ifdef CONFIG_USB_PD_VBUS_DETECTION_DURING_PR_SWAP
-	case PE_PRS_SRC_SNK_WAIT_SOURCE_ON:
-		pd_enable_vbus_valid_detection(pd_port, true);
-		return false;
-
-	case PE_PRS_SNK_SRC_TRANSITION_TO_OFF:
-		pd_enable_vbus_safe0v_detection(pd_port);
-		return false;
-
-#endif /* CONFIG_USB_PD_VBUS_DETECTION_DURING_PR_SWAP */
-	default:
-		return PE_MAKE_STATE_TRANSIT(PD_CTRL_MSG_PS_RDY);
-	}
-}
-
 static inline bool pd_process_ctrl_msg(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
@@ -137,7 +105,7 @@ static inline bool pd_process_ctrl_msg(
 		return PE_MAKE_STATE_TRANSIT(PD_CTRL_MSG_ACCEPT);
 
 	case PD_CTRL_PS_RDY:
-		return pd_process_ctrl_msg_ps_rdy(pd_port, pd_event);
+		return PE_MAKE_STATE_TRANSIT(PD_CTRL_MSG_PS_RDY);
 
 	default:
 		return false;
@@ -166,23 +134,32 @@ static inline bool pd_process_dpm_msg(
  * [BLOCK] Porcess HW MSG
  */
 
+static inline bool pd_process_hw_msg_vbus_present(
+	struct pd_port *pd_port, struct pd_event *pd_event)
+{
+	if (pd_port->pe_state_curr == PE_PRS_SNK_SRC_SOURCE_ON)
+		pd_send_sop_ctrl_msg(pd_port, PD_CTRL_PS_RDY);
+
+	return false;
+}
+
 static inline bool pd_process_hw_msg(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
 	switch (pd_event->msg) {
-	case PD_HW_VBUS_PRESENT:
-		if (pd_port->pe_state_curr == PE_PRS_SNK_SRC_SOURCE_ON)
-			pd_send_sop_ctrl_msg(pd_port, PD_CTRL_PS_RDY);
 
-		return PE_MAKE_STATE_TRANSIT(PD_HW_VBUS_PRESENT);
+	case PD_HW_VBUS_PRESENT:
+		return pd_process_hw_msg_vbus_present(pd_port, pd_event);
 
+#ifdef CONFIG_USB_PD_PR_SWAP_ERROR_RECOVERY
 	case PD_HW_TX_FAILED:
-	/* fallthrough */
-	case PD_HW_TX_DISCARD:
 		return PE_MAKE_STATE_TRANSIT(PD_HW_TX_FAILED);
+#endif	/* CONFIG_USB_PD_PR_SWAP_ERROR_RECOVERY */
 
 	case PD_HW_VBUS_SAFE0V:
-		return PE_MAKE_STATE_TRANSIT(PD_HW_VBUS_SAFE0V);
+		return PE_MAKE_STATE_TRANSIT_SINGLE(
+			PE_PRS_SRC_SNK_TRANSITION_TO_OFF,
+			PE_PRS_SRC_SNK_ASSERT_RD);
 
 	default:
 		return false;
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_snk.c b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_snk.c
index 4547af6..0de81b2 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_snk.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_snk.c
@@ -17,7 +17,6 @@
 #include "inc/pd_dpm_core.h"
 #include "inc/tcpci_event.h"
 #include "inc/pd_process_evt.h"
-#include "inc/tcpci_typec.h"
 
 /* PD Control MSG reactions */
 
@@ -60,8 +59,7 @@ static bool pd_process_ctrl_msg_get_source_cap(
 	}
 #endif	/* CONFIG_USB_PD_PR_SWAP */
 
-	pd_port->curr_unsupported_msg = true;
-
+	pd_send_sop_ctrl_msg(pd_port, PD_CTRL_REJECT);
 	return false;
 }
 
@@ -69,8 +67,6 @@ static inline bool pd_process_ctrl_msg(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
 #ifdef CONFIG_USB_PD_PARTNER_CTRL_MSG_FIRST
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
 	switch (pd_port->pe_state_curr) {
 	case PE_SNK_GET_SOURCE_CAP:
 
@@ -79,7 +75,7 @@ static inline bool pd_process_ctrl_msg(
 #endif	/* CONFIG_USB_PD_PR_SWAP */
 		if (pd_event->msg >= PD_CTRL_GET_SOURCE_CAP &&
 			pd_event->msg <= PD_CTRL_VCONN_SWAP) {
-			PE_DBG("Port Partner Request First\n");
+			PE_DBG("Port Partner Request First\r\n");
 			pd_port->pe_state_curr = PE_SNK_READY;
 			pd_disable_timer(
 				pd_port, PD_TIMER_SENDER_RESPONSE);
@@ -105,19 +101,10 @@ static inline bool pd_process_ctrl_msg(
 		break;
 
 	case PD_CTRL_PS_RDY:
-		switch (pd_port->pe_state_curr) {
-		case PE_SNK_TRANSITION_SINK:
+		if (pd_port->pe_state_curr == PE_SNK_TRANSITION_SINK) {
 			pd_dpm_snk_transition_power(pd_port);
 			PE_TRANSIT_STATE(pd_port, PE_SNK_READY);
 			return true;
-
-#ifdef CONFIG_USB_PD_VBUS_DETECTION_DURING_PR_SWAP
-		case PE_PRS_SRC_SNK_WAIT_SOURCE_ON:
-		case PE_PRS_SNK_SRC_TRANSITION_TO_OFF:
-			return false;
-#endif /* CONFIG_USB_PD_VBUS_DETECTION_DURING_PR_SWAP */
-		default:
-			break;
 		}
 		break;
 
@@ -201,7 +188,7 @@ static inline bool pd_process_data_msg(
 			return true;
 		break;
 #endif	/* CONFIG_USB_PD_PR_SWAP */
-
+		/* fall-through */
 #ifdef CONFIG_USB_PD_REV30
 #ifdef CONFIG_USB_PD_REV30_ALERT_REMOTE
 	case PD_DATA_ALERT:
@@ -228,13 +215,13 @@ static inline bool pd_process_ext_msg(
 {
 	switch (pd_event->msg) {
 
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
 	case PD_EXT_SOURCE_CAP_EXT:
 		if (PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_SNK_GET_SOURCE_CAP_EXT, PE_SNK_READY))
 			return true;
 		break;
-#endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE */
+#endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL */
 
 #ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
 	case PD_EXT_STATUS:
@@ -286,45 +273,24 @@ static inline bool pd_process_hw_msg_sink_tx_change(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
 #ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
-	struct pe_data *pe_data = &pd_port->pe_data;
 	uint8_t pd_traffic;
 
-#ifdef CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
-	if (pe_data->pd_traffic_control == PD_SINK_TX_START)
-		return false;
-#endif	/* CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP */
-
 	if (!pd_check_rev30(pd_port))
 		return false;
 
 	pd_traffic = pd_event->msg_sec ?
 		PD_SINK_TX_OK : PD_SINK_TX_NG;
 
-	if (pe_data->pd_traffic_control == pd_traffic)
+	if (pd_port->pe_data.pd_traffic_control == pd_traffic)
 		return false;
 
-	pe_data->pd_traffic_control = pd_traffic;
 	dpm_reaction_set_ready_once(pd_port);
+	pd_port->pe_data.pd_traffic_control = pd_traffic;
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
 
 	return false;
 }
 
-static inline bool pd_process_vbus_absent(struct pd_port *pd_port)
-{
-	if (pd_port->pe_state_curr != PE_SNK_DISCOVERY)
-		return false;
-#ifdef CONFIG_USB_PD_SNK_HRESET_KEEP_DRAW
-	/* iSafe0mA: Maximum current a Sink
-	 * is allowed to draw when VBUS is driven to vSafe0V
-	 */
-	pd_dpm_sink_vbus(pd_port, false);
-#endif	/* CONFIG_USB_PD_SNK_HRESET_KEEP_DRAW */
-	pd_disable_pe_state_timer(pd_port);
-	pd_enable_vbus_valid_detection(pd_port, true);
-	return false;
-}
-
 static inline bool pd_process_hw_msg(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
@@ -334,11 +300,12 @@ static inline bool pd_process_hw_msg(
 			PE_SNK_DISCOVERY, PE_SNK_WAIT_FOR_CAPABILITIES);
 
 	case PD_HW_VBUS_ABSENT:
-		return pd_process_vbus_absent(pd_port);
+		if (pd_port->pe_state_curr == PE_SNK_TRANSITION_TO_DEFAULT)
+			pd_put_pe_event(pd_port, PD_PE_POWER_ROLE_AT_DEFAULT);
+		return false;
 
 	case PD_HW_TX_FAILED:
-	case PD_HW_TX_DISCARD:
-		return pd_process_tx_failed_discard(pd_port, pd_event->msg);
+		return pd_process_tx_failed(pd_port);
 
 #ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
 	case PD_HW_SINK_TX_CHANGE:
@@ -382,14 +349,14 @@ static inline bool pd_process_pe_msg(
 static inline void pd_report_typec_only_charger(struct pd_port *pd_port)
 {
 	uint8_t state;
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
-	if (tcpc->typec_remote_rp_level == TYPEC_CC_VOLT_SNK_DFT)
+	if (tcpc_dev->typec_remote_rp_level == TYPEC_CC_VOLT_SNK_DFT)
 		state = PD_CONNECT_TYPEC_ONLY_SNK_DFT;
 	else
 		state = PD_CONNECT_TYPEC_ONLY_SNK;
 
-	PE_INFO("TYPE-C Only Charger!\n");
+	PE_INFO("TYPE-C Only Charger!\r\n");
 	pd_dpm_sink_vbus(pd_port, true);
 	pd_set_rx_enable(pd_port, PD_RX_CAP_PE_IDLE);
 	pd_notify_pe_hard_reset_completed(pd_port);
@@ -399,11 +366,6 @@ static inline void pd_report_typec_only_charger(struct pd_port *pd_port)
 static inline bool pd_process_timer_msg(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
-#ifndef CONFIG_USB_PD_DBG_IGRONE_TIMEOUT
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-#endif	/* CONFIG_USB_PD_DBG_IGRONE_TIMEOUT */
-	struct pe_data __maybe_unused *pe_data = &pd_port->pe_data;
-
 	switch (pd_event->msg) {
 	case PD_TIMER_SINK_REQUEST:
 		return PE_MAKE_STATE_TRANSIT_SINGLE(
@@ -412,19 +374,27 @@ static inline bool pd_process_timer_msg(
 #ifndef CONFIG_USB_PD_DBG_IGRONE_TIMEOUT
 	case PD_TIMER_SINK_WAIT_CAP:
 	case PD_TIMER_PS_TRANSITION:
-		if ((pd_port->pe_state_curr != PE_SNK_DISCOVERY) &&
-			(pe_data->hard_reset_counter <= PD_HARD_RESET_COUNT)) {
+		if (pd_port->pe_data.hard_reset_counter <=
+						PD_HARD_RESET_COUNT) {
 			PE_TRANSIT_STATE(pd_port, PE_SNK_HARD_RESET);
 			return true;
 		}
+		break;
 
-		PE_INFO("SRC NoResp\n");
-		if (pd_port->request_v == TCPC_VBUS_SINK_5V) {
-			pd_report_typec_only_charger(pd_port);
-		} else {
+	case PD_TIMER_NO_RESPONSE:
+		if (!pd_dpm_check_vbus_valid(pd_port)) {
+			PE_DBG("NoResp&VBUS=0\r\n");
+			PE_TRANSIT_STATE(pd_port, PE_ERROR_RECOVERY);
+			return true;
+		} else if (pd_port->pe_data.hard_reset_counter <=
+						PD_HARD_RESET_COUNT) {
+			PE_TRANSIT_STATE(pd_port, PE_SNK_HARD_RESET);
+			return true;
+		} else if (pd_port->pe_data.pd_prev_connected) {
 			PE_TRANSIT_STATE(pd_port, PE_ERROR_RECOVERY);
 			return true;
 		}
+		pd_report_typec_only_charger(pd_port);
 		break;
 #endif	/* CONFIG_USB_PD_DBG_IGRONE_TIMEOUT */
 
@@ -433,27 +403,21 @@ static inline bool pd_process_timer_msg(
 		vdm_put_dpm_discover_cable_event(pd_port);
 		break;
 #endif	/* CONFIG_USB_PD_DFP_READY_DISCOVER_ID */
-		/* fall through */
+
 #ifdef CONFIG_USB_PD_REV30
-	case PD_TIMER_CK_NOT_SUPPORTED:
+	case PD_TIMER_CK_NO_SUPPORT:
 		if (PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_SNK_CHUNK_RECEIVED, PE_SNK_SEND_NOT_SUPPORTED))
 			return true;
 		/* fall through */
-#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
 #ifdef CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
 	case PD_TIMER_SNK_FLOW_DELAY:
-		if (pe_data->pd_traffic_control == PD_SINK_TX_START) {
-			if (typec_get_cc_res() == TYPEC_CC_VOLT_SNK_3_0)
-				pe_data->pd_traffic_control = PD_SINK_TX_OK;
-			else
-				pe_data->pd_traffic_control = PD_SINK_TX_NG;
-			if (pd_check_rev30(pd_port))
-				dpm_reaction_set_ready_once(pd_port);
+		if (pd_port->pe_data.pd_traffic_control == PD_SINK_TX_START) {
+			pd_port->pe_data.pd_traffic_control = PD_SINK_TX_OK;
+			dpm_reaction_set_ready_once(pd_port);
 		}
 		break;
 #endif	/* CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP */
-#endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
 #endif	/* CONFIG_USB_PD_REV30 */
 	}
 
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_src.c b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_src.c
index bfdb65f..6bdf279 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_src.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_src.c
@@ -97,8 +97,7 @@ static inline bool pd_process_ctrl_msg_get_sink_cap(
 	}
 #endif	/* CONFIG_USB_PD_PR_SWAP */
 
-	pd_port->curr_unsupported_msg = true;
-
+	pd_send_sop_ctrl_msg(pd_port, PD_CTRL_REJECT);
 	return false;
 }
 
@@ -107,8 +106,6 @@ static inline bool pd_process_ctrl_msg(
 
 {
 #ifdef CONFIG_USB_PD_PARTNER_CTRL_MSG_FIRST
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
 	switch (pd_port->pe_state_curr) {
 	case PE_SRC_GET_SINK_CAP:
 
@@ -117,7 +114,7 @@ static inline bool pd_process_ctrl_msg(
 #endif	/* CONFIG_USB_PD_PR_SWAP */
 		if (pd_event->msg >= PD_CTRL_GET_SOURCE_CAP &&
 			pd_event->msg <= PD_CTRL_VCONN_SWAP) {
-			PE_DBG("Port Partner Request First\n");
+			PE_DBG("Port Partner Request First\r\n");
 			pd_port->pe_state_curr = PE_SRC_READY;
 			pd_disable_timer(
 				pd_port, PD_TIMER_SENDER_RESPONSE);
@@ -243,13 +240,13 @@ static inline bool pd_process_ext_msg(
 {
 	switch (pd_event->msg) {
 
-#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE
+#ifdef CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL
 	case PD_EXT_SOURCE_CAP_EXT:
 		if (PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_DR_SRC_GET_SOURCE_CAP_EXT, PE_SRC_READY))
 			return true;
 		break;
-#endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_REMOTE */
+#endif	/* CONFIG_USB_PD_REV30_SRC_CAP_EXT_LOCAL */
 
 #ifdef CONFIG_USB_PD_REV30_STATUS_LOCAL
 	case PD_EXT_STATUS:
@@ -317,10 +314,14 @@ static inline bool pd_process_hw_msg_tx_failed(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
 	struct pe_data *pe_data = &pd_port->pe_data;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (pd_port->pe_state_curr == PE_SRC_SEND_CAPABILITIES) {
-		if (!pe_data->pd_connected || !pe_data->explicit_contract) {
+		if (pe_data->pd_connected) {
+			if (!pe_data->explicit_contract) {
+				PE_DBG("PR_SWAP NoResp\r\n");
+				return false;
+			}
+		} else {
 			PE_TRANSIT_STATE(pd_port, PE_SRC_DISCOVERY);
 			return true;
 		}
@@ -333,7 +334,7 @@ static inline bool pd_process_hw_msg_tx_failed(
 	}
 #endif	/*  CONFIG_PD_SRC_RESET_CABLE */
 
-	return pd_process_tx_failed_discard(pd_port, pd_event->msg);
+	return pd_process_tx_failed(pd_port);
 }
 
 static inline bool pd_process_hw_msg(
@@ -352,8 +353,6 @@ static inline bool pd_process_hw_msg(
 			PE_SRC_TRANSITION_SUPPLY, PE_SRC_TRANSITION_SUPPLY2);
 
 	case PD_HW_TX_FAILED:
-	/* fallthrough */
-	case PD_HW_TX_DISCARD:
 		return pd_process_hw_msg_tx_failed(pd_port, pd_event);
 
 	default:
@@ -457,7 +456,7 @@ static inline bool pd_process_timer_msg(
 			PE_SRC_CBL_SEND_SOFT_RESET, PE_SRC_SEND_CAPABILITIES);
 #endif	/*  CONFIG_PD_SRC_RESET_CABLE */
 #endif
-
+		/* fall-through */
 	case PD_TIMER_PS_HARD_RESET:
 		return PE_MAKE_STATE_TRANSIT(PD_TIMER_PS_HARD_RESET);
 
@@ -497,9 +496,9 @@ static inline bool pd_process_timer_msg(
 
 		break;
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
-		/* fall through */
+
 #ifdef CONFIG_USB_PD_REV30
-	case PD_TIMER_CK_NOT_SUPPORTED:
+	case PD_TIMER_CK_NO_SUPPORT:
 		return PE_MAKE_STATE_TRANSIT_SINGLE(
 			PE_SRC_CHUNK_RECEIVED, PE_SRC_SEND_NOT_SUPPORTED);
 #endif	/* CONFIG_USB_PD_REV30 */
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_tcp.c b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_tcp.c
index a863c5d..4861883 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_tcp.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_tcp.c
@@ -118,8 +118,10 @@ static inline int pd_handle_tcp_event_cable_softreset(struct pd_port *pd_port)
 
 	role_check = pd_port->data_role == PD_ROLE_DFP;
 
+#ifdef CONFIG_USB_PD_REV30
 	if (pd_check_rev30(pd_port))
 		role_check = pd_port->vconn_role;
+#endif	/* CONFIG_USB_PD_REV30 */
 
 	if (!role_check)
 		return TCP_DPM_RET_DENIED_WRONG_DATA_ROLE;
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_vcs.c b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_vcs.c
index a1971c3..91aa862 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_vcs.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_vcs.c
@@ -17,7 +17,6 @@
 #include "inc/tcpci_event.h"
 #include "inc/pd_process_evt.h"
 
-#ifdef CONFIG_USB_PD_VCONN_SWAP
 /* DPM Event reactions */
 
 DECL_PE_STATE_TRANSITION(PD_DPM_MSG_ACK) = {
@@ -123,4 +122,3 @@ bool pd_process_event_vcs(struct pd_port *pd_port, struct pd_event *pd_event)
 		return false;
 	}
 }
-#endif	/* CONFIG_USB_PD_VCONN_SWAP */
diff --git a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_vdm.c b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_vdm.c
index e3e9cf1..b230ead 100644
--- a/drivers/misc/mediatek/typec/tcpc/pd_process_evt_vdm.c
+++ b/drivers/misc/mediatek/typec/tcpc/pd_process_evt_vdm.c
@@ -17,7 +17,6 @@
 #include "inc/tcpci_event.h"
 #include "inc/pd_process_evt.h"
 #include "inc/pd_dpm_core.h"
-#include "pd_dpm_prv.h"
 
 /* VDM reactions */
 
@@ -135,10 +134,8 @@ static const struct vdm_state_transition pe_vdm_state_reactions[] = {
 static inline bool pd_vdm_state_transit_rx(struct pd_port *pd_port,
 	const struct vdm_state_transition *state_transition)
 {
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
 	if (!pd_check_pe_state_ready(pd_port)) {
-		PE_DBG("670 : invalid, current status\n");
+		PE_DBG("670 : invalid, current status\r\n");
 		return false;
 	}
 
@@ -183,10 +180,12 @@ bool vdm_is_state_transition_available(struct pd_port *pd_port,
 	uint8_t shift = 1;
 	uint8_t vdm_cmd_flags = state_transition->vdm_cmd_flags;
 
+#ifdef CONFIG_USB_PD_REV30
 	if (pd_check_rev30(pd_port) &&
 		(vdm_cmd_flags & VDM_CMD_FLAG_PD30_DUPLEX)) {
 		return true;
 	}
+#endif	/* CONFIG_USB_PD_REV30 */
 
 	if (pd_port->data_role == PD_ROLE_DFP)
 		shift += 1;
@@ -358,8 +357,6 @@ DECL_PE_STATE_REACTION(PD_DPM_MSG_DISCOVER_CABLE);
  * [BLOCK] Porcess Ctrl MSG
  */
 
-#ifdef CONFIG_USB_PD_ALT_MODE
-#ifdef CONFIG_USB_PD_DBG_DP_UFP_U_AUTO_ATTENTION
 static inline bool pd_ufp_u_auto_send_attention(struct pd_port *pd_port)
 {
 	struct dp_data *dp_data = pd_get_dp_data(pd_port);
@@ -372,23 +369,15 @@ static inline bool pd_ufp_u_auto_send_attention(struct pd_port *pd_port)
 
 	return false;
 }
-#endif	/* CONFIG_USB_PD_DBG_DP_UFP_U_AUTO_ATTENTION */
-#endif	/* CONFIG_USB_PD_ALT_MODE */
 
 static inline bool pd_process_ctrl_msg(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
-	struct pe_data *pe_data = &pd_port->pe_data;
-
 	/* VDM Only handle CtrlMsg = GoodCRC */
 
 	if (pd_event->msg != PD_CTRL_GOOD_CRC)
 		return false;
 
-	if (pe_data->vdm_state_flags &
-		VDM_STATE_FLAG_ENABLE_VDM_RESPONSE_TIMER)
-		pd_enable_timer(pd_port, pe_data->vdm_state_timer);
-
 	switch (pd_port->pe_state_curr) {
 #ifdef CONFIG_USB_PD_ALT_MODE
 #ifdef CONFIG_USB_PD_DBG_DP_UFP_U_AUTO_ATTENTION
@@ -406,13 +395,13 @@ static inline bool pd_process_ctrl_msg(
 
 #ifdef CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID
 	case PE_SRC_VDM_IDENTITY_REQUEST:
-		pe_data->power_cable_present = true;
+		pd_port->pe_data.power_cable_present = true;
 		return false;
 #endif	/* CONFIG_USB_PD_SRC_STARTUP_DISCOVER_ID */
 
 #ifdef CONFIG_USB_PD_DFP_READY_DISCOVER_ID
 	case PE_DFP_CBL_VDM_IDENTITY_REQUEST:
-		pe_data->power_cable_present = true;
+		pd_port->pe_data.power_cable_present = true;
 		return false;
 #endif	/* CONFIG_USB_PD_DFP_READY_DISCOVER_ID */
 
@@ -426,7 +415,7 @@ static inline bool pd_process_ctrl_msg(
 #endif	/* CONFIG_USB_PD_CUSTOM_VDM */
 	}
 
-	if (pe_data->vdm_state_flags
+	if (pd_port->pe_data.vdm_state_flags
 		& VDM_STATE_FLAG_BACK_READY_IF_RECV_GOOD_CRC) {
 		pe_transit_ready_state(pd_port);
 		return true;
@@ -448,8 +437,10 @@ bool pd_process_custom_vdm(struct pd_port *pd_port, bool svdm)
 	if (pd_port->data_role == PD_ROLE_UFP)
 		recv = true;
 
+#ifdef CONFIG_USB_PD_REV30
 	if (pd_check_rev30(pd_port) && svdm)
 		recv = true;
+#endif	/* CONFIG_USB_PD_REV30 */
 
 	if (pd_check_pe_state_ready(pd_port)) {
 		if (recv) {
@@ -470,8 +461,6 @@ bool pd_process_custom_vdm(struct pd_port *pd_port, bool svdm)
 static inline bool pd_process_uvdm(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
 #ifdef CONFIG_USB_PD_UVDM
 	/* support sop only */
 	if (pd_event->pd_msg->frame_type != TCPC_TX_SOP)
@@ -484,7 +473,7 @@ static inline bool pd_process_uvdm(
 #endif	/* CONFIG_USB_PD_UVDM */
 
 	/* TODO: Reply Not_Supported Message*/
-	PE_DBG("659 : Invalid UVDM\n");
+	PE_DBG("659 : Invalid UVDM\r\n");
 	return false;
 }
 
@@ -502,14 +491,17 @@ static const char * const pe_vdm_cmd_name[] = {
 	"Attention",
 };
 
-#if PE_INFO_ENABLE
+static const char *const pe_vdm_dp_cmd_name[] = {
+	"DPStatus",
+	"DPConfig",
+};
+
 static const char *const pe_vdm_cmd_type_name[] = {
 	"INIT",
 	"ACK",
 	"NACK",
 	"BUSY",
 };
-#endif /* PE_INFO_ENABLE */
 
 static inline const char *assign_vdm_cmd_name(uint8_t cmd)
 {
@@ -522,11 +514,6 @@ static inline const char *assign_vdm_cmd_name(uint8_t cmd)
 }
 
 #ifdef CONFIG_USB_PD_ALT_MODE
-static const char *const pe_vdm_dp_cmd_name[] = {
-	"DPStatus",
-	"DPConfig",
-};
-
 static inline const char *assign_vdm_dp_cmd_name(uint8_t cmd)
 {
 	if (cmd >= CMD_DP_STATUS) {
@@ -550,7 +537,6 @@ static inline void print_vdm_msg(
 	uint16_t svid;
 	const char *name = NULL;
 	uint32_t vdm_hdr = pd_port->curr_vdm_hdr;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	cmd = PD_VDO_CMD(vdm_hdr);
 	cmd_type = PD_VDO_CMDT(vdm_hdr);
@@ -566,12 +552,10 @@ static inline void print_vdm_msg(
 	if (name == NULL)
 		return;
 
-#if PE_INFO_ENABLE
 	if (cmd_type >= ARRAY_SIZE(pe_vdm_cmd_type_name))
 		return;
 
-	PE_INFO("%s:%s\n", name, pe_vdm_cmd_type_name[cmd_type]);
-#endif /* PE_INFO_ENABLE */
+	PE_INFO("%s:%s\r\n", name, pe_vdm_cmd_type_name[cmd_type]);
 
 #endif	/* PE_EVT_INFO_VDM_DIS */
 }
@@ -579,8 +563,6 @@ static inline void print_vdm_msg(
 static inline bool pd_process_sop_vdm(
 	struct pd_port *pd_port, struct pd_event *pd_event)
 {
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
-
 	if (pd_make_vdm_state_transit_sop(pd_port))
 		return true;
 
@@ -589,7 +571,7 @@ static inline bool pd_process_sop_vdm(
 		return true;
 #endif	/* CONFIG_USB_PD_SVDM */
 
-	PE_DBG("Unknown SVDM\n");
+	PE_DBG("Unknown SVDM\r\n");
 	return false;
 }
 
@@ -623,22 +605,16 @@ static inline bool pd_process_data_msg(
 		pd_port->pe_state_curr = pd_port->pe_pd_state;
 
 #if PE_DBG_RESET_VDM_DIS == 0
-		PE_DBG("reset vdm_state\n");
+		PE_DBG("reset vdm_state\r\n");
 #endif /* if PE_DBG_RESET_VDM_DIS == 0 */
 	}
 
 	print_vdm_msg(pd_port, pd_event);
 
-	if (pd_port->curr_vdm_svid != USB_SID_PD &&
-		!dpm_get_svdm_svid_data(pd_port, pd_port->curr_vdm_svid) &&
-		pd_port->curr_vdm_svid != USB_VID_MQP) {
-		PE_TRANSIT_STATE(pd_port, PE_UFP_VDM_SEND_NAK);
-		ret = true;
-	} else if (pd_msg->frame_type == TCPC_TX_SOP_PRIME) {
+	if (pd_msg->frame_type == TCPC_TX_SOP_PRIME)
 		ret = pd_process_sop_prime_vdm(pd_port, pd_event);
-	} else {
+	else
 		ret = pd_process_sop_vdm(pd_port, pd_event);
-	}
 
 	return ret;
 }
@@ -670,11 +646,10 @@ static inline bool pd_process_hw_msg(
 		struct pd_port *pd_port, struct pd_event *pd_event)
 {
 	struct pe_data *pe_data = &pd_port->pe_data;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (pd_event->msg == PD_HW_TX_DISCARD &&
 		(pe_data->vdm_discard_retry_count < 10)) {
-		PE_INFO("vdm_discard_retry\n");
+		PE_INFO("vdm_discard_retry\r\n");
 		pe_data->vdm_discard_retry_flag = true;
 		pe_data->vdm_discard_retry_count++;
 	}
@@ -687,7 +662,7 @@ static inline bool pd_process_hw_msg(
 	case PD_HW_RETRY_VDM:
 		if (pd_port->pe_data.vdm_state_timer)
 			return pd_make_vdm_state_transit_nak(pd_port);
-		PE_DBG("RetryVDM\n");
+		PE_DBG("RetryVDM\r\n");
 		return pd_process_sop_vdm(pd_port, pd_event);
 	}
 
@@ -765,11 +740,14 @@ static inline bool pd_process_tcp_cable_event(
 {
 	bool ret;
 	int tcp_ret;
-#ifdef CONFIG_PD_DISCOVER_CABLE_ID
 	bool role_check = true;
 
+#ifdef CONFIG_PD_DISCOVER_CABLE_ID
+
+#ifdef CONFIG_USB_PD_REV30
 	if (pd_check_rev30(pd_port))
 		role_check = pd_port->vconn_role;
+#endif	/* CONFIG_USB_PD_REV30 */
 
 	if (role_check) {
 		ret = PE_MAKE_STATE_TRANSIT(PD_DPM_MSG_DISCOVER_CABLE);
@@ -845,9 +823,11 @@ static inline void pd_parse_tcp_dpm_evt_uvdm(struct pd_port *pd_port)
 		vdm_data->vdos, sizeof(uint32_t) * vdm_data->cnt);
 
 #ifdef CONFIG_USB_PD_SVDM
+#ifdef CONFIG_USB_PD_REV30
 	if (pd_check_rev30(pd_port) &&
 		(pd_port->uvdm_data[0] & VDO_SVDM_TYPE))
 		pd_port->uvdm_data[0] |= VDO_SVDM_VERS(SVDM_REV20);
+#endif	/* CONFIG_USB_PD_REV30 */
 #endif	/* CONFIG_USB_PD_SVDM */
 }
 #endif	/* CONFIG_USB_PD_CUSTOM_VDM */
@@ -862,7 +842,6 @@ static inline void pd_parse_tcp_dpm_evt_from_tcpm(
 		break;
 #endif	/* CONFIG_USB_PD_KEEP_SVIDS */
 
-#ifdef CONFIG_USB_PD_ALT_MODE
 	case TCP_DPM_EVT_DISCOVER_MODES:
 	case TCP_DPM_EVT_ENTER_MODE:
 	case TCP_DPM_EVT_EXIT_MODE:
@@ -882,7 +861,6 @@ static inline void pd_parse_tcp_dpm_evt_from_tcpm(
 		pd_parse_tcp_dpm_evt_dp_config(pd_port);
 		break;
 #endif	/* CONFIG_USB_PD_ALT_MODE_DFP */
-#endif	/* CONFIG_USB_PD_ALT_MODE */
 
 #ifdef CONFIG_USB_PD_CUSTOM_VDM
 	case TCP_DPM_EVT_UVDM:
@@ -902,7 +880,6 @@ static inline bool pd_process_tcp_msg(
 		struct pd_port *pd_port, struct pd_event *pd_event)
 {
 	uint8_t new_state;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (pd_event->msg == TCP_DPM_EVT_DISCOVER_CABLE)
 		return pd_process_tcp_cable_event(pd_port, pd_event);
@@ -910,7 +887,7 @@ static inline bool pd_process_tcp_msg(
 	if (!pd_check_pe_state_ready(pd_port)) {
 		pd_notify_tcp_event_1st_result(
 			pd_port, TCP_DPM_RET_DENIED_NOT_READY);
-		PE_DBG("skip vdm_request, not ready_state (%d)\n",
+		PE_DBG("skip vdm_request, not ready_state (%d)\r\n",
 					pd_port->pe_state_curr);
 		return false;
 	}
@@ -926,7 +903,7 @@ static inline bool pd_process_tcp_msg(
 	if (!pd_check_tcp_msg_valid(pd_port, new_state)) {
 		pd_notify_tcp_event_1st_result(
 			pd_port, TCP_DPM_RET_DENIED_WRONG_DATA_ROLE);
-		PE_DBG("skip vdm_request, WRONG DATA ROLE\n");
+		PE_DBG("skip vdm_request, WRONG DATA ROLE\r\n");
 		return false;
 	}
 
diff --git a/drivers/misc/mediatek/typec/tcpc/rt_pd_manager.c b/drivers/misc/mediatek/typec/tcpc/rt_pd_manager.c
deleted file mode 100644
index df5c8f5..0000000
--- a/drivers/misc/mediatek/typec/tcpc/rt_pd_manager.c
+++ /dev/null
@@ -1,697 +0,0 @@
-/*
- * Copyright (C) 2021 MediaTek Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/platform_device.h>
-#include <linux/usb/typec.h>
-
-#include "inc/tcpci_typec.h"
-#include <mt-plat/charger_class.h>
-#include <mt-plat/mtk_boot.h>
-#include <mt-plat/mtk_charger.h>
-#include "../../accdet/mt6359/accdet.h"
-#include <linux/soc/mediatek/ocp96011-i2c.h>
-
-#define RT_PD_MANAGER_VERSION	"1.0.6_MTK"
-#ifndef CONFIG_CHARGE_MACRO_P530
-extern bool batt_protect_powerpath;
-#endif
-struct rt_pd_manager_data {
-	struct device *dev;
-	struct charger_device *chg_dev;
-	struct charger_consumer *chg_consumer;
-	struct tcpc_device *tcpc;
-	struct notifier_block pd_nb;
-	bool tcpc_kpoc;
-	int sink_mv_new;
-	int sink_ma_new;
-	int sink_mv_old;
-	int sink_ma_old;
-
-	struct typec_capability typec_caps;
-	struct typec_port *typec_port;
-	struct typec_partner *partner;
-	struct typec_partner_desc partner_desc;
-	struct usb_pd_identity partner_identity;
-};
-
-void __attribute__((weak)) usb_dpdm_pulldown(bool enable)
-{
-	pr_notice("%s is not defined\n", __func__);
-}
-
-#if defined(CONFIG_OCP96011_I2C)
-extern void typec_headphone_irq_handler(int state);
-#endif
-
-static int pd_tcp_notifier_call(struct notifier_block *nb,
-				unsigned long event, void *data)
-{
-	int ret = 0;
-	struct tcp_notify *noti = data;
-	struct rt_pd_manager_data *rpmd =
-		container_of(nb, struct rt_pd_manager_data, pd_nb);
-	uint8_t old_state = TYPEC_UNATTACHED, new_state = TYPEC_UNATTACHED;
-	enum typec_pwr_opmode opmode = TYPEC_PWR_MODE_USB;
-	uint32_t partner_vdos[VDO_MAX_NR];
-
-	switch (event) {
-	case TCP_NOTIFY_SINK_VBUS:
-		rpmd->sink_mv_new = noti->vbus_state.mv;
-		rpmd->sink_ma_new = noti->vbus_state.ma;
-		dev_info(rpmd->dev, "%s sink vbus %dmV %dmA type(0x%02X)\n",
-				    __func__, rpmd->sink_mv_new,
-				    rpmd->sink_ma_new, noti->vbus_state.type);
-
-		if ((rpmd->sink_mv_new != rpmd->sink_mv_old) ||
-		    (rpmd->sink_ma_new != rpmd->sink_ma_old)) {
-			rpmd->sink_mv_old = rpmd->sink_mv_new;
-			rpmd->sink_ma_old = rpmd->sink_ma_new;
-			if (rpmd->sink_mv_new && rpmd->sink_ma_new) {
-#ifndef CONFIG_CHARGE_MACRO_P530
-				if (batt_protect_powerpath) {
-#endif
-					charger_manager_enable_power_path(
-						rpmd->chg_consumer, MAIN_CHARGER, true);
-#ifndef CONFIG_CHARGE_MACRO_P530
-				} else {
-					pr_info("%s batt_protect_powerpath=%d\n", __func__,batt_protect_powerpath);
-				}
-#endif
-			} else if (!rpmd->tcpc_kpoc) {
-				charger_manager_enable_power_path(
-					rpmd->chg_consumer, MAIN_CHARGER,
-					false);
-			}
-		}
-		break;
-	case TCP_NOTIFY_TYPEC_STATE:
-		old_state = noti->typec_state.old_state;
-		new_state = noti->typec_state.new_state;
-		if (old_state == TYPEC_UNATTACHED &&
-		    (new_state == TYPEC_ATTACHED_SNK ||
-		     new_state == TYPEC_ATTACHED_NORP_SRC ||
-		     new_state == TYPEC_ATTACHED_CUSTOM_SRC ||
-		     new_state == TYPEC_ATTACHED_DBGACC_SNK)) {
-			dev_info(rpmd->dev,
-				 "%s Charger plug in, polarity = %d\n",
-				 __func__, noti->typec_state.polarity);
-			/*
-			 * start charger type detection,
-			 * and enable device connection
-			 */
-
-			typec_set_data_role(rpmd->typec_port, TYPEC_DEVICE);
-			typec_set_pwr_role(rpmd->typec_port, TYPEC_SINK);
-			typec_set_pwr_opmode(rpmd->typec_port,
-					     noti->typec_state.rp_level -
-					     TYPEC_CC_VOLT_SNK_DFT);
-			typec_set_vconn_role(rpmd->typec_port, TYPEC_SINK);
-		} else if ((old_state == TYPEC_ATTACHED_SNK ||
-			    old_state == TYPEC_ATTACHED_NORP_SRC ||
-			    old_state == TYPEC_ATTACHED_CUSTOM_SRC ||
-			    old_state == TYPEC_ATTACHED_DBGACC_SNK) &&
-			    new_state == TYPEC_UNATTACHED) {
-			dev_info(rpmd->dev, "%s Charger plug out\n", __func__);
-			/*
-			 * report charger plug-out,
-			 * and disable device connection
-			 */
-		} else if (old_state == TYPEC_UNATTACHED &&
-			   (new_state == TYPEC_ATTACHED_SRC ||
-			    new_state == TYPEC_ATTACHED_DEBUG)) {
-			dev_info(rpmd->dev,
-				 "%s OTG plug in, polarity = %d\n",
-				 __func__, noti->typec_state.polarity);
-			/* enable host connection */
-
-			typec_set_data_role(rpmd->typec_port, TYPEC_HOST);
-			typec_set_pwr_role(rpmd->typec_port, TYPEC_SOURCE);
-			switch (noti->typec_state.local_rp_level) {
-			case TYPEC_RP_3_0:
-				opmode = TYPEC_PWR_MODE_3_0A;
-				break;
-			case TYPEC_RP_1_5:
-				opmode = TYPEC_PWR_MODE_1_5A;
-				break;
-			case TYPEC_RP_DFT:
-			default:
-				opmode = TYPEC_PWR_MODE_USB;
-				break;
-			}
-			typec_set_pwr_opmode(rpmd->typec_port, opmode);
-			typec_set_vconn_role(rpmd->typec_port, TYPEC_SOURCE);
-		} else if ((old_state == TYPEC_ATTACHED_SRC ||
-			    old_state == TYPEC_ATTACHED_DEBUG) &&
-			    new_state == TYPEC_UNATTACHED) {
-			dev_info(rpmd->dev, "%s OTG plug out\n", __func__);
-			/* disable host connection */
-		} else if (old_state == TYPEC_UNATTACHED &&
-			   new_state == TYPEC_ATTACHED_AUDIO) {
-			dev_info(rpmd->dev, "%s Audio plug in\n", __func__);
-			/* enable AudioAccessory connection */
-#if defined(CONFIG_OCP96011_I2C)
-			ocp96011_switch_event(0);
-			typec_headphone_irq_handler(1);
-#endif
-		} else if (old_state == TYPEC_ATTACHED_AUDIO &&
-			   new_state == TYPEC_UNATTACHED) {
-			dev_info(rpmd->dev, "%s Audio plug out\n", __func__);
-			/* disable AudioAccessory connection */
-#if defined(CONFIG_OCP96011_I2C)
-			ocp96011_switch_event(1);
-			typec_headphone_irq_handler(0);
-#endif
-		}
-
-		if (new_state == TYPEC_UNATTACHED) {
-			typec_unregister_partner(rpmd->partner);
-			rpmd->partner = NULL;
-			if (rpmd->typec_caps.prefer_role == TYPEC_SOURCE) {
-				typec_set_data_role(rpmd->typec_port,
-						    TYPEC_HOST);
-				typec_set_pwr_role(rpmd->typec_port,
-						   TYPEC_SOURCE);
-				typec_set_pwr_opmode(rpmd->typec_port,
-						     TYPEC_PWR_MODE_USB);
-				typec_set_vconn_role(rpmd->typec_port,
-						     TYPEC_SOURCE);
-			} else {
-				typec_set_data_role(rpmd->typec_port,
-						    TYPEC_DEVICE);
-				typec_set_pwr_role(rpmd->typec_port,
-						   TYPEC_SINK);
-				typec_set_pwr_opmode(rpmd->typec_port,
-						     TYPEC_PWR_MODE_USB);
-				typec_set_vconn_role(rpmd->typec_port,
-						     TYPEC_SINK);
-			}
-		} else if (!rpmd->partner) {
-			memset(&rpmd->partner_identity, 0,
-			       sizeof(rpmd->partner_identity));
-			rpmd->partner_desc.usb_pd = false;
-			switch (new_state) {
-			case TYPEC_ATTACHED_AUDIO:
-				rpmd->partner_desc.accessory =
-					TYPEC_ACCESSORY_AUDIO;
-				break;
-			case TYPEC_ATTACHED_DEBUG:
-			case TYPEC_ATTACHED_DBGACC_SNK:
-			case TYPEC_ATTACHED_CUSTOM_SRC:
-				rpmd->partner_desc.accessory =
-					TYPEC_ACCESSORY_DEBUG;
-				break;
-			default:
-				rpmd->partner_desc.accessory =
-					TYPEC_ACCESSORY_NONE;
-				break;
-			}
-			rpmd->partner = typec_register_partner(rpmd->typec_port,
-					&rpmd->partner_desc);
-			if (!rpmd->partner)
-				dev_notice(rpmd->dev,
-					   "%s typec register partner fail\n",
-					   __func__);
-		}
-		break;
-	case TCP_NOTIFY_PR_SWAP:
-		dev_info(rpmd->dev, "%s power role swap, new role = %d\n",
-				    __func__, noti->swap_state.new_role);
-		if (noti->swap_state.new_role == PD_ROLE_SINK) {
-			dev_info(rpmd->dev, "%s swap power role to sink\n",
-					    __func__);
-			/*
-			 * report charger plug-in without charger type detection
-			 * to not interfering with USB2.0 communication
-			 */
-
-			typec_set_pwr_role(rpmd->typec_port, TYPEC_SINK);
-		} else if (noti->swap_state.new_role == PD_ROLE_SOURCE) {
-			dev_info(rpmd->dev, "%s swap power role to source\n",
-					    __func__);
-			/* report charger plug-out */
-
-			typec_set_pwr_role(rpmd->typec_port, TYPEC_SOURCE);
-		}
-		break;
-	case TCP_NOTIFY_DR_SWAP:
-		dev_info(rpmd->dev, "%s data role swap, new role = %d\n",
-				    __func__, noti->swap_state.new_role);
-		if (noti->swap_state.new_role == PD_ROLE_UFP) {
-			dev_info(rpmd->dev, "%s swap data role to device\n",
-					    __func__);
-			/*
-			 * disable host connection,
-			 * and enable device connection
-			 */
-
-			typec_set_data_role(rpmd->typec_port, TYPEC_DEVICE);
-		} else if (noti->swap_state.new_role == PD_ROLE_DFP) {
-			dev_info(rpmd->dev, "%s swap data role to host\n",
-					    __func__);
-			/*
-			 * disable device connection,
-			 * and enable host connection
-			 */
-
-			typec_set_data_role(rpmd->typec_port, TYPEC_HOST);
-		}
-		break;
-	case TCP_NOTIFY_VCONN_SWAP:
-		dev_info(rpmd->dev, "%s vconn role swap, new role = %d\n",
-				    __func__, noti->swap_state.new_role);
-		if (noti->swap_state.new_role) {
-			dev_info(rpmd->dev, "%s swap vconn role to on\n",
-					    __func__);
-			typec_set_vconn_role(rpmd->typec_port, TYPEC_SOURCE);
-		} else {
-			dev_info(rpmd->dev, "%s swap vconn role to off\n",
-					    __func__);
-			typec_set_vconn_role(rpmd->typec_port, TYPEC_SINK);
-		}
-		break;
-	case TCP_NOTIFY_EXT_DISCHARGE:
-		dev_info(rpmd->dev, "%s ext discharge = %d\n",
-				    __func__, noti->en_state.en);
-		charger_dev_enable_discharge(rpmd->chg_dev, noti->en_state.en);
-		break;
-	case TCP_NOTIFY_PD_STATE:
-		dev_info(rpmd->dev, "%s pd state = %d\n",
-				    __func__, noti->pd_state.connected);
-		switch (noti->pd_state.connected) {
-		case PD_CONNECT_NONE:
-			break;
-		case PD_CONNECT_HARD_RESET:
-			break;
-		case PD_CONNECT_PE_READY_SNK:
-		case PD_CONNECT_PE_READY_SNK_PD30:
-		case PD_CONNECT_PE_READY_SNK_APDO:
-		case PD_CONNECT_PE_READY_SRC:
-		case PD_CONNECT_PE_READY_SRC_PD30:
-			typec_set_pwr_opmode(rpmd->typec_port,
-					     TYPEC_PWR_MODE_PD);
-			if (!rpmd->partner)
-				break;
-			ret = tcpm_inquire_pd_partner_inform(rpmd->tcpc,
-							     partner_vdos);
-			if (ret != TCPM_SUCCESS)
-				break;
-			rpmd->partner_identity.id_header = partner_vdos[0];
-			rpmd->partner_identity.cert_stat = partner_vdos[1];
-			rpmd->partner_identity.product = partner_vdos[2];
-			typec_partner_set_identity(rpmd->partner);
-			break;
-		};
-		break;
-	case TCP_NOTIFY_WD_STATUS:
-		dev_info(rpmd->dev, "%s wd status = %d\n",
-				    __func__, noti->wd_status.water_detected);
-
-		if (noti->wd_status.water_detected) {
-			usb_dpdm_pulldown(false);
-			if (!rpmd->tcpc_kpoc)
-				break;
-			dev_info(rpmd->dev, "%s Water is detected in KPOC\n",
-					    __func__);
-			charger_manager_enable_high_voltage_charging(
-					rpmd->chg_consumer, false);
-		} else {
-			usb_dpdm_pulldown(true);
-			if (!rpmd->tcpc_kpoc)
-				break;
-			dev_info(rpmd->dev, "%s Water is removed in KPOC\n",
-					    __func__);
-			charger_manager_enable_high_voltage_charging(
-					rpmd->chg_consumer, true);
-		}
-		break;
-	case TCP_NOTIFY_CABLE_TYPE:
-		dev_info(rpmd->dev, "%s cable type = %d\n",
-				    __func__, noti->cable_type.type);
-		break;
-	default:
-		break;
-	};
-	return NOTIFY_OK;
-}
-
-static int tcpc_typec_try_role(const struct typec_capability *cap, int role)
-{
-	struct rt_pd_manager_data *rpmd =
-		container_of(cap, struct rt_pd_manager_data, typec_caps);
-	uint8_t typec_role = TYPEC_ROLE_UNKNOWN;
-
-	dev_info(rpmd->dev, "%s role = %d\n", __func__, role);
-
-	switch (role) {
-	case TYPEC_NO_PREFERRED_ROLE:
-		typec_role = TYPEC_ROLE_DRP;
-		break;
-	case TYPEC_SINK:
-		typec_role = TYPEC_ROLE_TRY_SNK;
-		break;
-	case TYPEC_SOURCE:
-		typec_role = TYPEC_ROLE_TRY_SRC;
-		break;
-	default:
-		return 0;
-	}
-
-	return tcpm_typec_change_role_postpone(rpmd->tcpc, typec_role, true);
-}
-
-static int tcpc_typec_dr_set(const struct typec_capability *cap,
-			     enum typec_data_role role)
-{
-	int ret = 0;
-	struct rt_pd_manager_data *rpmd =
-		container_of(cap, struct rt_pd_manager_data, typec_caps);
-	uint8_t data_role = tcpm_inquire_pd_data_role(rpmd->tcpc);
-	bool do_swap = false;
-
-	dev_info(rpmd->dev, "%s role = %d\n", __func__, role);
-
-	if (role == TYPEC_HOST) {
-		if (data_role == PD_ROLE_UFP) {
-			do_swap = true;
-			data_role = PD_ROLE_DFP;
-		}
-	} else if (role == TYPEC_DEVICE) {
-		if (data_role == PD_ROLE_DFP) {
-			do_swap = true;
-			data_role = PD_ROLE_UFP;
-		}
-	} else {
-		dev_notice(rpmd->dev, "%s invalid role\n", __func__);
-		return -EINVAL;
-	}
-
-	if (do_swap) {
-		ret = tcpm_dpm_pd_data_swap(rpmd->tcpc, data_role, NULL);
-		if (ret != TCPM_SUCCESS) {
-			dev_notice(rpmd->dev, "%s data role swap fail(%d)\n",
-					      __func__, ret);
-			return -EPERM;
-		}
-	}
-
-	return 0;
-}
-
-static int tcpc_typec_pr_set(const struct typec_capability *cap,
-			     enum typec_role role)
-{
-	int ret = 0;
-	struct rt_pd_manager_data *rpmd =
-		container_of(cap, struct rt_pd_manager_data, typec_caps);
-	uint8_t power_role = tcpm_inquire_pd_power_role(rpmd->tcpc);
-	bool do_swap = false;
-
-	dev_info(rpmd->dev, "%s role = %d\n", __func__, role);
-
-	if (role == TYPEC_SOURCE) {
-		if (power_role == PD_ROLE_SINK) {
-			do_swap = true;
-			power_role = PD_ROLE_SOURCE;
-		}
-	} else if (role == TYPEC_SINK) {
-		if (power_role == PD_ROLE_SOURCE) {
-			do_swap = true;
-			power_role = PD_ROLE_SINK;
-		}
-	} else {
-		dev_notice(rpmd->dev, "%s invalid role\n", __func__);
-		return -EINVAL;
-	}
-
-	if (do_swap) {
-		ret = tcpm_dpm_pd_power_swap(rpmd->tcpc, power_role, NULL);
-		if (ret == TCPM_ERROR_NO_PD_CONNECTED)
-			ret = tcpm_typec_role_swap(rpmd->tcpc);
-		if (ret != TCPM_SUCCESS) {
-			dev_notice(rpmd->dev, "%s power role swap fail(%d)\n",
-					      __func__, ret);
-			return -EPERM;
-		}
-	}
-
-	return 0;
-}
-
-static int tcpc_typec_vconn_set(const struct typec_capability *cap,
-				enum typec_role role)
-{
-	int ret = 0;
-	struct rt_pd_manager_data *rpmd =
-		container_of(cap, struct rt_pd_manager_data, typec_caps);
-	uint8_t vconn_role = tcpm_inquire_pd_vconn_role(rpmd->tcpc);
-	bool do_swap = false;
-
-	dev_info(rpmd->dev, "%s role = %d\n", __func__, role);
-
-	if (role == TYPEC_SOURCE) {
-		if (vconn_role == PD_ROLE_VCONN_OFF) {
-			do_swap = true;
-			vconn_role = PD_ROLE_VCONN_ON;
-		}
-	} else if (role == TYPEC_SINK) {
-		if (vconn_role == PD_ROLE_VCONN_ON) {
-			do_swap = true;
-			vconn_role = PD_ROLE_VCONN_OFF;
-		}
-	} else {
-		dev_notice(rpmd->dev, "%s invalid role\n", __func__);
-		return -EINVAL;
-	}
-
-	if (do_swap) {
-		ret = tcpm_dpm_pd_vconn_swap(rpmd->tcpc, vconn_role, NULL);
-		if (ret != TCPM_SUCCESS) {
-			dev_notice(rpmd->dev, "%s vconn role swap fail(%d)\n",
-					      __func__, ret);
-			return -EPERM;
-		}
-	}
-
-	return 0;
-}
-
-static int tcpc_typec_port_type_set(const struct typec_capability *cap,
-				    enum typec_port_type type)
-{
-	struct rt_pd_manager_data *rpmd =
-		container_of(cap, struct rt_pd_manager_data, typec_caps);
-	bool as_sink = tcpc_typec_is_act_as_sink_role(rpmd->tcpc);
-	uint8_t typec_role = TYPEC_ROLE_UNKNOWN;
-
-	dev_info(rpmd->dev, "%s type = %d, as_sink = %d\n",
-			    __func__, type, as_sink);
-
-	switch (type) {
-	case TYPEC_PORT_UFP:
-		if (as_sink)
-			return 0;
-		break;
-	case TYPEC_PORT_DFP:
-		if (!as_sink)
-			return 0;
-		break;
-	case TYPEC_PORT_DRP:
-		if (cap->prefer_role == TYPEC_SOURCE)
-			typec_role = TYPEC_ROLE_TRY_SRC;
-		else if (cap->prefer_role == TYPEC_SINK)
-			typec_role = TYPEC_ROLE_TRY_SNK;
-		else
-			typec_role = TYPEC_ROLE_DRP;
-		return tcpm_typec_change_role(rpmd->tcpc, typec_role);
-	default:
-		return 0;
-	}
-
-	return tcpm_typec_role_swap(rpmd->tcpc);
-}
-
-static int typec_init(struct rt_pd_manager_data *rpmd)
-{
-	int ret = 0;
-
-	rpmd->typec_caps.type = TYPEC_PORT_DRP;
-	rpmd->typec_caps.revision = 0x0120;
-	rpmd->typec_caps.pd_revision = 0x0300;
-	switch (rpmd->tcpc->desc.role_def) {
-	case TYPEC_ROLE_SRC:
-	case TYPEC_ROLE_TRY_SRC:
-		rpmd->typec_caps.prefer_role = TYPEC_SOURCE;
-		break;
-	case TYPEC_ROLE_SNK:
-	case TYPEC_ROLE_TRY_SNK:
-		rpmd->typec_caps.prefer_role = TYPEC_SINK;
-		break;
-	default:
-		rpmd->typec_caps.prefer_role = TYPEC_NO_PREFERRED_ROLE;
-		break;
-	}
-	rpmd->typec_caps.try_role = tcpc_typec_try_role;
-	rpmd->typec_caps.dr_set = tcpc_typec_dr_set;
-	rpmd->typec_caps.pr_set = tcpc_typec_pr_set;
-	rpmd->typec_caps.vconn_set = tcpc_typec_vconn_set;
-	rpmd->typec_caps.port_type_set = tcpc_typec_port_type_set;
-
-	rpmd->typec_port = typec_register_port(rpmd->dev, &rpmd->typec_caps);
-	if (!rpmd->typec_port) {
-		ret = -ENOMEM;
-		dev_notice(rpmd->dev, "%s typec register port fail(%d)\n",
-				      __func__, ret);
-		goto out;
-	}
-
-	rpmd->partner_desc.identity = &rpmd->partner_identity;
-out:
-	return ret;
-}
-
-static int rt_pd_manager_probe(struct platform_device *pdev)
-{
-	int ret = 0;
-	struct rt_pd_manager_data *rpmd = NULL;
-
-	dev_info(&pdev->dev, "%s (%s)\n", __func__, RT_PD_MANAGER_VERSION);
-
-	rpmd = devm_kzalloc(&pdev->dev, sizeof(*rpmd), GFP_KERNEL);
-	if (!rpmd)
-		return -ENOMEM;
-
-	rpmd->dev = &pdev->dev;
-
-	rpmd->chg_dev = get_charger_by_name("primary_chg");
-	if (!rpmd->chg_dev) {
-		dev_notice(rpmd->dev, "%s get chg dev fail\n", __func__);
-		ret = -ENODEV;
-		goto err_get_chg_dev;
-	}
-
-	rpmd->chg_consumer = charger_manager_get_by_name(rpmd->dev,
-							 "charger_port1");
-	if (!rpmd->chg_consumer) {
-		dev_notice(rpmd->dev, "%s get chg consumer fail\n", __func__);
-		ret = -ENODEV;
-		goto err_get_chg_consumer;
-	}
-
-	rpmd->tcpc = tcpc_dev_get_by_name("type_c_port0");
-	if (!rpmd->tcpc) {
-		dev_notice(rpmd->dev, "%s get tcpc dev fail\n", __func__);
-		ret = -ENODEV;
-		goto err_get_tcpc_dev;
-	}
-
-	ret = get_boot_mode();
-	if (ret == KERNEL_POWER_OFF_CHARGING_BOOT ||
-	    ret == LOW_POWER_OFF_CHARGING_BOOT)
-		rpmd->tcpc_kpoc = true;
-	else
-		rpmd->tcpc_kpoc = false;
-	dev_info(rpmd->dev, "%s tcpc_kpoc = %d\n", __func__, rpmd->tcpc_kpoc);
-
-	rpmd->sink_mv_old = -1;
-	rpmd->sink_ma_old = -1;
-
-	ret = typec_init(rpmd);
-	if (ret < 0) {
-		dev_notice(rpmd->dev, "%s init typec fail(%d)\n",
-				      __func__, ret);
-		goto err_init_typec;
-	}
-
-	rpmd->pd_nb.notifier_call = pd_tcp_notifier_call;
-	ret = register_tcp_dev_notifier(rpmd->tcpc, &rpmd->pd_nb,
-					TCP_NOTIFY_TYPE_ALL);
-	if (ret < 0) {
-		dev_notice(rpmd->dev, "%s register tcpc notifier fail(%d)\n",
-				      __func__, ret);
-		goto err_reg_tcpc_notifier;
-	}
-
-	platform_set_drvdata(pdev, rpmd);
-	dev_info(rpmd->dev, "%s OK!!\n", __func__);
-	return 0;
-
-err_reg_tcpc_notifier:
-	typec_unregister_port(rpmd->typec_port);
-err_init_typec:
-err_get_tcpc_dev:
-err_get_chg_consumer:
-err_get_chg_dev:
-	return ret;
-}
-
-static int rt_pd_manager_remove(struct platform_device *pdev)
-{
-	int ret = 0;
-	struct rt_pd_manager_data *rpmd = platform_get_drvdata(pdev);
-
-	if (!rpmd)
-		return -EINVAL;
-
-	ret = unregister_tcp_dev_notifier(rpmd->tcpc, &rpmd->pd_nb,
-					  TCP_NOTIFY_TYPE_ALL);
-	if (ret < 0)
-		dev_notice(rpmd->dev, "%s unregister tcpc notifier fail(%d)\n",
-				      __func__, ret);
-
-	typec_unregister_port(rpmd->typec_port);
-
-	return ret;
-}
-
-static const struct of_device_id rt_pd_manager_of_match[] = {
-	{ .compatible = "mediatek,rt-pd-manager" },
-	{ }
-};
-MODULE_DEVICE_TABLE(of, rt_pd_manager_of_match);
-
-static struct platform_driver rt_pd_manager_driver = {
-	.driver = {
-		.name = "rt-pd-manager",
-		.of_match_table = of_match_ptr(rt_pd_manager_of_match),
-	},
-	.probe = rt_pd_manager_probe,
-	.remove = rt_pd_manager_remove,
-};
-
-static int __init rt_pd_manager_init(void)
-{
-	return platform_driver_register(&rt_pd_manager_driver);
-}
-late_initcall(rt_pd_manager_init);
-
-static void __exit rt_pd_manager_exit(void)
-{
-	platform_driver_unregister(&rt_pd_manager_driver);
-}
-module_exit(rt_pd_manager_exit);
-
-MODULE_AUTHOR("Jeff Chang");
-MODULE_DESCRIPTION("Richtek pd manager driver");
-MODULE_LICENSE("GPL");
-MODULE_VERSION(RT_PD_MANAGER_VERSION);
-
-/*
- * Release Note
- * 1.0.6
- * (1) Register typec_port
- * (2) Remove unused parts
- * (3) Add rt_pd_manager_remove()
- */
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpc_mt6360.c b/drivers/misc/mediatek/typec/tcpc/tcpc_mt6360.c
index d0d93a0..03014ea 100644
--- a/drivers/misc/mediatek/typec/tcpc/tcpc_mt6360.c
+++ b/drivers/misc/mediatek/typec/tcpc/tcpc_mt6360.c
@@ -1,14 +1,15 @@
 /*
  * Copyright (C) 2018 MediaTek Inc.
+ * Copyright (C) 2019 XiaoMi, Inc.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* Seehttp://www.gnu.org/licenses/gpl-2.0.htmlfor more details.
  */
 
 #include <linux/init.h>
@@ -44,15 +45,22 @@
 #include <linux/sched/rt.h>
 #endif /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)) */
 
-#if defined(CONFIG_WATER_DETECTION) || defined(CONFIG_CABLE_TYPE_DETECTION)
+#if defined(CONFIG_WATER_DETECTION) || \
+	defined(CONFIG_CABLE_TYPE_DETECTION) || \
+	defined(CONFIG_TYPEC_OTP)
 #if CONFIG_MTK_GAUGE_VERSION == 30
 #include <mt-plat/charger_class.h>
 #endif /* CONFIG_MTK_GAUGE_VERSION == 30 */
-#endif /* CONFIG_WATER_DETECTION || CONFIG_CABLE_TYPE_DETECTION */
+#endif /* WATER_DETECTION || CABLE_TYPE_DETECTION || TYPEC_OTP */
+
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+/* MTK only */
+#include <mt-plat/mtk_boot.h>
+#endif /* CONFIG_MTK_KERNEL_POWER_OFF_CHARGING */
 
 /* #define DEBUG_GPIO	66 */
 
-#define MT6360_DRV_VERSION	"2.0.7_MTK"
+#define MT6360_DRV_VERSION	"2.0.2_MTK"
 
 #define MT6360_IRQ_WAKE_TIME	(500) /* ms */
 
@@ -75,8 +83,8 @@ struct mt6360_chip {
 	struct kthread_worker irq_worker;
 	struct kthread_work irq_work;
 	struct task_struct *irq_worker_task;
-	struct wakeup_source *irq_wake_lock;
-	struct wakeup_source *i2c_wake_lock;
+	struct wakeup_source irq_wake_lock;
+	struct wakeup_source i2c_wake_lock;
 
 	atomic_t poll_count;
 	struct delayed_work poll_work;
@@ -87,12 +95,11 @@ struct mt6360_chip {
 
 #ifdef CONFIG_MTK_TYPEC_WATER_DETECT_BY_PCB
 	int pcb_gpio;
-	int pcb_gpio_polarity;
 #endif /* CONFIG_MTK_TYPEC_WATER_DETECT_BY_PCB */
 
 #ifdef CONFIG_WATER_DETECTION
 	atomic_t wd_protect_rty;
-	struct wakeup_source *wd_wakeup_src;
+	struct wakeup_source wd_wakeup_src;
 #endif /* CONFIG_WATER_DETECTION */
 
 #ifdef CONFIG_WD_SBU_POLLING
@@ -109,14 +116,16 @@ struct mt6360_chip {
 	enum tcpc_cable_type init_cable_type;
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
 
-#if defined(CONFIG_WATER_DETECTION) || defined(CONFIG_CABLE_TYPE_DETECTION)
+#if defined(CONFIG_WATER_DETECTION) || \
+	defined(CONFIG_CABLE_TYPE_DETECTION) || \
+	defined(CONFIG_TYPEC_OTP)
 #if CONFIG_MTK_GAUGE_VERSION == 30
 	struct charger_device *chgdev;
 #endif /* CONFIG_MTK_GAUGE_VERSION == 30 */
-#endif /* CONFIG_WATER_DETECTION || CONFIG_CABLE_TYPE_DETECTION */
+#endif /* WATER_DETECTION || CABLE_TYPE_DETECTION || TYPEC_OTP */
 };
 
 struct mt6360_chip *g_chip = NULL;
 static const u8 mt6360_vend_alert_clearall[MT6360_VEND_INT_MAX] = {
 	0x3F, 0xDF, 0xFF, 0xFF, 0xFF,
 };
@@ -126,56 +134,56 @@ static const u8 mt6360_vend_alert_maskall[MT6360_VEND_INT_MAX] = {
 };
 
 #ifdef CONFIG_RT_REGMAP
-RT_REG_DECL(TCPC_V10_REG_VID, 2, RT_NORMAL, {});
-RT_REG_DECL(TCPC_V10_REG_PID, 2, RT_NORMAL, {});
-RT_REG_DECL(TCPC_V10_REG_DID, 2, RT_NORMAL, {});
-RT_REG_DECL(TCPC_V10_REG_TYPEC_REV, 2, RT_NORMAL, {});
-RT_REG_DECL(TCPC_V10_REG_PD_REV, 2, RT_NORMAL, {});
-RT_REG_DECL(TCPC_V10_REG_PDIF_REV, 2, RT_NORMAL, {});
+RT_REG_DECL(TCPC_V10_REG_VID, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_PID, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_DID, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TYPEC_REV, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_PD_REV, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_PDIF_REV, 2, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_ALERT, 2, RT_VOLATILE, {});
-RT_REG_DECL(TCPC_V10_REG_ALERT_MASK, 2, RT_NORMAL, {});
-RT_REG_DECL(TCPC_V10_REG_POWER_STATUS_MASK, 1, RT_NORMAL, {});
-RT_REG_DECL(TCPC_V10_REG_FAULT_STATUS_MASK, 1, RT_NORMAL, {});
-RT_REG_DECL(TCPC_V10_REG_EXT_STATUS_MASK, 1, RT_NORMAL, {});
-RT_REG_DECL(TCPC_V10_REG_TCPC_CTRL, 1, RT_NORMAL, {});
-RT_REG_DECL(TCPC_V10_REG_ROLE_CTRL, 1, RT_NORMAL, {});
-RT_REG_DECL(TCPC_V10_REG_FAULT_CTRL, 1, RT_NORMAL, {});
+RT_REG_DECL(TCPC_V10_REG_ALERT_MASK, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_POWER_STATUS_MASK, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_FAULT_STATUS_MASK, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_EXT_STATUS_MASK, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TCPC_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_ROLE_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_FAULT_CTRL, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_POWER_CTRL, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_CC_STATUS, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_POWER_STATUS, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_FAULT_STATUS, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_EXT_STATUS, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_COMMAND, 1, RT_VOLATILE, {});
-RT_REG_DECL(TCPC_V10_REG_MSG_HDR_INFO, 1, RT_NORMAL, {});
-RT_REG_DECL(TCPC_V10_REG_RX_DETECT, 1, RT_NORMAL, {});
+RT_REG_DECL(TCPC_V10_REG_MSG_HDR_INFO, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_RX_DETECT, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_RX_BYTE_CNT, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_RX_BUF_FRAME_TYPE, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_RX_HDR, 2, RT_VOLATILE, {});
-RT_REG_DECL(TCPC_V10_REG_RX_DATA, 28, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_RX_DATA, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_TRANSMIT, 1, RT_VOLATILE, {});
-RT_REG_DECL(TCPC_V10_REG_TX_BYTE_CNT, 1, RT_NORMAL, {});
-RT_REG_DECL(TCPC_V10_REG_TX_HDR, 2, RT_NORMAL, {});
-RT_REG_DECL(TCPC_V10_REG_TX_DATA, 28, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_PHY_CTRL1, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_PHY_CTRL2, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_PHY_CTRL3, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_PHY_CTRL4, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_PHY_CTRL5, 1, RT_NORMAL, {});
+RT_REG_DECL(TCPC_V10_REG_TX_BYTE_CNT, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TX_HDR, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TX_DATA, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_PHY_CTRL1, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_PHY_CTRL2, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_PHY_CTRL3, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_PHY_CTRL4, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_PHY_CTRL5, 1, RT_VOLATILE, {});
 RT_REG_DECL(MT6360_REG_PHY_CTRL6, 1, RT_VOLATILE, {});
-RT_REG_DECL(MT6360_REG_PHY_CTRL7, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_CLK_CTRL1, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_CLK_CTRL2, 1, RT_NORMAL, {});
+RT_REG_DECL(MT6360_REG_PHY_CTRL7, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_CLK_CTRL1, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_CLK_CTRL2, 1, RT_VOLATILE, {});
 RT_REG_DECL(MT6360_REG_PHY_CTRL8, 1, RT_VOLATILE, {});
-RT_REG_DECL(MT6360_REG_CC1_CTRL1, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_VCONN_CTRL1, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_MODE_CTRL1, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_MODE_CTRL2, 1, RT_NORMAL, {});
+RT_REG_DECL(MT6360_REG_CC1_CTRL1, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_VCONN_CTRL1, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_MODE_CTRL1, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_MODE_CTRL2, 1, RT_VOLATILE, {});
 RT_REG_DECL(MT6360_REG_MODE_CTRL3, 1, RT_VOLATILE, {});
-RT_REG_DECL(MT6360_REG_MT_MASK1, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_MT_MASK2, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_MT_MASK3, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_MT_MASK4, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_MT_MASK5, 1, RT_NORMAL, {});
+RT_REG_DECL(MT6360_REG_MT_MASK1, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_MT_MASK2, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_MT_MASK3, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_MT_MASK4, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_MT_MASK5, 1, RT_VOLATILE, {});
 RT_REG_DECL(MT6360_REG_MT_INT1, 1, RT_VOLATILE, {});
 RT_REG_DECL(MT6360_REG_MT_INT2, 1, RT_VOLATILE, {});
 RT_REG_DECL(MT6360_REG_MT_INT3, 1, RT_VOLATILE, {});
@@ -187,35 +195,36 @@ RT_REG_DECL(MT6360_REG_MT_ST3, 1, RT_VOLATILE, {});
 RT_REG_DECL(MT6360_REG_MT_ST4, 1, RT_VOLATILE, {});
 RT_REG_DECL(MT6360_REG_MT_ST5, 1, RT_VOLATILE, {});
 RT_REG_DECL(MT6360_REG_SWRESET, 1, RT_VOLATILE, {});
-RT_REG_DECL(MT6360_REG_DEBOUNCE_CTRL1, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_DRP_CTRL1, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_DRP_CTRL2, 2, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_PD3_CTRL, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_VBUS_DISC_CTRL, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_CTD_CTRL1, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_WATCHDOG_CTRL, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_I2CRST_CTRL, 1, RT_NORMAL, {});
+RT_REG_DECL(MT6360_REG_DEBOUNCE_CTRL1, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_DRP_CTRL1, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_DRP_CTRL2, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_DRP_CTRL3, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_PD3_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_VBUS_DISC_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_CTD_CTRL1, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_WATCHDOG_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_I2CRST_CTRL, 1, RT_VOLATILE, {});
 RT_REG_DECL(MT6360_REG_WD_DET_CTRL1, 1, RT_VOLATILE, {});
-RT_REG_DECL(MT6360_REG_WD_DET_CTRL2, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_WD_DET_CTRL3, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_WD_DET_CTRL4, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_WD_DET_CTRL5, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_WD_DET_CTRL6, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_WD_DET_CTRL7, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_WD_DET_CTRL8, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_PHY_CTRL9, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_PHY_CTRL10, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_PHY_CTRL11, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_PHY_CTRL12, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_PHY_CTRL13, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_PHY_CTRL14, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_RX_CTRL1, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_RX_CTRL2, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_VBUS_CTRL2, 1, RT_NORMAL, {});
-RT_REG_DECL(MT6360_REG_HILO_CTRL5, 1, RT_NORMAL, {});
+RT_REG_DECL(MT6360_REG_WD_DET_CTRL2, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_WD_DET_CTRL3, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_WD_DET_CTRL4, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_WD_DET_CTRL5, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_WD_DET_CTRL6, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_WD_DET_CTRL7, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_WD_DET_CTRL8, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_PHY_CTRL9, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_PHY_CTRL10, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_PHY_CTRL11, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_PHY_CTRL12, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_PHY_CTRL13, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_PHY_CTRL14, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_RX_CTRL1, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_RX_CTRL2, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_VBUS_CTRL2, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6360_REG_HILO_CTRL5, 1, RT_VOLATILE, {});
 RT_REG_DECL(MT6360_REG_VCONN_CTRL2, 1, RT_VOLATILE, {});
 RT_REG_DECL(MT6360_REG_VCONN_CTRL3, 1, RT_VOLATILE, {});
-RT_REG_DECL(MT6360_REG_DEBOUNCE_CTRL4, 1, RT_NORMAL, {});
+RT_REG_DECL(MT6360_REG_DEBOUNCE_CTRL4, 1, RT_VOLATILE, {});
 RT_REG_DECL(MT6360_REG_CTD_CTRL2, 1, RT_VOLATILE, {});
 
 static const rt_register_map_t mt6360_chip_regmap[] = {
@@ -283,6 +292,7 @@ static const rt_register_map_t mt6360_chip_regmap[] = {
 	RT_REG(MT6360_REG_DEBOUNCE_CTRL1),
 	RT_REG(MT6360_REG_DRP_CTRL1),
 	RT_REG(MT6360_REG_DRP_CTRL2),
+	RT_REG(MT6360_REG_DRP_CTRL3),
 	RT_REG(MT6360_REG_PD3_CTRL),
 	RT_REG(MT6360_REG_VBUS_DISC_CTRL),
 	RT_REG(MT6360_REG_CTD_CTRL1),
@@ -321,7 +331,7 @@ static int mt6360_read_device(void *client, u32 reg, int len, void *dst)
 	struct mt6360_chip *chip = i2c_get_clientdata(i2c);
 	int ret, count = MT6360_I2C_RETRY_CNT;
 
-	__pm_stay_awake(chip->i2c_wake_lock);
+	__pm_stay_awake(&chip->i2c_wake_lock);
 	down(&chip->suspend_lock);
 	while (count) {
 		if (len > 1) {
@@ -343,7 +353,7 @@ static int mt6360_read_device(void *client, u32 reg, int len, void *dst)
 	}
 out:
 	up(&chip->suspend_lock);
-	__pm_relax(chip->i2c_wake_lock);
+	__pm_relax(&chip->i2c_wake_lock);
 	return ret;
 }
 
@@ -354,7 +364,7 @@ static int mt6360_write_device(void *client, u32 reg, int len, const void *src)
 	struct mt6360_chip *chip = i2c_get_clientdata(i2c);
 	int ret, count = MT6360_I2C_RETRY_CNT;
 
-	__pm_stay_awake(chip->i2c_wake_lock);
+	__pm_stay_awake(&chip->i2c_wake_lock);
 	down(&chip->suspend_lock);
 	while (count) {
 		if (len > 1) {
@@ -376,7 +386,7 @@ static int mt6360_write_device(void *client, u32 reg, int len, const void *src)
 	}
 out:
 	up(&chip->suspend_lock);
-	__pm_relax(chip->i2c_wake_lock);
+	__pm_relax(&chip->i2c_wake_lock);
 	return ret;
 }
 
@@ -572,7 +582,7 @@ static int mt6360_regmap_init(struct mt6360_chip *chip)
 {
 	struct rt_regmap_properties *props;
 	char name[32];
-	int len, ret;
+	int len;
 
 	props = devm_kzalloc(chip->dev, sizeof(*props), GFP_KERNEL);
 	if (!props)
@@ -580,12 +590,10 @@ static int mt6360_regmap_init(struct mt6360_chip *chip)
 
 	props->register_num = MT6360_CHIP_REGMAP_SIZE;
 	props->rm = mt6360_chip_regmap;
-	props->rt_regmap_mode = RT_MULTI_BYTE |
-				RT_IO_PASS_THROUGH | RT_DBG_SPECIAL;
+	props->rt_regmap_mode = RT_MULTI_BYTE | RT_CACHE_DISABLE |
+				RT_IO_PASS_THROUGH | RT_DBG_GENERAL;
 
-	ret = snprintf(name, sizeof(name), "mt6360-%02x", chip->client->addr);
-	if (ret < 0)
-		return -EINVAL;
+	snprintf(name, sizeof(name), "mt6360-%02x", chip->client->addr);
 	len = strlen(name);
 	props->name = kzalloc(len + 1, GFP_KERNEL);
 	props->aliases = kzalloc(len + 1, GFP_KERNEL);
@@ -612,16 +620,11 @@ static void mt6360_regmap_deinit(struct mt6360_chip *chip)
 static inline int mt6360_software_reset(struct tcpc_device *tcpc)
 {
 	int ret;
-#ifdef CONFIG_RT_REGMAP
-	struct mt6360_chip *chip = tcpc_get_dev_data(tcpc);
-#endif /* CONFIG_RT_REGMAP */
 
 	ret = mt6360_i2c_write8(tcpc, MT6360_REG_SWRESET, 1);
 	if (ret < 0)
 		return ret;
-#ifdef CONFIG_RT_REGMAP
-	rt_regmap_cache_reload(chip->m_dev);
-#endif /* CONFIG_RT_REGMAP */
+
 	usleep_range(1000, 2000);
 	return 0;
 }
@@ -670,6 +673,11 @@ static int mt6360_init_vend_mask(struct tcpc_device *tcpc)
 		mask[MT6360_VEND_INT1] |= MT6360_M_WAKEUP;
 #endif	/* CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG */
 
+#ifdef CONFIG_TYPEC_OTP
+	if (tcpc->tcpc_flags & TCPC_FLAGS_TYPEC_OTP)
+		mask[MT6360_VEND_INT1] |= MT6360_M_OTD;
+#endif /* CONFIG_TYPEC_OTP */
+
 #ifdef CONFIG_WATER_DETECTION
 	if (tcpc->tcpc_flags & TCPC_FLAGS_WATER_DETECTION)
 		mask[MT6360_VEND_INT2] |= MT6360_M_WD_EVT;
@@ -679,6 +687,7 @@ static int mt6360_init_vend_mask(struct tcpc_device *tcpc)
 	if (tcpc->tcpc_flags & TCPC_FLAGS_CABLE_TYPE_DETECTION)
 		mask[MT6360_VEND_INT3] |= MT6360_M_CTD;
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
+	mask[MT6360_VEND_INT5] |= MT6360_M_RADET_CC;
 
 	return mt6360_i2c_block_write(tcpc, MT6360_REG_MT_MASK1,
 				      MT6360_VEND_INT_MAX, mask);
@@ -777,7 +786,7 @@ static irqreturn_t mt6360_intr_handler(int irq, void *data)
 {
 	struct mt6360_chip *chip = data;
 
-	__pm_wakeup_event(chip->irq_wake_lock, MT6360_IRQ_WAKE_TIME);
+	__pm_wakeup_event(&chip->irq_wake_lock, MT6360_IRQ_WAKE_TIME);
 
 #ifdef DEBUG_GPIO
 	gpio_set_value(DEBUG_GPIO, 0);
@@ -1000,9 +1009,7 @@ static int mt6360_init_alert(struct tcpc_device *tcpc)
 	name = devm_kzalloc(chip->dev, len + 5, GFP_KERNEL);
 	if (!name)
 		return -ENOMEM;
-	ret = snprintf(name, PAGE_SIZE, "%s-IRQ", chip->tcpc_desc->name);
-	if ((ret < 0) || (ret >= PAGE_SIZE - 1))
-		return -EINVAL;
+	snprintf(name, PAGE_SIZE, "%s-IRQ", chip->tcpc_desc->name);
 	dev_info(chip->dev, "%s name = %s, gpio = %d\n", __func__,
 		 chip->tcpc_desc->name, chip->irq_gpio);
 	ret = devm_gpio_request(chip->dev, chip->irq_gpio, name);
@@ -1038,7 +1045,7 @@ static int mt6360_init_alert(struct tcpc_device *tcpc)
 #endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0) */
 
 	chip->irq_worker_task = kthread_run(kthread_worker_fn,
-					    &chip->irq_worker, "%s",
+					    &chip->irq_worker,
 					    chip->tcpc_desc->name);
 	if (IS_ERR(chip->irq_worker_task)) {
 		dev_err(chip->dev, "%s could not create tcpc task\n", __func__);
@@ -1053,7 +1060,7 @@ static int mt6360_init_alert(struct tcpc_device *tcpc)
 #endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0) */
 
 	ret = request_irq(chip->irq, mt6360_intr_handler, IRQF_TRIGGER_FALLING |
-			  IRQF_NO_THREAD, name, chip);
+			  IRQF_NO_THREAD | IRQF_NO_SUSPEND, name, chip);
 	if (ret < 0) {
 		dev_err(chip->dev, "%s fail to request irq%d, gpio%d (%d)\n",
 			__func__, chip->irq, chip->irq_gpio, ret);
@@ -1084,12 +1091,11 @@ static int mt6360_alert_status_clear(struct tcpc_device *tcpc, u32 mask)
 	return 0;
 }
 
-static int mt6360_set_clock_gating(struct tcpc_device *tcpc, bool en)
+static int mt6360_set_clock_gating(struct tcpc_device *tcpc_dev, bool en)
 {
 	int ret = 0;
 
 #ifdef CONFIG_TCPC_CLOCK_GATING
-	int i = 0;
 	u8 clk1 = MT6360_CLK_DIV_600K_EN | MT6360_CLK_DIV_300K_EN;
 	u8 clk2 = MT6360_CLK_DIV_2P4M_EN;
 
@@ -1099,15 +1105,16 @@ static int mt6360_set_clock_gating(struct tcpc_device *tcpc, bool en)
 	}
 
 	if (en) {
-		for (i = 0; i < 2; i++)
-			ret = mt6360_alert_status_clear(tcpc,
-				TCPC_REG_ALERT_RX_ALL_MASK);
+		ret = mt6360_alert_status_clear(tcpc_dev,
+						TCPC_REG_ALERT_RX_STATUS |
+						TCPC_REG_ALERT_RX_HARD_RST |
+						TCPC_REG_ALERT_RX_BUF_OVF);
 	}
 
 	if (ret == 0)
-		ret = mt6360_i2c_write8(tcpc, MT6360_REG_CLK_CTRL1, clk1);
+		ret = mt6360_i2c_write8(tcpc_dev, MT6360_REG_CLK_CTRL1, clk1);
 	if (ret == 0)
-		ret = mt6360_i2c_write8(tcpc, MT6360_REG_CLK_CTRL2, clk2);
+		ret = mt6360_i2c_write8(tcpc_dev, MT6360_REG_CLK_CTRL2, clk2);
 #endif	/* CONFIG_TCPC_CLOCK_GATING */
 
 	return ret;
@@ -1268,10 +1275,7 @@ static int mt6360_get_cc(struct tcpc_device *tcpc, int *cc1, int *cc2)
 	if (act_as_drp)
 		act_as_sink = TCPC_V10_REG_CC_STATUS_DRP_RESULT(status);
 	else {
-		if (tcpc->typec_polarity)
-			cc_role = TCPC_V10_REG_CC_STATUS_CC2(role_ctrl);
-		else
-			cc_role = TCPC_V10_REG_CC_STATUS_CC1(role_ctrl);
+		cc_role = TCPC_V10_REG_CC_STATUS_CC1(role_ctrl);
 		if (cc_role == TYPEC_CC_RP)
 			act_as_sink = false;
 		else
@@ -1304,10 +1308,8 @@ static int mt6360_set_cc(struct tcpc_device *tcpc, int pull)
 {
 	int ret;
 	u8 data;
-	int rp_lvl = TYPEC_CC_PULL_GET_RP_LVL(pull), pull1, pull2;
-#ifdef CONFIG_WD_SBU_POLLING
+	int rp_lvl = TYPEC_CC_PULL_GET_RP_LVL(pull);
 	struct mt6360_chip *chip = tcpc_get_dev_data(tcpc);
-#endif /* CONFIG_WD_SBU_POLLING */
 
 	MT6360_INFO("%s %d\n", __func__, pull);
 	pull = TYPEC_CC_PULL_GET_RES(pull);
@@ -1324,6 +1326,8 @@ static int mt6360_set_cc(struct tcpc_device *tcpc, int pull)
 
 		mt6360_enable_auto_rpconnect(tcpc, true);
 		mt6360_enable_oneshot_rpconnect(tcpc, true);
+		if (tcpc->tcpc_flags & TCPC_FLAGS_TYPEC_OTP)
+			charger_dev_enable_force_typec_otp(chip->chgdev, false);
 
 #ifdef CONFIG_TCPC_LOW_POWER_MODE
 		tcpci_set_low_power_mode(tcpc, true, pull);
@@ -1342,19 +1346,13 @@ static int mt6360_set_cc(struct tcpc_device *tcpc, int pull)
 		cancel_delayed_work(&chip->usbid_poll_work);
 		mt6360_enable_usbid_polling(chip, false);
 #endif /* CONFIG_WD_POLLING_ONLY */
-
-		pull1 = pull2 = pull;
-
-		if (pull == TYPEC_CC_RP && tcpc->typec_is_attached_src) {
-			if (tcpc->typec_polarity)
-				pull1 = TYPEC_CC_RD;
-			else
-				pull2 = TYPEC_CC_RD;
-		}
-		data = TCPC_V10_REG_ROLE_CTRL_RES_SET(0, rp_lvl, pull1, pull2);
-		ret = mt6360_i2c_write8(tcpc, TCPC_V10_REG_ROLE_CTRL, data);
-		mt6360_enable_auto_rpconnect(tcpc, false);
+		if ((tcpc->tcpc_flags & TCPC_FLAGS_TYPEC_OTP) &&
+		    (pull != TYPEC_CC_OPEN))
+			charger_dev_enable_force_typec_otp(chip->chgdev, true);
 		mt6360_enable_oneshot_rpconnect(tcpc, true);
+		mt6360_enable_auto_rpconnect(tcpc, false);
+		data = TCPC_V10_REG_ROLE_CTRL_RES_SET(0, rp_lvl, pull, pull);
+		ret = mt6360_i2c_write8(tcpc, TCPC_V10_REG_ROLE_CTRL, data);
 	}
 
 	return ret;
@@ -1443,16 +1441,8 @@ static int mt6360_is_low_power_mode(struct tcpc_device *tcpc)
 static int mt6360_set_low_power_mode(struct tcpc_device *tcpc, bool en,
 				     int pull)
 {
-	int ret = 0;
 	u8 data = 0;
 
-	ret = (en ? mt6360_i2c_clr_bit : mt6360_i2c_set_bit)
-		(tcpc, MT6360_REG_MODE_CTRL2, MT6360_AUTOIDLE_EN);
-	if (ret < 0)
-		return ret;
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
-	mt6360_enable_vsafe0v_detect(tcpc, !en);
-#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 	if (en) {
 		data = MT6360_LPWR_EN | MT6360_LPWR_LDO_EN;
 
@@ -1463,40 +1453,65 @@ static int mt6360_set_low_power_mode(struct tcpc_device *tcpc, bool en,
 	} else {
 		data = MT6360_VBUS_DET_EN | MT6360_PD_BG_EN |
 			MT6360_PD_IREF_EN | MT6360_BMCIO_OSC_EN;
+		mt6360_enable_vsafe0v_detect(tcpc, true);
 	}
 	return mt6360_i2c_write8(tcpc, MT6360_REG_MODE_CTRL3, data);
 }
 #endif	/* CONFIG_TCPC_LOW_POWER_MODE */
 
-static int mt6360_set_watchdog(struct tcpc_device *tcpc, bool en)
+static int mt6360_set_watchdog(struct tcpc_device *tcpc_dev, bool en)
 {
 	return (en ? mt6360_i2c_set_bit : mt6360_i2c_clr_bit)
-		(tcpc, TCPC_V10_REG_TCPC_CTRL,
+		(tcpc_dev, TCPC_V10_REG_TCPC_CTRL,
 		 TCPC_V10_REG_TCPC_CTRL_EN_WDT);
 }
 
-static int mt6360_tcpc_deinit(struct tcpc_device *tcpc)
+static int mt6360_tcpc_deinit(struct tcpc_device *tcpc_dev)
 {
-#ifdef CONFIG_RT_REGMAP
-	struct mt6360_chip *chip = tcpc_get_dev_data(tcpc);
-#endif /* CONFIG_RT_REGMAP */
-
 #ifdef CONFIG_TCPC_SHUTDOWN_CC_DETACH
-	mt6360_set_cc(tcpc, TYPEC_CC_DRP);
-	mt6360_set_cc(tcpc, TYPEC_CC_OPEN);
+	mt6360_set_cc(tcpc_dev, TYPEC_CC_DRP);
+	mt6360_set_cc(tcpc_dev, TYPEC_CC_OPEN);
 
-	mt6360_i2c_write8(tcpc, MT6360_REG_I2CRST_CTRL,
+	mt6360_i2c_write8(tcpc_dev, MT6360_REG_I2CRST_CTRL,
 			  MT6360_REG_I2CRST_SET(true, 4));
 #else
-	mt6360_i2c_write8(tcpc, MT6360_REG_SWRESET, 1);
+	mt6360_i2c_write8(tcpc_dev, MT6360_REG_SWRESET, 1);
 #endif	/* CONFIG_TCPC_SHUTDOWN_CC_DETACH */
-#ifdef CONFIG_RT_REGMAP
-	rt_regmap_cache_reload(chip->m_dev);
-#endif /* CONFIG_RT_REGMAP */
 
 	return 0;
 }
 
+#ifdef CONFIG_TYPEC_OTP
+static bool mt6360_is_typec_otp(struct tcpc_device *tcpc)
+{
+	bool otp = false;
+	int ret;
+	u8 status;
+
+	ret = mt6360_i2c_read8(tcpc, MT6360_REG_MT_ST1, &status);
+	if (ret < 0)
+		return false;
+	otp = (status & MT6360_ST_OTD) ? true : false;
+	MT6360_INFO("%s otp %d\n", __func__, otp);
+
+	return otp;
+}
+
+static int mt6360_typec_otp_irq_handler(struct tcpc_device *tcpc)
+{
+	struct mt6360_chip *chip = tcpc_get_dev_data(tcpc);
+	bool otp;
+
+	MT6360_INFO("%s\n", __func__);
+	otp = mt6360_is_typec_otp(tcpc);
+	if (otp)
+		charger_dev_enable_force_typec_otp(chip->chgdev, true);
+	tcpc_typec_handle_otp(tcpc, otp);
+
+	return 0;
+}
+#endif /* CONFIG_TYPEC_OTP */
+
 #ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
 static int mt6360_is_vsafe0v(struct tcpc_device *tcpc)
 {
@@ -1667,6 +1682,32 @@ static int mt6360_vconn_invalid_irq_handler(struct tcpc_device *tcpc)
 	return 0;
 }
 
+static int mt6360_ra_detect_process(struct tcpc_device *tcpc)
+{
+	int ret;
+	u8 data;
+
+	ret = mt6360_i2c_read8(tcpc, MT6360_REG_MT_ST5, &data);
+	if (ret < 0)
+		return ret;
+	tcpc->ra_detected = (data & MT6360_ST_RADET_CC) ? true : false;
+	return tcpci_notify_ra_detect(tcpc);
+}
+
+static int mt6360_ra_cc1_irq_handler(struct tcpc_device *tcpc)
+{
+	MT6360_INFO("%s\n", __func__);
+	mt6360_ra_detect_process(tcpc);
+	return 0;
+}
+
+static int mt6360_ra_cc2_irq_handler(struct tcpc_device *tcpc)
+{
+	MT6360_INFO("%s\n", __func__);
+	mt6360_ra_detect_process(tcpc);
+	return 0;
+}
+
 struct irq_mapping_tbl {
 	u8 num;
 	const char *name;
@@ -1681,6 +1722,10 @@ static struct irq_mapping_tbl mt6360_vend_irq_mapping_tbl[] = {
 	MT6360_IRQ_MAPPING(1, vsafe0v),
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 
+#ifdef CONFIG_TYPEC_OTP
+	MT6360_IRQ_MAPPING(2, typec_otp),
+#endif /* CONFIG_TYPEC_OTP */
+
 #ifdef CONFIG_WATER_DETECTION
 	MT6360_IRQ_MAPPING(14, wd),
 #endif /* CONFIG_WATER_DETECTION */
@@ -1694,6 +1739,8 @@ static struct irq_mapping_tbl mt6360_vend_irq_mapping_tbl[] = {
 	MT6360_IRQ_MAPPING(9, vconn_ov_cc2),
 	MT6360_IRQ_MAPPING(10, vconn_ocr),
 	MT6360_IRQ_MAPPING(12, vconn_invalid),
+	MT6360_IRQ_MAPPING(32, ra_cc1),
+	MT6360_IRQ_MAPPING(33, ra_cc2),
 };
 
 static int mt6360_alert_vendor_defined_handler(struct tcpc_device *tcpc)
@@ -1716,8 +1763,6 @@ static int mt6360_alert_vendor_defined_handler(struct tcpc_device *tcpc)
 		if (!alert[i])
 			continue;
 		MT6360_INFO("Vend INT%d:0x%02X\n", i + 1, alert[i]);
-		MT6360_INFO("Mask INT%d:0x%02X\n", i + 1, mask[i]);
-		alert[i] &= mask[i];
 	}
 
 	mt6360_vend_alert_status_clear(tcpc, alert);
@@ -1819,7 +1864,7 @@ static int mt6360_is_water_detected(struct tcpc_device *tcpc)
 	enum tcpc_cable_type cable_type;
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
 
-	__pm_stay_awake(chip->wd_wakeup_src);
+	__pm_stay_awake(&chip->wd_wakeup_src);
 
 #ifdef CONFIG_WD_SBU_POLLING
 	ret = mt6360_enable_usbid_polling(chip, false);
@@ -1942,7 +1987,7 @@ out:
 err:
 	charger_dev_enable_usbid_floating(chip->chgdev, true);
 	charger_dev_enable_usbid(chip->chgdev, false);
-	__pm_relax(chip->wd_wakeup_src);
+	__pm_relax(&chip->wd_wakeup_src);
 	return ret;
 }
 
@@ -2014,9 +2059,6 @@ static int mt6360_tcpc_init(struct tcpc_device *tcpc, bool sw_reset)
 	mt6360_i2c_write8(tcpc, MT6360_REG_DEBOUNCE_CTRL1, 10);
 	mt6360_init_drp_duty(tcpc);
 
-	/* Disable BLEED_DISC and Enable AUTO_DISC_DISCNCT */
-	mt6360_i2c_write8(tcpc, TCPC_V10_REG_POWER_CTRL, 0x70);
-
 	/* RX/TX Clock Gating (Auto Mode) */
 	if (!sw_reset)
 		mt6360_set_clock_gating(tcpc, true);
@@ -2043,7 +2085,13 @@ static int mt6360_tcpc_init(struct tcpc_device *tcpc, bool sw_reset)
 	mt6360_init_water_detection(tcpc);
 #endif /* CONFIG_WATER_DETECTION */
 
-	mt6360_init_alert_mask(tcpc);
+#ifdef CONFIG_TYPEC_OTP
+	/* Do not set CC to open if OT */
+	mt6360_i2c_clr_bit(tcpc, MT6360_REG_CTD_CTRL2, MT6360_OT_CCOPEN_EN);
+#endif
+
+	if (sw_reset)
+		mt6360_init_alert_mask(tcpc);
 
 	if (tcpc->tcpc_flags & TCPC_FLAGS_WATCHDOG_EN) {
 		mt6360_i2c_write8(tcpc, MT6360_REG_WATCHDOG_CTRL,
@@ -2051,10 +2099,9 @@ static int mt6360_tcpc_init(struct tcpc_device *tcpc, bool sw_reset)
 		mt6360_set_watchdog(tcpc, true);
 	}
 
-	/* SHIPPING off, AUTOIDLE enable, TIMEOUT = 6.4ms */
+	/* SHIPPING off, AUTOIDLE off */
 	mt6360_i2c_write8(tcpc, MT6360_REG_MODE_CTRL2,
-			  MT6360_REG_MODE_CTRL2_SET(1, 1, 0));
-	mdelay(1);
+			  MT6360_REG_MODE_CTRL2_SET(1, 0, 2));
 
 	return 0;
 }
@@ -2068,11 +2115,11 @@ static int mt6360_set_msg_header(
 	return mt6360_i2c_write8(tcpc, TCPC_V10_REG_MSG_HDR_INFO, msg_hdr);
 }
 
-static int mt6360_protocol_reset(struct tcpc_device *tcpc)
+static int mt6360_protocol_reset(struct tcpc_device *tcpc_dev)
 {
-	mt6360_i2c_clr_bit(tcpc, MT6360_REG_PHY_CTRL8, MT6360_PRL_FSM_RSTB);
+	mt6360_i2c_clr_bit(tcpc_dev, MT6360_REG_PHY_CTRL8, MT6360_PRL_FSM_RSTB);
 	mdelay(1);
-	mt6360_i2c_set_bit(tcpc, MT6360_REG_PHY_CTRL8, MT6360_PRL_FSM_RSTB);
+	mt6360_i2c_set_bit(tcpc_dev, MT6360_REG_PHY_CTRL8, MT6360_PRL_FSM_RSTB);
 	return 0;
 }
 
@@ -2086,11 +2133,12 @@ static int mt6360_set_rx_enable(struct tcpc_device *tcpc, u8 en)
 	if (ret == 0)
 		ret = mt6360_i2c_write8(tcpc, TCPC_V10_REG_RX_DETECT, en);
 
-	if ((ret == 0) && !en) {
-		mt6360_protocol_reset(tcpc);
+	if ((ret == 0) && !en)
 		ret = mt6360_set_clock_gating(tcpc, true);
-	}
 
+	/* For testing */
+	if (!en)
+		mt6360_protocol_reset(tcpc);
 	return ret;
 }
 
@@ -2100,7 +2148,7 @@ static int mt6360_get_message(struct tcpc_device *tcpc, u32 *payload,
 {
 	int ret;
 	u8 type, cnt = 0;
-	u8 buf[4] = {0};
+	u8 buf[4];
 
 	ret = mt6360_i2c_block_read(tcpc, TCPC_V10_REG_RX_BYTE_CNT, 4, buf);
 	cnt = buf[0];
@@ -2231,10 +2279,7 @@ static int mt6360_init_ctd(struct mt6360_chip *chip)
 	int ret = 0;
 
 #ifdef CONFIG_CABLE_TYPE_DETECTION
-	u8 ctd_evt;
-#if CONFIG_MTK_GAUGE_VERSION == 30
-	u8 status;
-#endif
+	u8 ctd_evt, status;
 
 	chip->tcpc->typec_cable_type = TCPC_CABLE_TYPE_NONE;
 	chip->handle_init_ctd = true;
@@ -2243,14 +2288,12 @@ static int mt6360_init_ctd(struct mt6360_chip *chip)
 		return ret;
 	if (ctd_evt & MT6360_M_CTD) {
 		mt6360_get_cable_type(chip->tcpc, &chip->init_cable_type);
-#if CONFIG_MTK_GAUGE_VERSION == 30
 		if (chip->init_cable_type == TCPC_CABLE_TYPE_C2C) {
 			ret = charger_dev_get_ctd_dischg_status(chip->chgdev,
 								&status);
 			if (ret >= 0 && (status & 0x82))
 				chip->init_cable_type = TCPC_CABLE_TYPE_A2C;
 		}
-#endif
 	}
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
 
@@ -2260,10 +2303,13 @@ static int mt6360_init_ctd(struct mt6360_chip *chip)
 static int mt6360_parse_dt(struct mt6360_chip *chip, struct device *dev,
 			   struct mt6360_tcpc_platform_data *pdata)
 {
-	struct device_node *np = NULL;
+	struct device_node *np = dev->of_node;
 	struct resource *res;
 	int res_cnt, ret;
 
+	if (!np)
+		return -EINVAL;
+
 	pr_info("%s\n", __func__);
 
 	np = of_find_node_by_name(NULL, "type_c_port0");
@@ -2271,7 +2317,6 @@ static int mt6360_parse_dt(struct mt6360_chip *chip, struct device *dev,
 		dev_err(dev, "%s find node fail\n", __func__);
 		return -ENODEV;
 	}
-	dev->of_node = np;
 
 #if (!defined(CONFIG_MTK_GPIO) || defined(CONFIG_MTK_GPIOLIB_STAND))
 	ret = of_get_named_gpio(np, "mt6360pd,intr_gpio", 0);
@@ -2297,13 +2342,6 @@ static int mt6360_parse_dt(struct mt6360_chip *chip, struct device *dev,
 		return ret;
 	}
 	chip->pcb_gpio = ret;
-
-	ret = of_property_read_u32(np, "mt6360pd,pcb_gpio_polarity",
-				    &chip->pcb_gpio_polarity);
-	if (ret < 0) {
-		dev_info(dev, "%s no pcb_gpio_polarity info\n", __func__);
-		return ret;
-	}
 #else
 	ret = of_property_read_u32(np, "mt6360pd,pcb_gpio_num",
 				   &chip->pcb_gpio);
@@ -2311,13 +2349,6 @@ static int mt6360_parse_dt(struct mt6360_chip *chip, struct device *dev,
 		dev_info(dev, "%s no pcb_gpio info\n", __func__);
 		return ret;
 	}
-
-	ret = of_property_read_u32(np, "mt6360pd,pcb_gpio_polarity",
-				    &chip->pcb_gpio_polarity);
-	if (ret < 0) {
-		dev_info(dev, "%s no pcb_gpio_polarity info\n", __func__);
-		return ret;
-	}
 #endif /* !CONFIG_MTK_GPIO || CONFIG_MTK_GPIOLIB_STAND */
 	ret = devm_gpio_request(dev, chip->pcb_gpio, "pcb_gpio");
 	if (ret < 0) {
@@ -2388,14 +2419,31 @@ static void check_printk_performance(void)
 static int mt6360_tcpcdev_init(struct mt6360_chip *chip, struct device *dev)
 {
 	struct tcpc_desc *desc;
-	struct device_node *np = dev->of_node;
-	u32 val = -EINVAL, len;
+	struct device_node *np;
+	u32 val, len;
 	const char *name = "default";
+	bool kpoc_boot = false;
+
+	np = of_find_node_by_name(NULL, "type_c_port0");
+	if (!np) {
+		dev_err(dev, "%s find type_c_port0 fail\n", __func__);
+		return -ENODEV;
+	}
 
 	desc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);
 	if (!desc)
 		return -ENOMEM;
-	if (of_property_read_u32(np, "mt-tcpc,role_def", &val) >= 0) {
+
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+	if (get_boot_mode() == KERNEL_POWER_OFF_CHARGING_BOOT
+		|| get_boot_mode() == LOW_POWER_OFF_CHARGING_BOOT)
+		kpoc_boot = true;
+#endif /* CONFIG_MTK_KERNEL_POWER_OFF_CHARGING */
+
+	if (kpoc_boot) {
+		dev_info(dev, "%s KPOC use default Role SNK\n", __func__);
+		desc->role_def = 0; /* SNK */
+	} else if (of_property_read_u32(np, "mt-tcpc,role_def", &val) >= 0) {
 		if (val >= TYPEC_ROLE_NR)
 			desc->role_def = TYPEC_ROLE_DRP;
 		else
@@ -2451,14 +2499,9 @@ static int mt6360_tcpcdev_init(struct mt6360_chip *chip, struct device *dev)
 
 	chip->tcpc_desc = desc;
 	chip->tcpc = tcpc_device_register(dev, desc, &mt6360_tcpc_ops, chip);
-	if (IS_ERR_OR_NULL(chip->tcpc))
+	if (IS_ERR(chip->tcpc))
 		return -EINVAL;
 
-#ifdef CONFIG_USB_PD_DISABLE_PE
-	chip->tcpc->disable_pe = of_property_read_bool(np,
-						       "mt-tcpc,disable_pe");
-#endif	/* CONFIG_USB_PD_DISABLE_PE */
-
 	/* Init tcpc_flags */
 	chip->tcpc->tcpc_flags = TCPC_FLAGS_LPM_WAKEUP_WATCHDOG |
 				 TCPC_FLAGS_RETRY_CRC_DISCARD;
@@ -2477,36 +2520,41 @@ static int mt6360_tcpcdev_init(struct mt6360_chip *chip, struct device *dev)
 	chip->tcpc->tcpc_flags |= TCPC_FLAGS_DISABLE_LEGACY;
 	chip->tcpc->tcpc_flags |= TCPC_FLAGS_WATCHDOG_EN;
 #ifdef CONFIG_MTK_TYPEC_WATER_DETECT_BY_PCB
-	if (gpio_get_value(chip->pcb_gpio) == chip->pcb_gpio_polarity)
+	if (gpio_get_value(chip->pcb_gpio) != 0)
 		chip->tcpc->tcpc_flags |= TCPC_FLAGS_WATER_DETECTION;
 #else
 	chip->tcpc->tcpc_flags |= TCPC_FLAGS_WATER_DETECTION;
 #endif /* CONFIG_MTK_TYPEC_WATER_DETECT_BY_PCB */
 	chip->tcpc->tcpc_flags |= TCPC_FLAGS_CABLE_TYPE_DETECTION;
+	chip->tcpc->tcpc_flags |= TCPC_FLAGS_TYPEC_OTP;
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+	if (kpoc_boot)
+		chip->tcpc->tcpc_flags |= TCPC_FLAGS_KPOC_BOOT;
+#endif /* CONFIG_MTK_KERNEL_POWER_OFF_CHARGING */
 	return 0;
 }
 
 int power_supply_get_cc(void)
 {
 	int cc1, cc2;
 
 	if (g_chip == NULL) {
 		pr_err("%s null address\n",__func__);
 		return ERR_STATUS;
 	}
 
 	tcpci_lock_typec(g_chip->tcpc);
 	mt6360_get_cc(g_chip->tcpc, &cc1, &cc2);
 	tcpci_unlock_typec(g_chip->tcpc);
 
 	pr_err("%s %d %d\n",__func__, cc1, cc2);
 	if (cc1 == cc2)
 		return ERR_STATUS;
 
 	return (cc1 > cc2) ? POSITIVE : NEGATIVE;
 }
 EXPORT_SYMBOL_GPL(power_supply_get_cc);
 
 static inline int mt6360_check_revision(struct i2c_client *client)
 {
 	int ret;
@@ -2593,14 +2620,11 @@ static int mt6360_i2c_probe(struct i2c_client *client,
 	sema_init(&chip->suspend_lock, 1);
 	i2c_set_clientdata(client, chip);
 	INIT_DELAYED_WORK(&chip->poll_work, mt6360_poll_work);
-	chip->irq_wake_lock =
-		wakeup_source_register(chip->dev, "mt6360_irq_wake_lock");
-	chip->i2c_wake_lock =
-		wakeup_source_register(chip->dev, "mt6360_i2c_wake_lock");
+	wakeup_source_init(&chip->irq_wake_lock, "mt6360_irq_wakelock");
+	wakeup_source_init(&chip->i2c_wake_lock, "mt6370_i2c_wakelock");
 
 #ifdef CONFIG_WATER_DETECTION
-	chip->wd_wakeup_src =
-		wakeup_source_register(chip->dev, "mt6360_wd_wakeup_src");
+	wakeup_source_init(&chip->wd_wakeup_src, "mt6360_wd_wakeup_src");
 	atomic_set(&chip->wd_protect_rty, CONFIG_WD_PROTECT_RETRY_COUNT);
 #ifdef CONFIG_WD_POLLING_ONLY
 	INIT_DELAYED_WORK(&chip->usbid_poll_work, mt6360_usbid_poll_work);
@@ -2627,13 +2651,13 @@ static int mt6360_i2c_probe(struct i2c_client *client,
 	chip->chgdev = get_charger_by_name("primary_chg");
 	if (!chip->chgdev) {
 		dev_err(chip->dev, "%s get charger device fail\n", __func__);
-		ret = -EPROBE_DEFER;
+		ret = -EINVAL;
 		goto err_tcpc_reg;
 	}
 #endif /* CONFIG_MTK_GAUGE_VERSION == 30 */
 #endif /* CONFIG_WATER_DETECTION || CONFIG_CABLE_TYPE_DETECTION */
 
 	g_chip = chip;
 	ret = mt6360_tcpcdev_init(chip, &client->dev);
 	if (ret < 0) {
 		dev_err(chip->dev, "%s tcpc dev init fail\n", __func__);
@@ -2801,7 +2822,7 @@ static int __init mt6360_init(void)
 
 	return i2c_add_driver(&mt6360_driver);
 }
-subsys_initcall(mt6360_init);
+device_initcall_sync(mt6360_init);
 
 static void __exit mt6360_exit(void)
 {
@@ -2814,26 +2835,8 @@ MODULE_DESCRIPTION("MT6360 TCPC Driver");
 MODULE_VERSION(MT6360_DRV_VERSION);
 
 /**** Release Note ****
- * 2.0.7_MTK
- *	(1) mdelay(1) after SHIPPING_OFF = 1
- *
- * 2.0.6_MTK
- *	(1) Utilize rt-regmap to reduce I2C accesses
- *	(2) Disable BLEED_DISC and Enable AUTO_DISC_DISCNCT
- *
- * 2.0.5_MTK
- *	(1) Mask vSafe0V IRQ before entering low power mode
- *	(2) AUTOIDLE enable
- *	(3) Reset Protocol FSM and clear RX alerts twice before clock gating
- *
- * 2.0.4_MTK
- *	(1) support mt6360 pd discard retry
- *	(2) fix system busy when rx pending2
- *	(3) handle mask alert event when unmask irq
- *
  * 2.0.3_MTK
- *	(1) Single Rp as Attatched.SRC for Ellisys TD.4.9.4
- *
+ *	Add type-c OTP
  * 2.0.2_MTK
  *	(1) Add vendor defined irq handler
  *	(2) Remove init_cc_param
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpc_mt6362.c b/drivers/misc/mediatek/typec/tcpc/tcpc_mt6362.c
deleted file mode 100644
index a85abde..0000000
--- a/drivers/misc/mediatek/typec/tcpc/tcpc_mt6362.c
+++ /dev/null
@@ -1,2281 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (c) 2019 MediaTek Inc.
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/regmap.h>
-#include <linux/platform_device.h>
-#include <linux/kthread.h>
-#include <linux/cpu.h>
-#include <linux/iio/consumer.h>
-#include <uapi/linux/sched/types.h>
-#include <dt-bindings/mfd/mt6362.h>
-
-#include "inc/tcpci.h"
-#include "inc/tcpci_typec.h"
-#include "inc/tcpci_core.h"
-#include "inc/std_tcpci_v10.h"
-
-#define MT6362_INFO_EN	1
-#define MT6362_DBGINFO_EN	1
-#define MT6362_WD1_EN	1
-#define MT6362_WD2_EN	1
-
-#define MT6362_INFO(fmt, ...) \
-	do { \
-		if (MT6362_INFO_EN) \
-			pd_dbg_info("%s " fmt, __func__, ##__VA_ARGS__); \
-	} while (0)
-
-#define MT6362_DBGINFO(fmt, ...) \
-	do { \
-		if (MT6362_DBGINFO_EN) \
-			pd_dbg_info("%s " fmt, __func__, ##__VA_ARGS__); \
-	} while (0)
-
-#define MT6362_VID	0x29CF
-#define MT6362_PID	0x6362
-
-#define MT6362_IRQ_WAKE_TIME	(500) /* ms */
-
-#define MT6362_REG_BASEADDR	(0x400)
-#define MT6362_REG_RT2BASEADDR	(0x500)
-#define MT6362_REG_PHYCTRL1	(0x80)
-#define MT6362_REG_PHYCTRL2	(0x81)
-#define MT6362_REG_PHYCTRL3	(0x82)
-#define MT6362_REG_PHYCTRL7	(0x86)
-#define MT6362_REG_PHYCTRL8	(0x89)
-#define MT6362_REG_VCONCTRL2	(0x8B)
-#define MT6362_REG_VCONCTRL3	(0x8C)
-#define MT6362_REG_SYSCTRL1	(0x8F)
-#define MT6362_REG_SYSCTRL2	(0x90)
-#define MT6362_REG_MTMASK1	(0x91)
-#define MT6362_REG_MTMASK2	(0x92)
-#define MT6362_REG_MTMASK3	(0x93)
-#define MT6362_REG_MTMASK4	(0x94)
-#define MT6362_REG_MTMASK5	(0x95)
-#define MT6362_REG_MTMASK6	(0x96)
-#define MT6362_REG_MTMASK7	(0x97)
-#define MT6362_REG_MTINT1	(0x98)
-#define MT6362_REG_MTINT2	(0x99)
-#define MT6362_REG_MTINT3	(0x9A)
-#define MT6362_REG_MTINT4	(0x9B)
-#define MT6362_REG_MTINT5	(0x9C)
-#define MT6362_REG_MTINT6	(0x9D)
-#define MT6362_REG_MTINT7	(0x9E)
-#define MT6362_REG_MTST1	(0x9F)
-#define MT6362_REG_MTST2	(0xA0)
-#define MT6362_REG_MTST3	(0xA1)
-#define MT6362_REG_MTST4	(0xA2)
-#define MT6362_REG_MTST5	(0xA3)
-#define MT6362_REG_MTST6	(0xA4)
-#define MT6362_REG_MTST7	(0xA5)
-#define MT6362_REG_PHYCTRL9	(0xAC)
-#define MT6362_REG_SYSCTRL3	(0xB0)
-#define MT6362_REG_TCPCCTRL1	(0xB1)
-#define MT6362_REG_TCPCCTRL2	(0xB2)
-#define MT6362_REG_TCPCCTRL3	(0xB3)
-#define MT6362_REG_LPWRCTRL3	(0xBB)
-#define MT6362_REG_WATCHDOGCTRL	(0xBE)
-#define MT6362_REG_HILOCTRL9	(0xC8)
-#define MT6362_REG_HILOCTRL10	(0xC9)
-#define MT6362_REG_SHIELDCTRL1	(0xCA)
-#define MT6362_REG_TYPECOTPCTRL	(0xCD)
-#define MT6362_REG_WD12MODECTRL	(0xD0)
-#define MT6362_REG_WD1PATHEN	(0xD1)
-#define MT6362_REG_WD1MISCCTRL	(0xD2)
-#define MT6362_REG_WD2PATHEN	(0xD3)
-#define MT6362_REG_WD2MISCCTRL	(0xD4)
-#define MT6362_REG_WD1PULLST	(0xD5)
-#define MT6362_REG_WD1DISCHGST	(0xD6)
-#define MT6362_REG_WD2PULLST	(0xD7)
-#define MT6362_REG_WD2DISCHGST	(0xD8)
-#define MT6362_REG_WD0MODECTRL	(0xD9)
-#define MT6362_REG_WD0SET	(0xDA)
-#define MT6362_REG_WDSET	(0xDB)
-#define MT6362_REG_WDSET1	(0xDC)
-
-/* RT2 */
-#define MT6362_REG_WDSET2	(0x20)
-#define MT6362_REG_WDSET3	(0x21)
-#define MT6362_REG_WD1MISCSET	(0x22)
-#define MT6362_REG_WD1VOLCMP	(0x23)
-#define MT6362_REG_WD2MISCSET	(0x28)
-#define MT6362_REG_WD2VOLCMP	(0x29)
-
-#define MT6362_MSK_OPEN40MS_EN	BIT(4)
-#define MT6362_MSK_WAKEUP	BIT(0)
-#define MT6362_MSK_VBUS80	BIT(1)
-#define MT6362_MSK_OTDFLAG	BIT(2)
-#define MT6362_MSK_VCON_OVCC1	BIT(0)
-#define MT6362_MSK_VCON_OVCC2	BIT(1)
-#define MT6362_MSK_VCON_RVP	BIT(2)
-#define MT6362_MSK_VCON_UVP	BIT(4)
-#define MT6362_MSK_VCON_SHTGND	BIT(5)
-#define MT6362_MSK_VCON_FAULT \
-	(MT6362_MSK_VCON_OVCC1 | MT6362_MSK_VCON_OVCC2 | MT6362_MSK_VCON_RVP | \
-	 MT6362_MSK_VCON_UVP | MT6362_MSK_VCON_SHTGND)
-#define MT6362_MSK_CTD		BIT(4)
-#define MT6362_MSK_FOD_DONE	BIT(0)
-#define MT6362_MSK_FOD_OV	BIT(1)
-#define MT6362_MSK_FOD_DISCHGF	BIT(7)
-#define MT6362_MSK_RPDET_AUTO	BIT(7)
-#define MT6362_MSK_RPDET_MANUAL	BIT(6)
-#define MT6362_MSK_CTD_EN	BIT(1)
-#define MT6362_MSK_BMCIOOSC_EN	BIT(0)
-#define MT6362_MSK_VBUSDET_EN	BIT(1)
-#define MT6362_MSK_LPWR_EN	BIT(3)
-#define MT6362_MSK_VCON_OVCC1EN	BIT(7)
-#define MT6362_MSK_VCON_OVCC2EN	BIT(6)
-#define MT6362_MSK_VCON_RVPEN	BIT(3)
-#define MT6362_MSK_VCON_PROTEN	\
-	(MT6362_MSK_VCON_OVCC1EN | MT6362_MSK_VCON_OVCC2EN | \
-	 MT6362_MSK_VCON_RVPEN)
-#define MT6362_MSK_PRLRSTB	BIT(1)
-#define MT6362_MSK_TYPECOTP_FWEN	BIT(2)
-#define MT6362_MSK_HIDET_CC1	BIT(4)
-#define MT6362_MSK_HIDET_CC2	BIT(5)
-#define MT6362_MSK_HIDET_CC	(MT6362_MSK_HIDET_CC1 | MT6362_MSK_HIDET_CC2)
-#define MT6362_MSK_HIDET_CC1_CMPEN	BIT(1)
-#define MT6362_MSK_HIDET_CC2_CMPEN	BIT(4)
-#define MT6362_MSK_HIDET_CC_CMPEN \
-	(MT6362_MSK_HIDET_CC1_CMPEN | MT6362_MSK_HIDET_CC2_CMPEN)
-#define MT6362_MSK_FOD_DONE	BIT(0)
-#define MT6362_MSK_FOD_OV	BIT(1)
-#define MT6362_MSK_FOD_LR	BIT(5)
-#define MT6362_MSK_FOD_HR	BIT(6)
-#define MT6362_MSK_FOD_DISCHGF	BIT(7)
-#define MT6362_MSK_FOD_ALL \
-	(MT6362_MSK_FOD_DONE | MT6362_MSK_FOD_OV | MT6362_MSK_FOD_LR | \
-	 MT6362_MSK_FOD_HR | MT6362_MSK_FOD_DISCHGF)
-#define MT6362_MSK_CABLE_TYPEC	BIT(4)
-#define MT6362_MSK_CABLE_TYPEA	BIT(5)
-#define MT6362_MSK_SHIPPING_OFF	BIT(5)
-#define MT6362_MSK_AUTOIDLE_EN	BIT(3)
-#define MT6362_MSK_WD12_STFALL	BIT(0)
-#define MT6362_MSK_WD12_STRISE	BIT(1)
-#define MT6362_MSK_WD12_DONE	BIT(2)
-#define MT6362_MSK_WDIPULL_SEL	(0x70)
-#define MT6362_SFT_WDIPULL_SEL	(4)
-#define MT6362_MSK_WDRPULL_SEL	(0x0E)
-#define MT6362_SFT_WDRPULL_SEL	(1)
-#define MT6362_MSK_WD12_VOLCOML	(0x0F)
-#define MT6362_SFT_WD12_VOLCOML	(0)
-#define MT6362_MSK_WDSBU1_EN	BIT(0)
-#define MT6362_MSK_WDSBU2_EN	BIT(1)
-#define MT6362_MSK_WDCC1_EN	BIT(2)
-#define MT6362_MSK_WDCC2_EN	BIT(3)
-#define MT6362_MSK_WDDP_EN	BIT(4)
-#define MT6362_MSK_WDDM_EN	BIT(5)
-#define MT6362_MSK_WD12PROT	BIT(6)
-#define MT6362_MSK_WD12MODE_EN	BIT(4)
-#define MT6362_MSK_WDIPULL_EN	BIT(3)
-#define MT6362_MSK_WDRPULL_EN	BIT(2)
-#define MT6362_MSK_WDDISCHG_EN	BIT(1)
-#define MT6362_MSK_WDFWMODE_EN	BIT(0)
-#define MT6362_MSK_WDLDO_SEL	(0xC0)
-#define MT6362_SFT_WDLDO_SEL	(6)
-#define MT6362_MSK_WD0MODE_EN	BIT(4)
-#define MT6362_MSK_WD0PULL_STS	BIT(7)
-#define MT6362_MASK_WD_TDET	(0x07)
-#define MT6362_SHFT_WD_TDET	(0)
-
-/* for Rust Protect DPDM */
-#define MT6362_REG_DPDM_CTRL1	(0x53)
-#define MT6362_MSK_MANUAL_MODE	BIT(7)
-#define MT6362_MSK_DPDM_DET_EN	BIT(6)
-
-#define MT6362_WD_TDET_10MS	(0x04)
-#define MT6362_WD_TDET_1MS	(0x01)
-
-#define MT6362_WD_VOL_CMPL_1_44V	(0x0A)
-#define MT6362_WD_VOL_CMPL_1_54V	(0x0B)
-
-enum mt6362_vend_int {
-	MT6362_VEND_INT1 = 0,
-	MT6362_VEND_INT2,
-	MT6362_VEND_INT3,
-	MT6362_VEND_INT4,
-	MT6362_VEND_INT5,
-	MT6362_VEND_INT6,
-	MT6362_VEND_INT7,
-	MT6362_VEND_INT_NUM,
-};
-
-enum mt6362_wd_chan {
-	MT6362_WD_CHAN_WD1,
-	MT6362_WD_CHAN_WD2,
-	MT6362_WD_CHAN_NUM,
-};
-
-enum mt6362_wd_rpull {
-	MT6362_WD_RPULL_500K,
-	MT6362_WD_RPULL_200K,
-	MT6362_WD_RPULL_75K,
-	MT6362_WD_RPULL_40K,
-	MT6362_WD_RPULL_20K,
-	MT6362_WD_RPULL_10K,
-	MT6362_WD_RPULL_5K,
-	MT6362_WD_RPULL_1K,
-};
-
-enum mt6362_wd_ipull {
-	MT6362_WD_IPULL_2UA,
-	MT6362_WD_IPULL_5UA,
-	MT6362_WD_IPULL_10UA,
-	MT6362_WD_IPULL_20UA,
-	MT6362_WD_IPULL_40UA,
-	MT6362_WD_IPULL_80UA,
-	MT6362_WD_IPULL_160UA,
-	MT6362_WD_IPULL_240UA,
-};
-
-enum mt6362_wd_status {
-	MT6362_WD_PULL,
-	MT6362_WD_DISCHG,
-	MT6362_WD_STATUS_NUM,
-};
-
-enum mt6362_wd_ldo {
-	MT6362_WD_LDO_0_6V,
-	MT6362_WD_LDO_1_8V,
-	MT6362_WD_LDO_2_5V,
-	MT6362_WD_LDO_3_0V,
-};
-
-static const u8 mt6362_vend_alert_clearall[MT6362_VEND_INT_NUM] = {
-	0xFF, 0xFF, 0xF0, 0xE3, 0xFF, 0xF8, 0x3F,
-};
-
-static const u8 mt6362_vend_alert_maskall[MT6362_VEND_INT_NUM] = {
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-};
-
-#ifdef CONFIG_WATER_DETECTION
-/* reg0x20 ~ reg0x2D */
-static const u8 mt6362_rt2_wd_init_setting[] = {
-	0x50, 0x34, 0x44, 0xCA, 0x68, 0x02, 0x20, 0x03,
-	0x44, 0xCA, 0x68, 0x02, 0x20, 0x03,
-};
-
-static const bool mt6362_wd_chan_en[MT6362_WD_CHAN_NUM] = {
-	MT6362_WD1_EN,
-	MT6362_WD2_EN,
-};
-
-static const u8 mt6362_wd_status_reg[MT6362_WD_CHAN_NUM] = {
-	MT6362_REG_WD1PULLST,
-	MT6362_REG_WD2PULLST,
-};
-
-static const u8 mt6362_wd_miscctrl_reg[MT6362_WD_CHAN_NUM] = {
-	MT6362_REG_WD1MISCCTRL,
-	MT6362_REG_WD2MISCCTRL,
-};
-
-static const u8 mt6362_wd_path_reg[MT6362_WD_CHAN_NUM] = {
-	MT6362_REG_WD1PATHEN,
-	MT6362_REG_WD2PATHEN,
-};
-
-static const u8 mt6362_wd_rpull_reg[MT6362_WD_CHAN_NUM] = {
-	MT6362_REG_WD1MISCSET,
-	MT6362_REG_WD2MISCSET
-};
-
-static const u8 __maybe_unused mt6362_wd_ipull_reg[MT6362_WD_CHAN_NUM] = {
-	MT6362_REG_WD1MISCSET,
-	MT6362_REG_WD2MISCSET
-};
-
-static const u8 mt6362_wd_volcmp_reg[MT6362_WD_CHAN_NUM] = {
-	MT6362_REG_WD1VOLCMP,
-	MT6362_REG_WD2VOLCMP,
-};
-
-static const u8 mt6362_wd_polling_path[MT6362_WD_CHAN_NUM] = {
-	MT6362_MSK_WDSBU1_EN,
-	MT6362_MSK_WDSBU2_EN,
-};
-
-static const u8 mt6362_wd_protection_path[MT6362_WD_CHAN_NUM] = {
-	MT6362_MSK_WDSBU1_EN | MT6362_MSK_WDSBU2_EN |
-	MT6362_MSK_WDCC1_EN | MT6362_MSK_WDCC2_EN,
-//	MT6362_MSK_WDDP_EN | MT6362_MSK_WDDM_EN,
-	MT6362_MSK_WDSBU1_EN | MT6362_MSK_WDSBU2_EN |
-	MT6362_MSK_WDCC1_EN | MT6362_MSK_WDCC2_EN,
-//	MT6362_MSK_WDDP_EN | MT6362_MSK_WDDM_EN,
-};
-#endif /* CONFIG_WATER_DETECTION */
-
-struct mt6362_tcpc_data {
-	struct device *dev;
-	struct regmap *regmap;
-	struct tcpc_desc *desc;
-	struct tcpc_device *tcpc;
-	struct kthread_worker irq_worker;
-	struct kthread_work irq_work;
-	struct task_struct *irq_worker_task;
-	struct iio_channel *adc_iio;
-	int irq;
-	u16 did;
-
-	atomic_t cpu_poll_count;
-	struct delayed_work cpu_poll_dwork;
-
-#ifdef CONFIG_WATER_DETECTION
-	atomic_t wd_protect_rty;
-#endif /* CONFIG_WATER_DETECTION */
-
-#ifdef CONFIG_WD_POLLING_ONLY
-	struct delayed_work wd_poll_dwork;
-#endif /* CONFIG_WD_POLLING_ONLY */
-
-#ifdef CONFIG_CABLE_TYPE_DETECTION
-	bool handle_init_ctd;
-	enum tcpc_cable_type init_cable_type;
-#endif /* CONFIG_CABLE_TYPE_DETECTION */
-
-};
-
-static inline int mt6362_write8(struct mt6362_tcpc_data *tdata, u32 reg,
-				u8 data)
-{
-	return regmap_write(tdata->regmap, reg + MT6362_REG_BASEADDR, data);
-}
-
-static inline int mt6362_read8(struct mt6362_tcpc_data *tdata, u32 reg,
-			       u8 *data)
-{
-	int ret;
-	u32 _data;
-
-	ret = regmap_read(tdata->regmap, reg + MT6362_REG_BASEADDR, &_data);
-	if (ret < 0)
-		return ret;
-	*data = _data;
-	return 0;
-}
-
-static inline int mt6362_write16(struct mt6362_tcpc_data *tdata, u32 reg,
-				 u16 data)
-{
-	data = cpu_to_le16(data);
-	return regmap_bulk_write(tdata->regmap, reg + MT6362_REG_BASEADDR,
-				 &data, 2);
-}
-
-static inline int mt6362_read16(struct mt6362_tcpc_data *tdata, u32 reg,
-				u16 *data)
-{
-	int ret;
-
-	ret = regmap_bulk_read(tdata->regmap, reg + MT6362_REG_BASEADDR, data,
-			       2);
-	if (ret < 0)
-		return ret;
-	*data = le16_to_cpu(*data);
-	return 0;
-}
-
-static inline int mt6362_bulk_write(struct mt6362_tcpc_data *tdata, u32 reg,
-				    const void *data, size_t count)
-{
-	return regmap_bulk_write(tdata->regmap, reg + MT6362_REG_BASEADDR, data,
-				 count);
-}
-
-
-static inline int mt6362_bulk_read(struct mt6362_tcpc_data *tdata, u32 reg,
-				   void *data, size_t count)
-{
-	return regmap_bulk_read(tdata->regmap, reg + MT6362_REG_BASEADDR, data,
-				count);
-}
-
-static inline int mt6362_update_bits(struct mt6362_tcpc_data *tdata, u32 reg,
-				     u8 mask, u8 data)
-{
-	return regmap_update_bits(tdata->regmap, reg + MT6362_REG_BASEADDR,
-				  mask, data);
-}
-
-static inline int mt6362_set_bits(struct mt6362_tcpc_data *tdata, u32 reg,
-				  u8 mask)
-{
-	return mt6362_update_bits(tdata, reg, mask, mask);
-}
-
-static inline int mt6362_clr_bits(struct mt6362_tcpc_data *tdata, u32 reg,
-				  u8 mask)
-{
-	return mt6362_update_bits(tdata, reg, mask, 0);
-}
-
-static inline int mt6362_write8_rt2(struct mt6362_tcpc_data *tdata, u32 reg,
-				    u8 data)
-{
-	return regmap_write(tdata->regmap, reg + MT6362_REG_RT2BASEADDR, data);
-}
-
-static inline int mt6362_bulk_write_rt2(struct mt6362_tcpc_data *tdata, u32 reg,
-					const void *data, size_t count)
-{
-	return regmap_bulk_write(tdata->regmap, reg + MT6362_REG_RT2BASEADDR,
-				 data, count);
-}
-
-static inline int mt6362_update_bits_rt2(struct mt6362_tcpc_data *tdata,
-					 u32 reg, u8 mask, u8 data)
-{
-	return regmap_update_bits(tdata->regmap, reg + MT6362_REG_RT2BASEADDR,
-				  mask, data);
-}
-
-static int mt6362_sw_reset(struct mt6362_tcpc_data *tdata)
-{
-	int ret;
-
-	ret = mt6362_write8(tdata, MT6362_REG_SYSCTRL3, 0x01);
-	if (ret < 0)
-		return ret;
-	usleep_range(1000, 2000);
-
-	/* disable ctd_en */
-	return mt6362_clr_bits(tdata, MT6362_REG_SHIELDCTRL1,
-			       MT6362_MSK_CTD_EN);
-}
-
-static int mt6362_init_power_status_mask(struct mt6362_tcpc_data *tdata)
-{
-	return mt6362_write8(tdata, TCPC_V10_REG_POWER_STATUS_MASK,
-			     TCPC_V10_REG_POWER_STATUS_VBUS_PRES);
-}
-
-static int mt6362_init_fault_mask(struct mt6362_tcpc_data *tdata)
-{
-	return mt6362_write8(tdata, TCPC_V10_REG_FAULT_STATUS_MASK,
-			     TCPC_V10_REG_FAULT_STATUS_VCONN_OC);
-}
-
-static int mt6362_init_ext_mask(struct mt6362_tcpc_data *tdata)
-{
-	return mt6362_write8(tdata, TCPC_V10_REG_EXT_STATUS_MASK, 0x00);
-}
-
-static int mt6362_init_vend_mask(struct mt6362_tcpc_data *tdata)
-{
-	u8 mask[MT6362_VEND_INT_NUM] = {0};
-
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
-	mask[MT6362_VEND_INT1] |= MT6362_MSK_VBUS80;
-#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
-	if (tdata->tcpc->tcpc_flags & TCPC_FLAGS_LPM_WAKEUP_WATCHDOG)
-		mask[MT6362_VEND_INT1] |= MT6362_MSK_WAKEUP;
-
-	mask[MT6362_VEND_INT2] |= MT6362_MSK_VCON_OVCC1 |
-				  MT6362_MSK_VCON_OVCC2 |
-				  MT6362_MSK_VCON_RVP |
-				  MT6362_MSK_VCON_UVP |
-				  MT6362_MSK_VCON_SHTGND;
-
-	if (tdata->tcpc->tcpc_flags & TCPC_FLAGS_CABLE_TYPE_DETECTION)
-		mask[MT6362_VEND_INT3] |= MT6362_MSK_CTD;
-
-	if (tdata->tcpc->tcpc_flags & TCPC_FLAGS_WATER_DETECTION)
-		mask[MT6362_VEND_INT7] |= MT6362_MSK_WD12_STFALL |
-					  MT6362_MSK_WD12_STRISE |
-					  MT6362_MSK_WD12_DONE;
-
-	return mt6362_bulk_write(tdata, MT6362_REG_MTMASK1, mask,
-				 MT6362_VEND_INT_NUM);
-}
-
-static int mt6362_init_alert_mask(struct mt6362_tcpc_data *tdata)
-{
-	u16 mask = TCPC_V10_REG_ALERT_CC_STATUS |
-		   TCPC_V10_REG_ALERT_POWER_STATUS |
-		   TCPC_V10_REG_ALERT_VENDOR_DEFINED;
-
-#ifdef CONFIG_USB_POWER_DELIVERY
-	mask |= TCPC_V10_REG_ALERT_TX_SUCCESS |
-		TCPC_V10_REG_ALERT_TX_DISCARDED |
-		TCPC_V10_REG_ALERT_TX_FAILED |
-		TCPC_V10_REG_ALERT_RX_HARD_RST |
-		TCPC_V10_REG_ALERT_RX_STATUS |
-		TCPC_V10_REG_RX_OVERFLOW;
-#endif /* CONFIG_USB_POWER_DELIVERY */
-
-	mask |= TCPC_REG_ALERT_FAULT;
-	return mt6362_write16(tdata, TCPC_V10_REG_ALERT_MASK, mask);
-}
-
-static int __mt6362_set_cc(struct mt6362_tcpc_data *tdata, int rp_lvl, int pull)
-{
-	return mt6362_write8(tdata, TCPC_V10_REG_ROLE_CTRL,
-			     TCPC_V10_REG_ROLE_CTRL_RES_SET(0, rp_lvl, pull,
-			     pull));
-}
-
-static int mt6362_enable_force_discharge(struct mt6362_tcpc_data *tdata,
-					 bool en)
-{
-	return (en ? mt6362_set_bits : mt6362_clr_bits)
-		(tdata, TCPC_V10_REG_POWER_CTRL, TCPC_V10_REG_FORCE_DISC_EN);
-}
-
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
-static int mt6362_enable_vsafe0v_detect(struct mt6362_tcpc_data *tdata, bool en)
-{
-	return (en ? mt6362_set_bits : mt6362_clr_bits)
-		(tdata, MT6362_REG_MTMASK1, MT6362_MSK_VBUS80);
-}
-#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
-
-static int __maybe_unused mt6362_enable_rpdet_auto(
-					struct mt6362_tcpc_data *tdata, bool en)
-{
-	return (en ? mt6362_set_bits : mt6362_clr_bits)
-		(tdata, MT6362_REG_SHIELDCTRL1, MT6362_MSK_RPDET_AUTO);
-}
-
-static int __maybe_unused mt6362_enable_rpdet_manual(
-					struct mt6362_tcpc_data *tdata, bool en)
-{
-	return (en ? mt6362_clr_bits : mt6362_set_bits)
-		(tdata, MT6362_REG_SHIELDCTRL1, MT6362_MSK_RPDET_MANUAL);
-}
-
-static int mt6362_is_vconn_fault(struct mt6362_tcpc_data *tdata, bool *fault)
-{
-	int ret;
-	u8 status;
-
-	ret = mt6362_read8(tdata, MT6362_REG_MTST2, &status);
-	if (ret < 0)
-		return ret;
-	*fault = (status & MT6362_MSK_VCON_FAULT) ? true : false;
-	return 0;
-}
-
-static int mt6362_vend_alert_status_clear(struct mt6362_tcpc_data *tdata,
-					  const u8 *mask)
-{
-	mt6362_bulk_write(tdata, MT6362_REG_MTINT1, mask, MT6362_VEND_INT_NUM);
-	return mt6362_write16(tdata, TCPC_V10_REG_ALERT,
-			      TCPC_V10_REG_ALERT_VENDOR_DEFINED);
-}
-
-#ifdef CONFIG_CABLE_TYPE_DETECTION
-static int mt6362_get_cable_type(struct mt6362_tcpc_data *tdata,
-				 enum tcpc_cable_type *type)
-{
-	int ret;
-	u8 data;
-
-	ret = mt6362_read8(tdata, MT6362_REG_MTST3, &data);
-	if (ret < 0)
-		return ret;
-	if (data & MT6362_MSK_CABLE_TYPEC)
-		*type = TCPC_CABLE_TYPE_C2C;
-	else if (data & MT6362_MSK_CABLE_TYPEA)
-		*type = TCPC_CABLE_TYPE_A2C;
-	else
-		*type = TCPC_CABLE_TYPE_NONE;
-	return 0;
-}
-#endif /* CONFIG_CABLE_TYPE_DETECTION */
-
-static int mt6362_init_fod_ctd(struct mt6362_tcpc_data *tdata)
-{
-	int ret = 0;
-#ifdef CONFIG_CABLE_TYPE_DETECTION
-	u8 ctd_evt;
-
-	tdata->tcpc->typec_cable_type = TCPC_CABLE_TYPE_NONE;
-	tdata->handle_init_ctd = true;
-	ret = mt6362_read8(tdata, MT6362_REG_MTINT3, &ctd_evt);
-	if (ret < 0)
-		return ret;
-	if (ctd_evt & MT6362_MSK_CTD)
-		mt6362_get_cable_type(tdata, &tdata->init_cable_type);
-#endif /* CONFIG_CABLE_TYPE_DETECTION */
-	return ret;
-}
-
-#ifdef CONFIG_WATER_DETECTION
-static int mt6362_set_wd_ldo(struct mt6362_tcpc_data *tdata,
-			     enum mt6362_wd_ldo ldo)
-{
-	return mt6362_update_bits(tdata, MT6362_REG_WDSET, MT6362_MSK_WDLDO_SEL,
-				  ldo << MT6362_SFT_WDLDO_SEL);
-}
-#endif /* CONFIG_WATER_DETECTION */
-
-#ifdef CONFIG_WATER_DETECTION
-static int mt6362_get_cc(struct tcpc_device *tcpc, int *cc1, int *cc2);
-static int mt6362_is_cc_toggling(struct mt6362_tcpc_data *tdata, bool *toggling)
-{
-	int ret;
-	int cc1 = 0, cc2 = 0;
-
-	ret = mt6362_get_cc(tdata->tcpc, &cc1, &cc2);
-	if (ret < 0)
-		return ret;
-	*toggling = (cc1 == TYPEC_CC_DRP_TOGGLING &&
-		     cc2 == TYPEC_CC_DRP_TOGGLING);
-	return 0;
-}
-
-static int mt6362_init_wd(struct mt6362_tcpc_data *tdata)
-{
-	/*
-	 * WD_LDO = 1.8V
-	 * WD_CHPHYS_EN = 0
-	 * WD_SWITCH_CNT = 100
-	 * WD_POLL_SWITCH = 0
-	 * WD12_TDET_ALWAYS = 0, depend on WD_TDET[2:0]
-	 * WD0_TDET_ALWAYS = 0, depend on WD_TDET[2:0]
-	 */
-	mt6362_write8(tdata, MT6362_REG_WDSET, 0x50);
-
-	/* WD_EXIT_CNT = 4times */
-	mt6362_set_bits(tdata, MT6362_REG_WDSET1, 0x02);
-
-	/* WD1_RPULL_EN = 1, WD1_DISCHG_EN = 1 */
-	mt6362_write8(tdata, MT6362_REG_WD1MISCCTRL, 0x06);
-
-	/* WD2_RPULL_EN = 1, WD2_DISCHG_EN = 1 */
-	mt6362_write8(tdata, MT6362_REG_WD2MISCCTRL, 0x06);
-
-	/* WD0_RPULL_EN = 1, WD0_DISCHG_EN = 1 */
-	mt6362_write8(tdata, MT6362_REG_WD0SET, 0x06);
-
-	mt6362_bulk_write_rt2(tdata, MT6362_REG_WDSET2,
-			      mt6362_rt2_wd_init_setting,
-			      ARRAY_SIZE(mt6362_rt2_wd_init_setting));
-	return 0;
-}
-
-static int mt6362_set_wd_rpull(struct mt6362_tcpc_data *tdata,
-			       enum mt6362_wd_chan chan,
-			       enum mt6362_wd_rpull rpull)
-{
-	return mt6362_update_bits_rt2(tdata, mt6362_wd_rpull_reg[chan],
-				      MT6362_MSK_WDRPULL_SEL,
-				      rpull << MT6362_SFT_WDRPULL_SEL);
-}
-
-static int  __maybe_unused mt6362_set_wd_ipull(struct mt6362_tcpc_data *tdata,
-					       enum mt6362_wd_chan chan,
-					       enum mt6362_wd_ipull ipull)
-{
-	return mt6362_update_bits_rt2(tdata, mt6362_wd_ipull_reg[chan],
-				      MT6362_MSK_WDIPULL_SEL,
-				      ipull << MT6362_SFT_WDIPULL_SEL);
-}
-
-static int mt6362_set_wd_path(struct mt6362_tcpc_data *tdata,
-			      enum mt6362_wd_chan chan, u8 path)
-{
-	return mt6362_write8(tdata, mt6362_wd_path_reg[chan], path);
-}
-
-static int mt6362_get_wd_path(struct mt6362_tcpc_data *tdata,
-			      enum mt6362_wd_chan chan, u8 *path)
-{
-	return mt6362_read8(tdata, mt6362_wd_path_reg[chan], path);
-}
-
-static int mt6362_set_wd_polling_path(struct mt6362_tcpc_data *tdata,
-				      enum mt6362_wd_chan chan)
-{
-	return mt6362_set_wd_path(tdata, chan, mt6362_wd_polling_path[chan]);
-}
-
-static int mt6362_set_wd_protection_path(struct mt6362_tcpc_data *tdata,
-					 enum mt6362_wd_chan chan)
-{
-	return mt6362_set_wd_path(tdata, chan, mt6362_wd_protection_path[chan]);
-}
-
-static int mt6362_set_wd_polling_parameter(struct mt6362_tcpc_data *tdata,
-					   enum mt6362_wd_chan chan)
-{
-	int ret;
-
-	ret = mt6362_set_wd_rpull(tdata, chan, MT6362_WD_RPULL_75K);
-	if (ret < 0)
-		return ret;
-	ret = mt6362_write8(tdata, mt6362_wd_miscctrl_reg[chan],
-			    MT6362_MSK_WDRPULL_EN | MT6362_MSK_WDDISCHG_EN);
-	if (ret < 0)
-		return ret;
-	ret = mt6362_update_bits_rt2(tdata,
-				     mt6362_wd_volcmp_reg[chan],
-				     MT6362_MSK_WD12_VOLCOML,
-				     MT6362_WD_VOL_CMPL_1_44V <<
-						MT6362_SFT_WD12_VOLCOML);
-	if (ret < 0)
-		return ret;
-	return mt6362_set_wd_polling_path(tdata, chan);
-}
-
-static int mt6362_set_wd_protection_parameter(struct mt6362_tcpc_data *tdata,
-					      enum mt6362_wd_chan chan)
-{
-	int ret;
-
-	ret = mt6362_set_wd_rpull(tdata, chan, MT6362_WD_RPULL_75K);
-	if (ret < 0)
-		return ret;
-	ret = mt6362_update_bits_rt2(tdata,
-				     mt6362_wd_volcmp_reg[chan],
-				     MT6362_MSK_WD12_VOLCOML,
-				     MT6362_WD_VOL_CMPL_1_54V <<
-						MT6362_SFT_WD12_VOLCOML);
-	if (ret < 0)
-		return ret;
-	ret = mt6362_write8(tdata, mt6362_wd_miscctrl_reg[chan],
-			    MT6362_MSK_WDRPULL_EN | MT6362_MSK_WDDISCHG_EN);
-	if (ret < 0)
-		return ret;
-	return mt6362_set_wd_protection_path(tdata, chan);
-}
-
-static int mt6362_check_wd_status(struct mt6362_tcpc_data *tdata,
-				  enum mt6362_wd_chan chan, bool *error)
-{
-	int i, ret;
-	u8 path;
-	u8 data[MT6362_WD_STATUS_NUM];
-
-	ret = mt6362_bulk_read(tdata, mt6362_wd_status_reg[chan], data,
-			       MT6362_WD_STATUS_NUM);
-	if (ret < 0)
-		return ret;
-	ret = mt6362_get_wd_path(tdata, chan, &path);
-	if (ret < 0)
-		return ret;
-	*error = false;
-	for (i = 0; i < MT6362_WD_STATUS_NUM; i++) {
-		if (path & data[i])
-			*error = true;
-		MT6362_DBGINFO("chan(path,stat)=%d(0x%02X,0x%02X)\n", chan,
-			       path, data[i]);
-	}
-	return 0;
-}
-
-static int mt6362_enable_wd_dischg(struct mt6362_tcpc_data *tdata,
-				   enum mt6362_wd_chan chan, bool en)
-{
-	int ret;
-
-	if (en) {
-		ret = mt6362_set_wd_polling_path(tdata, chan);
-		if (ret < 0)
-			return ret;
-		ret = mt6362_write8(tdata, mt6362_wd_miscctrl_reg[chan],
-				    MT6362_MSK_WDDISCHG_EN |
-				    MT6362_MSK_WDFWMODE_EN);
-	} else {
-		ret = mt6362_set_wd_path(tdata, chan, 0);
-		if (ret < 0)
-			return ret;
-		ret = mt6362_write8(tdata, mt6362_wd_miscctrl_reg[chan],
-				    MT6362_MSK_WDRPULL_EN |
-				    MT6362_MSK_WDDISCHG_EN);
-	}
-	return ret;
-}
-
-static int mt6362_enable_wd_pullup(struct mt6362_tcpc_data *tdata,
-				   enum mt6362_wd_chan chan,
-				   enum mt6362_wd_rpull rpull, bool en)
-{
-	int ret;
-
-	if (en) {
-		ret = mt6362_set_wd_polling_path(tdata, chan);
-		if (ret < 0)
-			return ret;
-		ret = mt6362_set_wd_rpull(tdata, chan, rpull);
-		if (ret < 0)
-			return ret;
-		ret = mt6362_write8(tdata, mt6362_wd_miscctrl_reg[chan],
-				    MT6362_MSK_WDRPULL_EN |
-				    MT6362_MSK_WDFWMODE_EN);
-	} else {
-		ret = mt6362_set_wd_path(tdata, chan, 0);
-		if (ret < 0)
-			return ret;
-		ret = mt6362_write8(tdata, mt6362_wd_miscctrl_reg[chan],
-				    MT6362_MSK_WDRPULL_EN |
-				    MT6362_MSK_WDDISCHG_EN);
-	}
-	return ret;
-}
-
-static int mt6362_get_wd_adc(struct mt6362_tcpc_data *tdata,
-			     enum mt6362_wd_chan chan, int *val)
-{
-	int ret;
-
-	ret = iio_read_channel_processed(&tdata->adc_iio[chan], val);
-	if (ret < 0)
-		return ret;
-	*val /= 1000;
-	return 0;
-}
-
-static bool mt6362_is_wd_audio_device(struct mt6362_tcpc_data *tdata,
-				      enum mt6362_wd_chan chan, int wd_adc)
-{
-	struct tcpc_desc *desc = tdata->desc;
-	int ret;
-
-	if (wd_adc >= desc->wd_sbu_ph_auddev)
-		return false;
-
-	/* Pull high with 1K resistor */
-	ret = mt6362_enable_wd_pullup(tdata, chan, MT6362_WD_RPULL_1K, true);
-	if (ret < 0) {
-		MT6362_DBGINFO("chan%d pull up 1k fail(%d)\n", chan, ret);
-		goto not_auddev;
-	}
-
-	ret = mt6362_get_wd_adc(tdata, chan, &wd_adc);
-	if (ret < 0) {
-		MT6362_DBGINFO("get chan%d adc fail(%d)\n", chan, ret);
-		goto not_auddev;
-	}
-
-	if (wd_adc >= desc->wd_sbu_aud_ubound)
-		goto not_auddev;
-	return true;
-
-not_auddev:
-	mt6362_enable_wd_pullup(tdata, chan, MT6362_WD_RPULL_500K, true);
-	return false;
-}
-
-static int __mt6362_is_water_detected(struct mt6362_tcpc_data *tdata,
-				      enum mt6362_wd_chan chan, bool *wd)
-{
-	int ret, wd_adc, i;
-	struct tcpc_desc *desc = tdata->desc;
-	u32 lb = desc->wd_sbu_ph_lbound;
-	u32 ub = desc->wd_sbu_calib_init * 110 / 100;
-#ifdef CONFIG_CABLE_TYPE_DETECTION
-	enum tcpc_cable_type cable_type;
-	u8 ctd_evt;
-#endif /* CONFIG_CABLE_TYPE_DETECTION */
-
-	pm_stay_awake(tdata->dev);
-	/* Check WD1/2 pulled low */
-	for (i = 0; i < CONFIG_WD_SBU_PL_RETRY; i++) {
-		ret = mt6362_enable_wd_dischg(tdata, chan, true);
-		if (ret < 0) {
-			MT6362_DBGINFO("en chan%d dischg fail(%d)\n", chan,
-				       ret);
-			goto out;
-		}
-		ret = mt6362_get_wd_adc(tdata, chan, &wd_adc);
-		if (ret < 0) {
-			MT6362_DBGINFO("get chan%d adc fail(%d)\n", chan, ret);
-			goto out;
-		}
-		MT6362_DBGINFO("chan%d pull low %dmV\n", chan, wd_adc);
-		ret = mt6362_enable_wd_dischg(tdata, chan, false);
-		if (ret < 0) {
-			MT6362_DBGINFO("disable chan%d dischg fail(%d)\n", chan,
-				       ret);
-			goto out;
-		}
-		if (wd_adc <= desc->wd_sbu_pl_bound ||
-			(wd_adc >= desc->wd_sbu_pl_lbound_c2c &&
-			wd_adc <= desc->wd_sbu_pl_ubound_c2c))
-			break;
-	}
-	if (i == CONFIG_WD_SBU_PL_RETRY) {
-		*wd = true;
-		goto out;
-	}
-
-	ret = mt6362_enable_wd_pullup(tdata, chan, MT6362_WD_RPULL_500K, true);
-	if (ret < 0) {
-		MT6362_DBGINFO("chan%d pull up 500k fail(%d)\n", chan, ret);
-		goto out;
-	}
-
-	for (i = 0; i < CONFIG_WD_SBU_PH_RETRY; i++) {
-		ret = mt6362_get_wd_adc(tdata, chan, &wd_adc);
-		if (ret < 0) {
-			MT6362_DBGINFO("get chan%d adc fail(%d)\n", chan, ret);
-			goto out;
-		}
-		MT6362_DBGINFO("chan%d pull high %dmV(lb %d, ub %d)\n", chan,
-			       wd_adc, lb, ub);
-		if (wd_adc >= lb && wd_adc <= ub) {
-			*wd = false;
-			goto out;
-		}
-		msleep(20);
-	}
-
-#ifdef CONFIG_CABLE_TYPE_DETECTION
-	cable_type = tdata->tcpc->typec_cable_type;
-	if (cable_type == TCPC_CABLE_TYPE_NONE) {
-		ret = mt6362_read8(tdata, MT6362_REG_MTINT3, &ctd_evt);
-		if (ret >= 0 && (ctd_evt & MT6362_MSK_CTD))
-			ret = mt6362_get_cable_type(tdata, &cable_type);
-	}
-	if (cable_type == TCPC_CABLE_TYPE_C2C) {
-		if (((wd_adc >= desc->wd_sbu_ph_lbound1_c2c) &&
-		    (wd_adc <= desc->wd_sbu_ph_ubound1_c2c)) ||
-		    (wd_adc > desc->wd_sbu_ph_ubound2_c2c)) {
-			MT6362_DBGINFO("ignore water for C2C\n");
-			*wd = false;
-			goto out;
-		}
-	}
-#endif /* CONFIG_CABLE_TYPE_DETECTION */
-
-	if (mt6362_is_wd_audio_device(tdata, chan, wd_adc)) {
-		MT6362_DBGINFO("suspect audio device but not water\n");
-		*wd = false;
-		goto out;
-	}
-	*wd = true;
-out:
-	MT6362_DBGINFO("water %s\n", *wd ? "detected" : "not detected");
-	mt6362_write8(tdata, mt6362_wd_miscctrl_reg[chan],
-		      MT6362_MSK_WDRPULL_EN | MT6362_MSK_WDDISCHG_EN);
-	pm_relax(tdata->dev);
-	return ret;
-}
-
-static int mt6362_enable_wd_polling(struct mt6362_tcpc_data *tdata, bool en)
-{
-	int ret, i;
-
-	if (en) {
-		ret = mt6362_set_wd_ldo(tdata, MT6362_WD_LDO_1_8V);
-		if (ret < 0)
-			return ret;
-		/* set wd detect time interval base 10ms */
-		ret = mt6362_update_bits_rt2(tdata,
-					     MT6362_REG_WDSET3,
-					     MT6362_MASK_WD_TDET,
-					     MT6362_WD_TDET_10MS <<
-						MT6362_SHFT_WD_TDET);
-		if (ret < 0)
-			return ret;
-		for (i = 0; i < MT6362_WD_CHAN_NUM; i++) {
-			if (!mt6362_wd_chan_en[i])
-				continue;
-			ret = mt6362_set_wd_polling_parameter(tdata, i);
-			if (ret < 0)
-				return ret;
-		}
-	}
-	return mt6362_write8(tdata, MT6362_REG_WD12MODECTRL,
-			     en ? MT6362_MSK_WD12MODE_EN : 0);
-}
-
-static int mt6362_enable_wd_protection(struct mt6362_tcpc_data *tdata, bool en)
-{
-	int i, ret;
-
-	MT6362_DBGINFO("%s: en = %d\n", __func__, en);
-	if (en) {
-		/* set wd detect time interval base 1ms */
-		ret = mt6362_update_bits_rt2(tdata,
-					     MT6362_REG_WDSET3,
-					     MT6362_MASK_WD_TDET,
-					     MT6362_WD_TDET_1MS <<
-						MT6362_SHFT_WD_TDET);
-		if (ret < 0)
-			return ret;
-		for (i = 0; i < MT6362_WD_CHAN_NUM; i++) {
-			if (!mt6362_wd_chan_en[i])
-				continue;
-			mt6362_set_wd_protection_parameter(tdata, i);
-		}
-	}
-	/* set DPDM manual mode and DPDM_DET_EN = 1 */
-	ret = regmap_update_bits(tdata->regmap, MT6362_REG_DPDM_CTRL1,
-		MT6362_MSK_MANUAL_MODE | MT6362_MSK_DPDM_DET_EN, en ? 0xff : 0);
-	if (ret < 0)
-		return ret;
-	return mt6362_write8(tdata, MT6362_REG_WD12MODECTRL,
-			     en ?
-			     MT6362_MSK_WD12MODE_EN | MT6362_MSK_WD12PROT : 0);
-}
-
-static int mt6362_wd_polling_evt_process(struct mt6362_tcpc_data *tdata)
-{
-	int i, ret;
-	bool toggling, polling = true, error = false;
-
-	/* Only handle this event if CCs are still toggling */
-	ret = mt6362_is_cc_toggling(tdata, &toggling);
-	if (ret < 0)
-		return ret;
-	if (!toggling)
-		return 0;
-
-	mt6362_enable_wd_polling(tdata, false);
-	for (i = 0; i < MT6362_WD_CHAN_NUM; i++) {
-		if (!mt6362_wd_chan_en[i])
-			continue;
-		ret = mt6362_check_wd_status(tdata, i, &error);
-		if (ret < 0 || !error)
-			continue;
-		ret = __mt6362_is_water_detected(tdata, i, &error);
-		if (ret < 0 || !error)
-			continue;
-		polling = false;
-		break;
-	}
-	if (polling)
-		mt6362_enable_wd_polling(tdata, true);
-	else
-		tcpc_typec_handle_wd(tdata->tcpc, true);
-	return 0;
-}
-
-static int mt6362_wd_protection_evt_process(struct mt6362_tcpc_data *tdata)
-{
-	int i, ret;
-	bool error[2] = {false, false}, protection = false;
-
-	for (i = 0; i < MT6362_WD_CHAN_NUM; i++) {
-		if (!mt6362_wd_chan_en[i])
-			continue;
-		ret = mt6362_check_wd_status(tdata, i, &error[0]);
-		if (ret < 0)
-			goto out;
-		ret = __mt6362_is_water_detected(tdata, i, &error[1]);
-		if (ret < 0)
-			goto out;
-		MT6362_DBGINFO("%s: err1:%d, err2:%d\n",
-			       __func__, error[0], error[1]);
-		if (!error[0] && !error[1])
-			continue;
-out:
-		protection = true;
-		break;
-	}
-	MT6362_DBGINFO("%s: retry cnt = %d\n", __func__, tdata->wd_protect_rty);
-	if (!protection && atomic_dec_and_test(&tdata->wd_protect_rty)) {
-		tcpc_typec_handle_wd(tdata->tcpc, false);
-		atomic_set(&tdata->wd_protect_rty,
-			   CONFIG_WD_PROTECT_RETRY_COUNT);
-	} else
-		mt6362_enable_wd_protection(tdata, true);
-	return 0;
-}
-
-#ifdef CONFIG_WD_POLLING_ONLY
-static void mt6362_wd_poll_dwork_handler(struct work_struct *work)
-{
-	int ret;
-	bool toggling;
-	struct delayed_work *dwork = to_delayed_work(work);
-	struct mt6362_tcpc_data *tdata = container_of(dwork,
-						     struct mt6362_tcpc_data,
-						     wd_poll_dwork);
-
-	ret = mt6362_is_cc_toggling(tdata, &toggling);
-	if (ret < 0)
-		return;
-	if (!toggling)
-		return;
-	mt6362_enable_wd_polling(tdata, true);
-}
-#endif /* CONFIG_WD_POLLING_ONLY */
-#endif /* CONFIG_WATER_DETECTION */
-
-static int mt6362_set_cc_toggling(struct mt6362_tcpc_data *tdata, int pull)
-{
-	int ret, rp_lvl = TYPEC_CC_PULL_GET_RP_LVL(pull);
-	u8 data = TCPC_V10_REG_ROLE_CTRL_RES_SET(1, rp_lvl, TYPEC_CC_RD,
-						 TYPEC_CC_RD);
-
-	ret = mt6362_write8(tdata, TCPC_V10_REG_ROLE_CTRL, data);
-	if (ret < 0)
-		return ret;
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
-	ret = mt6362_enable_vsafe0v_detect(tdata, false);
-	if (ret < 0)
-		return ret;
-#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
-	/* Set LDO to 2V */
-	ret = mt6362_write8(tdata, MT6362_REG_LPWRCTRL3, 0xD9);
-	if (ret < 0)
-		return ret;
-#ifdef CONFIG_TCPC_LOW_POWER_MODE
-	tcpci_set_low_power_mode(tdata->tcpc, true, pull);
-#endif /* CONFIG_TCPC_LOW_POWER_MODE */
-	udelay(30);
-	ret = mt6362_write8(tdata, TCPC_V10_REG_COMMAND,
-			    TCPM_CMD_LOOK_CONNECTION);
-	if (ret < 0)
-		return ret;
-#ifdef CONFIG_WD_SBU_POLLING
-#ifdef CONFIG_WD_POLLING_ONLY
-	schedule_delayed_work(&tdata->wd_poll_dwork,
-			msecs_to_jiffies(500));
-#else
-	mt6362_enable_wd_polling(tdata, true);
-#endif /* CONFIG_WD_POLLING_ONLY */
-#endif /* CONFIG_WD_SBU_POLLING */
-	return 0;
-}
-
-/*
- * ==================================================================
- * TCPC ops
- * ==================================================================
- */
-
-static int mt6362_tcpc_init(struct tcpc_device *tcpc, bool sw_reset)
-{
-	int ret;
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	if (sw_reset) {
-		ret = mt6362_sw_reset(tdata);
-		if (ret < 0)
-			return ret;
-	}
-
-	/* Select PD_IRQB from synchronous to 3M path */
-	mt6362_set_bits(tdata, MT6362_REG_SYSCTRL1, 0x80);
-
-	/* UFP Both RD setting */
-	/* DRP = 0, RpVal = 0 (Default), Rd, Rd */
-	mt6362_write8(tdata, TCPC_V10_REG_ROLE_CTRL,
-		      TCPC_V10_REG_ROLE_CTRL_RES_SET(0, 0, CC_RD, CC_RD));
-
-	/* tTCPCFilter = 250us */
-	mt6362_write8(tdata, MT6362_REG_TCPCCTRL1, 0x0A);
-
-	/*
-	 * DRP Toggle Cycle : 51.2 + 6.4*val ms
-	 * DRP Duyt Ctrl : dcSRC / 1024
-	 */
-	mt6362_write8(tdata, MT6362_REG_TCPCCTRL2, 4);
-	mt6362_write16(tdata, MT6362_REG_TCPCCTRL3, TCPC_NORMAL_RP_DUTY);
-
-	/*
-	 * Transition toggle count = 7
-	 * OSC_FREQ_CFG = 0x01
-	 * RXFilter out 100ns glich = 0x00
-	 */
-	mt6362_write8(tdata, MT6362_REG_PHYCTRL1, 0x74);
-
-	/* PHY_CDR threshold = 0x3A */
-	mt6362_write8(tdata, MT6362_REG_PHYCTRL2, 0x3A);
-
-	/* Transition window time = 43.29us */
-	mt6362_write8(tdata, MT6362_REG_PHYCTRL3, 0x82);
-
-	/* BMC decoder idle time = 17.982us */
-	mt6362_write8(tdata, MT6362_REG_PHYCTRL7, 0x36);
-
-	/* Retry period = 24.96us */
-	mt6362_write8(tdata, MT6362_REG_PHYCTRL9, 0x3C);
-
-	/* Enable PD Vconn current limit mode */
-	mt6362_write8(tdata, MT6362_REG_VCONCTRL3, 0x41);
-
-	/* Set HILOCCFILTER 250us */
-	mt6362_write8(tdata, MT6362_REG_HILOCTRL9, 0x0A);
-
-	/* Enable CC open 40ms when PMIC SYSUV */
-	mt6362_set_bits(tdata, MT6362_REG_SHIELDCTRL1, MT6362_MSK_OPEN40MS_EN);
-
-	/*
-	 * Enable Alert.CCStatus assertion
-	 * when CCStatus.Looking4Connection changes
-	 */
-	mt6362_set_bits(tdata, TCPC_V10_REG_TCPC_CTRL,
-			TCPC_V10_REG_TCPC_CTRL_EN_LOOK4CONNECTION_ALERT);
-
-#ifdef CONFIG_WATER_DETECTION
-	mt6362_init_wd(tdata);
-#endif /* CONFIG_WATER_DETECTION */
-
-	tcpci_init_alert_mask(tcpc);
-
-	if (tcpc->tcpc_flags & TCPC_FLAGS_WATCHDOG_EN) {
-		/* Set watchdog timer = 3.2s and enable */
-		mt6362_write8(tdata, MT6362_REG_WATCHDOGCTRL, 0x07);
-		tcpci_set_watchdog(tcpc, true);
-	}
-
-	/* enable ctd_en */
-	ret = mt6362_set_bits(tdata, MT6362_REG_SHIELDCTRL1, MT6362_MSK_CTD_EN);
-
-	/* SHIPPING off, AUTOIDLE on */
-	mt6362_set_bits(tdata, MT6362_REG_SYSCTRL1,
-			MT6362_MSK_SHIPPING_OFF | MT6362_MSK_AUTOIDLE_EN);
-	return 0;
-}
-
-static int mt6362_init_mask(struct tcpc_device *tcpc)
-{
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	mt6362_init_alert_mask(tdata);
-	mt6362_init_power_status_mask(tdata);
-	mt6362_init_fault_mask(tdata);
-	mt6362_init_ext_mask(tdata);
-	mt6362_init_vend_mask(tdata);
-
-#ifdef CONFIG_CABLE_TYPE_DETECTION
-	/* Init cable type must be done after fod */
-	if (tdata->handle_init_ctd) {
-		/*
-		 * wait 3ms for exit low power mode and
-		 * TCPC filter debounce
-		 */
-		mdelay(3);
-		tdata->handle_init_ctd = false;
-		tcpc_typec_handle_ctd(tcpc, tdata->init_cable_type);
-	}
-#endif /* CONFIG_CABLE_TYPE_DETECTION */
-	return 0;
-}
-
-static int mt6362_alert_status_clear(struct tcpc_device *tcpc, u32 mask)
-{
-	u16 std_mask = mask & 0xffff;
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	return std_mask ?
-	       mt6362_write16(tdata, TCPC_V10_REG_ALERT, std_mask) : 0;
-}
-
-static int mt6362_fault_status_clear(struct tcpc_device *tcpc, u8 status)
-{
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	/*
-	 * Not sure how to react after discharge fail
-	 * follow previous H/W behavior, turn off force discharge
-	 */
-	if (status & TCPC_V10_REG_FAULT_STATUS_FORCE_DISC_FAIL)
-		mt6362_enable_force_discharge(tdata, false);
-	return mt6362_write8(tdata, TCPC_V10_REG_FAULT_STATUS, status);
-}
-
-static int mt6362_set_alert_mask(struct tcpc_device *tcpc, u32 mask)
-{
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	MT6362_DBGINFO("%s: mask = 0x%04x\n", __func__, mask);
-	return mt6362_write16(tdata, TCPC_V10_REG_ALERT_MASK, mask);
-}
-
-static int mt6362_get_alert_mask(struct tcpc_device *tcpc, u32 *mask)
-{
-	int ret;
-	u16 data;
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	ret = mt6362_read16(tdata, TCPC_V10_REG_ALERT_MASK, &data);
-	if (ret < 0)
-		return ret;
-	*mask = data;
-	return 0;
-}
-
-static int mt6362_get_alert_status(struct tcpc_device *tcpc, u32 *alert)
-{
-	int ret;
-	u16 data;
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	ret = mt6362_read16(tdata, TCPC_V10_REG_ALERT, &data);
-	if (ret < 0)
-		return ret;
-	*alert = data;
-	return 0;
-}
-
-static int mt6362_get_power_status(struct tcpc_device *tcpc, u16 *status)
-{
-	int ret;
-	u8 data;
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	ret = mt6362_read8(tdata, TCPC_V10_REG_POWER_STATUS, &data);
-	if (ret < 0)
-		return ret;
-
-	*status = 0;
-	if (data & TCPC_V10_REG_POWER_STATUS_VBUS_PRES)
-		*status |= TCPC_REG_POWER_STATUS_VBUS_PRES;
-
-	/*
-	 * Vsafe0v only triggers when vbus falls under 0.8V,
-	 * also update parameter if vbus present triggers
-	 */
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
-	ret = tcpci_is_vsafe0v(tcpc);
-	if (ret < 0)
-		goto out;
-	tcpc->vbus_safe0v = ret ? true : false;
-#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
-out:
-	return 0;
-}
-
-static int mt6362_get_fault_status(struct tcpc_device *tcpc, u8 *status)
-{
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	return mt6362_read8(tdata, TCPC_V10_REG_FAULT_STATUS, status);
-}
-
-static int mt6362_get_cc(struct tcpc_device *tcpc, int *cc1, int *cc2)
-{
-	int ret;
-	bool act_as_sink, act_as_drp;
-	u8 status, role_ctrl, cc_role;
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	ret = mt6362_read8(tdata, TCPC_V10_REG_CC_STATUS, &status);
-	if (ret < 0)
-		return ret;
-
-	ret = mt6362_read8(tdata, TCPC_V10_REG_ROLE_CTRL, &role_ctrl);
-	if (ret < 0)
-		return ret;
-
-	if (status & TCPC_V10_REG_CC_STATUS_DRP_TOGGLING) {
-		*cc1 = TYPEC_CC_DRP_TOGGLING;
-		*cc2 = TYPEC_CC_DRP_TOGGLING;
-		return 0;
-	}
-
-	*cc1 = TCPC_V10_REG_CC_STATUS_CC1(status);
-	*cc2 = TCPC_V10_REG_CC_STATUS_CC2(status);
-
-	act_as_drp = TCPC_V10_REG_ROLE_CTRL_DRP & role_ctrl;
-
-	if (act_as_drp)
-		act_as_sink = TCPC_V10_REG_CC_STATUS_DRP_RESULT(status);
-	else {
-		cc_role = TCPC_V10_REG_CC_STATUS_CC1(role_ctrl);
-		act_as_sink = (cc_role == TYPEC_CC_RP) ? false : true;
-	}
-
-	/*
-	 * If status is not open, then OR in termination to convert to
-	 * enum tcpc_cc_voltage_status.
-	 */
-	if (*cc1 != TYPEC_CC_VOLT_OPEN)
-		*cc1 |= (act_as_sink << 2);
-	if (*cc2 != TYPEC_CC_VOLT_OPEN)
-		*cc2 |= (act_as_sink << 2);
-	return 0;
-}
-
-static int mt6362_set_cc(struct tcpc_device *tcpc, int pull)
-{
-	int ret;
-	int rp_lvl = TYPEC_CC_PULL_GET_RP_LVL(pull);
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	MT6362_INFO("%s %d\n", __func__, pull);
-	pull = TYPEC_CC_PULL_GET_RES(pull);
-	if (pull == TYPEC_CC_DRP) {
-		ret = mt6362_set_cc_toggling(tdata, pull);
-	} else {
-#ifdef CONFIG_WD_POLLING_ONLY
-		cancel_delayed_work_sync(&tdata->wd_poll_dwork);
-		mt6362_enable_wd_polling(tdata, false);
-#endif /* CONFIG_WD_POLLING_ONLY */
-		ret = __mt6362_set_cc(tdata, rp_lvl, pull);
-	}
-	return ret;
-}
-
-static int mt6362_set_polarity(struct tcpc_device *tcpc, int polarity)
-{
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	return (polarity ? mt6362_set_bits : mt6362_clr_bits)
-		(tdata, TCPC_V10_REG_TCPC_CTRL,
-		 TCPC_V10_REG_TCPC_CTRL_PLUG_ORIENT);
-}
-
-static int mt6362_set_low_rp_duty(struct tcpc_device *tcpc, bool low_rp)
-{
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-	u16 duty = low_rp ? TCPC_LOW_RP_DUTY : TCPC_NORMAL_RP_DUTY;
-
-	return mt6362_write16(tdata, MT6362_REG_TCPCCTRL2, duty);
-}
-
-static int mt6362_set_vconn(struct tcpc_device *tcpc, int en)
-{
-	int ret;
-	bool fault = false;
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	/*
-	 * Set Vconn OVP RVP
-	 * Otherwise vconn present fail will be triggered
-	 */
-	if (en) {
-		mt6362_set_bits(tdata, MT6362_REG_VCONCTRL2,
-				MT6362_MSK_VCON_PROTEN);
-		usleep_range(20, 50);
-		ret = mt6362_is_vconn_fault(tdata, &fault);
-		if (ret >= 0 && fault)
-			return -EINVAL;
-	}
-	ret = (en ? mt6362_set_bits : mt6362_clr_bits)
-		(tdata, TCPC_V10_REG_POWER_CTRL, TCPC_V10_REG_POWER_CTRL_VCONN);
-	if (!en)
-		mt6362_clr_bits(tdata, MT6362_REG_VCONCTRL2,
-				MT6362_MSK_VCON_PROTEN);
-	return ret;
-}
-
-static int mt6362_tcpc_deinit(struct tcpc_device *tcpc)
-{
-#ifdef CONFIG_TCPC_SHUTDOWN_CC_DETACH
-	mt6362_set_cc(tcpc, TYPEC_CC_DRP);
-	mt6362_set_cc(tcpc, TYPEC_CC_OPEN);
-#else
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	mt6362_write8(tdata, MT6362_REG_SYSCTRL3, 0x01);
-#endif	/* CONFIG_TCPC_SHUTDOWN_CC_DETACH */
-	return 0;
-}
-
-static int mt6362_set_watchdog(struct tcpc_device *tcpc, bool en)
-{
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	return (en ? mt6362_set_bits : mt6362_clr_bits)
-		(tdata, TCPC_V10_REG_TCPC_CTRL, TCPC_V10_REG_TCPC_CTRL_EN_WDT);
-}
-
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
-static int mt6362_is_vsafe0v(struct tcpc_device *tcpc)
-{
-	int ret;
-	u8 data;
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	ret = mt6362_read8(tdata, MT6362_REG_MTST1, &data);
-	if (ret < 0)
-		return ret;
-	return (data & MT6362_MSK_VBUS80) ? 1 : 0;
-}
-#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
-
-#ifdef CONFIG_TCPC_LOW_POWER_MODE
-static int mt6362_is_low_power_mode(struct tcpc_device *tcpc)
-{
-	int ret;
-	u8 data;
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	ret = mt6362_read8(tdata, MT6362_REG_SYSCTRL2, &data);
-	if (ret < 0)
-		return ret;
-	return (data & MT6362_MSK_LPWR_EN) != 0;
-}
-
-static int mt6362_set_low_power_mode(struct tcpc_device *tcpc, bool en,
-				     int pull)
-{
-	u8 data;
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	if (en) {
-		data = MT6362_MSK_LPWR_EN;
-#ifdef CONFIG_TYPEC_CAP_NORP_SRC
-		data |= MT6362_MSK_VBUSDET_EN;
-#endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
-	} else {
-		data = MT6362_MSK_VBUSDET_EN | MT6362_MSK_BMCIOOSC_EN;
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
-		mt6362_enable_vsafe0v_detect(tdata, true);
-#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
-	}
-	return mt6362_write8(tdata, MT6362_REG_SYSCTRL2, data);
-}
-#endif	/* CONFIG_TCPC_LOW_POWER_MODE */
-
-#ifdef CONFIG_USB_POWER_DELIVERY
-static int mt6362_set_msg_header(struct tcpc_device *tcpc, u8 power_role,
-				 u8 data_role)
-{
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-	u8 msg_hdr = TCPC_V10_REG_MSG_HDR_INFO_SET(data_role, power_role);
-
-	return mt6362_write8(tdata, TCPC_V10_REG_MSG_HDR_INFO, msg_hdr);
-}
-
-static int mt6362_protocol_reset(struct tcpc_device *tcpc)
-{
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	mt6362_clr_bits(tdata, MT6362_REG_PHYCTRL8, MT6362_MSK_PRLRSTB);
-	mdelay(1);
-	mt6362_set_bits(tdata, MT6362_REG_PHYCTRL8, MT6362_MSK_PRLRSTB);
-	return 0;
-}
-
-static int mt6362_set_rx_enable(struct tcpc_device *tcpc, u8 en)
-{
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	return mt6362_write8(tdata, TCPC_V10_REG_RX_DETECT, en);
-}
-
-static int mt6362_get_message(struct tcpc_device *tcpc, u32 *payload,
-			      u16 *msg_head,
-			      enum tcpm_transmit_type *frame_type)
-{
-	int ret;
-	u8 type, cnt = 0;
-	u8 buf[4] = {0};
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	ret = mt6362_bulk_read(tdata, TCPC_V10_REG_RX_BYTE_CNT, buf, 4);
-	cnt = buf[0];
-	type = buf[1];
-	*msg_head = *(u16 *)&buf[2];
-
-	/* TCPC 1.0 ==> no need to subtract the size of msg_head */
-	if (ret >= 0 && cnt > 3) {
-		cnt -= 3; /* MSG_HDR */
-		ret = mt6362_bulk_read(tdata, TCPC_V10_REG_RX_DATA,
-				       (u8 *)payload, cnt);
-	}
-	*frame_type = (enum tcpm_transmit_type)type;
-
-	/* Read complete, clear RX status alert bit */
-	tcpci_alert_status_clear(tcpc, TCPC_V10_REG_ALERT_RX_STATUS |
-				 TCPC_V10_REG_RX_OVERFLOW);
-	return ret;
-}
-
-/* message header (2byte) + data object (7*4) */
-#define MT6362_TRANSMIT_MAX_SIZE	(sizeof(u16) + sizeof(u32) * 7)
-
-static int mt6362_transmit(struct tcpc_device *tcpc,
-			   enum tcpm_transmit_type type, u16 header,
-			   const u32 *data)
-{
-	int ret, data_cnt, packet_cnt;
-	u8 temp[MT6362_TRANSMIT_MAX_SIZE];
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	if (type < TCPC_TX_HARD_RESET) {
-		data_cnt = sizeof(u32) * PD_HEADER_CNT(header);
-		packet_cnt = data_cnt + sizeof(u16);
-
-		temp[0] = packet_cnt;
-		memcpy(temp + 1, (u8 *)&header, 2);
-		if (data_cnt > 0)
-			memcpy(temp + 3, (u8 *)data, data_cnt);
-
-		ret = mt6362_bulk_write(tdata, TCPC_V10_REG_TX_BYTE_CNT,
-					(u8 *)temp, packet_cnt + 1);
-		if (ret < 0)
-			return ret;
-	}
-
-	return mt6362_write8(tdata, TCPC_V10_REG_TRANSMIT,
-			     TCPC_V10_REG_TRANSMIT_SET(tcpc->pd_retry_count,
-			     type));
-}
-
-static int mt6362_set_bist_test_mode(struct tcpc_device *tcpc, bool en)
-{
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	return (en ? mt6362_set_bits : mt6362_clr_bits)
-		(tdata, TCPC_V10_REG_TCPC_CTRL,
-		 TCPC_V10_REG_TCPC_CTRL_BIST_TEST_MODE);
-}
-
-static int mt6362_set_bist_carrier_mode(struct tcpc_device *tcpc, u8 pattern)
-{
-	/* Not support this function */
-	return 0;
-}
-#endif /* CONFIG_USB_POWER_DELIVERY */
-
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
-static int mt6362_retransmit(struct tcpc_device *tcpc)
-{
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	return mt6362_write8(tdata, TCPC_V10_REG_TRANSMIT,
-			     TCPC_V10_REG_TRANSMIT_SET(tcpc->pd_retry_count,
-			     TCPC_TX_SOP));
-}
-#endif /* CONFIG_USB_PD_RETRY_CRC_DISCARD */
-
-#ifdef CONFIG_WATER_DETECTION
-static int mt6362_is_water_detected(struct tcpc_device *tcpc)
-{
-	int ret, i;
-	bool error, wd = false;
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	ret = mt6362_set_wd_ldo(tdata, MT6362_WD_LDO_1_8V);
-	if (ret < 0)
-		return ret;
-	for (i = 0; i < MT6362_WD_CHAN_NUM; i++) {
-		if (!mt6362_wd_chan_en[i])
-			continue;
-		ret = __mt6362_is_water_detected(tdata, i, &error);
-		if (ret < 0 || !error)
-			continue;
-		wd = true;
-		break;
-	}
-	return wd ? 1 : 0;
-}
-
-static int mt6362_set_water_protection(struct tcpc_device *tcpc, bool en)
-{
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	return mt6362_enable_wd_protection(tdata, en);
-}
-
-static int mt6362_set_wd_polling(struct tcpc_device *tcpc, bool en)
-{
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-#ifdef CONFIG_WD_POLLING_ONLY
-	if (!en)
-		cancel_delayed_work_sync(&tdata->wd_poll_dwork);
-#endif /* CONFIG_WD_POLLING_ONLY */
-	return mt6362_enable_wd_polling(tdata, en);
-}
-#endif /* CONFIG_WATER_DETECTION */
-
-/*
- * ==================================================================
- * TCPC vendor irq handlers
- * ==================================================================
- */
-
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
-static int mt6362_vsafe0v_irq_handler(struct mt6362_tcpc_data *tdata)
-{
-	int ret;
-
-	ret = tcpci_is_vsafe0v(tdata->tcpc);
-	if (ret < 0)
-		return ret;
-	tdata->tcpc->vbus_safe0v = ret ? true : false;
-	return 0;
-}
-#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
-
-#ifdef CONFIG_WATER_DETECTION
-static int mt6362_wd12_strise_irq_handler(struct mt6362_tcpc_data *tdata)
-{
-	/* Pull or discharge status from 0 to 1 in normal polling mode */
-	return mt6362_wd_polling_evt_process(tdata);
-}
-
-static int mt6362_wd12_done_irq_handler(struct mt6362_tcpc_data *tdata)
-{
-	/* Oneshot or protect mode done */
-	MT6362_DBGINFO("%s\n", __func__);
-	return mt6362_wd_protection_evt_process(tdata);
-}
-#endif /* CONFIG_WATER_DETECTION */
-
-#ifdef CONFIG_CABLE_TYPE_DETECTION
-static int mt6362_ctd_irq_handler(struct mt6362_tcpc_data *tdata)
-{
-	int ret;
-	enum tcpc_cable_type cable_type;
-
-	ret = mt6362_get_cable_type(tdata, &cable_type);
-	if (ret < 0)
-		return ret;
-
-	tcpc_typec_handle_ctd(tdata->tcpc, cable_type);
-	return 0;
-}
-#endif /* CONFIG_CABLE_TYPE_DETECTION */
-
-
-struct irq_mapping_tbl {
-	u8 num;
-	const char *name;
-	int (*hdlr)(struct mt6362_tcpc_data *tdata);
-};
-
-#define MT6362_IRQ_MAPPING(_num, _name) \
-	{ .num = _num, .name = #_name, .hdlr = mt6362_##_name##_irq_handler }
-
-static struct irq_mapping_tbl mt6362_vend_irq_mapping_tbl[] = {
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
-	MT6362_IRQ_MAPPING(1, vsafe0v),
-#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
-
-#ifdef CONFIG_WATER_DETECTION
-	MT6362_IRQ_MAPPING(49, wd12_strise),
-	MT6362_IRQ_MAPPING(50, wd12_done),
-#endif /* CONFIG_WATER_DETECTION */
-
-#ifdef CONFIG_CABLE_TYPE_DETECTION
-	MT6362_IRQ_MAPPING(20, ctd),
-#endif /* CONFIG_CABLE_TYPE_DETECTION */
-};
-
-static int mt6362_alert_vendor_defined_handler(struct tcpc_device *tcpc)
-{
-	int ret, i, irqnum, irqbit;
-	u8 alert[MT6362_VEND_INT_NUM];
-	u8 mask[MT6362_VEND_INT_NUM];
-	struct mt6362_tcpc_data *tdata = tcpc_get_dev_data(tcpc);
-
-	ret = mt6362_bulk_read(tdata, MT6362_REG_MTINT1, alert,
-			       MT6362_VEND_INT_NUM);
-	if (ret < 0)
-		return ret;
-	ret = mt6362_bulk_read(tdata, MT6362_REG_MTMASK1, mask,
-			       MT6362_VEND_INT_NUM);
-	if (ret < 0)
-		return ret;
-
-	for (i = 0; i < MT6362_VEND_INT_NUM; i++) {
-		if (!alert[i])
-			continue;
-		MT6362_DBGINFO("vend_alert[%d]=alert,mask(0x%02X,0x%02X)\n",
-			       i + 1, alert[i], mask[i]);
-		alert[i] &= mask[i];
-	}
-
-	mt6362_vend_alert_status_clear(tdata, alert);
-
-	for (i = 0; i < ARRAY_SIZE(mt6362_vend_irq_mapping_tbl); i++) {
-		irqnum = mt6362_vend_irq_mapping_tbl[i].num / 8;
-		if (irqnum >= MT6362_VEND_INT_NUM)
-			continue;
-		alert[irqnum] &= mask[irqnum];
-		irqbit = mt6362_vend_irq_mapping_tbl[i].num % 8;
-		if (alert[irqnum] & (1 << irqbit))
-			mt6362_vend_irq_mapping_tbl[i].hdlr(tdata);
-	}
-	return 0;
-}
-
-static struct tcpc_ops mt6362_tcpc_ops = {
-	.init = mt6362_tcpc_init,
-	.init_alert_mask = mt6362_init_mask,
-	.alert_status_clear = mt6362_alert_status_clear,
-	.fault_status_clear = mt6362_fault_status_clear,
-	.get_alert_mask = mt6362_get_alert_mask,
-	.set_alert_mask = mt6362_set_alert_mask,
-	.get_alert_status = mt6362_get_alert_status,
-	.get_power_status = mt6362_get_power_status,
-	.get_fault_status = mt6362_get_fault_status,
-	.get_cc = mt6362_get_cc,
-	.set_cc = mt6362_set_cc,
-	.set_polarity = mt6362_set_polarity,
-	.set_low_rp_duty = mt6362_set_low_rp_duty,
-	.set_vconn = mt6362_set_vconn,
-	.deinit = mt6362_tcpc_deinit,
-	.set_watchdog = mt6362_set_watchdog,
-	.alert_vendor_defined_handler = mt6362_alert_vendor_defined_handler,
-
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
-	.is_vsafe0v = mt6362_is_vsafe0v,
-#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
-
-#ifdef CONFIG_TCPC_LOW_POWER_MODE
-	.is_low_power_mode = mt6362_is_low_power_mode,
-	.set_low_power_mode = mt6362_set_low_power_mode,
-#endif	/* CONFIG_TCPC_LOW_POWER_MODE */
-
-#ifdef CONFIG_USB_POWER_DELIVERY
-	.set_msg_header = mt6362_set_msg_header,
-	.set_rx_enable = mt6362_set_rx_enable,
-	.protocol_reset = mt6362_protocol_reset,
-	.get_message = mt6362_get_message,
-	.transmit = mt6362_transmit,
-	.set_bist_test_mode = mt6362_set_bist_test_mode,
-	.set_bist_carrier_mode = mt6362_set_bist_carrier_mode,
-#endif	/* CONFIG_USB_POWER_DELIVERY */
-
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
-	.retransmit = mt6362_retransmit,
-#endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
-
-#ifdef CONFIG_WATER_DETECTION
-	.is_water_detected = mt6362_is_water_detected,
-	.set_water_protection = mt6362_set_water_protection,
-	.set_usbid_polling = mt6362_set_wd_polling,
-#endif /* CONFIG_WATER_DETECTION */
-};
-
-static void mt6362_cpu_poll_ctrl(struct mt6362_tcpc_data *tdata)
-{
-	cancel_delayed_work_sync(&tdata->cpu_poll_dwork);
-
-	if (atomic_read(&tdata->cpu_poll_count) == 0) {
-		atomic_inc(&tdata->cpu_poll_count);
-		cpu_idle_poll_ctrl(true);
-	}
-
-	schedule_delayed_work(&tdata->cpu_poll_dwork, msecs_to_jiffies(40));
-}
-
-static void mt6362_cpu_poll_dwork_handler(struct work_struct *work)
-{
-	struct delayed_work *dwork = to_delayed_work(work);
-	struct mt6362_tcpc_data *tdata = container_of(dwork,
-						      struct mt6362_tcpc_data,
-						      cpu_poll_dwork);
-
-	if (atomic_dec_and_test(&tdata->cpu_poll_count))
-		cpu_idle_poll_ctrl(false);
-}
-
-static void mt6362_irq_work_handler(struct kthread_work *work)
-{
-	struct mt6362_tcpc_data *tdata = container_of(work,
-						      struct mt6362_tcpc_data,
-						      irq_work);
-
-	MT6362_DBGINFO("++\n");
-	mt6362_cpu_poll_ctrl(tdata);
-	tcpci_lock_typec(tdata->tcpc);
-	tcpci_alert(tdata->tcpc);
-	tcpci_unlock_typec(tdata->tcpc);
-}
-
-static irqreturn_t mt6362_irq_handler(int irq, void *data)
-{
-	struct mt6362_tcpc_data *tdata = data;
-
-	MT6362_DBGINFO("++\n");
-	pm_wakeup_event(tdata->dev, MT6362_IRQ_WAKE_TIME);
-	kthread_queue_work(&tdata->irq_worker, &tdata->irq_work);
-	return IRQ_HANDLED;
-}
-
-static int mt6362_init_irq(struct mt6362_tcpc_data *tdata,
-			   struct platform_device *pdev)
-{
-	int ret;
-	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
-
-	/* Mask all alerts & clear them */
-	mt6362_bulk_write(tdata, MT6362_REG_MTMASK1, mt6362_vend_alert_maskall,
-			  ARRAY_SIZE(mt6362_vend_alert_maskall));
-	mt6362_bulk_write(tdata, MT6362_REG_MTINT1, mt6362_vend_alert_clearall,
-			  ARRAY_SIZE(mt6362_vend_alert_clearall));
-	mt6362_write16(tdata, TCPC_V10_REG_ALERT_MASK, 0);
-	mt6362_write16(tdata, TCPC_V10_REG_ALERT, 0xFFFF);
-
-	kthread_init_worker(&tdata->irq_worker);
-	tdata->irq_worker_task = kthread_run(kthread_worker_fn,
-					     &tdata->irq_worker, "%s",
-					     tdata->desc->name);
-	if (IS_ERR(tdata->irq_worker_task)) {
-		dev_err(tdata->dev, "%s create tcpc task fail\n", __func__);
-		return -EINVAL;
-	}
-	sched_setscheduler(tdata->irq_worker_task, SCHED_FIFO, &param);
-	kthread_init_work(&tdata->irq_work, mt6362_irq_work_handler);
-
-	tdata->irq = platform_get_irq_byname(pdev, "pd_evt");
-	if (tdata->irq <= 0) {
-		dev_err(tdata->dev, "%s get irq number fail(%d)\n", __func__,
-			tdata->irq);
-		return -EINVAL;
-	}
-	ret = devm_request_threaded_irq(tdata->dev, tdata->irq, NULL,
-					mt6362_irq_handler, IRQF_TRIGGER_NONE,
-					NULL, tdata);
-	if (ret < 0) {
-		dev_err(tdata->dev, "%s fail to request irq%d(%d)\n", __func__,
-			tdata->irq, ret);
-		return -EINVAL;
-	}
-	device_init_wakeup(tdata->dev, true);
-	return 0;
-}
-
-static int mt6362_register_tcpcdev(struct mt6362_tcpc_data *tdata)
-{
-	struct device_node *np = tdata->dev->of_node;
-
-	tdata->tcpc = tcpc_device_register(tdata->dev, tdata->desc,
-					  &mt6362_tcpc_ops, tdata);
-	if (IS_ERR_OR_NULL(tdata->tcpc))
-		return -EINVAL;
-
-#ifdef CONFIG_USB_PD_DISABLE_PE
-	tdata->tcpc->disable_pe = of_property_read_bool(np, "tcpc,disable_pe");
-#endif	/* CONFIG_USB_PD_DISABLE_PE */
-
-	/* Init tcpc_flags */
-#ifdef CONFIG_CABLE_TYPE_DETECTION
-	tdata->tcpc->tcpc_flags |= TCPC_FLAGS_CABLE_TYPE_DETECTION;
-#endif /* CONFIG_CABLE_TYPE_DETECTION */
-#ifdef CONFIG_WATER_DETECTION
-	tdata->tcpc->tcpc_flags |= TCPC_FLAGS_WATER_DETECTION;
-#endif /* CONFIG_WATER_DETECTION */
-#ifdef CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
-	tdata->tcpc->tcpc_flags |= TCPC_FLAGS_LPM_WAKEUP_WATCHDOG;
-#endif	/* CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG */
-#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
-	tdata->tcpc->tcpc_flags |= TCPC_FLAGS_RETRY_CRC_DISCARD;
-#endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
-#ifdef CONFIG_USB_PD_REV30
-	tdata->tcpc->tcpc_flags |= TCPC_FLAGS_PD_REV30;
-#endif	/* CONFIG_USB_PD_REV30 */
-	if (tdata->tcpc->tcpc_flags & TCPC_FLAGS_PD_REV30)
-		dev_info(tdata->dev, "%s PD REV30\n", __func__);
-	else
-		dev_info(tdata->dev, "%s PD REV20\n", __func__);
-	tdata->tcpc->tcpc_flags |= TCPC_FLAGS_DISABLE_LEGACY;
-	tdata->tcpc->tcpc_flags |= TCPC_FLAGS_WATCHDOG_EN;
-	return 0;
-}
-
-static int mt6362_parse_dt(struct mt6362_tcpc_data *tdata)
-{
-	u32 val;
-	struct tcpc_desc *desc;
-	struct device_node *np = tdata->dev->of_node;
-
-	desc = devm_kzalloc(tdata->dev, sizeof(*desc), GFP_KERNEL);
-	if (!desc)
-		return -ENOMEM;
-
-	/* default setting */
-	desc->role_def = TYPEC_ROLE_DRP;
-	desc->notifier_supply_num = 0;
-	desc->rp_lvl = TYPEC_RP_DFT;
-	desc->vconn_supply = TCPC_VCONN_SUPPLY_ALWAYS;
-
-	if (of_property_read_u32(np, "tcpc,role_def", &val) >= 0) {
-		if (val >= TYPEC_ROLE_NR)
-			desc->role_def = TYPEC_ROLE_DRP;
-		else
-			desc->role_def = val;
-	}
-
-	if (of_property_read_u32(np, "tcpc,notifier_supply_num", &val) >= 0) {
-		if (val < 0)
-			desc->notifier_supply_num = 0;
-		else
-			desc->notifier_supply_num = val;
-	}
-
-	if (of_property_read_u32(np, "tcpc,rp_level", &val) >= 0) {
-		switch (val) {
-		case TYPEC_RP_DFT:
-		case TYPEC_RP_1_5:
-		case TYPEC_RP_3_0:
-			desc->rp_lvl = val;
-			break;
-		default:
-			break;
-		}
-	}
-
-#ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
-	if (of_property_read_u32(np, "tcpc,vconn_supply", &val) >= 0) {
-		if (val >= TCPC_VCONN_SUPPLY_NR)
-			desc->vconn_supply = TCPC_VCONN_SUPPLY_ALWAYS;
-		else
-			desc->vconn_supply = val;
-	}
-#endif	/* CONFIG_TCPC_VCONN_SUPPLY_MODE */
-
-#ifdef CONFIG_WATER_DETECTION
-	if (of_property_read_u32(np, "wd,sbu_calib_init", &val) < 0)
-		desc->wd_sbu_calib_init = CONFIG_WD_SBU_CALIB_INIT;
-	else
-		desc->wd_sbu_calib_init = val;
-	if (of_property_read_u32(np, "wd,sbu_pl_bound", &val) < 0)
-		desc->wd_sbu_pl_bound = CONFIG_WD_SBU_PL_BOUND;
-	else
-		desc->wd_sbu_pl_bound = val;
-	if (of_property_read_u32(np, "wd,sbu_pl_lbound_c2c", &val) < 0)
-		desc->wd_sbu_pl_lbound_c2c = CONFIG_WD_SBU_PL_LBOUND_C2C;
-	else
-		desc->wd_sbu_pl_lbound_c2c = val;
-	if (of_property_read_u32(np, "wd,sbu_pl_ubound_c2c", &val) < 0)
-		desc->wd_sbu_pl_ubound_c2c = CONFIG_WD_SBU_PL_UBOUND_C2C;
-	else
-		desc->wd_sbu_pl_ubound_c2c = val;
-	if (of_property_read_u32(np, "wd,sbu_ph_auddev", &val) < 0)
-		desc->wd_sbu_ph_auddev = CONFIG_WD_SBU_PH_AUDDEV;
-	else
-		desc->wd_sbu_ph_auddev = val;
-	if (of_property_read_u32(np, "wd,sbu_ph_lbound", &val) < 0)
-		desc->wd_sbu_ph_lbound = CONFIG_WD_SBU_PH_LBOUND;
-	else
-		desc->wd_sbu_ph_lbound = val;
-	if (of_property_read_u32(np, "wd,sbu_ph_lbound1_c2c", &val) < 0)
-		desc->wd_sbu_ph_lbound1_c2c = CONFIG_WD_SBU_PH_LBOUND1_C2C;
-	else
-		desc->wd_sbu_ph_lbound1_c2c = val;
-	if (of_property_read_u32(np, "wd,sbu_ph_ubound1_c2c", &val) < 0)
-		desc->wd_sbu_ph_ubound1_c2c = CONFIG_WD_SBU_PH_UBOUND1_C2C;
-	else
-		desc->wd_sbu_ph_ubound1_c2c = val;
-	if (of_property_read_u32(np, "wd,sbu_ph_ubound2_c2c", &val) < 0)
-		desc->wd_sbu_ph_ubound2_c2c = CONFIG_WD_SBU_PH_UBOUND2_C2C;
-	else
-		desc->wd_sbu_ph_ubound2_c2c = val;
-	if (of_property_read_u32(np, "wd,sbu_aud_ubound", &val) < 0)
-		desc->wd_sbu_aud_ubound = CONFIG_WD_SBU_AUD_UBOUND;
-	else
-		desc->wd_sbu_aud_ubound = val;
-#endif /* CONFIG_WATER_DETECTION */
-
-	of_property_read_string(np, "tcpc,name", (const char **)&desc->name);
-	tdata->desc = desc;
-	return 0;
-}
-
-static int mt6362_check_revision(struct mt6362_tcpc_data *tdata)
-{
-	int ret;
-	u16 id;
-
-	ret = mt6362_read16(tdata, TCPC_V10_REG_VID, &id);
-	if (ret < 0) {
-		dev_err(tdata->dev, "%s read vid fail(%d)\n", __func__, ret);
-		return ret;
-	}
-	if (id != MT6362_VID) {
-		dev_err(tdata->dev, "%s vid incorrect(0x%04X)\n", __func__, id);
-		return -ENODEV;
-	}
-
-	ret = mt6362_read16(tdata, TCPC_V10_REG_PID, &id);
-	if (ret < 0) {
-		dev_err(tdata->dev, "%s read pid fail(%d)\n", __func__, ret);
-		return ret;
-	}
-	if (id != MT6362_PID) {
-		dev_err(tdata->dev, "%s pid incorrect(0x%04X)\n", __func__, id);
-		return -ENODEV;
-	}
-
-	ret = mt6362_read16(tdata, TCPC_V10_REG_DID, &id);
-	if (ret < 0) {
-		dev_err(tdata->dev, "%s read did fail(%d)\n", __func__, ret);
-		return ret;
-	}
-	dev_info(tdata->dev, "%s did = 0x%04X\n", __func__, id);
-	tdata->did = id;
-	return 0;
-}
-
-/*
- * In some platform pr_info may spend too much time on printing debug message.
- * So we use this function to test the printk performance.
- * If your platform cannot not pass this check function, please config
- * PD_DBG_INFO, this will provide the threaded debug message for you.
- */
-#if TCPC_ENABLE_ANYMSG
-static void check_printk_performance(void)
-{
-	int i;
-	u64 t1, t2;
-	u32 nsrem;
-
-#ifdef CONFIG_PD_DBG_INFO
-	for (i = 0; i < 10; i++) {
-		t1 = local_clock();
-		pd_dbg_info("%d\n", i);
-		t2 = local_clock();
-		t2 -= t1;
-		nsrem = do_div(t2, 1000000000);
-		pd_dbg_info("pd_dbg_info : t2-t1 = %lu\n",
-			    (unsigned long)nsrem / 1000);
-	}
-	for (i = 0; i < 10; i++) {
-		t1 = local_clock();
-		pr_info("%d\n", i);
-		t2 = local_clock();
-		t2 -= t1;
-		nsrem = do_div(t2, 1000000000);
-		pr_info("pr_info : t2-t1 = %lu\n", (unsigned long)nsrem / 1000);
-	}
-#else
-	for (i = 0; i < 10; i++) {
-		t1 = local_clock();
-		pr_info("%d\n", i);
-		t2 = local_clock();
-		t2 -= t1;
-		nsrem = do_div(t2, 1000000000);
-		pr_info("t2-t1 = %lu\n", (unsigned long)nsrem /  1000);
-		PD_BUG_ON(nsrem > 100*1000);
-	}
-#endif /* CONFIG_PD_DBG_INFO */
-}
-#endif /* TCPC_ENABLE_ANYMSG */
-
-static int mt6362_tcpc_probe(struct platform_device *pdev)
-{
-	int ret;
-	bool use_dt = pdev->dev.of_node;
-	struct mt6362_tcpc_data *tdata;
-
-	if (!use_dt) {
-		dev_err(&pdev->dev, "%s no dts node\n", __func__);
-		return -ENODEV;
-	}
-
-	tdata = devm_kzalloc(&pdev->dev, sizeof(*tdata), GFP_KERNEL);
-	if (!tdata)
-		return -ENOMEM;
-	tdata->dev = &pdev->dev;
-	tdata->regmap = dev_get_regmap(pdev->dev.parent, NULL);
-	if (!tdata->regmap) {
-		dev_err(tdata->dev, "failed to allocate regmap\n");
-		return -ENODEV;
-	}
-	platform_set_drvdata(pdev, tdata);
-
-	ret = mt6362_check_revision(tdata);
-	if (ret < 0) {
-		dev_err(tdata->dev, "%s check revision fail(%d)\n", __func__,
-			ret);
-		return ret;
-	}
-#if TCPC_ENABLE_ANYMSG
-	check_printk_performance();
-#endif /* TCPC_ENABLE_ANYMSG */
-	INIT_DELAYED_WORK(&tdata->cpu_poll_dwork,
-			  mt6362_cpu_poll_dwork_handler);
-
-#ifdef CONFIG_WATER_DETECTION
-	atomic_set(&tdata->wd_protect_rty, CONFIG_WD_PROTECT_RETRY_COUNT);
-#ifdef CONFIG_WD_POLLING_ONLY
-	INIT_DELAYED_WORK(&tdata->wd_poll_dwork, mt6362_wd_poll_dwork_handler);
-#endif /* CONFIG_WD_POLLING_ONLY */
-#endif /* CONFIG_WATER_DETECTION */
-
-	ret = mt6362_parse_dt(tdata);
-	if (ret < 0) {
-		dev_err(tdata->dev, "%s parse dt fail(%d)\n", __func__, ret);
-		return ret;
-	}
-
-	tdata->adc_iio = devm_iio_channel_get_all(tdata->dev);
-	if (IS_ERR(tdata->adc_iio)) {
-		ret = PTR_ERR(tdata->adc_iio);
-		dev_err(tdata->dev, "%s get adc iio fail(%d)\n", __func__, ret);
-		return ret;
-	}
-
-	ret = mt6362_register_tcpcdev(tdata);
-	if (ret < 0) {
-		dev_err(tdata->dev, "%s register tcpcdev fail(%d)\n", __func__,
-			ret);
-		return ret;
-	}
-
-	/* Must init before sw reset */
-	ret = mt6362_init_fod_ctd(tdata);
-	if (ret < 0) {
-		dev_err(tdata->dev, "%s init fod ctd fail(%d)\n", __func__,
-			ret);
-		goto err;
-	}
-
-	ret = mt6362_sw_reset(tdata);
-	if (ret < 0) {
-		dev_err(tdata->dev, "%s sw reset fail(%d)\n", __func__, ret);
-		goto err;
-	}
-
-	ret = mt6362_init_irq(tdata, pdev);
-	if (ret < 0) {
-		dev_err(tdata->dev, "%s init alert fail\n", __func__);
-		goto err;
-	}
-
-	tcpc_schedule_init_work(tdata->tcpc);
-	dev_info(tdata->dev, "%s successfully!\n", __func__);
-	return 0;
-err:
-	tcpc_device_unregister(tdata->dev, tdata->tcpc);
-	return ret;
-}
-
-static int mt6362_tcpc_remove(struct platform_device *pdev)
-{
-	struct mt6362_tcpc_data *tdata = platform_get_drvdata(pdev);
-
-	if (!tdata)
-		return 0;
-#ifdef CONFIG_WD_POLLING_ONLY
-	cancel_delayed_work_sync(&tdata->wd_poll_dwork);
-#endif /* CONFIG_WD_POLLING_ONLY */
-	cancel_delayed_work_sync(&tdata->cpu_poll_dwork);
-	if (tdata->tcpc)
-		tcpc_device_unregister(tdata->dev, tdata->tcpc);
-	return 0;
-}
-
-static void mt6362_shutdown(struct platform_device *pdev)
-{
-	struct mt6362_tcpc_data *tdata = platform_get_drvdata(pdev);
-
-	/* Please reset IC here */
-	if (!tdata)
-		return;
-	if (tdata->irq)
-		disable_irq(tdata->irq);
-	tcpm_shutdown(tdata->tcpc);
-}
-
-static const struct of_device_id __maybe_unused mt6362_tcpc_ofid_tbls[] = {
-	{ .compatible = "mediatek,mt6362-tcpc", },
-	{ },
-};
-MODULE_DEVICE_TABLE(of, mt6362_tcpc_ofid_tbls);
-
-static struct platform_driver mt6362_tcpc_driver = {
-	.driver = {
-		.name = "mt6362-tcpc",
-		.of_match_table = of_match_ptr(mt6362_tcpc_ofid_tbls),
-	},
-	.probe = mt6362_tcpc_probe,
-	.remove = mt6362_tcpc_remove,
-	.shutdown = mt6362_shutdown,
-};
-module_platform_driver(mt6362_tcpc_driver);
-
-MODULE_AUTHOR("ShuFan Lee<shufan_lee@richtek.com>");
-MODULE_DESCRIPTION("MT6362 SPMI TCPC Driver");
-MODULE_LICENSE("GPL");
-MODULE_VERSION("1.0.0");
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpc_mt6370.c b/drivers/misc/mediatek/typec/tcpc/tcpc_mt6370.c
index c138f98..654f60f 100644
--- a/drivers/misc/mediatek/typec/tcpc/tcpc_mt6370.c
+++ b/drivers/misc/mediatek/typec/tcpc/tcpc_mt6370.c
@@ -44,9 +44,14 @@
 #include <linux/sched/rt.h>
 #endif /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)) */
 
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+/* MTK only */
+#include <mt-plat/mtk_boot.h>
+#endif /* CONFIG_MTK_KERNEL_POWER_OFF_CHARGING */
+
 /* #define DEBUG_GPIO	66 */
 
-#define MT6370_DRV_VERSION	"2.0.6_MTK"
+#define MT6370_DRV_VERSION	"2.0.1_MTK"
 
 #define MT6370_IRQ_WAKE_TIME	(500) /* ms */
 
@@ -63,8 +68,8 @@ struct mt6370_chip {
 	struct kthread_worker irq_worker;
 	struct kthread_work irq_work;
 	struct task_struct *irq_worker_task;
-	struct wakeup_source *irq_wake_lock;
-	struct wakeup_source *i2c_wake_lock;
+	struct wakeup_source irq_wake_lock;
+	struct wakeup_source i2c_wake_lock;
 
 	atomic_t poll_count;
 	struct delayed_work	poll_work;
@@ -75,57 +80,52 @@ struct mt6370_chip {
 };
 
 #ifdef CONFIG_RT_REGMAP
-RT_REG_DECL(TCPC_V10_REG_VID, 2, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_PID, 2, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_DID, 2, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_TYPEC_REV, 2, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_PD_REV, 2, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_PDIF_REV, 2, RT_NORMAL_WR_ONCE, {});
+RT_REG_DECL(TCPC_V10_REG_VID, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_PID, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_DID, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TYPEC_REV, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_PD_REV, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_PDIF_REV, 2, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_ALERT, 2, RT_VOLATILE, {});
-RT_REG_DECL(TCPC_V10_REG_ALERT_MASK, 2, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_POWER_STATUS_MASK, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_FAULT_STATUS_MASK, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_TCPC_CTRL, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_ROLE_CTRL, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_FAULT_CTRL, 1, RT_NORMAL_WR_ONCE, {});
+RT_REG_DECL(TCPC_V10_REG_ALERT_MASK, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_POWER_STATUS_MASK, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_FAULT_STATUS_MASK, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TCPC_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_ROLE_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_FAULT_CTRL, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_POWER_CTRL, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_CC_STATUS, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_POWER_STATUS, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_FAULT_STATUS, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_COMMAND, 1, RT_VOLATILE, {});
-RT_REG_DECL(TCPC_V10_REG_MSG_HDR_INFO, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_RX_DETECT, 1, RT_NORMAL_WR_ONCE, {});
+RT_REG_DECL(TCPC_V10_REG_MSG_HDR_INFO, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_RX_DETECT, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_RX_BYTE_CNT, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_RX_BUF_FRAME_TYPE, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_RX_HDR, 2, RT_VOLATILE, {});
-RT_REG_DECL(TCPC_V10_REG_RX_DATA, 28, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_RX_DATA, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_TRANSMIT, 1, RT_VOLATILE, {});
-RT_REG_DECL(TCPC_V10_REG_TX_BYTE_CNT, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_TX_HDR, 2, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_TX_DATA, 28, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(MT6370_REG_PHY_CTRL1, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(MT6370_REG_PHY_CTRL2, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(MT6370_REG_PHY_CTRL3, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(MT6370_REG_CLK_CTRL2, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(MT6370_REG_CLK_CTRL3, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(MT6370_REG_PRL_FSM_RESET, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TX_BYTE_CNT, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TX_HDR, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TX_DATA, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6370_REG_PHY_CTRL1, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6370_REG_PHY_CTRL3, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6370_REG_CLK_CTRL2, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6370_REG_CLK_CTRL3, 1, RT_VOLATILE, {});
 RT_REG_DECL(MT6370_REG_BMC_CTRL, 1, RT_VOLATILE, {});
-RT_REG_DECL(MT6370_REG_BMCIO_RXDZSEL, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(MT6370_REG_VCONN_CLIMITEN, 1, RT_NORMAL_WR_ONCE, {});
+RT_REG_DECL(MT6370_REG_BMCIO_RXDZSEL, 1, RT_VOLATILE, {});
 RT_REG_DECL(MT6370_REG_MT_STATUS, 1, RT_VOLATILE, {});
 RT_REG_DECL(MT6370_REG_MT_INT, 1, RT_VOLATILE, {});
-RT_REG_DECL(MT6370_REG_MT_MASK, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(MT6370_REG_BMCIO_RXDZEN, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(MT6370_REG_IDLE_CTRL, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(MT6370_REG_INTRST_CTRL, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(MT6370_REG_WATCHDOG_CTRL, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(MT6370_REG_I2CRST_CTRL, 1, RT_NORMAL_WR_ONCE, {});
+RT_REG_DECL(MT6370_REG_MT_MASK, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6370_REG_BMCIO_RXDZEN, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6370_REG_IDLE_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6370_REG_INTRST_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6370_REG_WATCHDOG_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6370_REG_I2CRST_CTRL, 1, RT_VOLATILE, {});
 RT_REG_DECL(MT6370_REG_SWRESET, 1, RT_VOLATILE, {});
-RT_REG_DECL(MT6370_REG_TTCPC_FILTER, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(MT6370_REG_DRP_TOGGLE_CYCLE, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(MT6370_REG_DRP_DUTY_CTRL, 2, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(MT6370_REG_PHY_CTRL11, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(MT6370_REG_PHY_CTRL12, 1, RT_NORMAL_WR_ONCE, {});
+RT_REG_DECL(MT6370_REG_TTCPC_FILTER, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6370_REG_DRP_TOGGLE_CYCLE, 1, RT_VOLATILE, {});
+RT_REG_DECL(MT6370_REG_DRP_DUTY_CTRL, 1, RT_VOLATILE, {});
 
 static const rt_register_map_t mt6370_chip_regmap[] = {
 	RT_REG(TCPC_V10_REG_VID),
@@ -157,14 +157,11 @@ static const rt_register_map_t mt6370_chip_regmap[] = {
 	RT_REG(TCPC_V10_REG_TX_HDR),
 	RT_REG(TCPC_V10_REG_TX_DATA),
 	RT_REG(MT6370_REG_PHY_CTRL1),
-	RT_REG(MT6370_REG_PHY_CTRL2),
 	RT_REG(MT6370_REG_PHY_CTRL3),
 	RT_REG(MT6370_REG_CLK_CTRL2),
 	RT_REG(MT6370_REG_CLK_CTRL3),
-	RT_REG(MT6370_REG_PRL_FSM_RESET),
 	RT_REG(MT6370_REG_BMC_CTRL),
 	RT_REG(MT6370_REG_BMCIO_RXDZSEL),
-	RT_REG(MT6370_REG_VCONN_CLIMITEN),
 	RT_REG(MT6370_REG_MT_STATUS),
 	RT_REG(MT6370_REG_MT_INT),
 	RT_REG(MT6370_REG_MT_MASK),
@@ -177,8 +174,6 @@ static const rt_register_map_t mt6370_chip_regmap[] = {
 	RT_REG(MT6370_REG_TTCPC_FILTER),
 	RT_REG(MT6370_REG_DRP_TOGGLE_CYCLE),
 	RT_REG(MT6370_REG_DRP_DUTY_CTRL),
-	RT_REG(MT6370_REG_PHY_CTRL11),
-	RT_REG(MT6370_REG_PHY_CTRL12),
 };
 #define MT6370_CHIP_REGMAP_SIZE ARRAY_SIZE(mt6370_chip_regmap)
 
@@ -190,7 +185,7 @@ static int mt6370_read_device(void *client, u32 reg, int len, void *dst)
 	struct mt6370_chip *chip = i2c_get_clientdata(i2c);
 	int ret = 0, count = 5;
 
-	__pm_stay_awake(chip->i2c_wake_lock);
+	__pm_stay_awake(&chip->i2c_wake_lock);
 	down(&chip->suspend_lock);
 	while (count) {
 		if (len > 1) {
@@ -212,7 +207,7 @@ static int mt6370_read_device(void *client, u32 reg, int len, void *dst)
 	}
 out:
 	up(&chip->suspend_lock);
-	__pm_relax(chip->i2c_wake_lock);
+	__pm_relax(&chip->i2c_wake_lock);
 	return ret;
 }
 
@@ -223,7 +218,7 @@ static int mt6370_write_device(void *client, u32 reg, int len, const void *src)
 	struct mt6370_chip *chip = i2c_get_clientdata(i2c);
 	int ret = 0, count = 5;
 
-	__pm_stay_awake(chip->i2c_wake_lock);
+	__pm_stay_awake(&chip->i2c_wake_lock);
 	down(&chip->suspend_lock);
 	while (count) {
 		if (len > 1) {
@@ -245,7 +240,7 @@ static int mt6370_write_device(void *client, u32 reg, int len, const void *src)
 	}
 out:
 	up(&chip->suspend_lock);
-	__pm_relax(chip->i2c_wake_lock);
+	__pm_relax(&chip->i2c_wake_lock);
 	return ret;
 }
 
@@ -381,7 +376,6 @@ static int mt6370_regmap_init(struct mt6370_chip *chip)
 	struct rt_regmap_properties *props;
 	char name[32];
 	int len;
-	int ret;
 
 	props = devm_kzalloc(chip->dev, sizeof(*props), GFP_KERNEL);
 	if (!props)
@@ -390,14 +384,9 @@ static int mt6370_regmap_init(struct mt6370_chip *chip)
 	props->register_num = MT6370_CHIP_REGMAP_SIZE;
 	props->rm = mt6370_chip_regmap;
 
-	props->rt_regmap_mode = RT_MULTI_BYTE |
-				RT_IO_PASS_THROUGH | RT_DBG_SPECIAL;
-	ret = snprintf(name, sizeof(name), "mt6370-%02x",
-		chip->client->addr);
-	if (ret < 0 || ret >= sizeof(name)) {
-		dev_info(chip->dev, "%s-%d, snprintf fail\n",
-			__func__, __LINE__);
-	}
+	props->rt_regmap_mode = RT_MULTI_BYTE | RT_CACHE_DISABLE |
+				RT_IO_PASS_THROUGH | RT_DBG_GENERAL;
+	snprintf(name, sizeof(name), "mt6370-%02x", chip->client->addr);
 
 	len = strlen(name);
 	props->name = kzalloc(len+1, GFP_KERNEL);
@@ -431,15 +420,10 @@ static int mt6370_regmap_deinit(struct mt6370_chip *chip)
 static inline int mt6370_software_reset(struct tcpc_device *tcpc)
 {
 	int ret = mt6370_i2c_write8(tcpc, MT6370_REG_SWRESET, 1);
-#ifdef CONFIG_RT_REGMAP
-	struct mt6370_chip *chip = tcpc_get_dev_data(tcpc);
-#endif /* CONFIG_RT_REGMAP */
 
 	if (ret < 0)
 		return ret;
-#ifdef CONFIG_RT_REGMAP
-	rt_regmap_cache_reload(chip->m_dev);
-#endif /* CONFIG_RT_REGMAP */
+
 	usleep_range(1000, 2000);
 	return 0;
 }
@@ -566,7 +550,7 @@ static irqreturn_t mt6370_intr_handler(int irq, void *data)
 {
 	struct mt6370_chip *chip = data;
 
-	__pm_wakeup_event(chip->irq_wake_lock, MT6370_IRQ_WAKE_TIME);
+	__pm_wakeup_event(&chip->irq_wake_lock, MT6370_IRQ_WAKE_TIME);
 
 #ifdef DEBUG_GPIO
 	gpio_set_value(DEBUG_GPIO, 0);
@@ -592,10 +576,7 @@ static int mt6370_init_alert(struct tcpc_device *tcpc)
 	if (!name)
 		return -ENOMEM;
 
-	ret = snprintf(name, PAGE_SIZE, "%s-IRQ", chip->tcpc_desc->name);
-	if (ret < 0 || ret >= PAGE_SIZE)
-		pr_info("%s-%d, snprintf fail, ret=%d\n",
-			__func__, __LINE__, ret);
+	snprintf(name, PAGE_SIZE, "%s-IRQ", chip->tcpc_desc->name);
 
 	pr_info("%s name = %s, gpio = %d\n", __func__,
 				chip->tcpc_desc->name, chip->irq_gpio);
@@ -629,7 +610,7 @@ static int mt6370_init_alert(struct tcpc_device *tcpc)
 
 	kthread_init_worker(&chip->irq_worker);
 	chip->irq_worker_task = kthread_run(kthread_worker_fn,
-			&chip->irq_worker, "%s", chip->tcpc_desc->name);
+			&chip->irq_worker, chip->tcpc_desc->name);
 	if (IS_ERR(chip->irq_worker_task)) {
 		pr_err("Error: Could not create tcpc task\n");
 		goto init_alert_err;
@@ -638,9 +619,10 @@ static int mt6370_init_alert(struct tcpc_device *tcpc)
 	sched_setscheduler(chip->irq_worker_task, SCHED_FIFO, &param);
 	kthread_init_work(&chip->irq_work, mt6370_irq_work_handler);
 
-	pr_info("IRQF_NO_THREAD Test\n");
+	pr_info("IRQF_NO_THREAD Test\r\n");
 	ret = request_irq(chip->irq, mt6370_intr_handler,
-		IRQF_TRIGGER_FALLING | IRQF_NO_THREAD, name, chip);
+		IRQF_TRIGGER_FALLING | IRQF_NO_THREAD |
+		IRQF_NO_SUSPEND, name, chip);
 	if (ret < 0) {
 		pr_err("Error: failed to request irq%d (gpio = %d, ret = %d)\n",
 			chip->irq, chip->irq_gpio, ret);
@@ -682,15 +664,15 @@ int mt6370_alert_status_clear(struct tcpc_device *tcpc, uint32_t mask)
 	return 0;
 }
 
-static int mt6370_set_clock_gating(struct tcpc_device *tcpc,
+static int mt6370_set_clock_gating(struct tcpc_device *tcpc_dev,
 									bool en)
 {
 	int ret = 0;
 
 #ifdef CONFIG_TCPC_CLOCK_GATING
-	int i = 0;
 	uint8_t clk2 = MT6370_REG_CLK_DIV_600K_EN
 		| MT6370_REG_CLK_DIV_300K_EN | MT6370_REG_CLK_CK_300K_EN;
+
 	uint8_t clk3 = MT6370_REG_CLK_DIV_2P4M_EN;
 
 	if (!en) {
@@ -701,15 +683,16 @@ static int mt6370_set_clock_gating(struct tcpc_device *tcpc,
 	}
 
 	if (en) {
-		for (i = 0; i < 2; i++)
-			ret = mt6370_alert_status_clear(tcpc,
-				TCPC_REG_ALERT_RX_ALL_MASK);
+		ret = mt6370_alert_status_clear(tcpc_dev,
+			TCPC_REG_ALERT_RX_STATUS |
+			TCPC_REG_ALERT_RX_HARD_RST |
+			TCPC_REG_ALERT_RX_BUF_OVF);
 	}
 
 	if (ret == 0)
-		ret = mt6370_i2c_write8(tcpc, MT6370_REG_CLK_CTRL2, clk2);
+		ret = mt6370_i2c_write8(tcpc_dev, MT6370_REG_CLK_CTRL2, clk2);
 	if (ret == 0)
-		ret = mt6370_i2c_write8(tcpc, MT6370_REG_CLK_CTRL3, clk3);
+		ret = mt6370_i2c_write8(tcpc_dev, MT6370_REG_CLK_CTRL3, clk3);
 #endif	/* CONFIG_TCPC_CLOCK_GATING */
 
 	return ret;
@@ -723,10 +706,14 @@ static inline int mt6370_init_cc_params(
 #ifdef CONFIG_USB_POWER_DELIVERY
 #ifdef CONFIG_USB_PD_SNK_DFT_NO_GOOD_CRC
 	uint8_t en, sel;
+	struct mt6370_chip *chip = tcpc_get_dev_data(tcpc);
 
 	if (cc_res == TYPEC_CC_VOLT_SNK_DFT) { /* 0.55 */
 		en = 1;
 		sel = 0x81;
+	} else if (chip->chip_id >= MT6370_DID_D) { /* 0.35 & 0.75 */
+		en = 1;
+		sel = 0x81;
 	} else { /* 0.4 & 0.7 */
 		en = 0;
 		sel = 0x80;
@@ -756,10 +743,9 @@ static int mt6370_tcpc_init(struct tcpc_device *tcpc, bool sw_reset)
 	}
 
 	/* For No-GoodCRC Case (0x70) */
-	mt6370_i2c_write8(tcpc, MT6370_REG_PHY_CTRL2, 0x38);
-	mt6370_i2c_write8(tcpc, MT6370_REG_PHY_CTRL3, 0x82);
-	mt6370_i2c_write8(tcpc, MT6370_REG_PHY_CTRL11, 0xfc);
-	mt6370_i2c_write8(tcpc, MT6370_REG_PHY_CTRL12, 0x50);
+	mt6370_i2c_write8(tcpc, MT6370_REG_PHY_CTRL3, 0x70);
+	/* For BIST, Change Transition Toggle Counter (Noise) from 3 to 7 */
+	mt6370_i2c_write8(tcpc, MT6370_REG_PHY_CTRL1, 0x71);
 
 #ifdef CONFIG_TCPC_I2CRST_EN
 	mt6370_i2c_write8(tcpc,
@@ -784,7 +770,7 @@ static int mt6370_tcpc_init(struct tcpc_device *tcpc, bool sw_reset)
 	 * DRP Duyt Ctrl : dcSRC: /1024
 	 */
 
-	mt6370_i2c_write8(tcpc, MT6370_REG_TTCPC_FILTER, 10);
+	mt6370_i2c_write8(tcpc, MT6370_REG_TTCPC_FILTER, 5);
 	mt6370_i2c_write8(tcpc, MT6370_REG_DRP_TOGGLE_CYCLE, 4);
 	mt6370_i2c_write16(tcpc, MT6370_REG_DRP_DUTY_CTRL, TCPC_NORMAL_RP_DUTY);
 
@@ -798,7 +784,6 @@ static int mt6370_tcpc_init(struct tcpc_device *tcpc, bool sw_reset)
 	if (!(tcpc->tcpc_flags & TCPC_FLAGS_RETRY_CRC_DISCARD))
 		retry_discard_old = true;
 
-	/* For BIST, Change Transition Toggle Counter (Noise) from 3 to 7 */
 	mt6370_i2c_write8(tcpc, MT6370_REG_PHY_CTRL1,
 		MT6370_REG_PHY_CTRL1_SET(retry_discard_old, 7, 0, 1));
 
@@ -809,10 +794,9 @@ static int mt6370_tcpc_init(struct tcpc_device *tcpc, bool sw_reset)
 	mt6370_init_fault_mask(tcpc);
 	mt6370_init_mt_mask(tcpc);
 
-	/* CK_300K from 320K, SHIPPING off, AUTOIDLE enable, TIMEOUT = 6.4ms */
+	/* CK_300K from 320K, SHIPPING off, AUTOIDLE enable, TIMEOUT = 32ms */
 	mt6370_i2c_write8(tcpc, MT6370_REG_IDLE_CTRL,
-		MT6370_REG_IDLE_SET(0, 1, 1, 0));
-	mdelay(1);
+		MT6370_REG_IDLE_SET(0, 1, 1, 2));
 
 	return 0;
 }
@@ -877,6 +861,7 @@ int mt6370_get_alert_mask(struct tcpc_device *tcpc, uint32_t *mask)
 int mt6370_get_alert_status(struct tcpc_device *tcpc, uint32_t *alert)
 {
 	int ret;
+
 #ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
 	uint8_t v2;
 #endif
@@ -962,10 +947,7 @@ static int mt6370_get_cc(struct tcpc_device *tcpc, int *cc1, int *cc2)
 	if (act_as_drp) {
 		act_as_sink = TCPC_V10_REG_CC_STATUS_DRP_RESULT(status);
 	} else {
-		if (tcpc->typec_polarity)
-			cc_role = TCPC_V10_REG_CC_STATUS_CC2(role_ctrl);
-		else
-			cc_role = TCPC_V10_REG_CC_STATUS_CC1(role_ctrl);
+		cc_role =  TCPC_V10_REG_CC_STATUS_CC1(role_ctrl);
 		if (cc_role == TYPEC_CC_RP)
 			act_as_sink = false;
 		else
@@ -989,7 +971,6 @@ static int mt6370_get_cc(struct tcpc_device *tcpc, int *cc1, int *cc2)
 	return 0;
 }
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
 static int mt6370_enable_vsafe0v_detect(
 	struct tcpc_device *tcpc, bool enable)
 {
@@ -1003,17 +984,17 @@ static int mt6370_enable_vsafe0v_detect(
 	else
 		ret &= ~MT6370_REG_M_VBUS_80;
 
-	return mt6370_i2c_write8(tcpc, MT6370_REG_MT_MASK, (uint8_t) ret);
+	mt6370_i2c_write8(tcpc, MT6370_REG_MT_MASK, (uint8_t) ret);
+	return ret;
 }
-#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 
 static int mt6370_set_cc(struct tcpc_device *tcpc, int pull)
 {
 	int ret;
 	uint8_t data;
-	int rp_lvl = TYPEC_CC_PULL_GET_RP_LVL(pull), pull1, pull2;
+	int rp_lvl = TYPEC_CC_PULL_GET_RP_LVL(pull);
 
-	MT6370_INFO("pull = 0x%02X\n", pull);
+	MT6370_INFO("\n");
 	pull = TYPEC_CC_PULL_GET_RES(pull);
 	if (pull == TYPEC_CC_DRP) {
 		data = TCPC_V10_REG_ROLE_CTRL_RES_SET(
@@ -1023,9 +1004,7 @@ static int mt6370_set_cc(struct tcpc_device *tcpc, int pull)
 			tcpc, TCPC_V10_REG_ROLE_CTRL, data);
 
 		if (ret == 0) {
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
 			mt6370_enable_vsafe0v_detect(tcpc, false);
-#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 			ret = mt6370_command(tcpc, TCPM_CMD_LOOK_CONNECTION);
 		}
 	} else {
@@ -1033,16 +1012,7 @@ static int mt6370_set_cc(struct tcpc_device *tcpc, int pull)
 		if (pull == TYPEC_CC_RD && tcpc->pd_wait_pr_swap_complete)
 			mt6370_init_cc_params(tcpc, TYPEC_CC_VOLT_SNK_DFT);
 #endif	/* CONFIG_USB_POWER_DELIVERY */
-
-		pull1 = pull2 = pull;
-
-		if (pull == TYPEC_CC_RP && tcpc->typec_is_attached_src) {
-			if (tcpc->typec_polarity)
-				pull1 = TYPEC_CC_OPEN;
-			else
-				pull2 = TYPEC_CC_OPEN;
-		}
-		data = TCPC_V10_REG_ROLE_CTRL_RES_SET(0, rp_lvl, pull1, pull2);
+		data = TCPC_V10_REG_ROLE_CTRL_RES_SET(0, rp_lvl, pull, pull);
 		ret = mt6370_i2c_write8(tcpc, TCPC_V10_REG_ROLE_CTRL, data);
 	}
 
@@ -1053,9 +1023,6 @@ static int mt6370_set_polarity(struct tcpc_device *tcpc, int polarity)
 {
 	int data;
 
-	if (polarity < 0 || polarity > 1)
-		return -EOVERFLOW;
-
 	data = mt6370_init_cc_params(tcpc,
 		tcpc->typec_remote_cc[polarity]);
 	if (data)
@@ -1094,6 +1061,11 @@ static int mt6370_set_vconn(struct tcpc_device *tcpc, int enable)
 	if (rv < 0)
 		return rv;
 
+#ifndef CONFIG_TCPC_IDLE_MODE
+	rv = mt6370_i2c_write8(tcpc, MT6370_REG_IDLE_CTRL,
+		MT6370_REG_IDLE_SET(0, 1, enable ? 0 : 1, 2));
+#endif /* CONFIG_TCPC_IDLE_MODE */
+
 	if (enable)
 		mt6370_init_fault_mask(tcpc);
 
@@ -1101,9 +1073,9 @@ static int mt6370_set_vconn(struct tcpc_device *tcpc, int enable)
 }
 
 #ifdef CONFIG_TCPC_LOW_POWER_MODE
-static int mt6370_is_low_power_mode(struct tcpc_device *tcpc)
+static int mt6370_is_low_power_mode(struct tcpc_device *tcpc_dev)
 {
-	int rv = mt6370_i2c_read8(tcpc, MT6370_REG_BMC_CTRL);
+	int rv = mt6370_i2c_read8(tcpc_dev, MT6370_REG_BMC_CTRL);
 
 	if (rv < 0)
 		return rv;
@@ -1112,18 +1084,11 @@ static int mt6370_is_low_power_mode(struct tcpc_device *tcpc)
 }
 
 static int mt6370_set_low_power_mode(
-		struct tcpc_device *tcpc, bool en, int pull)
+		struct tcpc_device *tcpc_dev, bool en, int pull)
 {
-	int ret = 0;
+	int rv = 0;
 	uint8_t data;
 
-	ret = mt6370_i2c_write8(tcpc, MT6370_REG_IDLE_CTRL,
-		MT6370_REG_IDLE_SET(0, 1, en ? 0 : 1, 0));
-	if (ret < 0)
-		return ret;
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
-	mt6370_enable_vsafe0v_detect(tcpc, !en);
-#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 	if (en) {
 		data = MT6370_REG_BMCIO_LPEN;
 
@@ -1131,58 +1096,54 @@ static int mt6370_set_low_power_mode(
 			data |= MT6370_REG_BMCIO_LPRPRD;
 
 #ifdef CONFIG_TYPEC_CAP_NORP_SRC
-		data |= MT6370_REG_BMCIO_BG_EN | MT6370_REG_VBUS_DET_EN;
+		data |= MT6370_REG_VBUS_DET_EN;
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
 	} else {
 		data = MT6370_REG_BMCIO_BG_EN |
 			MT6370_REG_VBUS_DET_EN | MT6370_REG_BMCIO_OSC_EN;
+
+		mt6370_enable_vsafe0v_detect(tcpc_dev, true);
 	}
 
-	return mt6370_i2c_write8(tcpc, MT6370_REG_BMC_CTRL, data);
+	rv = mt6370_i2c_write8(tcpc_dev, MT6370_REG_BMC_CTRL, data);
+	return rv;
 }
 #endif	/* CONFIG_TCPC_LOW_POWER_MODE */
 
 #ifdef CONFIG_TCPC_WATCHDOG_EN
-int mt6370_set_watchdog(struct tcpc_device *tcpc, bool en)
+int mt6370_set_watchdog(struct tcpc_device *tcpc_dev, bool en)
 {
 	uint8_t data = MT6370_REG_WATCHDOG_CTRL_SET(en, 7);
 
-	return mt6370_i2c_write8(tcpc,
+	return mt6370_i2c_write8(tcpc_dev,
 		MT6370_REG_WATCHDOG_CTRL, data);
 }
 #endif	/* CONFIG_TCPC_WATCHDOG_EN */
 
 #ifdef CONFIG_TCPC_INTRST_EN
-int mt6370_set_intrst(struct tcpc_device *tcpc, bool en)
+int mt6370_set_intrst(struct tcpc_device *tcpc_dev, bool en)
 {
-	return mt6370_i2c_write8(tcpc,
+	return mt6370_i2c_write8(tcpc_dev,
 		MT6370_REG_INTRST_CTRL, MT6370_REG_INTRST_SET(en, 3));
 }
 #endif	/* CONFIG_TCPC_INTRST_EN */
 
-static int mt6370_tcpc_deinit(struct tcpc_device *tcpc)
+static int mt6370_tcpc_deinit(struct tcpc_device *tcpc_dev)
 {
-#ifdef CONFIG_RT_REGMAP
-	struct mt6370_chip *chip = tcpc_get_dev_data(tcpc);
-#endif /* CONFIG_RT_REGMAP */
-
 #ifdef CONFIG_TCPC_SHUTDOWN_CC_DETACH
-	mt6370_set_cc(tcpc, TYPEC_CC_DRP);
-	mt6370_set_cc(tcpc, TYPEC_CC_OPEN);
+	mt6370_set_cc(tcpc_dev, TYPEC_CC_DRP);
+	mt6370_set_cc(tcpc_dev, TYPEC_CC_OPEN);
 
-	mt6370_i2c_write8(tcpc,
+	mt6370_i2c_write8(tcpc_dev,
 		MT6370_REG_I2CRST_CTRL,
 		MT6370_REG_I2CRST_SET(true, 4));
 
-	mt6370_i2c_write8(tcpc,
+	mt6370_i2c_write8(tcpc_dev,
 		MT6370_REG_INTRST_CTRL,
 		MT6370_REG_INTRST_SET(true, 0));
 #else
-	mt6370_i2c_write8(tcpc, MT6370_REG_SWRESET, 1);
+	mt6370_i2c_write8(tcpc_dev, MT6370_REG_SWRESET, 1);
 #endif	/* CONFIG_TCPC_SHUTDOWN_CC_DETACH */
-#ifdef CONFIG_RT_REGMAP
-	rt_regmap_cache_reload(chip->m_dev);
-#endif /* CONFIG_RT_REGMAP */
 
 	return 0;
 }
@@ -1198,11 +1159,11 @@ static int mt6370_set_msg_header(
 		tcpc, TCPC_V10_REG_MSG_HDR_INFO, msg_hdr);
 }
 
-static int mt6370_protocol_reset(struct tcpc_device *tcpc)
+static int mt6370_protocol_reset(struct tcpc_device *tcpc_dev)
 {
-	mt6370_i2c_write8(tcpc, MT6370_REG_PRL_FSM_RESET, 0);
+	mt6370_i2c_write8(tcpc_dev, MT6370_REG_PRL_FSM_RESET, 0);
 	mdelay(1);
-	mt6370_i2c_write8(tcpc, MT6370_REG_PRL_FSM_RESET, 1);
+	mt6370_i2c_write8(tcpc_dev, MT6370_REG_PRL_FSM_RESET, 1);
 	return 0;
 }
 
@@ -1216,11 +1177,12 @@ static int mt6370_set_rx_enable(struct tcpc_device *tcpc, uint8_t enable)
 	if (ret == 0)
 		ret = mt6370_i2c_write8(tcpc, TCPC_V10_REG_RX_DETECT, enable);
 
-	if ((ret == 0) && (!enable)) {
-		mt6370_protocol_reset(tcpc);
+	if ((ret == 0) && (!enable))
 		ret = mt6370_set_clock_gating(tcpc, true);
-	}
 
+	/* For testing */
+	if (!enable)
+		mt6370_protocol_reset(tcpc);
 	return ret;
 }
 
@@ -1363,24 +1325,29 @@ static struct tcpc_ops mt6370_tcpc_ops = {
 #endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
 };
 
+
 static int mt_parse_dt(struct mt6370_chip *chip, struct device *dev)
 {
-	struct device_node *np = NULL;
-	int ret = 0;
+	struct device_node *np = dev->of_node;
+	int ret;
+
+	if (!np)
+		return -EINVAL;
 
 	pr_info("%s\n", __func__);
 
 	np = of_find_node_by_name(NULL, "type_c_port0");
 	if (!np) {
-		pr_notice("%s find node type_c_port0 fail\n", __func__);
+		pr_err("%s find node mt6370 fail\n", __func__);
 		return -ENODEV;
 	}
-	dev->of_node = np;
 
 #if (!defined(CONFIG_MTK_GPIO) || defined(CONFIG_MTK_GPIOLIB_STAND))
 	ret = of_get_named_gpio(np, "mt6370pd,intr_gpio", 0);
-	if (ret < 0)
+	if (ret < 0) {
 		pr_err("%s no intr_gpio info\n", __func__);
+		return ret;
+	}
 	chip->irq_gpio = ret;
 #else
 	ret = of_property_read_u32(
@@ -1388,7 +1355,7 @@ static int mt_parse_dt(struct mt6370_chip *chip, struct device *dev)
 	if (ret < 0)
 		pr_err("%s no intr_gpio info\n", __func__);
 #endif
-	return ret < 0 ? ret : 0;
+	return ret;
 }
 
 /*
@@ -1441,16 +1408,31 @@ static void check_printk_performance(void)
 static int mt6370_tcpcdev_init(struct mt6370_chip *chip, struct device *dev)
 {
 	struct tcpc_desc *desc;
-	struct device_node *np = dev->of_node;
+	struct device_node *np;
 	u32 val, len;
 	const char *name = "default";
+	bool kpoc_boot = false;
 
-	dev_info(dev, "%s\n", __func__);
+	np = of_find_node_by_name(NULL, "type_c_port0");
+	if (!np) {
+		pr_err("%s find node mt6370 fail\n", __func__);
+		return -ENODEV;
+	}
 
 	desc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);
 	if (!desc)
 		return -ENOMEM;
-	if (of_property_read_u32(np, "mt-tcpc,role_def", &val) >= 0) {
+
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+	if (get_boot_mode() == KERNEL_POWER_OFF_CHARGING_BOOT
+		|| get_boot_mode() == LOW_POWER_OFF_CHARGING_BOOT)
+		kpoc_boot = true;
+#endif /* CONFIG_MTK_KERNEL_POWER_OFF_CHARGING */
+
+	if (kpoc_boot) {
+		dev_info(dev, "%s KPOC use default Role SNK\n", __func__);
+		desc->role_def = 0; /* SNK */
+	} else if (of_property_read_u32(np, "mt-tcpc,role_def", &val) >= 0) {
 		if (val >= TYPEC_ROLE_NR)
 			desc->role_def = TYPEC_ROLE_DRP;
 		else
@@ -1471,10 +1453,14 @@ static int mt6370_tcpcdev_init(struct mt6370_chip *chip, struct device *dev)
 
 	if (of_property_read_u32(np, "mt-tcpc,rp_level", &val) >= 0) {
 		switch (val) {
-		case TYPEC_RP_DFT:
-		case TYPEC_RP_1_5:
-		case TYPEC_RP_3_0:
-			desc->rp_lvl = val;
+		case 0: /* RP Default */
+			desc->rp_lvl = TYPEC_CC_RP_DFT;
+			break;
+		case 1: /* RP 1.5V */
+			desc->rp_lvl = TYPEC_CC_RP_1_5;
+			break;
+		case 2: /* RP 3.0V */
+			desc->rp_lvl = TYPEC_CC_RP_3_0;
 			break;
 		default:
 			break;
@@ -1493,10 +1479,7 @@ static int mt6370_tcpcdev_init(struct mt6370_chip *chip, struct device *dev)
 	}
 #endif	/* CONFIG_TCPC_VCONN_SUPPLY_MODE */
 
-	if (of_property_read_string(np, "mt-tcpc,name",
-				(char const **)&name) < 0) {
-		dev_info(dev, "use default name\n");
-	}
+	of_property_read_string(np, "mt-tcpc,name", (char const **)&name);
 
 	len = strlen(name);
 	desc->name = kzalloc(len+1, GFP_KERNEL);
@@ -1509,14 +1492,9 @@ static int mt6370_tcpcdev_init(struct mt6370_chip *chip, struct device *dev)
 
 	chip->tcpc = tcpc_device_register(dev,
 			desc, &mt6370_tcpc_ops, chip);
-	if (IS_ERR_OR_NULL(chip->tcpc))
+	if (IS_ERR(chip->tcpc))
 		return -EINVAL;
 
-#ifdef CONFIG_USB_PD_DISABLE_PE
-	chip->tcpc->disable_pe =
-			of_property_read_bool(np, "mt-tcpc,disable_pe");
-#endif	/* CONFIG_USB_PD_DISABLE_PE */
-
 	chip->tcpc->tcpc_flags =
 		TCPC_FLAGS_LPM_WAKEUP_WATCHDOG |
 		TCPC_FLAGS_RETRY_CRC_DISCARD;
@@ -1533,8 +1511,10 @@ static int mt6370_tcpcdev_init(struct mt6370_chip *chip, struct device *dev)
 	else
 		dev_info(dev, "PD_REV20\n");
 #endif	/* CONFIG_USB_PD_REV30 */
-	chip->tcpc->tcpc_flags |= TCPC_FLAGS_ALERT_V10;
-
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+	if (kpoc_boot)
+		chip->tcpc->tcpc_flags |= TCPC_FLAGS_KPOC_BOOT;
+#endif /* CONFIG_MTK_KERNEL_POWER_OFF_CHARGING */
 	return 0;
 }
 
@@ -1572,7 +1552,7 @@ static inline int mt6370_check_revision(struct i2c_client *client)
 		return -ENODEV;
 	}
 
-	ret = i2c_smbus_write_i2c_block_data(client,
+	ret = i2c_smbus_read_i2c_block_data(client,
 			MT6370_REG_SWRESET, 1, (u8 *)&data);
 	if (ret < 0)
 		return ret;
@@ -1615,11 +1595,9 @@ static int mt6370_i2c_probe(struct i2c_client *client,
 	if (!chip)
 		return -ENOMEM;
 
-	if (use_dt) {
-		ret = mt_parse_dt(chip, &client->dev);
-		if (ret < 0)
-			return ret;
-	} else {
+	if (use_dt)
+		mt_parse_dt(chip, &client->dev);
+	else {
 		dev_err(&client->dev, "no dts node\n");
 		return -ENODEV;
 	}
@@ -1629,10 +1607,10 @@ static int mt6370_i2c_probe(struct i2c_client *client,
 	sema_init(&chip->suspend_lock, 1);
 	i2c_set_clientdata(client, chip);
 	INIT_DELAYED_WORK(&chip->poll_work, mt6370_poll_work);
-	chip->irq_wake_lock =
-		wakeup_source_register(chip->dev, "mt6370_irq_wake_lock");
-	chip->i2c_wake_lock =
-		wakeup_source_register(chip->dev, "mt6370_i2c_wake_lock");
+	wakeup_source_init(&chip->irq_wake_lock,
+		"mt6370_irq_wakelock");
+	wakeup_source_init(&chip->i2c_wake_lock,
+		"mt6370_i2c_wakelock");
 
 	chip->chip_id = chip_id;
 	pr_info("mt6370_chipID = 0x%0x\n", chip_id);
@@ -1663,8 +1641,6 @@ err_irq_init:
 	tcpc_device_unregister(chip->dev, chip->tcpc);
 err_tcpc_reg:
 	mt6370_regmap_deinit(chip);
-	wakeup_source_unregister(chip->i2c_wake_lock);
-	wakeup_source_unregister(chip->irq_wake_lock);
 	return ret;
 }
 
@@ -1820,24 +1796,6 @@ MODULE_DESCRIPTION("MT6370 TCPC Driver");
 MODULE_VERSION(MT6370_DRV_VERSION);
 
 /**** Release Note ****
- * 2.0.6_MTK
- * (1) Update tTCPCfilter to 267us
- *
- * 2.0.5_MTK
- * (1) Utilize rt-regmap to reduce I2C accesses
- *
- * 2.0.4_MTK
- * (1) Mask vSafe0V IRQ before entering low power mode
- * (2) Disable auto idle mode before entering low power mode
- * (3) Reset Protocol FSM and clear RX alerts twice before clock gating
- *
- * 2.0.3_MTK
- * (1) Move down the shipping off
- *
- * 2.0.2_MTK
- * (1) Single Rp as Attatched.SRC for Ellisys TD.4.9.4
- * (2) Fix Rx Noise for MQP
- *
  * 2.0.1_MTK
- *  First released PD3.0 Driver on MTK platform
+ *	First released PD3.0 Driver on MTK platform
  */
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpc_rt1711h.c b/drivers/misc/mediatek/typec/tcpc/tcpc_rt1711h.c
index eac77d6..b4ecaf1 100644
--- a/drivers/misc/mediatek/typec/tcpc/tcpc_rt1711h.c
+++ b/drivers/misc/mediatek/typec/tcpc/tcpc_rt1711h.c
@@ -1,7 +1,7 @@
 /*
  * Copyright (C) 2017 MediaTek Inc.
  *
- * Richtek RT1711H Type-C Port Control Driver
+ * Mediatek MT6370 Type-C Port Control Driver
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -28,7 +28,7 @@
 #include <linux/kthread.h>
 #include <linux/cpu.h>
 #include <linux/version.h>
-#include <uapi/linux/sched/types.h>
+#include <linux/sched/types.h>
 #include <linux/sched/clock.h>
 
 #include "inc/pd_dbg_info.h"
@@ -43,9 +43,14 @@
 #include <linux/sched/rt.h>
 #endif /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)) */
 
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+/* MTK only */
+#include <mt-plat/mtk_boot.h>
+#endif /* CONFIG_MTK_KERNEL_POWER_OFF_CHARGING */
+
 /* #define DEBUG_GPIO	66 */
 
-#define RT1711H_DRV_VERSION	"2.0.5_MTK"
+#define RT1711H_DRV_VERSION	"2.0.1_MTK"
 
 #define RT1711H_IRQ_WAKE_TIME	(500) /* ms */
 
@@ -62,7 +67,7 @@ struct rt1711_chip {
 	struct kthread_worker irq_worker;
 	struct kthread_work irq_work;
 	struct task_struct *irq_worker_task;
-	struct wakeup_source *irq_wake_lock;
+	struct wakeup_source irq_wake_lock;
 
 	atomic_t poll_count;
 	struct delayed_work	poll_work;
@@ -73,56 +78,52 @@ struct rt1711_chip {
 };
 
 #ifdef CONFIG_RT_REGMAP
-RT_REG_DECL(TCPC_V10_REG_VID, 2, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_PID, 2, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_DID, 2, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_TYPEC_REV, 2, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_PD_REV, 2, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_PDIF_REV, 2, RT_NORMAL_WR_ONCE, {});
+RT_REG_DECL(TCPC_V10_REG_VID, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_PID, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_DID, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TYPEC_REV, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_PD_REV, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_PDIF_REV, 2, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_ALERT, 2, RT_VOLATILE, {});
-RT_REG_DECL(TCPC_V10_REG_ALERT_MASK, 2, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_POWER_STATUS_MASK, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_FAULT_STATUS_MASK, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_TCPC_CTRL, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_ROLE_CTRL, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_FAULT_CTRL, 1, RT_NORMAL_WR_ONCE, {});
+RT_REG_DECL(TCPC_V10_REG_ALERT_MASK, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_POWER_STATUS_MASK, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_FAULT_STATUS_MASK, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TCPC_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_ROLE_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_FAULT_CTRL, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_POWER_CTRL, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_CC_STATUS, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_POWER_STATUS, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_FAULT_STATUS, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_COMMAND, 1, RT_VOLATILE, {});
-RT_REG_DECL(TCPC_V10_REG_MSG_HDR_INFO, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_RX_DETECT, 1, RT_NORMAL_WR_ONCE, {});
+RT_REG_DECL(TCPC_V10_REG_MSG_HDR_INFO, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_RX_DETECT, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_RX_BYTE_CNT, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_RX_BUF_FRAME_TYPE, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_RX_HDR, 2, RT_VOLATILE, {});
-RT_REG_DECL(TCPC_V10_REG_RX_DATA, 28, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_RX_DATA, 1, RT_VOLATILE, {});
 RT_REG_DECL(TCPC_V10_REG_TRANSMIT, 1, RT_VOLATILE, {});
-RT_REG_DECL(TCPC_V10_REG_TX_BYTE_CNT, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_TX_HDR, 2, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(TCPC_V10_REG_TX_DATA, 28, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(RT1711H_REG_CONFIG_GPIO0, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(RT1711H_REG_PHY_CTRL1, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(RT1711H_REG_CLK_CTRL2, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(RT1711H_REG_CLK_CTRL3, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(RT1711H_REG_PRL_FSM_RESET, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TX_BYTE_CNT, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TX_HDR, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TX_DATA, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT1711H_REG_PHY_CTRL1, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT1711H_REG_CLK_CTRL2, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT1711H_REG_CLK_CTRL3, 1, RT_VOLATILE, {});
 RT_REG_DECL(RT1711H_REG_BMC_CTRL, 1, RT_VOLATILE, {});
-RT_REG_DECL(RT1711H_REG_BMCIO_RXDZSEL, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(RT1711H_REG_VCONN_CLIMITEN, 1, RT_NORMAL_WR_ONCE, {});
+RT_REG_DECL(RT1711H_REG_BMCIO_RXDZSEL, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT1711H_REG_VCONN_CLIMITEN, 1, RT_VOLATILE, {});
 RT_REG_DECL(RT1711H_REG_RT_STATUS, 1, RT_VOLATILE, {});
 RT_REG_DECL(RT1711H_REG_RT_INT, 1, RT_VOLATILE, {});
-RT_REG_DECL(RT1711H_REG_RT_MASK, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(RT1711H_REG_IDLE_CTRL, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(RT1711H_REG_INTRST_CTRL, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(RT1711H_REG_WATCHDOG_CTRL, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(RT1711H_REG_I2CRST_CTRL, 1, RT_NORMAL_WR_ONCE, {});
+RT_REG_DECL(RT1711H_REG_RT_MASK, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT1711H_REG_IDLE_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT1711H_REG_INTRST_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT1711H_REG_WATCHDOG_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT1711H_REG_I2CRST_CTRL, 1, RT_VOLATILE, {});
 RT_REG_DECL(RT1711H_REG_SWRESET, 1, RT_VOLATILE, {});
-RT_REG_DECL(RT1711H_REG_TTCPC_FILTER, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(RT1711H_REG_DRP_TOGGLE_CYCLE, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(RT1711H_REG_DRP_DUTY_CTRL, 2, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(RT1711H_REG_BMCIO_RXDZEN, 1, RT_NORMAL_WR_ONCE, {});
-RT_REG_DECL(RT1711H_REG_UNLOCK_PW_2, 2, RT_VOLATILE, {});
-RT_REG_DECL(RT1711H_REG_EFUSE5, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT1711H_REG_TTCPC_FILTER, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT1711H_REG_DRP_TOGGLE_CYCLE, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT1711H_REG_DRP_DUTY_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT1711H_REG_BMCIO_RXDZEN, 1, RT_VOLATILE, {});
 
 static const rt_register_map_t rt1711_chip_regmap[] = {
 	RT_REG(TCPC_V10_REG_VID),
@@ -153,11 +154,9 @@ static const rt_register_map_t rt1711_chip_regmap[] = {
 	RT_REG(TCPC_V10_REG_TX_BYTE_CNT),
 	RT_REG(TCPC_V10_REG_TX_HDR),
 	RT_REG(TCPC_V10_REG_TX_DATA),
-	RT_REG(RT1711H_REG_CONFIG_GPIO0),
 	RT_REG(RT1711H_REG_PHY_CTRL1),
 	RT_REG(RT1711H_REG_CLK_CTRL2),
 	RT_REG(RT1711H_REG_CLK_CTRL3),
-	RT_REG(RT1711H_REG_PRL_FSM_RESET),
 	RT_REG(RT1711H_REG_BMC_CTRL),
 	RT_REG(RT1711H_REG_BMCIO_RXDZSEL),
 	RT_REG(RT1711H_REG_VCONN_CLIMITEN),
@@ -173,8 +172,6 @@ static const rt_register_map_t rt1711_chip_regmap[] = {
 	RT_REG(RT1711H_REG_DRP_TOGGLE_CYCLE),
 	RT_REG(RT1711H_REG_DRP_DUTY_CTRL),
 	RT_REG(RT1711H_REG_BMCIO_RXDZEN),
-	RT_REG(RT1711H_REG_UNLOCK_PW_2),
-	RT_REG(RT1711H_REG_EFUSE5),
 };
 #define RT1711_CHIP_REGMAP_SIZE ARRAY_SIZE(rt1711_chip_regmap)
 
@@ -182,20 +179,25 @@ static const rt_register_map_t rt1711_chip_regmap[] = {
 
 static int rt1711_read_device(void *client, u32 reg, int len, void *dst)
 {
-	struct i2c_client *i2c = client;
+	struct i2c_client *i2c = (struct i2c_client *)client;
 	int ret = 0, count = 5;
-	u64 t1 = 0, t2 = 0;
 
-	while (1) {
-		t1 = local_clock();
-		ret = i2c_smbus_read_i2c_block_data(i2c, reg, len, dst);
-		t2 = local_clock();
-		RT1711_INFO("%s del = %lluus, reg = %02X, len = %d\n",
-			    __func__, (t2 - t1) / NSEC_PER_USEC, reg, len);
-		if (ret < 0 && count > 1)
-			count--;
-		else
-			break;
+	while (count) {
+		if (len > 1) {
+			ret = i2c_smbus_read_i2c_block_data(i2c, reg, len, dst);
+			if (ret < 0)
+				count--;
+			else
+				return ret;
+		} else {
+			ret = i2c_smbus_read_byte_data(i2c, reg);
+			if (ret < 0)
+				count--;
+			else {
+				*(u8 *)dst = (u8)ret;
+				return ret;
+			}
+		}
 		udelay(100);
 	}
 	return ret;
@@ -203,20 +205,26 @@ static int rt1711_read_device(void *client, u32 reg, int len, void *dst)
 
 static int rt1711_write_device(void *client, u32 reg, int len, const void *src)
 {
-	struct i2c_client *i2c = client;
+	const u8 *data;
+	struct i2c_client *i2c = (struct i2c_client *)client;
 	int ret = 0, count = 5;
-	u64 t1 = 0, t2 = 0;
 
-	while (1) {
-		t1 = local_clock();
-		ret = i2c_smbus_write_i2c_block_data(i2c, reg, len, src);
-		t2 = local_clock();
-		RT1711_INFO("%s del = %lluus, reg = %02X, len = %d\n",
-			    __func__, (t2 - t1) / NSEC_PER_USEC, reg, len);
-		if (ret < 0 && count > 1)
-			count--;
-		else
-			break;
+	while (count) {
+		if (len > 1) {
+			ret = i2c_smbus_write_i2c_block_data(i2c,
+							reg, len, src);
+			if (ret < 0)
+				count--;
+			else
+				return ret;
+		} else {
+			data = src;
+			ret = i2c_smbus_write_byte_data(i2c, reg, *data);
+			if (ret < 0)
+				count--;
+			else
+				return ret;
+		}
 		udelay(100);
 	}
 	return ret;
@@ -362,8 +370,8 @@ static int rt1711_regmap_init(struct rt1711_chip *chip)
 	props->register_num = RT1711_CHIP_REGMAP_SIZE;
 	props->rm = rt1711_chip_regmap;
 
-	props->rt_regmap_mode = RT_MULTI_BYTE |
-				RT_IO_PASS_THROUGH | RT_DBG_SPECIAL;
+	props->rt_regmap_mode = RT_MULTI_BYTE | RT_CACHE_DISABLE |
+				RT_IO_PASS_THROUGH | RT_DBG_GENERAL;
 	snprintf(name, sizeof(name), "rt1711-%02x", chip->client->addr);
 
 	len = strlen(name);
@@ -373,8 +381,8 @@ static int rt1711_regmap_init(struct rt1711_chip *chip)
 	if ((!props->name) || (!props->aliases))
 		return -ENOMEM;
 
-	strlcpy((char *)props->name, name, len+1);
-	strlcpy((char *)props->aliases, name, len+1);
+	strlcpy((char *)props->name, name, len + 1);
+	strlcpy((char *)props->aliases, name, len + 1);
 	props->io_log_en = 0;
 
 	chip->m_dev = rt_regmap_device_register(props,
@@ -398,15 +406,10 @@ static int rt1711_regmap_deinit(struct rt1711_chip *chip)
 static inline int rt1711_software_reset(struct tcpc_device *tcpc)
 {
 	int ret = rt1711_i2c_write8(tcpc, RT1711H_REG_SWRESET, 1);
-#ifdef CONFIG_RT_REGMAP
-	struct rt1711_chip *chip = tcpc_get_dev_data(tcpc);
-#endif /* CONFIG_RT_REGMAP */
 
 	if (ret < 0)
 		return ret;
-#ifdef CONFIG_RT_REGMAP
-	rt_regmap_cache_reload(chip->m_dev);
-#endif /* CONFIG_RT_REGMAP */
+
 	usleep_range(1000, 2000);
 	return 0;
 }
@@ -416,44 +419,6 @@ static inline int rt1711_command(struct tcpc_device *tcpc, uint8_t cmd)
 	return rt1711_i2c_write8(tcpc, TCPC_V10_REG_COMMAND, cmd);
 }
 
-static int rt1711_init_vbus_cal(struct tcpc_device *tcpc)
-{
-	struct rt1711_chip *chip = tcpc_get_dev_data(tcpc);
-	const u8 val_en_test_mode[] = {0x86, 0x62};
-	const u8 val_dis_test_mode[] = {0x00, 0x00};
-	int ret = 0;
-	u8 data = 0;
-	s8 cal = 0;
-
-	ret = rt1711_block_write(chip->client, RT1711H_REG_UNLOCK_PW_2,
-			ARRAY_SIZE(val_en_test_mode), val_en_test_mode);
-	if (ret < 0)
-		dev_notice(chip->dev, "%s en test mode fail(%d)\n",
-				__func__, ret);
-
-	ret = rt1711_reg_read(chip->client, RT1711H_REG_EFUSE5);
-	if (ret < 0)
-		goto out;
-
-	data = ret;
-	data = (data & RT1711H_REG_M_VBUS_CAL) >> RT1711H_REG_S_VBUS_CAL;
-	cal = (data & BIT(2)) ? (data | GENMASK(7, 3)) : data;
-	cal -= 2;
-	if (cal < RT1711H_REG_MIN_VBUS_CAL)
-		cal = RT1711H_REG_MIN_VBUS_CAL;
-	data = (cal << RT1711H_REG_S_VBUS_CAL) | (ret & GENMASK(4, 0));
-
-	ret = rt1711_reg_write(chip->client, RT1711H_REG_EFUSE5, data);
-out:
-	ret = rt1711_block_write(chip->client, RT1711H_REG_UNLOCK_PW_2,
-			ARRAY_SIZE(val_dis_test_mode), val_dis_test_mode);
-	if (ret < 0)
-		dev_notice(chip->dev, "%s dis test mode fail(%d)\n",
-				__func__, ret);
-
-	return ret;
-}
-
 static int rt1711_init_alert_mask(struct tcpc_device *tcpc)
 {
 	uint16_t mask;
@@ -573,7 +538,7 @@ static irqreturn_t rt1711_intr_handler(int irq, void *data)
 {
 	struct rt1711_chip *chip = data;
 
-	__pm_wakeup_event(chip->irq_wake_lock, RT1711H_IRQ_WAKE_TIME);
+	__pm_wakeup_event(&chip->irq_wake_lock, RT1711H_IRQ_WAKE_TIME);
 
 #ifdef DEBUG_GPIO
 	gpio_set_value(DEBUG_GPIO, 0);
@@ -633,7 +598,7 @@ static int rt1711_init_alert(struct tcpc_device *tcpc)
 
 	kthread_init_worker(&chip->irq_worker);
 	chip->irq_worker_task = kthread_run(kthread_worker_fn,
-			&chip->irq_worker, "%s", chip->tcpc_desc->name);
+			&chip->irq_worker, chip->tcpc_desc->name);
 	if (IS_ERR(chip->irq_worker_task)) {
 		pr_err("Error: Could not create tcpc task\n");
 		goto init_alert_err;
@@ -642,9 +607,10 @@ static int rt1711_init_alert(struct tcpc_device *tcpc)
 	sched_setscheduler(chip->irq_worker_task, SCHED_FIFO, &param);
 	kthread_init_work(&chip->irq_work, rt1711_irq_work_handler);
 
-	pr_info("IRQF_NO_THREAD Test\n");
+	pr_info("IRQF_NO_THREAD Test\r\n");
 	ret = request_irq(chip->irq, rt1711_intr_handler,
-		IRQF_TRIGGER_FALLING | IRQF_NO_THREAD, name, chip);
+		IRQF_TRIGGER_FALLING | IRQF_NO_THREAD |
+		IRQF_NO_SUSPEND, name, chip);
 	if (ret < 0) {
 		pr_err("Error: failed to request irq%d (gpio = %d, ret = %d)\n",
 			chip->irq, chip->irq_gpio, ret);
@@ -652,9 +618,11 @@ static int rt1711_init_alert(struct tcpc_device *tcpc)
 	}
 
 	enable_irq_wake(chip->irq);
+	device_init_wakeup(chip->dev, true);
 	return 0;
 init_alert_err:
 	return -EINVAL;
+
 }
 
 int rt1711_alert_status_clear(struct tcpc_device *tcpc, uint32_t mask)
@@ -686,14 +654,15 @@ int rt1711_alert_status_clear(struct tcpc_device *tcpc, uint32_t mask)
 	return 0;
 }
 
-static int rt1711h_set_clock_gating(struct tcpc_device *tcpc, bool en)
+static int rt1711h_set_clock_gating(struct tcpc_device *tcpc_dev,
+									bool en)
 {
 	int ret = 0;
 
 #ifdef CONFIG_TCPC_CLOCK_GATING
-	int i = 0;
 	uint8_t clk2 = RT1711H_REG_CLK_DIV_600K_EN
 		| RT1711H_REG_CLK_DIV_300K_EN | RT1711H_REG_CLK_CK_300K_EN;
+
 	uint8_t clk3 = RT1711H_REG_CLK_DIV_2P4M_EN;
 
 	if (!en) {
@@ -704,15 +673,16 @@ static int rt1711h_set_clock_gating(struct tcpc_device *tcpc, bool en)
 	}
 
 	if (en) {
-		for (i = 0; i < 2; i++)
-			ret = rt1711_alert_status_clear(tcpc,
-				TCPC_REG_ALERT_RX_ALL_MASK);
+		ret = rt1711_alert_status_clear(tcpc_dev,
+			TCPC_REG_ALERT_RX_STATUS |
+			TCPC_REG_ALERT_RX_HARD_RST |
+			TCPC_REG_ALERT_RX_BUF_OVF);
 	}
 
 	if (ret == 0)
-		ret = rt1711_i2c_write8(tcpc, RT1711H_REG_CLK_CTRL2, clk2);
+		ret = rt1711_i2c_write8(tcpc_dev, RT1711H_REG_CLK_CTRL2, clk2);
 	if (ret == 0)
-		ret = rt1711_i2c_write8(tcpc, RT1711H_REG_CLK_CTRL3, clk3);
+		ret = rt1711_i2c_write8(tcpc_dev, RT1711H_REG_CLK_CTRL3, clk3);
 #endif	/* CONFIG_TCPC_CLOCK_GATING */
 
 	return ret;
@@ -762,6 +732,10 @@ static int rt1711_tcpc_init(struct tcpc_device *tcpc, bool sw_reset)
 			return ret;
 	}
 
+	/* CK_300K from 320K, SHIPPING off, AUTOIDLE enable, TIMEOUT = 32ms */
+	rt1711_i2c_write8(tcpc, RT1711H_REG_IDLE_CTRL,
+		RT1711H_REG_IDLE_SET(0, 1, 1, 2));
+
 #ifdef CONFIG_TCPC_I2CRST_EN
 	rt1711_i2c_write8(tcpc,
 		RT1711H_REG_I2CRST_CTRL,
@@ -800,25 +774,16 @@ static int rt1711_tcpc_init(struct tcpc_device *tcpc, bool sw_reset)
 	if (!(tcpc->tcpc_flags & TCPC_FLAGS_RETRY_CRC_DISCARD))
 		retry_discard_old = true;
 
-	rt1711_i2c_write8(tcpc, RT1711H_REG_CONFIG_GPIO0, 0x80);
-
-	/* For BIST, Change Transition Toggle Counter (Noise) from 3 to 7 */
 	rt1711_i2c_write8(tcpc, RT1711H_REG_PHY_CTRL1,
 		RT1711H_REG_PHY_CTRL1_SET(retry_discard_old, 7, 0, 1));
 
 	tcpci_alert_status_clear(tcpc, 0xffffffff);
 
-	rt1711_init_vbus_cal(tcpc);
 	rt1711_init_power_status_mask(tcpc);
 	rt1711_init_alert_mask(tcpc);
 	rt1711_init_fault_mask(tcpc);
 	rt1711_init_rt_mask(tcpc);
 
-	/* CK_300K from 320K, SHIPPING off, AUTOIDLE enable, TIMEOUT = 6.4ms */
-	rt1711_i2c_write8(tcpc, RT1711H_REG_IDLE_CTRL,
-		RT1711H_REG_IDLE_SET(0, 1, 1, 0));
-	mdelay(1);
-
 	return 0;
 }
 
@@ -855,7 +820,6 @@ int rt1711_get_alert_mask(struct tcpc_device *tcpc, uint32_t *mask)
 	ret = rt1711_i2c_read16(tcpc, TCPC_V10_REG_ALERT_MASK);
 	if (ret < 0)
 		return ret;
-
 	*mask = (uint16_t) ret;
 
 #ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
@@ -866,13 +830,13 @@ int rt1711_get_alert_mask(struct tcpc_device *tcpc, uint32_t *mask)
 	v2 = (uint8_t) ret;
 	*mask |= v2 << 16;
 #endif
-
 	return 0;
 }
 
 int rt1711_get_alert_status(struct tcpc_device *tcpc, uint32_t *alert)
 {
 	int ret;
+
 #ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
 	uint8_t v2;
 #endif
@@ -958,10 +922,7 @@ static int rt1711_get_cc(struct tcpc_device *tcpc, int *cc1, int *cc2)
 	if (act_as_drp) {
 		act_as_sink = TCPC_V10_REG_CC_STATUS_DRP_RESULT(status);
 	} else {
-		if (tcpc->typec_polarity)
-			cc_role = TCPC_V10_REG_CC_STATUS_CC2(role_ctrl);
-		else
-			cc_role = TCPC_V10_REG_CC_STATUS_CC1(role_ctrl);
+		cc_role =  TCPC_V10_REG_CC_STATUS_CC1(role_ctrl);
 		if (cc_role == TYPEC_CC_RP)
 			act_as_sink = false;
 		else
@@ -985,7 +946,6 @@ static int rt1711_get_cc(struct tcpc_device *tcpc, int *cc1, int *cc2)
 	return 0;
 }
 
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
 static int rt1711_enable_vsafe0v_detect(
 	struct tcpc_device *tcpc, bool enable)
 {
@@ -999,17 +959,17 @@ static int rt1711_enable_vsafe0v_detect(
 	else
 		ret &= ~RT1711H_REG_M_VBUS_80;
 
-	return rt1711_i2c_write8(tcpc, RT1711H_REG_RT_MASK, (uint8_t) ret);
+	rt1711_i2c_write8(tcpc, RT1711H_REG_RT_MASK, (uint8_t) ret);
+	return ret;
 }
-#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 
 static int rt1711_set_cc(struct tcpc_device *tcpc, int pull)
 {
 	int ret;
 	uint8_t data;
-	int rp_lvl = TYPEC_CC_PULL_GET_RP_LVL(pull), pull1, pull2;
+	int rp_lvl = TYPEC_CC_PULL_GET_RP_LVL(pull);
 
-	RT1711_INFO("pull = 0x%02X\n", pull);
+	RT1711_INFO("\n");
 	pull = TYPEC_CC_PULL_GET_RES(pull);
 	if (pull == TYPEC_CC_DRP) {
 		data = TCPC_V10_REG_ROLE_CTRL_RES_SET(
@@ -1019,9 +979,7 @@ static int rt1711_set_cc(struct tcpc_device *tcpc, int pull)
 			tcpc, TCPC_V10_REG_ROLE_CTRL, data);
 
 		if (ret == 0) {
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
 			rt1711_enable_vsafe0v_detect(tcpc, false);
-#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 			ret = rt1711_command(tcpc, TCPM_CMD_LOOK_CONNECTION);
 		}
 	} else {
@@ -1030,15 +988,7 @@ static int rt1711_set_cc(struct tcpc_device *tcpc, int pull)
 			rt1711h_init_cc_params(tcpc, TYPEC_CC_VOLT_SNK_DFT);
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
-		pull1 = pull2 = pull;
-
-		if (pull == TYPEC_CC_RP && tcpc->typec_is_attached_src) {
-			if (tcpc->typec_polarity)
-				pull1 = TYPEC_CC_OPEN;
-			else
-				pull2 = TYPEC_CC_OPEN;
-		}
-		data = TCPC_V10_REG_ROLE_CTRL_RES_SET(0, rp_lvl, pull1, pull2);
+		data = TCPC_V10_REG_ROLE_CTRL_RES_SET(0, rp_lvl, pull, pull);
 		ret = rt1711_i2c_write8(tcpc, TCPC_V10_REG_ROLE_CTRL, data);
 	}
 
@@ -1087,14 +1037,18 @@ static int rt1711_set_vconn(struct tcpc_device *tcpc, int enable)
 	if (rv < 0)
 		return rv;
 
-	return rt1711_i2c_write8(tcpc, RT1711H_REG_IDLE_CTRL,
-		RT1711H_REG_IDLE_SET(0, 1, enable ? 0 : 1, 0));
+#ifndef CONFIG_TCPC_IDLE_MODE
+	rv = rt1711_i2c_write8(tcpc, RT1711H_REG_IDLE_CTRL,
+		RT1711H_REG_IDLE_SET(0, 1, enable ? 0 : 1, 2));
+#endif /* CONFIG_TCPC_IDLE_MODE */
+
+	return rv;
 }
 
 #ifdef CONFIG_TCPC_LOW_POWER_MODE
-static int rt1711_is_low_power_mode(struct tcpc_device *tcpc)
+static int rt1711_is_low_power_mode(struct tcpc_device *tcpc_dev)
 {
-	int rv = rt1711_i2c_read8(tcpc, RT1711H_REG_BMC_CTRL);
+	int rv = rt1711_i2c_read8(tcpc_dev, RT1711H_REG_BMC_CTRL);
 
 	if (rv < 0)
 		return rv;
@@ -1103,18 +1057,11 @@ static int rt1711_is_low_power_mode(struct tcpc_device *tcpc)
 }
 
 static int rt1711_set_low_power_mode(
-		struct tcpc_device *tcpc, bool en, int pull)
+		struct tcpc_device *tcpc_dev, bool en, int pull)
 {
-	int ret = 0;
+	int rv = 0;
 	uint8_t data;
 
-	ret = rt1711_i2c_write8(tcpc, RT1711H_REG_IDLE_CTRL,
-		RT1711H_REG_IDLE_SET(0, 1, en ? 0 : 1, 0));
-	if (ret < 0)
-		return ret;
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
-	rt1711_enable_vsafe0v_detect(tcpc, !en);
-#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 	if (en) {
 		data = RT1711H_REG_BMCIO_LPEN;
 
@@ -1127,53 +1074,48 @@ static int rt1711_set_low_power_mode(
 	} else {
 		data = RT1711H_REG_BMCIO_BG_EN |
 			RT1711H_REG_VBUS_DET_EN | RT1711H_REG_BMCIO_OSC_EN;
+		rt1711_enable_vsafe0v_detect(tcpc_dev, true);
 	}
 
-	return rt1711_i2c_write8(tcpc, RT1711H_REG_BMC_CTRL, data);
+	rv = rt1711_i2c_write8(tcpc_dev, RT1711H_REG_BMC_CTRL, data);
+	return rv;
 }
 #endif	/* CONFIG_TCPC_LOW_POWER_MODE */
 
 #ifdef CONFIG_TCPC_WATCHDOG_EN
-int rt1711h_set_watchdog(struct tcpc_device *tcpc, bool en)
+int rt1711h_set_watchdog(struct tcpc_device *tcpc_dev, bool en)
 {
 	uint8_t data = RT1711H_REG_WATCHDOG_CTRL_SET(en, 7);
 
-	return rt1711_i2c_write8(tcpc,
+	return rt1711_i2c_write8(tcpc_dev,
 		RT1711H_REG_WATCHDOG_CTRL, data);
 }
 #endif	/* CONFIG_TCPC_WATCHDOG_EN */
 
 #ifdef CONFIG_TCPC_INTRST_EN
-int rt1711h_set_intrst(struct tcpc_device *tcpc, bool en)
+int rt1711h_set_intrst(struct tcpc_device *tcpc_dev, bool en)
 {
-	return rt1711_i2c_write8(tcpc,
+	return rt1711_i2c_write8(tcpc_dev,
 		RT1711H_REG_INTRST_CTRL, RT1711H_REG_INTRST_SET(en, 3));
 }
 #endif	/* CONFIG_TCPC_INTRST_EN */
 
-static int rt1711_tcpc_deinit(struct tcpc_device *tcpc)
+static int rt1711_tcpc_deinit(struct tcpc_device *tcpc_dev)
 {
-#ifdef CONFIG_RT_REGMAP
-	struct rt1711_chip *chip = tcpc_get_dev_data(tcpc);
-#endif /* CONFIG_RT_REGMAP */
-
 #ifdef CONFIG_TCPC_SHUTDOWN_CC_DETACH
-	rt1711_set_cc(tcpc, TYPEC_CC_DRP);
-	rt1711_set_cc(tcpc, TYPEC_CC_OPEN);
+	rt1711_set_cc(tcpc_dev, TYPEC_CC_DRP);
+	rt1711_set_cc(tcpc_dev, TYPEC_CC_OPEN);
 
-	rt1711_i2c_write8(tcpc,
+	rt1711_i2c_write8(tcpc_dev,
 		RT1711H_REG_I2CRST_CTRL,
 		RT1711H_REG_I2CRST_SET(true, 4));
 
-	rt1711_i2c_write8(tcpc,
+	rt1711_i2c_write8(tcpc_dev,
 		RT1711H_REG_INTRST_CTRL,
 		RT1711H_REG_INTRST_SET(true, 0));
 #else
-	rt1711_i2c_write8(tcpc, RT1711H_REG_SWRESET, 1);
+	rt1711_i2c_write8(tcpc_dev, RT1711H_REG_SWRESET, 1);
 #endif	/* CONFIG_TCPC_SHUTDOWN_CC_DETACH */
-#ifdef CONFIG_RT_REGMAP
-	rt_regmap_cache_reload(chip->m_dev);
-#endif /* CONFIG_RT_REGMAP */
 
 	return 0;
 }
@@ -1189,11 +1131,11 @@ static int rt1711_set_msg_header(
 		tcpc, TCPC_V10_REG_MSG_HDR_INFO, msg_hdr);
 }
 
-static int rt1711_protocol_reset(struct tcpc_device *tcpc)
+static int rt1711_protocol_reset(struct tcpc_device *tcpc_dev)
 {
-	rt1711_i2c_write8(tcpc, RT1711H_REG_PRL_FSM_RESET, 0);
+	rt1711_i2c_write8(tcpc_dev, RT1711H_REG_PRL_FSM_RESET, 0);
 	mdelay(1);
-	rt1711_i2c_write8(tcpc, RT1711H_REG_PRL_FSM_RESET, 1);
+	rt1711_i2c_write8(tcpc_dev, RT1711H_REG_PRL_FSM_RESET, 1);
 	return 0;
 }
 
@@ -1207,10 +1149,12 @@ static int rt1711_set_rx_enable(struct tcpc_device *tcpc, uint8_t enable)
 	if (ret == 0)
 		ret = rt1711_i2c_write8(tcpc, TCPC_V10_REG_RX_DETECT, enable);
 
-	if ((ret == 0) && (!enable)) {
-		rt1711_protocol_reset(tcpc);
+	if ((ret == 0) && (!enable))
 		ret = rt1711h_set_clock_gating(tcpc, true);
-	}
+
+	/* For testing */
+	if (!enable)
+		rt1711_protocol_reset(tcpc);
 
 	return ret;
 }
@@ -1254,6 +1198,9 @@ static int rt1711_set_bist_carrier_mode(
 	return 0;
 }
 
+/* transmit count (1byte) + message header (2byte) + data object (7*4) */
+#define RT1711_TRANSMIT_MAX_SIZE	(1+sizeof(uint16_t)+sizeof(uint32_t)*7)
+
 #ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
 static int rt1711_retransmit(struct tcpc_device *tcpc)
 {
@@ -1361,17 +1308,19 @@ static struct tcpc_ops rt1711_tcpc_ops = {
 
 static int rt_parse_dt(struct rt1711_chip *chip, struct device *dev)
 {
-	struct device_node *np = NULL;
-	int ret = 0;
+	struct device_node *np = dev->of_node;
+	int ret;
+
+	if (!np)
+		return -EINVAL;
 
 	pr_info("%s\n", __func__);
 
-	np = of_find_node_by_name(NULL, "rt1711_type_c_port0");
+	np = of_find_node_by_name(NULL, "type_c_port0");
 	if (!np) {
-		pr_notice("%s find node rt1711_type_c_port0 fail\n", __func__);
+		pr_notice("%s find node type_c_port0 fail\n", __func__);
 		return -ENODEV;
 	}
-	dev->of_node = np;
 
 #if (!defined(CONFIG_MTK_GPIO) || defined(CONFIG_MTK_GPIOLIB_STAND))
 	ret = of_get_named_gpio(np, "rt1711pd,intr_gpio", 0);
@@ -1386,7 +1335,7 @@ static int rt_parse_dt(struct rt1711_chip *chip, struct device *dev)
 	if (ret < 0)
 		pr_err("%s no intr_gpio info\n", __func__);
 #endif
-	return ret < 0 ? ret : 0;
+	return ret;
 }
 
 /*
@@ -1442,13 +1391,28 @@ static int rt1711_tcpcdev_init(struct rt1711_chip *chip, struct device *dev)
 	struct device_node *np = dev->of_node;
 	u32 val, len;
 	const char *name = "default";
+	bool kpoc_boot = false;
 
-	dev_info(dev, "%s\n", __func__);
+	np = of_find_node_by_name(NULL, "type_c_port0");
+	if (!np) {
+		pr_notice("%s find node type_c_port0 fail\n", __func__);
+		return -ENODEV;
+	}
 
 	desc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);
 	if (!desc)
 		return -ENOMEM;
-	if (of_property_read_u32(np, "rt-tcpc,role_def", &val) >= 0) {
+
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+	if (get_boot_mode() == KERNEL_POWER_OFF_CHARGING_BOOT
+		|| get_boot_mode() == LOW_POWER_OFF_CHARGING_BOOT)
+		kpoc_boot = true;
+#endif /* CONFIG_MTK_KERNEL_POWER_OFF_CHARGING */
+
+	if (kpoc_boot) {
+		dev_info(dev, "%s KPOC use default Role SNK\n", __func__);
+		desc->role_def = 0; /* SNK */
+	} else if (of_property_read_u32(np, "rt-tcpc,role_def", &val) >= 0) {
 		if (val >= TYPEC_ROLE_NR)
 			desc->role_def = TYPEC_ROLE_DRP;
 		else
@@ -1469,10 +1433,14 @@ static int rt1711_tcpcdev_init(struct rt1711_chip *chip, struct device *dev)
 
 	if (of_property_read_u32(np, "rt-tcpc,rp_level", &val) >= 0) {
 		switch (val) {
-		case TYPEC_RP_DFT:
-		case TYPEC_RP_1_5:
-		case TYPEC_RP_3_0:
-			desc->rp_lvl = val;
+		case 0: /* RP Default */
+			desc->rp_lvl = TYPEC_CC_RP_DFT;
+			break;
+		case 1: /* RP 1.5V */
+			desc->rp_lvl = TYPEC_CC_RP_1_5;
+			break;
+		case 2: /* RP 3.0V */
+			desc->rp_lvl = TYPEC_CC_RP_3_0;
 			break;
 		default:
 			break;
@@ -1491,32 +1459,23 @@ static int rt1711_tcpcdev_init(struct rt1711_chip *chip, struct device *dev)
 	}
 #endif	/* CONFIG_TCPC_VCONN_SUPPLY_MODE */
 
-	if (of_property_read_string(np, "rt-tcpc,name",
-				(char const **)&name) < 0) {
-		dev_info(dev, "use default name\n");
-	}
+	of_property_read_string(np, "rt-tcpc,name", (char const **)&name);
 
 	len = strlen(name);
 	desc->name = kzalloc(len+1, GFP_KERNEL);
 	if (!desc->name)
 		return -ENOMEM;
 
-	strlcpy((char *)desc->name, name, len+1);
+	strlcpy((char *)desc->name, name, len + 1);
 
 	chip->tcpc_desc = desc;
 
 	chip->tcpc = tcpc_device_register(dev,
 			desc, &rt1711_tcpc_ops, chip);
-	if (IS_ERR_OR_NULL(chip->tcpc))
+	if (IS_ERR(chip->tcpc))
 		return -EINVAL;
 
-#ifdef CONFIG_USB_PD_DISABLE_PE
-	chip->tcpc->disable_pe =
-			of_property_read_bool(np, "rt-tcpc,disable_pe");
-#endif	/* CONFIG_USB_PD_DISABLE_PE */
-
-	chip->tcpc->tcpc_flags = TCPC_FLAGS_LPM_WAKEUP_WATCHDOG |
-			TCPC_FLAGS_VCONN_SAFE5V_ONLY;
+	chip->tcpc->tcpc_flags = TCPC_FLAGS_LPM_WAKEUP_WATCHDOG;
 
 	if (chip->chip_id > RT1711H_DID_B)
 		chip->tcpc->tcpc_flags |= TCPC_FLAGS_CHECK_RA_DETACHE;
@@ -1535,7 +1494,10 @@ static int rt1711_tcpcdev_init(struct rt1711_chip *chip, struct device *dev)
 	else
 		dev_info(dev, "PD_REV20\n");
 #endif	/* CONFIG_USB_PD_REV30 */
-	chip->tcpc->tcpc_flags |= TCPC_FLAGS_ALERT_V10;
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+	if (kpoc_boot)
+		chip->tcpc->tcpc_flags |= TCPC_FLAGS_KPOC_BOOT;
+#endif /* CONFIG_MTK_KERNEL_POWER_OFF_CHARGING */
 
 	return 0;
 }
@@ -1593,7 +1555,7 @@ static int rt1711_i2c_probe(struct i2c_client *client,
 	int ret = 0, chip_id;
 	bool use_dt = client->dev.of_node;
 
-	pr_info("%s (%s)\n", __func__, RT1711H_DRV_VERSION);
+	pr_info("%s\n", __func__);
 	if (i2c_check_functionality(client->adapter,
 			I2C_FUNC_SMBUS_I2C_BLOCK | I2C_FUNC_SMBUS_BYTE_DATA))
 		pr_info("I2C functionality : OK...\n");
@@ -1612,11 +1574,9 @@ static int rt1711_i2c_probe(struct i2c_client *client,
 	if (!chip)
 		return -ENOMEM;
 
-	if (use_dt) {
-		ret = rt_parse_dt(chip, &client->dev);
-		if (ret < 0)
-			return ret;
-	} else {
+	if (use_dt)
+		rt_parse_dt(chip, &client->dev);
+	else {
 		dev_err(&client->dev, "no dts node\n");
 		return -ENODEV;
 	}
@@ -1626,8 +1586,7 @@ static int rt1711_i2c_probe(struct i2c_client *client,
 	sema_init(&chip->suspend_lock, 1);
 	i2c_set_clientdata(client, chip);
 	INIT_DELAYED_WORK(&chip->poll_work, rt1711_poll_work);
-	chip->irq_wake_lock =
-		wakeup_source_register(chip->dev, "rt1711h_irq_wake_lock");
+	wakeup_source_init(&chip->irq_wake_lock, "rt1711h_irq_wakelock");
 
 	chip->chip_id = chip_id;
 	pr_info("rt1711h_chipID = 0x%0x\n", chip_id);
@@ -1635,7 +1594,7 @@ static int rt1711_i2c_probe(struct i2c_client *client,
 	ret = rt1711_regmap_init(chip);
 	if (ret < 0) {
 		dev_err(chip->dev, "rt1711 regmap init fail\n");
-		goto err_regmap_init;
+		return -EINVAL;
 	}
 
 	ret = rt1711_tcpcdev_init(chip, &client->dev);
@@ -1658,8 +1617,6 @@ err_irq_init:
 	tcpc_device_unregister(chip->dev, chip->tcpc);
 err_tcpc_reg:
 	rt1711_regmap_deinit(chip);
-err_regmap_init:
-	wakeup_source_unregister(chip->irq_wake_lock);
 	return ret;
 }
 
@@ -1753,7 +1710,7 @@ static const struct dev_pm_ops rt1711_pm_ops = {
 #endif /* CONFIG_PM */
 
 static const struct i2c_device_id rt1711_id_table[] = {
-	{"rt1711h", 0},
+	{"rt1711", 0},
 	{"rt1715", 0},
 	{"rt1716", 0},
 	{},
@@ -1782,7 +1739,7 @@ static int __init rt1711_init(void)
 {
 	struct device_node *np;
 
-	pr_info("%s (%s): initializing...\n", __func__, RT1711H_DRV_VERSION);
+	pr_info("rt1711h_init (%s): initializing...\n", RT1711H_DRV_VERSION);
 	np = of_find_node_by_name(NULL, "usb_type_c");
 	if (np != NULL)
 		pr_info("usb_type_c node found...\n");
@@ -1805,25 +1762,6 @@ MODULE_DESCRIPTION("RT1711 TCPC Driver");
 MODULE_VERSION(RT1711H_DRV_VERSION);
 
 /**** Release Note ****
- * 2.0.5_MTK
- * (1) Utilize rt-regmap to reduce I2C accesses
- * (2) Decrease VBUS present threshold (VBUS_CAL) by 60mV (2LSBs)
- *
- * 2.0.4_MTK
- * (1) Mask vSafe0V IRQ before entering low power mode
- * (2) Disable auto idle mode before entering low power mode
- * (3) Reset Protocol FSM and clear RX alerts twice before clock gating
- *
- * 2.0.3_MTK
- * (1) Single Rp as Attatched.SRC for Ellisys TD.4.9.4
- *
- * 2.0.2_MTK
- * (1) Replace wake_lock with wakeup_source
- * (2) Move down the shipping off
- * (3) Add support for NoRp.SRC
- * (4) Reg0x71[7] = 1'b1 to workaround unstable VDD Iq in low power mode
- * (5) Add get_alert_mask of tcpc_ops
- *
  * 2.0.1_MTK
- * First released PD3.0 Driver on MTK platform
+ *	First released PD3.0 Driver on MTK platform
  */
diff --git a/./tcpc_rt5081.c b/drivers/misc/mediatek/typec/tcpc/tcpc_rt5081.c
new file mode 100644
index 0000000..90e6694
--- /dev/null
+++ b/drivers/misc/mediatek/typec/tcpc/tcpc_rt5081.c
@@ -0,0 +1,1719 @@
+/*
+ * Copyright (C) 2017 MediaTek Inc.
+ *
+ * Mediatek MT6370 Type-C Port Control Driver
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/semaphore.h>
+#include <linux/pm_runtime.h>
+#include <linux/workqueue.h>
+#include <linux/kthread.h>
+#include <linux/cpu.h>
+#include <linux/version.h>
+#include <linux/wakelock.h>
+
+#include "inc/pd_dbg_info.h"
+#include "inc/tcpci.h"
+#include "inc/rt5081.h"
+
+#ifdef CONFIG_RT_REGMAP
+#include <mt-plat/rt-regmap.h>
+#endif /* CONFIG_RT_REGMAP */
+
+#if 1 /*  #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))*/
+#include <linux/sched/rt.h>
+#endif /* #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)) */
+
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+/* MTK only */
+#include <mt-plat/mtk_boot.h>
+#endif /* CONFIG_MTK_KERNEL_POWER_OFF_CHARGING */
+
+/* #define DEBUG_GPIO	66 */
+
+#define RT5081_DRV_VERSION	"2.0.1_MTK"
+
+#define RT5081_IRQ_WAKE_TIME	(500) /* ms */
+
+struct rt5081_chip {
+	struct i2c_client *client;
+	struct device *dev;
+#ifdef CONFIG_RT_REGMAP
+	struct rt_regmap_device *m_dev;
+#endif /* CONFIG_RT_REGMAP */
+	struct semaphore io_lock;
+	struct semaphore suspend_lock;
+	struct tcpc_desc *tcpc_desc;
+	struct tcpc_device *tcpc;
+	struct kthread_worker irq_worker;
+	struct kthread_work irq_work;
+	struct task_struct *irq_worker_task;
+	struct wakeup_source irq_wake_lock;
+
+	atomic_t poll_count;
+	struct delayed_work	poll_work;
+
+	int irq_gpio;
+	int irq;
+	int chip_id;
+};
+
+#ifdef CONFIG_RT_REGMAP
+RT_REG_DECL(TCPC_V10_REG_VID, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_PID, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_DID, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TYPEC_REV, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_PD_REV, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_PDIF_REV, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_ALERT, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_ALERT_MASK, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_POWER_STATUS_MASK, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_FAULT_STATUS_MASK, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TCPC_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_ROLE_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_FAULT_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_POWER_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_CC_STATUS, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_POWER_STATUS, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_FAULT_STATUS, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_COMMAND, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_MSG_HDR_INFO, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_RX_DETECT, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_RX_BYTE_CNT, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_RX_BUF_FRAME_TYPE, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_RX_HDR, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_RX_DATA, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TRANSMIT, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TX_BYTE_CNT, 1, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TX_HDR, 2, RT_VOLATILE, {});
+RT_REG_DECL(TCPC_V10_REG_TX_DATA, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_PHY_CTRL1, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_PHY_CTRL3, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_CLK_CTRL2, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_CLK_CTRL3, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_BMC_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_BMCIO_RXDZSEL, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_RT_STATUS, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_RT_INT, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_RT_MASK, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_BMCIO_RXDZEN, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_IDLE_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_INTRST_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_WATCHDOG_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_I2CRST_CTRL, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_SWRESET, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_TTCPC_FILTER, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_DRP_TOGGLE_CYCLE, 1, RT_VOLATILE, {});
+RT_REG_DECL(RT5081_REG_DRP_DUTY_CTRL, 1, RT_VOLATILE, {});
+
+static const rt_register_map_t rt5081_chip_regmap[] = {
+	RT_REG(TCPC_V10_REG_VID),
+	RT_REG(TCPC_V10_REG_PID),
+	RT_REG(TCPC_V10_REG_DID),
+	RT_REG(TCPC_V10_REG_TYPEC_REV),
+	RT_REG(TCPC_V10_REG_PD_REV),
+	RT_REG(TCPC_V10_REG_PDIF_REV),
+	RT_REG(TCPC_V10_REG_ALERT),
+	RT_REG(TCPC_V10_REG_ALERT_MASK),
+	RT_REG(TCPC_V10_REG_POWER_STATUS_MASK),
+	RT_REG(TCPC_V10_REG_FAULT_STATUS_MASK),
+	RT_REG(TCPC_V10_REG_TCPC_CTRL),
+	RT_REG(TCPC_V10_REG_ROLE_CTRL),
+	RT_REG(TCPC_V10_REG_FAULT_CTRL),
+	RT_REG(TCPC_V10_REG_POWER_CTRL),
+	RT_REG(TCPC_V10_REG_CC_STATUS),
+	RT_REG(TCPC_V10_REG_POWER_STATUS),
+	RT_REG(TCPC_V10_REG_FAULT_STATUS),
+	RT_REG(TCPC_V10_REG_COMMAND),
+	RT_REG(TCPC_V10_REG_MSG_HDR_INFO),
+	RT_REG(TCPC_V10_REG_RX_DETECT),
+	RT_REG(TCPC_V10_REG_RX_BYTE_CNT),
+	RT_REG(TCPC_V10_REG_RX_BUF_FRAME_TYPE),
+	RT_REG(TCPC_V10_REG_RX_HDR),
+	RT_REG(TCPC_V10_REG_RX_DATA),
+	RT_REG(TCPC_V10_REG_TRANSMIT),
+	RT_REG(TCPC_V10_REG_TX_BYTE_CNT),
+	RT_REG(TCPC_V10_REG_TX_HDR),
+	RT_REG(TCPC_V10_REG_TX_DATA),
+	RT_REG(RT5081_REG_PHY_CTRL1),
+	RT_REG(RT5081_REG_PHY_CTRL3),
+	RT_REG(RT5081_REG_CLK_CTRL2),
+	RT_REG(RT5081_REG_CLK_CTRL3),
+	RT_REG(RT5081_REG_BMC_CTRL),
+	RT_REG(RT5081_REG_BMCIO_RXDZSEL),
+	RT_REG(RT5081_REG_RT_STATUS),
+	RT_REG(RT5081_REG_RT_INT),
+	RT_REG(RT5081_REG_RT_MASK),
+	RT_REG(RT5081_REG_BMCIO_RXDZEN),
+	RT_REG(RT5081_REG_IDLE_CTRL),
+	RT_REG(RT5081_REG_INTRST_CTRL),
+	RT_REG(RT5081_REG_WATCHDOG_CTRL),
+	RT_REG(RT5081_REG_I2CRST_CTRL),
+	RT_REG(RT5081_REG_SWRESET),
+	RT_REG(RT5081_REG_TTCPC_FILTER),
+	RT_REG(RT5081_REG_DRP_TOGGLE_CYCLE),
+	RT_REG(RT5081_REG_DRP_DUTY_CTRL),
+};
+#define RT5081_CHIP_REGMAP_SIZE ARRAY_SIZE(rt5081_chip_regmap)
+
+#endif /* CONFIG_RT_REGMAP */
+
+static int rt5081_read_device(void *client, u32 reg, int len, void *dst)
+{
+	struct i2c_client *i2c = (struct i2c_client *)client;
+	int ret = 0, count = 5;
+
+	while (count) {
+		if (len > 1) {
+			ret = i2c_smbus_read_i2c_block_data(i2c, reg, len, dst);
+			if (ret < 0)
+				count--;
+			else
+				return ret;
+		} else {
+			ret = i2c_smbus_read_byte_data(i2c, reg);
+			if (ret < 0)
+				count--;
+			else {
+				*(u8 *)dst = (u8)ret;
+				return ret;
+			}
+		}
+		udelay(100);
+	}
+	return ret;
+}
+
+static int rt5081_write_device(void *client, u32 reg, int len, const void *src)
+{
+	const u8 *data;
+	struct i2c_client *i2c = (struct i2c_client *)client;
+	int ret = 0, count = 5;
+
+	while (count) {
+		if (len > 1) {
+			ret = i2c_smbus_write_i2c_block_data(i2c,
+							reg, len, src);
+			if (ret < 0)
+				count--;
+			else
+				return ret;
+		} else {
+			data = src;
+			ret = i2c_smbus_write_byte_data(i2c, reg, *data);
+			if (ret < 0)
+				count--;
+			else
+				return ret;
+		}
+		udelay(100);
+	}
+	return ret;
+}
+
+static int rt5081_reg_read(struct i2c_client *i2c, u8 reg)
+{
+	struct rt5081_chip *chip = i2c_get_clientdata(i2c);
+	u8 val = 0;
+	int ret = 0;
+
+#ifdef CONFIG_RT_REGMAP
+	ret = rt_regmap_block_read(chip->m_dev, reg, 1, &val);
+#else
+	ret = rt5081_read_device(chip->client, reg, 1, &val);
+#endif /* CONFIG_RT_REGMAP */
+	if (ret < 0) {
+		dev_err(chip->dev, "rt5081 reg read fail\n");
+		return ret;
+	}
+	return val;
+}
+
+static int rt5081_reg_write(struct i2c_client *i2c, u8 reg, const u8 data)
+{
+	struct rt5081_chip *chip = i2c_get_clientdata(i2c);
+	int ret = 0;
+
+#ifdef CONFIG_RT_REGMAP
+	ret = rt_regmap_block_write(chip->m_dev, reg, 1, &data);
+#else
+	ret = rt5081_write_device(chip->client, reg, 1, &data);
+#endif /* CONFIG_RT_REGMAP */
+	if (ret < 0)
+		dev_err(chip->dev, "rt5081 reg write fail\n");
+	return ret;
+}
+
+static int rt5081_block_read(struct i2c_client *i2c,
+			u8 reg, int len, void *dst)
+{
+	struct rt5081_chip *chip = i2c_get_clientdata(i2c);
+	int ret = 0;
+#ifdef CONFIG_RT_REGMAP
+	ret = rt_regmap_block_read(chip->m_dev, reg, len, dst);
+#else
+	ret = rt5081_read_device(chip->client, reg, len, dst);
+#endif /* #ifdef CONFIG_RT_REGMAP */
+	if (ret < 0)
+		dev_err(chip->dev, "rt5081 block read fail\n");
+	return ret;
+}
+
+static int rt5081_block_write(struct i2c_client *i2c,
+			u8 reg, int len, const void *src)
+{
+	struct rt5081_chip *chip = i2c_get_clientdata(i2c);
+	int ret = 0;
+#ifdef CONFIG_RT_REGMAP
+	ret = rt_regmap_block_write(chip->m_dev, reg, len, src);
+#else
+	ret = rt5081_write_device(chip->client, reg, len, src);
+#endif /* #ifdef CONFIG_RT_REGMAP */
+	if (ret < 0)
+		dev_err(chip->dev, "rt5081 block write fail\n");
+	return ret;
+}
+
+static int32_t rt5081_write_word(struct i2c_client *client,
+					uint8_t reg_addr, uint16_t data)
+{
+	int ret;
+
+	/* don't need swap */
+	ret = rt5081_block_write(client, reg_addr, 2, (uint8_t *)&data);
+	return ret;
+}
+
+static int32_t rt5081_read_word(struct i2c_client *client,
+					uint8_t reg_addr, uint16_t *data)
+{
+	int ret;
+
+	/* don't need swap */
+	ret = rt5081_block_read(client, reg_addr, 2, (uint8_t *)data);
+	return ret;
+}
+
+static inline int rt5081_i2c_write8(
+	struct tcpc_device *tcpc, u8 reg, const u8 data)
+{
+	struct rt5081_chip *chip = tcpc_get_dev_data(tcpc);
+
+	return rt5081_reg_write(chip->client, reg, data);
+}
+
+static inline int rt5081_i2c_write16(
+		struct tcpc_device *tcpc, u8 reg, const u16 data)
+{
+	struct rt5081_chip *chip = tcpc_get_dev_data(tcpc);
+
+	return rt5081_write_word(chip->client, reg, data);
+}
+
+static inline int rt5081_i2c_read8(struct tcpc_device *tcpc, u8 reg)
+{
+	struct rt5081_chip *chip = tcpc_get_dev_data(tcpc);
+
+	return rt5081_reg_read(chip->client, reg);
+}
+
+static inline int rt5081_i2c_read16(
+	struct tcpc_device *tcpc, u8 reg)
+{
+	struct rt5081_chip *chip = tcpc_get_dev_data(tcpc);
+	u16 data;
+	int ret;
+
+	ret = rt5081_read_word(chip->client, reg, &data);
+	if (ret < 0)
+		return ret;
+	return data;
+}
+
+#ifdef CONFIG_RT_REGMAP
+static struct rt_regmap_fops rt5081_regmap_fops = {
+	.read_device = rt5081_read_device,
+	.write_device = rt5081_write_device,
+};
+#endif /* CONFIG_RT_REGMAP */
+
+static int rt5081_regmap_init(struct rt5081_chip *chip)
+{
+#ifdef CONFIG_RT_REGMAP
+	struct rt_regmap_properties *props;
+	char name[32];
+	int len;
+
+	props = devm_kzalloc(chip->dev, sizeof(*props), GFP_KERNEL);
+	if (!props)
+		return -ENOMEM;
+
+	props->register_num = RT5081_CHIP_REGMAP_SIZE;
+	props->rm = rt5081_chip_regmap;
+
+	props->rt_regmap_mode = RT_MULTI_BYTE | RT_CACHE_DISABLE |
+				RT_IO_PASS_THROUGH | RT_DBG_GENERAL;
+	snprintf(name, sizeof(name), "rt5081-%02x", chip->client->addr);
+
+	len = strlen(name);
+	props->name = kzalloc(len+1, GFP_KERNEL);
+	props->aliases = kzalloc(len+1, GFP_KERNEL);
+
+	if ((!props->name) || (!props->aliases))
+		return -ENOMEM;
+
+	strlcpy((char *)props->name, name, strlen(name)+1);
+	strlcpy((char *)props->aliases, name, strlen(name)+1);
+	props->io_log_en = 0;
+
+	chip->m_dev = rt_regmap_device_register(props,
+			&rt5081_regmap_fops, chip->dev, chip->client, chip);
+	if (!chip->m_dev) {
+		dev_err(chip->dev, "rt5081 chip rt_regmap register fail\n");
+		return -EINVAL;
+	}
+#endif
+	return 0;
+}
+
+static int rt5081_regmap_deinit(struct rt5081_chip *chip)
+{
+#ifdef CONFIG_RT_REGMAP
+	rt_regmap_device_unregister(chip->m_dev);
+#endif
+	return 0;
+}
+
+static inline int rt5081_software_reset(struct tcpc_device *tcpc)
+{
+	int ret = rt5081_i2c_write8(tcpc, RT5081_REG_SWRESET, 1);
+
+	if (ret < 0)
+		return ret;
+
+	usleep_range(1000, 2000);
+	return 0;
+}
+
+static inline int rt5081_command(struct tcpc_device *tcpc, uint8_t cmd)
+{
+	return rt5081_i2c_write8(tcpc, TCPC_V10_REG_COMMAND, cmd);
+}
+
+static int rt5081_init_alert_mask(struct tcpc_device *tcpc)
+{
+	uint16_t mask;
+	struct rt5081_chip *chip = tcpc_get_dev_data(tcpc);
+
+	mask = TCPC_V10_REG_ALERT_CC_STATUS | TCPC_V10_REG_ALERT_POWER_STATUS;
+
+#ifdef CONFIG_USB_POWER_DELIVERY
+	/* Need to handle RX overflow */
+	mask |= TCPC_V10_REG_ALERT_TX_SUCCESS | TCPC_V10_REG_ALERT_TX_DISCARDED
+			| TCPC_V10_REG_ALERT_TX_FAILED
+			| TCPC_V10_REG_ALERT_RX_HARD_RST
+			| TCPC_V10_REG_ALERT_RX_STATUS
+			| TCPC_V10_REG_RX_OVERFLOW;
+#endif
+
+	mask |= TCPC_REG_ALERT_FAULT;
+
+	return rt5081_write_word(chip->client, TCPC_V10_REG_ALERT_MASK, mask);
+}
+
+static int rt5081_init_power_status_mask(struct tcpc_device *tcpc)
+{
+	const uint8_t mask = TCPC_V10_REG_POWER_STATUS_VBUS_PRES;
+
+	return rt5081_i2c_write8(tcpc,
+			TCPC_V10_REG_POWER_STATUS_MASK, mask);
+}
+
+static int rt5081_init_fault_mask(struct tcpc_device *tcpc)
+{
+	const uint8_t mask =
+		TCPC_V10_REG_FAULT_STATUS_VCONN_OV |
+		TCPC_V10_REG_FAULT_STATUS_VCONN_OC;
+
+	return rt5081_i2c_write8(tcpc,
+			TCPC_V10_REG_FAULT_STATUS_MASK, mask);
+}
+
+static int rt5081_init_rt_mask(struct tcpc_device *tcpc)
+{
+	uint8_t rt_mask = 0;
+#ifdef CONFIG_TCPC_WATCHDOG_EN
+	rt_mask |= RT5081_REG_M_WATCHDOG;
+#endif /* CONFIG_TCPC_WATCHDOG_EN */
+#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+	rt_mask |= RT5081_REG_M_VBUS_80;
+#endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
+
+#ifdef CONFIG_TYPEC_CAP_RA_DETACH
+	if (tcpc->tcpc_flags & TCPC_FLAGS_CHECK_RA_DETACHE)
+		rt_mask |= RT5081_REG_M_RA_DETACH;
+#endif /* CONFIG_TYPEC_CAP_RA_DETACH */
+
+#ifdef CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
+	if (tcpc->tcpc_flags & TCPC_FLAGS_LPM_WAKEUP_WATCHDOG)
+		rt_mask |= RT5081_REG_M_WAKEUP;
+#endif	/* CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG */
+
+	return rt5081_i2c_write8(tcpc, RT5081_REG_RT_MASK, rt_mask);
+}
+
+static inline void rt5081_poll_ctrl(struct rt5081_chip *chip)
+{
+	cancel_delayed_work_sync(&chip->poll_work);
+
+	if (atomic_read(&chip->poll_count) == 0) {
+		atomic_inc(&chip->poll_count);
+		cpu_idle_poll_ctrl(true);
+	}
+
+	schedule_delayed_work(
+		&chip->poll_work, msecs_to_jiffies(40));
+}
+
+static void rt5081_irq_work_handler(struct kthread_work *work)
+{
+	struct rt5081_chip *chip =
+			container_of(work, struct rt5081_chip, irq_work);
+	int regval = 0;
+	int gpio_val;
+
+	rt5081_poll_ctrl(chip);
+	/* make sure I2C bus had resumed */
+	down(&chip->suspend_lock);
+	tcpci_lock_typec(chip->tcpc);
+
+#ifdef DEBUG_GPIO
+	gpio_set_value(DEBUG_GPIO, 1);
+#endif
+
+	do {
+		regval = tcpci_alert(chip->tcpc);
+		if (regval)
+			break;
+		gpio_val = gpio_get_value(chip->irq_gpio);
+	} while (gpio_val == 0);
+
+	tcpci_unlock_typec(chip->tcpc);
+	up(&chip->suspend_lock);
+
+#ifdef DEBUG_GPIO
+	gpio_set_value(DEBUG_GPIO, 1);
+#endif
+}
+
+static void rt5081_poll_work(struct work_struct *work)
+{
+	struct rt5081_chip *chip = container_of(
+		work, struct rt5081_chip, poll_work.work);
+
+	if (atomic_dec_and_test(&chip->poll_count))
+		cpu_idle_poll_ctrl(false);
+}
+
+static irqreturn_t rt5081_intr_handler(int irq, void *data)
+{
+	struct rt5081_chip *chip = data;
+
+	__pm_wakeup_event(&chip->irq_wake_lock, RT5081_IRQ_WAKE_TIME);
+
+#ifdef DEBUG_GPIO
+	gpio_set_value(DEBUG_GPIO, 0);
+#endif
+	kthread_queue_work(&chip->irq_worker, &chip->irq_work);
+	return IRQ_HANDLED;
+}
+
+static int rt5081_init_alert(struct tcpc_device *tcpc)
+{
+	struct rt5081_chip *chip = tcpc_get_dev_data(tcpc);
+	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
+	int ret;
+	char *name;
+	int len;
+
+	/* Clear Alert Mask & Status */
+	rt5081_write_word(chip->client, TCPC_V10_REG_ALERT_MASK, 0);
+	rt5081_write_word(chip->client, TCPC_V10_REG_ALERT, 0xffff);
+
+	len = strlen(chip->tcpc_desc->name);
+	name = devm_kzalloc(chip->dev, len+5, GFP_KERNEL);
+	if (!name)
+		return -ENOMEM;
+
+	snprintf(name, PAGE_SIZE, "%s-IRQ", chip->tcpc_desc->name);
+
+	pr_info("%s name = %s, gpio = %d\n", __func__,
+				chip->tcpc_desc->name, chip->irq_gpio);
+
+	ret = devm_gpio_request(chip->dev, chip->irq_gpio, name);
+#ifdef DEBUG_GPIO
+	gpio_request(DEBUG_GPIO, "debug_latency_pin");
+	gpio_direction_output(DEBUG_GPIO, 1);
+#endif
+	if (ret < 0) {
+		pr_err("Error: failed to request GPIO%d (ret = %d)\n",
+		chip->irq_gpio, ret);
+		goto init_alert_err;
+	}
+
+	ret = gpio_direction_input(chip->irq_gpio);
+	if (ret < 0) {
+		pr_err("Error: failed to set GPIO%d as input pin(ret = %d)\n",
+		chip->irq_gpio, ret);
+		goto init_alert_err;
+	}
+
+	chip->irq = gpio_to_irq(chip->irq_gpio);
+	if (chip->irq <= 0) {
+		pr_err("%s gpio to irq fail, chip->irq(%d)\n",
+						__func__, chip->irq);
+		goto init_alert_err;
+	}
+
+	pr_info("%s : IRQ number = %d\n", __func__, chip->irq);
+
+	kthread_init_worker(&chip->irq_worker);
+	chip->irq_worker_task = kthread_run(kthread_worker_fn,
+			&chip->irq_worker, chip->tcpc_desc->name);
+	if (IS_ERR(chip->irq_worker_task)) {
+		pr_err("Error: Could not create tcpc task\n");
+		goto init_alert_err;
+	}
+
+	sched_setscheduler(chip->irq_worker_task, SCHED_FIFO, &param);
+	kthread_init_work(&chip->irq_work, rt5081_irq_work_handler);
+
+	pr_info("IRQF_NO_THREAD Test\r\n");
+	ret = request_irq(chip->irq, rt5081_intr_handler,
+		IRQF_TRIGGER_FALLING | IRQF_NO_THREAD |
+		IRQF_NO_SUSPEND, name, chip);
+	if (ret < 0) {
+		pr_err("Error: failed to request irq%d (gpio = %d, ret = %d)\n",
+			chip->irq, chip->irq_gpio, ret);
+		goto init_alert_err;
+	}
+
+	enable_irq_wake(chip->irq);
+	return 0;
+init_alert_err:
+	return -EINVAL;
+}
+
+int rt5081_alert_status_clear(struct tcpc_device *tcpc, uint32_t mask)
+{
+	int ret;
+	uint16_t mask_t1;
+
+#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+	uint8_t mask_t2;
+#endif
+
+	/* Write 1 clear */
+	mask_t1 = (uint16_t) mask;
+	if (mask_t1) {
+		ret = rt5081_i2c_write16(tcpc, TCPC_V10_REG_ALERT, mask_t1);
+		if (ret < 0)
+			return ret;
+	}
+
+#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+	mask_t2 = mask >> 16;
+	if (mask_t2) {
+		ret = rt5081_i2c_write8(tcpc, RT5081_REG_RT_INT, mask_t2);
+		if (ret < 0)
+			return ret;
+	}
+#endif
+
+	return 0;
+}
+
+static int rt5081_set_clock_gating(struct tcpc_device *tcpc_dev,
+									bool en)
+{
+	int ret = 0;
+
+#ifdef CONFIG_TCPC_CLOCK_GATING
+	uint8_t clk2 = RT5081_REG_CLK_DIV_600K_EN
+		| RT5081_REG_CLK_DIV_300K_EN | RT5081_REG_CLK_CK_300K_EN;
+
+	uint8_t clk3 = RT5081_REG_CLK_DIV_2P4M_EN;
+
+	if (!en) {
+		clk2 |=
+			RT5081_REG_CLK_BCLK2_EN | RT5081_REG_CLK_BCLK_EN;
+		clk3 |=
+			RT5081_REG_CLK_CK_24M_EN | RT5081_REG_CLK_PCLK_EN;
+	}
+
+	if (en) {
+		ret = rt5081_alert_status_clear(tcpc_dev,
+			TCPC_REG_ALERT_RX_STATUS |
+			TCPC_REG_ALERT_RX_HARD_RST |
+			TCPC_REG_ALERT_RX_BUF_OVF);
+	}
+
+	if (ret == 0)
+		ret = rt5081_i2c_write8(tcpc_dev, RT5081_REG_CLK_CTRL2, clk2);
+	if (ret == 0)
+		ret = rt5081_i2c_write8(tcpc_dev, RT5081_REG_CLK_CTRL3, clk3);
+#endif	/* CONFIG_TCPC_CLOCK_GATING */
+
+	return ret;
+}
+
+static inline int rt5081_init_cc_params(
+			struct tcpc_device *tcpc, uint8_t cc_res)
+{
+	int rv = 0;
+
+#ifdef CONFIG_USB_POWER_DELIVERY
+#ifdef CONFIG_USB_PD_SNK_DFT_NO_GOOD_CRC
+	uint8_t en, sel;
+	struct rt5081_chip *chip = tcpc_get_dev_data(tcpc);
+
+	if (cc_res == TYPEC_CC_VOLT_SNK_DFT) { /* 0.55 */
+		en = 1;
+		sel = 0x81;
+	} else if (chip->chip_id >= RT1715_DID_D) { /* 0.35 & 0.75 */
+		en = 1;
+		sel = 0x81;
+	} else { /* 0.4 & 0.7 */
+		en = 0;
+		sel = 0x80;
+	}
+
+	rv = rt5081_i2c_write8(tcpc, RT5081_REG_BMCIO_RXDZEN, en);
+	if (rv == 0)
+		rv = rt5081_i2c_write8(tcpc, RT5081_REG_BMCIO_RXDZSEL, sel);
+#endif	/* CONFIG_USB_PD_SNK_DFT_NO_GOOD_CRC */
+#endif	/* CONFIG_USB_POWER_DELIVERY */
+
+	return rv;
+}
+
+static int rt5081_tcpc_init(struct tcpc_device *tcpc, bool sw_reset)
+{
+	int ret;
+	bool retry_discard_old = false;
+	struct rt5081_chip *chip = tcpc_get_dev_data(tcpc);
+
+	RT5081_INFO("\n");
+
+	if (sw_reset) {
+		ret = rt5081_software_reset(tcpc);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* CK_300K from 320K, SHIPPING off, AUTOIDLE enable, TIMEOUT = 32ms */
+	rt5081_i2c_write8(tcpc, RT5081_REG_IDLE_CTRL,
+		RT5081_REG_IDLE_SET(0, 1, 1, 2));
+
+	/* For No-GoodCRC Case (0x70) */
+	rt5081_i2c_write8(tcpc, RT5081_REG_PHY_CTRL3, 0x70);
+	/* For BIST, Change Transition Toggle Counter (Noise) from 3 to 7 */
+	rt5081_i2c_write8(tcpc, RT5081_REG_PHY_CTRL1, 0x71);
+
+#ifdef CONFIG_TCPC_I2CRST_EN
+	rt5081_i2c_write8(tcpc,
+		RT5081_REG_I2CRST_CTRL,
+		RT5081_REG_I2CRST_SET(true, 0x0f));
+#endif	/* CONFIG_TCPC_I2CRST_EN */
+
+	/* UFP Both RD setting */
+	/* DRP = 0, RpVal = 0 (Default), Rd, Rd */
+	rt5081_i2c_write8(tcpc, TCPC_V10_REG_ROLE_CTRL,
+		TCPC_V10_REG_ROLE_CTRL_RES_SET(0, 0, CC_RD, CC_RD));
+
+	if (chip->chip_id == RT5081_DID_A) {
+		rt5081_i2c_write8(tcpc, TCPC_V10_REG_FAULT_CTRL,
+			TCPC_V10_REG_FAULT_CTRL_DIS_VCONN_OV);
+	}
+
+	/*
+	 * CC Detect Debounce : 26.7*val us
+	 * Transition window count : spec 12~20us, based on 2.4MHz
+	 * DRP Toggle Cycle : 51.2 + 6.4*val ms
+	 * DRP Duyt Ctrl : dcSRC: /1024
+	 */
+
+	rt5081_i2c_write8(tcpc, RT5081_REG_TTCPC_FILTER, 5);
+	rt5081_i2c_write8(tcpc, RT5081_REG_DRP_TOGGLE_CYCLE, 4);
+	rt5081_i2c_write16(tcpc, RT5081_REG_DRP_DUTY_CTRL, TCPC_NORMAL_RP_DUTY);
+
+	/* Vconn OC */
+	rt5081_i2c_write8(tcpc, RT5081_REG_VCONN_CLIMITEN, 1);
+
+	/* RX/TX Clock Gating (Auto Mode)*/
+	if (!sw_reset)
+		rt5081_set_clock_gating(tcpc, true);
+
+	if (!(tcpc->tcpc_flags & TCPC_FLAGS_RETRY_CRC_DISCARD))
+		retry_discard_old = true;
+
+	rt5081_i2c_write8(tcpc, RT5081_REG_PHY_CTRL1,
+		RT5081_REG_PHY_CTRL1_SET(retry_discard_old, 7, 0, 1));
+
+	tcpci_alert_status_clear(tcpc, 0xffffffff);
+
+	rt5081_init_power_status_mask(tcpc);
+	rt5081_init_alert_mask(tcpc);
+	rt5081_init_fault_mask(tcpc);
+	rt5081_init_rt_mask(tcpc);
+
+	return 0;
+}
+
+static inline int rt5081_fault_status_vconn_ov(struct tcpc_device *tcpc)
+{
+	int ret;
+
+	ret = rt5081_i2c_read8(tcpc, RT5081_REG_BMC_CTRL);
+	if (ret < 0)
+		return ret;
+
+	ret &= ~RT5081_REG_DISCHARGE_EN;
+	return rt5081_i2c_write8(tcpc, RT5081_REG_BMC_CTRL, ret);
+}
+
+static inline int rt5081_fault_status_vconn_oc(struct tcpc_device *tcpc)
+{
+	const uint8_t mask =
+		TCPC_V10_REG_FAULT_STATUS_VCONN_OV;
+
+	return rt5081_i2c_write8(tcpc,
+		TCPC_V10_REG_FAULT_STATUS_MASK, mask);
+}
+
+int rt5081_fault_status_clear(struct tcpc_device *tcpc, uint8_t status)
+{
+	int ret;
+
+	if (status & TCPC_V10_REG_FAULT_STATUS_VCONN_OV)
+		ret = rt5081_fault_status_vconn_ov(tcpc);
+	if (status & TCPC_V10_REG_FAULT_STATUS_VCONN_OC)
+		ret = rt5081_fault_status_vconn_oc(tcpc);
+
+	rt5081_i2c_write8(tcpc, TCPC_V10_REG_FAULT_STATUS, status);
+	return 0;
+}
+
+int rt5081_get_alert_status(struct tcpc_device *tcpc, uint32_t *alert)
+{
+	int ret;
+
+#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+	uint8_t v2;
+#endif
+
+	ret = rt5081_i2c_read16(tcpc, TCPC_V10_REG_ALERT);
+	if (ret < 0)
+		return ret;
+
+	*alert = (uint16_t) ret;
+
+#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+	ret = rt5081_i2c_read8(tcpc, RT5081_REG_RT_INT);
+	if (ret < 0)
+		return ret;
+
+	v2 = (uint8_t) ret;
+	*alert |= v2 << 16;
+#endif
+
+	return 0;
+}
+
+static int rt5081_get_power_status(
+		struct tcpc_device *tcpc, uint16_t *pwr_status)
+{
+	int ret;
+
+	ret = rt5081_i2c_read8(tcpc, TCPC_V10_REG_POWER_STATUS);
+	if (ret < 0)
+		return ret;
+
+	*pwr_status = 0;
+
+	if (ret & TCPC_V10_REG_POWER_STATUS_VBUS_PRES)
+		*pwr_status |= TCPC_REG_POWER_STATUS_VBUS_PRES;
+
+#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+	ret = rt5081_i2c_read8(tcpc, RT5081_REG_RT_STATUS);
+	if (ret < 0)
+		return ret;
+
+	if (ret & RT5081_REG_VBUS_80)
+		*pwr_status |= TCPC_REG_POWER_STATUS_EXT_VSAFE0V;
+#endif
+	return 0;
+}
+
+int rt5081_get_fault_status(struct tcpc_device *tcpc, uint8_t *status)
+{
+	int ret;
+
+	ret = rt5081_i2c_read8(tcpc, TCPC_V10_REG_FAULT_STATUS);
+	if (ret < 0)
+		return ret;
+	*status = (uint8_t) ret;
+	return 0;
+}
+
+static int rt5081_get_cc(struct tcpc_device *tcpc, int *cc1, int *cc2)
+{
+	int status, role_ctrl, cc_role;
+	bool act_as_sink, act_as_drp;
+
+	status = rt5081_i2c_read8(tcpc, TCPC_V10_REG_CC_STATUS);
+	if (status < 0)
+		return status;
+
+	role_ctrl = rt5081_i2c_read8(tcpc, TCPC_V10_REG_ROLE_CTRL);
+	if (role_ctrl < 0)
+		return role_ctrl;
+
+	if (status & TCPC_V10_REG_CC_STATUS_DRP_TOGGLING) {
+		*cc1 = TYPEC_CC_DRP_TOGGLING;
+		*cc2 = TYPEC_CC_DRP_TOGGLING;
+		return 0;
+	}
+
+	*cc1 = TCPC_V10_REG_CC_STATUS_CC1(status);
+	*cc2 = TCPC_V10_REG_CC_STATUS_CC2(status);
+
+	act_as_drp = TCPC_V10_REG_ROLE_CTRL_DRP & role_ctrl;
+
+	if (act_as_drp) {
+		act_as_sink = TCPC_V10_REG_CC_STATUS_DRP_RESULT(status);
+	} else {
+		cc_role =  TCPC_V10_REG_CC_STATUS_CC1(role_ctrl);
+		if (cc_role == TYPEC_CC_RP)
+			act_as_sink = false;
+		else
+			act_as_sink = true;
+	}
+
+	/*
+	 * If status is not open, then OR in termination to convert to
+	 * enum tcpc_cc_voltage_status.
+	 */
+
+	if (*cc1 != TYPEC_CC_VOLT_OPEN)
+		*cc1 |= (act_as_sink << 2);
+
+	if (*cc2 != TYPEC_CC_VOLT_OPEN)
+		*cc2 |= (act_as_sink << 2);
+
+	rt5081_init_cc_params(tcpc,
+		(uint8_t)tcpc->typec_polarity ? *cc2 : *cc1);
+
+	return 0;
+}
+
+static int rt5081_set_cc(struct tcpc_device *tcpc, int pull)
+{
+	int ret;
+	uint8_t data;
+	int rp_lvl = TYPEC_CC_PULL_GET_RP_LVL(pull);
+
+	RT5081_INFO("\n");
+	pull = TYPEC_CC_PULL_GET_RES(pull);
+	if (pull == TYPEC_CC_DRP) {
+		data = TCPC_V10_REG_ROLE_CTRL_RES_SET(
+				1, rp_lvl, TYPEC_CC_RD, TYPEC_CC_RD);
+
+		ret = rt5081_i2c_write8(
+			tcpc, TCPC_V10_REG_ROLE_CTRL, data);
+
+		if (ret == 0)
+			ret = rt5081_command(tcpc, TCPM_CMD_LOOK_CONNECTION);
+	} else {
+#ifdef CONFIG_USB_POWER_DELIVERY
+		if (pull == TYPEC_CC_RD && tcpc->pd_wait_pr_swap_complete)
+			rt5081_init_cc_params(tcpc, TYPEC_CC_VOLT_SNK_DFT);
+#endif	/* CONFIG_USB_POWER_DELIVERY */
+		data = TCPC_V10_REG_ROLE_CTRL_RES_SET(0, rp_lvl, pull, pull);
+		ret = rt5081_i2c_write8(tcpc, TCPC_V10_REG_ROLE_CTRL, data);
+	}
+
+	return 0;
+}
+
+static int rt5081_set_polarity(struct tcpc_device *tcpc, int polarity)
+{
+	int data;
+
+	data = rt5081_init_cc_params(tcpc,
+		tcpc->typec_remote_cc[polarity]);
+	if (data)
+		return data;
+
+	data = rt5081_i2c_read8(tcpc, TCPC_V10_REG_TCPC_CTRL);
+	if (data < 0)
+		return data;
+
+	data &= ~TCPC_V10_REG_TCPC_CTRL_PLUG_ORIENT;
+	data |= polarity ? TCPC_V10_REG_TCPC_CTRL_PLUG_ORIENT : 0;
+
+	return rt5081_i2c_write8(tcpc, TCPC_V10_REG_TCPC_CTRL, data);
+}
+
+static int rt5081_set_low_rp_duty(struct tcpc_device *tcpc, bool low_rp)
+{
+	uint16_t duty = low_rp ? TCPC_LOW_RP_DUTY : TCPC_NORMAL_RP_DUTY;
+
+	return rt5081_i2c_write16(tcpc, RT5081_REG_DRP_DUTY_CTRL, duty);
+}
+
+static int rt5081_set_vconn(struct tcpc_device *tcpc, int enable)
+{
+	int rv;
+	int data;
+
+	data = rt5081_i2c_read8(tcpc, TCPC_V10_REG_POWER_CTRL);
+	if (data < 0)
+		return data;
+
+	data &= ~TCPC_V10_REG_POWER_CTRL_VCONN;
+	data |= enable ? TCPC_V10_REG_POWER_CTRL_VCONN : 0;
+
+	rv = rt5081_i2c_write8(tcpc, TCPC_V10_REG_POWER_CTRL, data);
+	if (rv < 0)
+		return rv;
+
+#ifndef CONFIG_TCPC_IDLE_MODE
+	rv = rt5081_i2c_write8(tcpc, RT5081_REG_IDLE_CTRL,
+		RT5081_REG_IDLE_SET(0, 1, enable ? 0 : 1, 2));
+#endif /* CONFIG_TCPC_IDLE_MODE */
+
+	if (enable)
+		rt5081_init_fault_mask(tcpc);
+
+	return rv;
+}
+
+#ifdef CONFIG_TCPC_LOW_POWER_MODE
+static int rt5081_is_low_power_mode(struct tcpc_device *tcpc_dev)
+{
+	int rv = rt5081_i2c_read8(tcpc_dev, RT5081_REG_BMC_CTRL);
+
+	if (rv < 0)
+		return rv;
+
+	return (rv & RT5081_REG_BMCIO_LPEN) != 0;
+}
+
+static int rt5081_set_low_power_mode(
+		struct tcpc_device *tcpc_dev, bool en, int pull)
+{
+	int rv = 0;
+	uint8_t data;
+
+	if (en) {
+		data = RT5081_REG_BMCIO_LPEN;
+
+		if (pull & TYPEC_CC_RP)
+			data |= RT5081_REG_BMCIO_LPRPRD;
+	} else
+		data = RT5081_REG_BMCIO_BG_EN |
+			RT5081_REG_VBUS_DET_EN | RT5081_REG_BMCIO_OSC_EN;
+
+	rv = rt5081_i2c_write8(tcpc_dev, RT5081_REG_BMC_CTRL, data);
+	return rv;
+}
+#endif	/* CONFIG_TCPC_LOW_POWER_MODE */
+
+#ifdef CONFIG_TCPC_WATCHDOG_EN
+int rt5081_set_watchdog(struct tcpc_device *tcpc_dev, bool en)
+{
+	uint8_t data = RT5081_REG_WATCHDOG_CTRL_SET(en, 7);
+
+	return rt5081_i2c_write8(tcpc_dev,
+		RT5081_REG_WATCHDOG_CTRL, data);
+}
+#endif	/* CONFIG_TCPC_WATCHDOG_EN */
+
+#ifdef CONFIG_TCPC_INTRST_EN
+int rt5081_set_intrst(struct tcpc_device *tcpc_dev, bool en)
+{
+	return rt5081_i2c_write8(tcpc_dev,
+		RT5081_REG_INTRST_CTRL, RT5081_REG_INTRST_SET(en, 3));
+}
+#endif	/* CONFIG_TCPC_INTRST_EN */
+
+static int rt5081_tcpc_deinit(struct tcpc_device *tcpc_dev)
+{
+#ifdef CONFIG_TCPC_SHUTDOWN_CC_DETACH
+	rt5081_set_cc(tcpc_dev, TYPEC_CC_DRP);
+	rt5081_set_cc(tcpc_dev, TYPEC_CC_OPEN);
+
+	rt5081_i2c_write8(tcpc_dev,
+		RT5081_REG_I2CRST_CTRL,
+		RT5081_REG_I2CRST_SET(true, 4));
+
+	rt5081_i2c_write8(tcpc_dev,
+		RT5081_REG_INTRST_CTRL,
+		RT5081_REG_INTRST_SET(true, 0));
+#else
+	rt5081_i2c_write8(tcpc_dev, RT5081_REG_SWRESET, 1);
+#endif	/* CONFIG_TCPC_SHUTDOWN_CC_DETACH */
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_POWER_DELIVERY
+static int rt5081_set_msg_header(
+	struct tcpc_device *tcpc, uint8_t power_role, uint8_t data_role)
+{
+	uint8_t msg_hdr = TCPC_V10_REG_MSG_HDR_INFO_SET(
+		data_role, power_role);
+
+	return rt5081_i2c_write8(
+		tcpc, TCPC_V10_REG_MSG_HDR_INFO, msg_hdr);
+}
+
+static int rt5081_protocol_reset(struct tcpc_device *tcpc_dev)
+{
+	rt5081_i2c_write8(tcpc_dev, RT5081_REG_PRL_FSM_RESET, 0);
+	mdelay(1);
+	rt5081_i2c_write8(tcpc_dev, RT5081_REG_PRL_FSM_RESET, 1);
+	return 0;
+}
+
+static int rt5081_set_rx_enable(struct tcpc_device *tcpc, uint8_t enable)
+{
+	int ret = 0;
+
+	if (enable)
+		ret = rt5081_set_clock_gating(tcpc, false);
+
+	if (ret == 0)
+		ret = rt5081_i2c_write8(tcpc, TCPC_V10_REG_RX_DETECT, enable);
+
+	if ((ret == 0) && (!enable))
+		ret = rt5081_set_clock_gating(tcpc, true);
+
+	/* For testing */
+	if (!enable)
+		rt5081_protocol_reset(tcpc);
+	return ret;
+}
+
+static int rt5081_get_message(struct tcpc_device *tcpc, uint32_t *payload,
+			uint16_t *msg_head, enum tcpm_transmit_type *frame_type)
+{
+	struct rt5081_chip *chip = tcpc_get_dev_data(tcpc);
+	int rv;
+	uint8_t type, cnt = 0;
+	uint8_t buf[4];
+	const uint16_t alert_rx =
+		TCPC_V10_REG_ALERT_RX_STATUS|TCPC_V10_REG_RX_OVERFLOW;
+
+	rv = rt5081_block_read(chip->client,
+			TCPC_V10_REG_RX_BYTE_CNT, 4, buf);
+	cnt = buf[0];
+	type = buf[1];
+	*msg_head = *(uint16_t *)&buf[2];
+
+	/* TCPC 1.0 ==> no need to subtract the size of msg_head */
+	if (rv >= 0 && cnt > 3) {
+		cnt -= 3; /* MSG_HDR */
+		rv = rt5081_block_read(chip->client, TCPC_V10_REG_RX_DATA, cnt,
+				(uint8_t *) payload);
+	}
+
+	*frame_type = (enum tcpm_transmit_type) type;
+
+	/* Read complete, clear RX status alert bit */
+	tcpci_alert_status_clear(tcpc, alert_rx);
+
+	/*mdelay(1); */
+	return rv;
+}
+
+static int rt5081_set_bist_carrier_mode(
+	struct tcpc_device *tcpc, uint8_t pattern)
+{
+	/* Don't support this function */
+	return 0;
+}
+
+/* message header (2byte) + data object (7*4) */
+#define RT5081_TRANSMIT_MAX_SIZE	(sizeof(uint16_t) + sizeof(uint32_t)*7)
+
+#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+static int rt5081_retransmit(struct tcpc_device *tcpc)
+{
+	return rt5081_i2c_write8(tcpc, TCPC_V10_REG_TRANSMIT,
+			TCPC_V10_REG_TRANSMIT_SET(
+			tcpc->pd_retry_count, TCPC_TX_SOP));
+}
+#endif
+
+static int rt5081_transmit(struct tcpc_device *tcpc,
+	enum tcpm_transmit_type type, uint16_t header, const uint32_t *data)
+{
+	struct rt5081_chip *chip = tcpc_get_dev_data(tcpc);
+	int rv;
+	int data_cnt, packet_cnt;
+	uint8_t temp[RT5081_TRANSMIT_MAX_SIZE];
+
+	if (type < TCPC_TX_HARD_RESET) {
+		data_cnt = sizeof(uint32_t) * PD_HEADER_CNT(header);
+		packet_cnt = data_cnt + sizeof(uint16_t);
+
+		temp[0] = packet_cnt;
+		memcpy(temp+1, (uint8_t *)&header, 2);
+		if (data_cnt > 0)
+			memcpy(temp+3, (uint8_t *)data, data_cnt);
+
+		rv = rt5081_block_write(chip->client,
+				TCPC_V10_REG_TX_BYTE_CNT,
+				packet_cnt+1, (uint8_t *)temp);
+		if (rv < 0)
+			return rv;
+	}
+
+	rv = rt5081_i2c_write8(tcpc, TCPC_V10_REG_TRANSMIT,
+			TCPC_V10_REG_TRANSMIT_SET(
+			tcpc->pd_retry_count, type));
+	return rv;
+}
+
+static int rt5081_set_bist_test_mode(struct tcpc_device *tcpc, bool en)
+{
+	int data;
+
+	data = rt5081_i2c_read8(tcpc, TCPC_V10_REG_TCPC_CTRL);
+	if (data < 0)
+		return data;
+
+	data &= ~TCPC_V10_REG_TCPC_CTRL_BIST_TEST_MODE;
+	data |= en ? TCPC_V10_REG_TCPC_CTRL_BIST_TEST_MODE : 0;
+
+	return rt5081_i2c_write8(tcpc, TCPC_V10_REG_TCPC_CTRL, data);
+}
+#endif /* CONFIG_USB_POWER_DELIVERY */
+
+static struct tcpc_ops rt5081_tcpc_ops = {
+	.init = rt5081_tcpc_init,
+	.alert_status_clear = rt5081_alert_status_clear,
+	.fault_status_clear = rt5081_fault_status_clear,
+	.get_alert_status = rt5081_get_alert_status,
+	.get_power_status = rt5081_get_power_status,
+	.get_fault_status = rt5081_get_fault_status,
+	.get_cc = rt5081_get_cc,
+	.set_cc = rt5081_set_cc,
+	.set_polarity = rt5081_set_polarity,
+	.set_low_rp_duty = rt5081_set_low_rp_duty,
+	.set_vconn = rt5081_set_vconn,
+	.deinit = rt5081_tcpc_deinit,
+
+#ifdef CONFIG_TCPC_LOW_POWER_MODE
+	.is_low_power_mode = rt5081_is_low_power_mode,
+	.set_low_power_mode = rt5081_set_low_power_mode,
+#endif	/* CONFIG_TCPC_LOW_POWER_MODE */
+
+#ifdef CONFIG_TCPC_WATCHDOG_EN
+	.set_watchdog = rt5081_set_watchdog,
+#endif	/* CONFIG_TCPC_WATCHDOG_EN */
+
+#ifdef CONFIG_TCPC_INTRST_EN
+	.set_intrst = rt5081_set_intrst,
+#endif	/* CONFIG_TCPC_INTRST_EN */
+
+#ifdef CONFIG_USB_POWER_DELIVERY
+	.set_msg_header = rt5081_set_msg_header,
+	.set_rx_enable = rt5081_set_rx_enable,
+	.protocol_reset = rt5081_protocol_reset,
+	.get_message = rt5081_get_message,
+	.transmit = rt5081_transmit,
+	.set_bist_test_mode = rt5081_set_bist_test_mode,
+	.set_bist_carrier_mode = rt5081_set_bist_carrier_mode,
+#endif	/* CONFIG_USB_POWER_DELIVERY */
+
+#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+	.retransmit = rt5081_retransmit,
+#endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
+};
+
+
+static int rt_parse_dt(struct rt5081_chip *chip, struct device *dev)
+{
+	struct device_node *np = dev->of_node;
+	int ret;
+
+	if (!np)
+		return -EINVAL;
+
+	pr_info("%s\n", __func__);
+
+	np = of_find_node_by_name(NULL, "type_c_port0");
+	if (!np) {
+		pr_err("%s find node rt5081 fail\n", __func__);
+		return -ENODEV;
+	}
+
+#if (!defined(CONFIG_MTK_GPIO) || defined(CONFIG_MTK_GPIOLIB_STAND))
+	ret = of_get_named_gpio(np, "rt5081pd,intr_gpio", 0);
+	if (ret < 0) {
+		pr_err("%s no intr_gpio info\n", __func__);
+		return ret;
+	}
+	chip->irq_gpio = ret;
+#else
+	ret = of_property_read_u32(
+		np, "rt5081pd,intr_gpio_num", &chip->irq_gpio);
+	if (ret < 0)
+		pr_err("%s no intr_gpio info\n", __func__);
+#endif
+	return ret;
+}
+
+/*
+ * In some platform pr_info may spend too much time on printing debug message.
+ * So we use this function to test the printk performance.
+ * If your platform cannot not pass this check function, please config
+ * PD_DBG_INFO, this will provide the threaded debug message for you.
+ */
+#if TCPC_ENABLE_ANYMSG
+static void check_printk_performance(void)
+{
+	int i;
+	u64 t1, t2;
+	u32 nsrem;
+
+#ifdef CONFIG_PD_DBG_INFO
+	for (i = 0; i < 10; i++) {
+		t1 = local_clock();
+		pd_dbg_info("%d\n", i);
+		t2 = local_clock();
+		t2 -= t1;
+		nsrem = do_div(t2, 1000000000);
+		pd_dbg_info("pd_dbg_info : t2-t1 = %lu\n",
+				(unsigned long)nsrem / 1000);
+	}
+	for (i = 0; i < 10; i++) {
+		t1 = local_clock();
+		pr_info("%d\n", i);
+		t2 = local_clock();
+		t2 -= t1;
+		nsrem = do_div(t2, 1000000000);
+		pr_info("pr_info : t2-t1 = %lu\n",
+				(unsigned long)nsrem / 1000);
+	}
+#else
+	for (i = 0; i < 10; i++) {
+		t1 = local_clock();
+		pr_info("%d\n", i);
+		t2 = local_clock();
+		t2 -= t1;
+		nsrem = do_div(t2, 1000000000);
+		pr_info("t2-t1 = %lu\n",
+				(unsigned long)nsrem /  1000);
+		PD_BUG_ON(nsrem > 100*1000);
+	}
+#endif /* CONFIG_PD_DBG_INFO */
+}
+#endif /* TCPC_ENABLE_ANYMSG */
+
+static int rt5081_tcpcdev_init(struct rt5081_chip *chip, struct device *dev)
+{
+	struct tcpc_desc *desc;
+	struct device_node *np;
+	u32 val, len;
+	const char *name = "default";
+	bool kpoc_boot = false;
+
+	np = of_find_node_by_name(NULL, "type_c_port0");
+	if (!np) {
+		pr_err("%s find node rt5081 fail\n", __func__);
+		return -ENODEV;
+	}
+
+	desc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);
+	if (!desc)
+		return -ENOMEM;
+
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+	if (get_boot_mode() == KERNEL_POWER_OFF_CHARGING_BOOT
+		|| get_boot_mode() == LOW_POWER_OFF_CHARGING_BOOT)
+		kpoc_boot = true;
+#endif /* CONFIG_MTK_KERNEL_POWER_OFF_CHARGING */
+
+	if (kpoc_boot) {
+		dev_info(dev, "%s KPOC use default Role SNK\n", __func__);
+		desc->role_def = 0; /* SNK */
+	} else if (of_property_read_u32(np, "rt-tcpc,role_def", &val) >= 0) {
+		if (val >= TYPEC_ROLE_NR)
+			desc->role_def = TYPEC_ROLE_DRP;
+		else
+			desc->role_def = val;
+	} else {
+		dev_info(dev, "use default Role DRP\n");
+		desc->role_def = TYPEC_ROLE_DRP;
+	}
+
+	if (of_property_read_u32(
+		np, "rt-tcpc,notifier_supply_num", &val) >= 0) {
+		if (val < 0)
+			desc->notifier_supply_num = 0;
+		else
+			desc->notifier_supply_num = val;
+	} else
+		desc->notifier_supply_num = 0;
+
+	if (of_property_read_u32(np, "rt-tcpc,rp_level", &val) >= 0) {
+		switch (val) {
+		case 0: /* RP Default */
+			desc->rp_lvl = TYPEC_CC_RP_DFT;
+			break;
+		case 1: /* RP 1.5V */
+			desc->rp_lvl = TYPEC_CC_RP_1_5;
+			break;
+		case 2: /* RP 3.0V */
+			desc->rp_lvl = TYPEC_CC_RP_3_0;
+			break;
+		default:
+			break;
+		}
+	}
+
+#ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
+	if (of_property_read_u32(np, "rt-tcpc,vconn_supply", &val) >= 0) {
+		if (val >= TCPC_VCONN_SUPPLY_NR)
+			desc->vconn_supply = TCPC_VCONN_SUPPLY_ALWAYS;
+		else
+			desc->vconn_supply = val;
+	} else {
+		dev_info(dev, "use default VconnSupply\n");
+		desc->vconn_supply = TCPC_VCONN_SUPPLY_ALWAYS;
+	}
+#endif	/* CONFIG_TCPC_VCONN_SUPPLY_MODE */
+
+	of_property_read_string(np, "rt-tcpc,name", (char const **)&name);
+
+	len = strlen(name);
+	desc->name = kzalloc(len+1, GFP_KERNEL);
+	if (!desc->name)
+		return -ENOMEM;
+
+	strlcpy((char *)desc->name, name, strlen(name)+1);
+
+	chip->tcpc_desc = desc;
+
+	chip->tcpc = tcpc_device_register(dev,
+			desc, &rt5081_tcpc_ops, chip);
+	if (IS_ERR(chip->tcpc))
+		return -EINVAL;
+
+	chip->tcpc->tcpc_flags =
+		TCPC_FLAGS_LPM_WAKEUP_WATCHDOG |
+		TCPC_FLAGS_RETRY_CRC_DISCARD;
+
+#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+	chip->tcpc->tcpc_flags |= TCPC_FLAGS_RETRY_CRC_DISCARD;
+#endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
+
+#ifdef CONFIG_USB_PD_REV30
+	chip->tcpc->tcpc_flags |= TCPC_FLAGS_PD_REV30;
+
+	if (chip->tcpc->tcpc_flags & TCPC_FLAGS_PD_REV30)
+		dev_info(dev, "PD_REV30\n");
+	else
+		dev_info(dev, "PD_REV20\n");
+#endif	/* CONFIG_USB_PD_REV30 */
+#ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
+	if (kpoc_boot)
+		chip->tcpc->tcpc_flags |= TCPC_FLAGS_KPOC_BOOT;
+#endif /* CONFIG_MTK_KERNEL_POWER_OFF_CHARGING */
+	return 0;
+}
+
+#define MEDIATEK_5081_VID	0x29cf
+#define MEDIATEK_5081_PID	0x5081
+
+static inline int rt5081_check_revision(struct i2c_client *client)
+{
+	u16 vid, pid, did;
+	int ret;
+	u8 data = 1;
+
+	ret = rt5081_read_device(client, TCPC_V10_REG_VID, 2, &vid);
+	if (ret < 0) {
+		dev_err(&client->dev, "read chip ID fail\n");
+		return -EIO;
+	}
+
+	if (vid != MEDIATEK_5081_VID) {
+		pr_info("%s failed, VID=0x%04x\n", __func__, vid);
+		return -ENODEV;
+	}
+
+	ret = rt5081_read_device(client, TCPC_V10_REG_PID, 2, &pid);
+	if (ret < 0) {
+		dev_err(&client->dev, "read product ID fail\n");
+		return -EIO;
+	}
+
+	if (pid != MEDIATEK_5081_PID) {
+		pr_info("%s failed, PID=0x%04x\n", __func__, pid);
+		return -ENODEV;
+	}
+
+	ret = rt5081_write_device(client, RT5081_REG_SWRESET, 1, &data);
+	if (ret < 0)
+		return ret;
+
+	usleep_range(1000, 2000);
+
+	ret = rt5081_read_device(client, TCPC_V10_REG_DID, 2, &did);
+	if (ret < 0) {
+		dev_err(&client->dev, "read device ID fail\n");
+		return -EIO;
+	}
+
+	return did;
+}
+
+static int rt5081_i2c_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	struct rt5081_chip *chip;
+	int ret = 0, chip_id;
+	bool use_dt = client->dev.of_node;
+
+	pr_info("%s\n", __func__);
+	if (i2c_check_functionality(client->adapter,
+			I2C_FUNC_SMBUS_I2C_BLOCK | I2C_FUNC_SMBUS_BYTE_DATA))
+		pr_info("I2C functionality : OK...\n");
+	else
+		pr_info("I2C functionality check : failuare...\n");
+
+	chip_id = rt5081_check_revision(client);
+	if (chip_id < 0)
+		return chip_id;
+
+#if TCPC_ENABLE_ANYMSG
+	check_printk_performance();
+#endif /* TCPC_ENABLE_ANYMSG */
+
+	chip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	if (use_dt)
+		rt_parse_dt(chip, &client->dev);
+	else {
+		dev_err(&client->dev, "no dts node\n");
+		return -ENODEV;
+	}
+	chip->dev = &client->dev;
+	chip->client = client;
+	sema_init(&chip->io_lock, 1);
+	sema_init(&chip->suspend_lock, 1);
+	i2c_set_clientdata(client, chip);
+	INIT_DELAYED_WORK(&chip->poll_work, rt5081_poll_work);
+	wakeup_source_init(&chip->irq_wake_lock,
+		"rt5081_irq_wakelock");
+
+	chip->chip_id = chip_id;
+	pr_info("rt5081_chipID = 0x%0x\n", chip_id);
+
+	ret = rt5081_regmap_init(chip);
+	if (ret < 0) {
+		dev_err(chip->dev, "rt5081 regmap init fail\n");
+		return -EINVAL;
+	}
+
+	ret = rt5081_tcpcdev_init(chip, &client->dev);
+	if (ret < 0) {
+		dev_err(&client->dev, "rt5081 tcpc dev init fail\n");
+		goto err_tcpc_reg;
+	}
+
+	ret = rt5081_init_alert(chip->tcpc);
+	if (ret < 0) {
+		pr_err("rt5081 init alert fail\n");
+		goto err_irq_init;
+	}
+
+	tcpc_schedule_init_work(chip->tcpc);
+	pr_info("%s probe OK!\n", __func__);
+	return 0;
+
+err_irq_init:
+	tcpc_device_unregister(chip->dev, chip->tcpc);
+err_tcpc_reg:
+	rt5081_regmap_deinit(chip);
+	return ret;
+}
+
+static int rt5081_i2c_remove(struct i2c_client *client)
+{
+	struct rt5081_chip *chip = i2c_get_clientdata(client);
+
+	if (chip) {
+		cancel_delayed_work_sync(&chip->poll_work);
+
+		tcpc_device_unregister(chip->dev, chip->tcpc);
+		rt5081_regmap_deinit(chip);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int rt5081_i2c_suspend(struct device *dev)
+{
+	struct rt5081_chip *chip;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (client) {
+		chip = i2c_get_clientdata(client);
+		if (chip)
+			down(&chip->suspend_lock);
+	}
+
+	return 0;
+}
+
+static int rt5081_i2c_resume(struct device *dev)
+{
+	struct rt5081_chip *chip;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (client) {
+		chip = i2c_get_clientdata(client);
+		if (chip)
+			up(&chip->suspend_lock);
+	}
+
+	return 0;
+}
+
+static void rt5081_shutdown(struct i2c_client *client)
+{
+	struct rt5081_chip *chip = i2c_get_clientdata(client);
+
+	/* Please reset IC here */
+	if (chip != NULL) {
+		if (chip->irq)
+			disable_irq(chip->irq);
+		tcpm_shutdown(chip->tcpc);
+	} else {
+		i2c_smbus_write_byte_data(
+			client, RT5081_REG_SWRESET, 0x01);
+	}
+}
+
+#ifdef CONFIG_PM_RUNTIME
+static int rt5081_pm_suspend_runtime(struct device *device)
+{
+	dev_dbg(device, "pm_runtime: suspending...\n");
+	return 0;
+}
+
+static int rt5081_pm_resume_runtime(struct device *device)
+{
+	dev_dbg(device, "pm_runtime: resuming...\n");
+	return 0;
+}
+#endif /* CONFIG_PM_RUNTIME */
+
+
+static const struct dev_pm_ops rt5081_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(
+			rt5081_i2c_suspend,
+			rt5081_i2c_resume)
+#ifdef CONFIG_PM_RUNTIME
+	SET_RUNTIME_PM_OPS(
+		rt5081_pm_suspend_runtime,
+		rt5081_pm_resume_runtime,
+		NULL
+	)
+#endif /* CONFIG_PM_RUNTIME */
+};
+#define RT5081_PM_OPS	(&rt5081_pm_ops)
+#else
+#define RT5081_PM_OPS	(NULL)
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id rt5081_id_table[] = {
+	{"rt5081", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, rt5081_id_table);
+
+static const struct of_device_id rt_match_table[] = {
+	{.compatible = "mediatek,usb_type_c",},
+	{},
+};
+
+static struct i2c_driver rt5081_driver = {
+	.driver = {
+		.name = "usb_type_c",
+		.owner = THIS_MODULE,
+		.of_match_table = rt_match_table,
+		.pm = RT5081_PM_OPS,
+	},
+	.probe = rt5081_i2c_probe,
+	.remove = rt5081_i2c_remove,
+	.shutdown = rt5081_shutdown,
+	.id_table = rt5081_id_table,
+};
+
+static int __init rt5081_init(void)
+{
+	struct device_node *np;
+
+	pr_info("rt5081h_init (%s): initializing...\n", RT5081_DRV_VERSION);
+	np = of_find_node_by_name(NULL, "usb_type_c");
+	if (np != NULL)
+		pr_info("usb_type_c node found...\n");
+	else
+		pr_info("usb_type_c node not found...\n");
+
+	return i2c_add_driver(&rt5081_driver);
+}
+subsys_initcall(rt5081_init);
+
+static void __exit rt5081_exit(void)
+{
+	i2c_del_driver(&rt5081_driver);
+}
+module_exit(rt5081_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("RT5081 TCPC Driver");
+MODULE_VERSION(RT5081_DRV_VERSION);
+
+/**** Release Note ****
+ * 2.0.1_MTK
+ *	First released PD3.0 Driver on MTK platform
+ */
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpci.c b/drivers/misc/mediatek/typec/tcpc/tcpci.c
index 115d6c7..f612cd8 100644
--- a/drivers/misc/mediatek/typec/tcpc/tcpci.c
+++ b/drivers/misc/mediatek/typec/tcpc/tcpci.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2017 MediaTek Inc.
+ * Copyright (C) 2019 XiaoMi, Inc.
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -13,61 +14,9 @@
 
 #include "inc/tcpci.h"
 #include <linux/time.h>
-#include <linux/slab.h>
 
 #define TCPC_NOTIFY_OVERTIME	(20) /* ms */
 
-#ifdef CONFIG_TCPC_NOTIFICATION_NON_BLOCKING
-struct tcp_notify_work {
-	struct work_struct work;
-	struct tcpc_device *tcpc;
-	struct tcp_notify tcp_noti;
-	uint8_t type;
-	uint8_t state;
-};
-
-static void tcp_notify_func(struct work_struct *work)
-{
-	struct tcp_notify_work *tn_work =
-		container_of(work, struct tcp_notify_work, work);
-	struct tcpc_device *tcpc = tn_work->tcpc;
-	struct tcp_notify *tcp_noti = &tn_work->tcp_noti;
-	uint8_t type = tn_work->type;
-	uint8_t state = tn_work->state;
-#ifdef CONFIG_PD_BEGUG_ON
-	struct timeval begin, end;
-	int timeval = 0;
-
-	do_gettimeofday(&begin);
-	srcu_notifier_call_chain(&tcpc->evt_nh[type], state, tcp_noti);
-	do_gettimeofday(&end);
-	timeval = (timeval_to_ns(end) - timeval_to_ns(begin))/1000/1000;
-	PD_BUG_ON(timeval > TCPC_NOTIFY_OVERTIME);
-#else
-	srcu_notifier_call_chain(&tcpc->evt_nh[type], state, tcp_noti);
-#endif
-
-	kfree(tn_work);
-}
-
-static int tcpc_check_notify_time(struct tcpc_device *tcpc,
-	struct tcp_notify *tcp_noti, uint8_t type, uint8_t state)
-{
-	struct tcp_notify_work *tn_work;
-
-	tn_work = kzalloc(sizeof(*tn_work), GFP_KERNEL);
-	if (!tn_work)
-		return -ENOMEM;
-
-	INIT_WORK(&tn_work->work, tcp_notify_func);
-	tn_work->tcpc = tcpc;
-	tn_work->tcp_noti = *tcp_noti;
-	tn_work->type = type;
-	tn_work->state = state;
-
-	return queue_work(tcpc->evt_wq, &tn_work->work) ? 0 : -EAGAIN;
-}
-#else
 static int tcpc_check_notify_time(struct tcpc_device *tcpc,
 	struct tcp_notify *tcp_noti, uint8_t type, uint8_t state)
 {
@@ -86,7 +35,6 @@ static int tcpc_check_notify_time(struct tcpc_device *tcpc,
 #endif
 	return ret;
 }
-#endif /* CONFIG_TCPC_NOTIFICATION_BLOCKING */
 
 int tcpci_check_vbus_valid_from_ic(struct tcpc_device *tcpc)
 {
@@ -95,7 +43,7 @@ int tcpci_check_vbus_valid_from_ic(struct tcpc_device *tcpc)
 
 	if (tcpci_get_power_status(tcpc, &power_status) == 0) {
 		if (vbus_level != tcpc->vbus_level) {
-			TCPC_INFO("[Warning] ps_changed %d -> %d\n",
+			TCPC_INFO("[Warning] ps_chagned %d ->%d\r\n",
 				vbus_level, tcpc->vbus_level);
 		}
 	}
@@ -133,16 +81,6 @@ int tcpci_fault_status_clear(
 	return tcpc->ops->fault_status_clear(tcpc, status);
 }
 
-int tcpci_set_alert_mask(struct tcpc_device *tcpc, uint32_t mask)
-{
-	int rv = 0;
-
-	if (tcpc->ops->set_alert_mask)
-		return tcpc->ops->set_alert_mask(tcpc, mask);
-
-	return rv;
-}
-
 int tcpci_get_alert_mask(
 	struct tcpc_device *tcpc, uint32_t *mask)
 {
@@ -200,9 +138,9 @@ int tcpci_init(struct tcpc_device *tcpc, bool sw_reset)
 
 int tcpci_init_alert_mask(struct tcpc_device *tcpc)
 {
-	if (tcpc->ops->init_alert_mask)
-		return tcpc->ops->init_alert_mask(tcpc);
-	return 0;
+	PD_BUG_ON(tcpc->ops->init_alert_mask == NULL);
+
+	return tcpc->ops->init_alert_mask(tcpc);
 }
 
 int tcpci_get_cc(struct tcpc_device *tcpc)
@@ -229,11 +167,12 @@ int tcpci_get_cc(struct tcpc_device *tcpc)
 
 int tcpci_set_cc(struct tcpc_device *tcpc, int pull)
 {
-#ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
-#ifdef CONFIG_TYPEC_LEGACY3_ALWAYS_LOCAL_RP
-	uint8_t rp_lvl = TYPEC_RP_DFT, res = TYPEC_CC_DRP;
-#endif /* CONFIG_TYPEC_LEGACY3_ALWAYS_LOCAL_RP */
-#endif /* CONFIG_TYPEC_CHECK_LEGACY_CABLE */
+	PD_BUG_ON(tcpc->ops->set_cc == NULL);
+
+#ifdef CONFIG_USB_PD_DBG_ALWAYS_LOCAL_RP
+	if (pull == TYPEC_CC_RP)
+		pull = tcpc->typec_local_rp_level;
+#endif /* CONFIG_USB_PD_DBG_ALWAYS_LOCAL_RP */
 
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
 	if (pull == TYPEC_CC_DRP && tcpc->typec_legacy_cable) {
@@ -245,18 +184,18 @@ int tcpci_set_cc(struct tcpc_device *tcpc, int pull)
 		else
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE2 */
 			pull = TYPEC_CC_RP_1_5;
-		TCPC_DBG2("LC->Toggling (%d)\n", pull);
-	} else if (!tcpc->typec_legacy_cable) {
-#ifdef CONFIG_TYPEC_LEGACY3_ALWAYS_LOCAL_RP
-		rp_lvl = TYPEC_CC_PULL_GET_RP_LVL(pull);
-		res = TYPEC_CC_PULL_GET_RES(pull);
-		pull = TYPEC_CC_PULL(rp_lvl == TYPEC_RP_DFT ?
-			tcpc->typec_local_rp_level : rp_lvl, res);
-#endif /* CONFIG_TYPEC_LEGACY3_ALWAYS_LOCAL_RP */
+		TCPC_DBG2("LC->Toggling (%d)\r\n", pull);
 	}
 #endif /* CONFIG_TYPEC_CHECK_LEGACY_CABLE */
 
-	return __tcpci_set_cc(tcpc, pull);
+	if (pull & TYPEC_CC_DRP) {
+		tcpc->typec_remote_cc[0] =
+		tcpc->typec_remote_cc[1] =
+			TYPEC_CC_DRP_TOGGLING;
+	}
+
+	tcpc->typec_local_cc = pull;
+	return tcpc->ops->set_cc(tcpc, pull);
 }
 
 int tcpci_set_polarity(struct tcpc_device *tcpc, int polarity)
@@ -270,7 +209,7 @@ int tcpci_set_low_rp_duty(struct tcpc_device *tcpc, bool low_rp)
 {
 #ifdef CONFIG_TYPEC_CAP_LOW_RP_DUTY
 	if (low_rp)
-		TCPC_INFO("low_rp_duty\n");
+		TCPC_INFO("low_rp_duty\r\n");
 
 	if (tcpc->ops->set_low_rp_duty)
 		return tcpc->ops->set_low_rp_duty(tcpc, low_rp);
@@ -325,13 +264,49 @@ int tcpci_set_low_power_mode(
 	return rv;
 }
 
+int tcpci_idle_poll_ctrl(
+	struct tcpc_device *tcpc, bool en, bool lock)
+{
+	int rv = 0;
+
+#ifdef CONFIG_TCPC_IDLE_MODE
+	bool update_mode = false;
+
+	if (lock)
+		mutex_lock(&tcpc->access_lock);
+
+	if (en) {
+		if (tcpc->tcpc_busy_cnt == 0)
+			update_mode = true;
+		tcpc->tcpc_busy_cnt++;
+	} else {	/* idle mode */
+		if (tcpc->tcpc_busy_cnt <= 0)
+			TCPC_DBG2("tcpc_busy_cnt<=0\r\n");
+		else
+			tcpc->tcpc_busy_cnt--;
+
+		if (tcpc->tcpc_busy_cnt == 0)
+			update_mode = true;
+	}
+
+	if (lock)
+		mutex_unlock(&tcpc->access_lock);
+
+	if (update_mode && tcpc->ops->set_idle_mode)
+		rv = tcpc->ops->set_idle_mode(tcpc, !en);
+#endif
+
+	return rv;
+}
+
 int tcpci_set_watchdog(struct tcpc_device *tcpc, bool en)
 {
 	int rv = 0;
 
-	if (tcpc->tcpc_flags & TCPC_FLAGS_WATCHDOG_EN)
+	if (tcpc->tcpc_flags & TCPC_FLAGS_WATCHDOG_EN) {
 		if (tcpc->ops->set_watchdog)
 			rv = tcpc->ops->set_watchdog(tcpc, en);
+	}
 
 	return rv;
 }
@@ -401,6 +376,25 @@ int tcpci_notify_cable_type(struct tcpc_device *tcpc)
 }
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
 
+int tcpci_notify_ra_detect(struct tcpc_device *tcpc)
+{
+	struct tcp_notify tcp_noti;
+
+	tcp_noti.ra_detect.detected = tcpc->ra_detected;
+	return tcpc_check_notify_time(tcpc, &tcp_noti, TCP_NOTIFY_IDX_MISC,
+				      TCP_NOTIFY_RA_DETECT);
+}
+#ifdef CONFIG_TYPEC_OTP
+int tcpci_notify_typec_otp(struct tcpc_device *tcpc)
+{
+	struct tcp_notify tcp_noti;
+
+	tcp_noti.typec_otp.otp = tcpc->typec_otp;
+	return tcpc_check_notify_time(tcpc, &tcp_noti, TCP_NOTIFY_IDX_MISC,
+				      TCP_NOTIFY_TYPEC_OTP);
+}
+#endif /* CONFIG_TYPEC_OTP */
+
 #ifdef CONFIG_USB_POWER_DELIVERY
 
 int tcpci_set_msg_header(struct tcpc_device *tcpc,
@@ -479,7 +473,6 @@ int tcpci_notify_typec_state(struct tcpc_device *tcpc)
 	tcp_noti.typec_state.old_state = tcpc->typec_attach_old;
 	tcp_noti.typec_state.new_state = tcpc->typec_attach_new;
 	tcp_noti.typec_state.rp_level = tcpc->typec_remote_rp_level;
-	tcp_noti.typec_state.local_rp_level = tcpc->typec_local_rp_level;
 
 	ret = tcpc_check_notify_time(tcpc, &tcp_noti,
 		TCP_NOTIFY_IDX_USB, TCP_NOTIFY_TYPEC_STATE);
@@ -524,7 +517,7 @@ int tcpci_enable_watchdog(struct tcpc_device *tcpc, bool en)
 	if (!(tcpc->tcpc_flags & TCPC_FLAGS_WATCHDOG_EN))
 		return 0;
 
-	TCPC_DBG2("enable_WG: %d\n", en);
+	TCPC_DBG2("enable_WG: %d\r\n", en);
 
 	if (tcpc->typec_watchdog == en)
 		return 0;
@@ -560,14 +553,14 @@ int tcpci_source_vbus(
 	if (ma < 0) {
 		if (mv != 0) {
 			switch (tcpc->typec_local_rp_level) {
-			case TYPEC_RP_3_0:
-				ma = 3000;
-				break;
-			case TYPEC_RP_1_5:
+			case TYPEC_CC_RP_1_5:
 				ma = 1500;
 				break;
-			case TYPEC_RP_DFT:
+			case TYPEC_CC_RP_3_0:
+				ma = 3000;
+				break;
 			default:
+			case TYPEC_CC_RP_DFT:
 				ma = CONFIG_TYPEC_SRC_CURR_DFT;
 				break;
 			}
@@ -580,7 +573,7 @@ int tcpci_source_vbus(
 	tcp_noti.vbus_state.type = type;
 
 	tcpci_enable_watchdog(tcpc, mv != 0);
-	TCPC_DBG("source_vbus: %d mV, %d mA\n", mv, ma);
+	TCPC_DBG("source_vbus: %d mV, %d mA\r\n", mv, ma);
 	ret = tcpc_check_notify_time(tcpc, &tcp_noti,
 		TCP_NOTIFY_IDX_VBUS, TCP_NOTIFY_SOURCE_VBUS);
 	return ret;
@@ -624,7 +617,7 @@ int tcpci_sink_vbus(
 	tcp_noti.vbus_state.mv = mv;
 	tcp_noti.vbus_state.type = type;
 
-	TCPC_DBG("sink_vbus: %d mV, %d mA\n", mv, ma);
+	TCPC_DBG("sink_vbus: %d mV, %d mA\r\n", mv, ma);
 	ret = tcpc_check_notify_time(tcpc, &tcp_noti,
 		TCP_NOTIFY_IDX_VBUS, TCP_NOTIFY_SINK_VBUS);
 	return ret;
@@ -636,7 +629,7 @@ int tcpci_disable_vbus_control(struct tcpc_device *tcpc)
 	struct tcp_notify tcp_noti;
 	int ret;
 
-	TCPC_DBG("disable_vbus\n");
+	TCPC_DBG("disable_vbus\r\n");
 	tcpci_enable_watchdog(tcpc, false);
 
 	ret = tcpc_check_notify_time(tcpc, &tcp_noti,
@@ -678,6 +671,29 @@ int tcpci_notify_attachwait_state(struct tcpc_device *tcpc, bool as_sink)
 
 }
 
+int tcpci_enable_ext_discharge(struct tcpc_device *tcpc, bool en)
+{
+	int ret = 0;
+
+#ifdef CONFIG_TCPC_EXT_DISCHARGE
+	struct tcp_notify tcp_noti;
+
+	mutex_lock(&tcpc->access_lock);
+
+	if (tcpc->typec_ext_discharge != en) {
+		tcpc->typec_ext_discharge = en;
+		tcp_noti.en_state.en = en;
+		TCPC_DBG("EXT-Discharge: %d\r\n", en);
+		ret = tcpc_check_notify_time(tcpc, &tcp_noti,
+			TCP_NOTIFY_IDX_VBUS, TCP_NOTIFY_EXT_DISCHARGE);
+	}
+
+	mutex_unlock(&tcpc->access_lock);
+#endif	/* CONFIG_TCPC_EXT_DISCHARGE */
+
+	return ret;
+}
+
 int tcpci_enable_auto_discharge(struct tcpc_device *tcpc, bool en)
 {
 	int ret = 0;
@@ -695,51 +711,42 @@ int tcpci_enable_auto_discharge(struct tcpc_device *tcpc, bool en)
 	return ret;
 }
 
-static int __tcpci_enable_force_discharge(
-	struct tcpc_device *tcpc, bool en, int mv)
+int tcpci_enable_force_discharge(struct tcpc_device *tcpc, int mv)
 {
 	int ret = 0;
 
 #ifdef CONFIG_TYPEC_CAP_FORCE_DISCHARGE
 #ifdef CONFIG_TCPC_FORCE_DISCHARGE_IC
-	if (tcpc->pd_force_discharge != en) {
-		tcpc->pd_force_discharge = en;
+	if (!tcpc->pd_force_discharge) {
+		tcpc->pd_force_discharge = true;
 		if (tcpc->ops->set_force_discharge)
-			ret = tcpc->ops->set_force_discharge(tcpc, en, mv);
+			ret = tcpc->ops->set_force_discharge(tcpc, true, mv);
 	}
 #endif	/* CONFIG_TCPC_FORCE_DISCHARGE_IC */
+
+#ifdef CONFIG_TCPC_FORCE_DISCHARGE_EXT
+	ret = tcpci_enable_ext_discharge(tcpc, true);
+#endif	/* CONFIG_TCPC_FORCE_DISCHARGE_EXT */
 #endif	/* CONFIG_TYPEC_CAP_FORCE_DISCHARGE */
 
 	return ret;
 }
 
-static int __tcpci_enable_ext_discharge(struct tcpc_device *tcpc, bool en)
+int tcpci_disable_force_discharge(struct tcpc_device *tcpc)
 {
 	int ret = 0;
 
-#ifdef CONFIG_TCPC_EXT_DISCHARGE
-	struct tcp_notify tcp_noti;
-
-	if (tcpc->typec_ext_discharge != en) {
-		tcpc->typec_ext_discharge = en;
-		tcp_noti.en_state.en = en;
-		TCPC_DBG("EXT-Discharge: %d\n", en);
-		ret = tcpc_check_notify_time(tcpc, &tcp_noti,
-			TCP_NOTIFY_IDX_VBUS, TCP_NOTIFY_EXT_DISCHARGE);
+#ifdef CONFIG_TYPEC_CAP_FORCE_DISCHARGE
+#ifdef CONFIG_TCPC_FORCE_DISCHARGE_IC
+	if (tcpc->pd_force_discharge) {
+		tcpc->pd_force_discharge = false;
+		if (tcpc->ops->set_force_discharge)
+			ret = tcpc->ops->set_force_discharge(tcpc, false, 0);
 	}
-#endif	/* CONFIG_TCPC_EXT_DISCHARGE */
-
-	return ret;
-}
-
-int tcpci_enable_force_discharge(struct tcpc_device *tcpc, bool en, int mv)
-{
-	int ret = 0;
+#endif	/* CONFIG_TCPC_FORCE_DISCHARGE_IC */
 
-#ifdef CONFIG_TYPEC_CAP_FORCE_DISCHARGE
-	ret = __tcpci_enable_force_discharge(tcpc, en, mv);
 #ifdef CONFIG_TCPC_FORCE_DISCHARGE_EXT
-	ret = __tcpci_enable_ext_discharge(tcpc, en);
+	ret = tcpci_enable_ext_discharge(tcpc, false);
 #endif	/* CONFIG_TCPC_FORCE_DISCHARGE_EXT */
 #endif	/* CONFIG_TYPEC_CAP_FORCE_DISCHARGE */
 
@@ -816,7 +823,7 @@ int tcpci_report_hpd_state(struct tcpc_device *tcpc, uint32_t dp_status)
 
 int tcpci_dp_status_update(struct tcpc_device *tcpc, uint32_t dp_status)
 {
-	DP_INFO("Status0: 0x%x\n", dp_status);
+	DP_INFO("Status0: 0x%x\r\n", dp_status);
 	tcpci_report_hpd_state(tcpc, dp_status);
 	return 0;
 }
@@ -826,26 +833,22 @@ int tcpci_dp_configure(struct tcpc_device *tcpc, uint32_t dp_config)
 	struct tcp_notify tcp_noti;
 	int ret;
 
-	DP_INFO("LocalCFG: 0x%x\n", dp_config);
+	DP_INFO("LocalCFG: 0x%x\r\n", dp_config);
 
 	switch (dp_config & 0x03) {
 	case 0:
 		tcp_noti.ama_dp_state.sel_config = SW_USB;
 		break;
 	case MODE_DP_SNK:
-		tcp_noti.ama_dp_state.sel_config = SW_DFP_D;
-		tcp_noti.ama_dp_state.pin_assignment = (dp_config >> 8) & 0xff;
-		break;
-	case MODE_DP_SRC:
 		tcp_noti.ama_dp_state.sel_config = SW_UFP_D;
 		tcp_noti.ama_dp_state.pin_assignment = (dp_config >> 16) & 0xff;
 		break;
+	case MODE_DP_SRC:
+		tcp_noti.ama_dp_state.sel_config = SW_DFP_D;
+		tcp_noti.ama_dp_state.pin_assignment = (dp_config >> 8) & 0xff;
+		break;
 	}
-	if (tcp_noti.ama_dp_state.pin_assignment == 0)
-		tcp_noti.ama_dp_state.pin_assignment = (dp_config >> 16) & 0xff;
 
-	DP_INFO("pin assignment: 0x%x\n",
-		tcp_noti.ama_dp_state.pin_assignment);
 	tcp_noti.ama_dp_state.signal = (dp_config >> 2) & 0x0f;
 	tcp_noti.ama_dp_state.polarity = tcpc->typec_polarity;
 	tcp_noti.ama_dp_state.active = 1;
@@ -859,7 +862,7 @@ int tcpci_dp_attention(struct tcpc_device *tcpc, uint32_t dp_status)
 	/* DFP_U : Not call this function during internal flow */
 	struct tcp_notify tcp_noti;
 
-	DP_INFO("Attention: 0x%x\n", dp_status);
+	DP_INFO("Attention: 0x%x\r\n", dp_status);
 	tcp_noti.ama_dp_attention.state = (uint8_t) dp_status;
 	tcpc_check_notify_time(tcpc, &tcp_noti,
 		TCP_NOTIFY_IDX_MODE, TCP_NOTIFY_AMA_DP_ATTENTION);
@@ -870,7 +873,7 @@ int tcpci_dp_notify_status_update_done(
 	struct tcpc_device *tcpc, uint32_t dp_status, bool ack)
 {
 	/* DFP_U : Not call this function during internal flow */
-	DP_INFO("Status1: 0x%x, ack=%d\n", dp_status, ack);
+	DP_INFO("Status1: 0x%x, ack=%d\r\n", dp_status, ack);
 	return 0;
 }
 
@@ -879,7 +882,7 @@ int tcpci_dp_notify_config_start(struct tcpc_device *tcpc)
 	/* DFP_U : Put signal & mux into the Safe State */
 	struct tcp_notify tcp_noti;
 
-	DP_INFO("ConfigStart\n");
+	DP_INFO("ConfigStart\r\n");
 	tcp_noti.ama_dp_state.sel_config = SW_USB;
 	tcp_noti.ama_dp_state.active = 0;
 	tcpc_check_notify_time(tcpc, &tcp_noti,
@@ -893,7 +896,7 @@ int tcpci_dp_notify_config_done(struct tcpc_device *tcpc,
 	/* DFP_U : If DP success,
 	 * internal flow will enter this function finally
 	 */
-	DP_INFO("ConfigDone, L:0x%x, R:0x%x, ack=%d\n",
+	DP_INFO("ConfigDone, L:0x%x, R:0x%x, ack=%d\r\n",
 		local_cfg, remote_cfg, ack);
 
 	if (ack)
@@ -930,7 +933,7 @@ int tcpci_dc_notify_en_unlock(struct tcpc_device *tcpc)
 	struct tcp_notify tcp_noti;
 	int ret;
 
-	DC_INFO("DirectCharge en_unlock\n");
+	DC_INFO("DirectCharge en_unlock\r\n");
 	ret = tcpc_check_notify_time(tcpc, &tcp_noti,
 		TCP_NOTIFY_IDX_MODE, TCP_NOTIFY_DC_EN_UNLOCK);
 	return ret;
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpci_alert.c b/drivers/misc/mediatek/typec/tcpc/tcpci_alert.c
index aa58760..4a940a2 100644
--- a/drivers/misc/mediatek/typec/tcpc/tcpci_alert.c
+++ b/drivers/misc/mediatek/typec/tcpc/tcpci_alert.c
@@ -1,14 +1,16 @@
 /*
- * Copyright (C) 2021 MediaTek Inc.
+ * Copyright (C) 2016 MediaTek Inc.
  *
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-* Seehttp://www.gnu.org/licenses/gpl-2.0.htmlfor more details.
+ * TCPC Interface for alert handler
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
  */
 
 #include <linux/init.h>
@@ -34,22 +36,22 @@
  * [BLOCK] TCPCI IRQ Handler
  */
 
-static int tcpci_alert_cc_changed(struct tcpc_device *tcpc)
+static int tcpci_alert_cc_changed(struct tcpc_device *tcpc_dev)
 {
-	return tcpc_typec_handle_cc_change(tcpc);
+	return tcpc_typec_handle_cc_change(tcpc_dev);
 }
 
 #ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
 
-static inline int tcpci_alert_vsafe0v(struct tcpc_device *tcpc)
+static inline int tcpci_alert_vsafe0v(struct tcpc_device *tcpc_dev)
 {
-	tcpc_typec_handle_vsafe0v(tcpc);
+	tcpc_typec_handle_vsafe0v(tcpc_dev);
 
 #ifdef CONFIG_USB_POWER_DELIVERY
 #ifdef CONFIG_USB_PD_SAFE0V_DELAY
-	tcpc_enable_timer(tcpc, PD_TIMER_VSAFE0V_DELAY);
+	tcpc_enable_timer(tcpc_dev, PD_TIMER_VSAFE0V_DELAY);
 #else
-	pd_put_vbus_safe0v_event(tcpc);
+	pd_put_vbus_safe0v_event(tcpc_dev);
 #endif	/* CONFIG_USB_PD_SAFE0V_DELAY */
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
@@ -58,145 +60,62 @@ static inline int tcpci_alert_vsafe0v(struct tcpc_device *tcpc)
 
 #endif	/* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 
-static inline void tcpci_vbus_level_init_v10(
-	struct tcpc_device *tcpc, uint16_t power_status)
+void tcpci_vbus_level_init(struct tcpc_device *tcpc_dev, uint16_t power_status)
 {
-	mutex_lock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
 
-	tcpc->vbus_level =
+	tcpc_dev->vbus_level =
 			power_status & TCPC_REG_POWER_STATUS_VBUS_PRES ?
 			TCPC_VBUS_VALID : TCPC_VBUS_INVALID;
 
 #ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
 	if (power_status & TCPC_REG_POWER_STATUS_EXT_VSAFE0V) {
-		if (tcpc->vbus_level == TCPC_VBUS_INVALID)
-			tcpc->vbus_level = TCPC_VBUS_SAFE0V;
+		if (tcpc_dev->vbus_level == TCPC_VBUS_INVALID)
+			tcpc_dev->vbus_level = TCPC_VBUS_SAFE0V;
 		else
-			TCPC_INFO("ps_confused: 0x%02x\n", power_status);
+			TCPC_INFO("ps_confused: 0x%02x\r\n", power_status);
 	}
 #endif	/* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 
-	mutex_unlock(&tcpc->access_lock);
-}
-
-static inline void __tcpci_vbus_level_refresh(struct tcpc_device *tcpc)
-{
-	tcpc->vbus_level = tcpc->vbus_present ? TCPC_VBUS_VALID :
-			       TCPC_VBUS_INVALID;
-
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
-	if (tcpc->vbus_safe0v) {
-		if (tcpc->vbus_level == TCPC_VBUS_INVALID)
-			tcpc->vbus_level = TCPC_VBUS_SAFE0V;
-		else
-			TCPC_INFO("ps_confused: %d\n", tcpc->vbus_level);
-	}
-#endif	/* CONFIG_TCPC_VSAFE0V_DETECT_IC */
-}
-
-static inline void tcpci_vbus_level_refresh(struct tcpc_device *tcpc)
-{
-	mutex_lock(&tcpc->access_lock);
-	__tcpci_vbus_level_refresh(tcpc);
-	mutex_unlock(&tcpc->access_lock);
-}
-
-void tcpci_vbus_level_init(struct tcpc_device *tcpc, uint16_t status)
-{
-	if (tcpc->tcpc_flags & TCPC_FLAGS_ALERT_V10) {
-		tcpci_vbus_level_init_v10(tcpc, status);
-		return;
-	}
-
-	mutex_lock(&tcpc->access_lock);
-
-	tcpc->vbus_present = status & TCPC_REG_POWER_STATUS_VBUS_PRES ?
-				 true : false;
-	__tcpci_vbus_level_refresh(tcpc);
-	mutex_unlock(&tcpc->access_lock);
+	mutex_unlock(&tcpc_dev->access_lock);
 }
 
-static inline int tcpci_alert_power_status_changed_v10(struct tcpc_device *tcpc)
+static int tcpci_alert_power_status_changed(struct tcpc_device *tcpc_dev)
 {
 	int rv = 0;
 	bool show_msg = true;
 	uint16_t power_status = 0;
 
-	rv = tcpci_get_power_status(tcpc, &power_status);
+	rv = tcpci_get_power_status(tcpc_dev, &power_status);
 	if (rv < 0)
 		return rv;
 
 #ifdef CONFIG_USB_PD_DIRECT_CHARGE
-	if (tcpc->pd_during_direct_charge && tcpc->vbus_level != 0)
+	if (tcpc_dev->pd_during_direct_charge && tcpc_dev->vbus_level != 0)
 		show_msg = false;
 #endif	/* CONFIG_USB_PD_DIRECT_CHARGE */
 
 	if (show_msg)
-		TCPC_INFO("ps_change=%d\n", tcpc->vbus_level);
+		TCPC_INFO("ps_change=%d\r\n", tcpc_dev->vbus_level);
 
-	rv = tcpc_typec_handle_ps_change(tcpc, tcpc->vbus_level);
+	rv = tcpc_typec_handle_ps_change(tcpc_dev, tcpc_dev->vbus_level);
 	if (rv < 0)
 		return rv;
 
 #ifdef CONFIG_USB_POWER_DELIVERY
-	pd_put_vbus_changed_event(tcpc, true);
+	pd_put_vbus_changed_event(tcpc_dev, true);
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
 #ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
-	if (tcpc->vbus_level == TCPC_VBUS_SAFE0V)
-		rv = tcpci_alert_vsafe0v(tcpc);
+	if (tcpc_dev->vbus_level == TCPC_VBUS_SAFE0V)
+		rv = tcpci_alert_vsafe0v(tcpc_dev);
 #endif	/* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 
 	return rv;
 }
 
-static inline int tcpci_vbus_level_changed(struct tcpc_device *tcpc)
-{
-	int rv = 0;
-	bool show_msg = true;
-
-#ifdef CONFIG_USB_PD_DIRECT_CHARGE
-	if (tcpc->pd_during_direct_charge && tcpc->vbus_level != 0)
-		show_msg = false;
-#endif	/* CONFIG_USB_PD_DIRECT_CHARGE */
-
-	if (show_msg)
-		TCPC_INFO("ps_change=%d\n", tcpc->vbus_level);
-
-	rv = tcpc_typec_handle_ps_change(tcpc, tcpc->vbus_level);
-	if (rv < 0)
-		return rv;
-
-#ifdef CONFIG_USB_POWER_DELIVERY
-	pd_put_vbus_changed_event(tcpc, true);
-#endif /* CONFIG_USB_POWER_DELIVERY */
-
-#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
-	if (tcpc->vbus_level == TCPC_VBUS_SAFE0V)
-		rv = tcpci_alert_vsafe0v(tcpc);
-#endif	/* CONFIG_TCPC_VSAFE0V_DETECT_IC */
-	return rv;
-}
-
-static int tcpci_alert_power_status_changed(struct tcpc_device *tcpc)
-{
-	int rv = 0;
-	uint16_t status = 0;
-
-	if (tcpc->tcpc_flags & TCPC_FLAGS_ALERT_V10)
-		return tcpci_alert_power_status_changed_v10(tcpc);
-
-	rv = tcpci_get_power_status(tcpc, &status);
-	if (rv < 0)
-		return rv;
-
-	tcpc->vbus_present = (status & TCPC_REG_POWER_STATUS_VBUS_PRES) ?
-				 true : false;
-	return rv;
-}
-
 #ifdef CONFIG_USB_POWER_DELIVERY
-static int tcpci_alert_tx_success(struct tcpc_device *tcpc)
+static int tcpci_alert_tx_success(struct tcpc_device *tcpc_dev)
 {
 	uint8_t tx_state;
 
@@ -206,145 +125,141 @@ static int tcpci_alert_tx_success(struct tcpc_device *tcpc)
 		.pd_msg = NULL,
 	};
 
-	mutex_lock(&tcpc->access_lock);
-	tx_state = tcpc->pd_transmit_state;
-	tcpc->pd_transmit_state = PD_TX_STATE_GOOD_CRC;
-	mutex_unlock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
+	tx_state = tcpc_dev->pd_transmit_state;
+	tcpc_dev->pd_transmit_state = PD_TX_STATE_GOOD_CRC;
+	mutex_unlock(&tcpc_dev->access_lock);
 
 	if (tx_state == PD_TX_STATE_WAIT_CRC_VDM)
-		pd_put_vdm_event(tcpc, &evt, false);
+		pd_put_vdm_event(tcpc_dev, &evt, false);
 	else
-		pd_put_event(tcpc, &evt, false);
+		pd_put_event(tcpc_dev, &evt, false);
 
 	return 0;
 }
 
-static int tcpci_alert_tx_failed(struct tcpc_device *tcpc)
+static int tcpci_alert_tx_failed(struct tcpc_device *tcpc_dev)
 {
 	uint8_t tx_state;
 
-	mutex_lock(&tcpc->access_lock);
-	tx_state = tcpc->pd_transmit_state;
-	tcpc->pd_transmit_state = PD_TX_STATE_NO_GOOD_CRC;
-	mutex_unlock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
+	tx_state = tcpc_dev->pd_transmit_state;
+	tcpc_dev->pd_transmit_state = PD_TX_STATE_NO_GOOD_CRC;
+	mutex_unlock(&tcpc_dev->access_lock);
 
 	if (tx_state == PD_TX_STATE_WAIT_CRC_VDM)
-		vdm_put_hw_event(tcpc, PD_HW_TX_FAILED);
+		vdm_put_hw_event(tcpc_dev, PD_HW_TX_FAILED);
 	else
-		pd_put_hw_event(tcpc, PD_HW_TX_FAILED);
+		pd_put_hw_event(tcpc_dev, PD_HW_TX_FAILED);
 
 	return 0;
 }
 
-static int tcpci_alert_tx_discard(struct tcpc_device *tcpc)
+static int tcpci_alert_tx_discard(struct tcpc_device *tcpc_dev)
 {
 	uint8_t tx_state;
 	bool retry_crc_discard = false;
 
-	mutex_lock(&tcpc->access_lock);
-	tx_state = tcpc->pd_transmit_state;
-	tcpc->pd_transmit_state = PD_TX_STATE_DISCARD;
-	mutex_unlock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
+	tx_state = tcpc_dev->pd_transmit_state;
+	tcpc_dev->pd_transmit_state = PD_TX_STATE_DISCARD;
+	mutex_unlock(&tcpc_dev->access_lock);
 
-	TCPC_INFO("Discard\n");
+	TCPC_INFO("Discard\r\n");
 
 	if (tx_state == PD_TX_STATE_WAIT_CRC_VDM)
-		pd_put_last_vdm_event(tcpc);
+		pd_put_last_vdm_event(tcpc_dev);
 	else {
 		retry_crc_discard =
-			(tcpc->tcpc_flags &
+			(tcpc_dev->tcpc_flags &
 					TCPC_FLAGS_RETRY_CRC_DISCARD) != 0;
 
 		if (retry_crc_discard) {
 #ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
-			tcpc->pd_discard_pending = true;
-			tcpc_enable_timer(tcpc, PD_TIMER_DISCARD);
+			tcpc_dev->pd_discard_pending = true;
+			tcpc_enable_timer(tcpc_dev, PD_TIMER_DISCARD);
 #else
-			TCPC_ERR("RETRY_CRC_DISCARD\n");
+			TCPC_ERR("RETRY_CRC_DISCARD\r\n");
 #endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
 		} else {
-			pd_put_hw_event(tcpc, PD_HW_TX_FAILED);
+			pd_put_hw_event(tcpc_dev, PD_HW_TX_FAILED);
 		}
 	}
 	return 0;
 }
 
-static int tcpci_alert_recv_msg(struct tcpc_device *tcpc)
+static int tcpci_alert_recv_msg(struct tcpc_device *tcpc_dev)
 {
 	int retval;
 	struct pd_msg *pd_msg;
 	enum tcpm_transmit_type type;
 
-	pd_msg = pd_alloc_msg(tcpc);
+	const uint32_t alert_rx =
+		TCPC_REG_ALERT_RX_STATUS | TCPC_REG_ALERT_RX_BUF_OVF;
+
+	pd_msg = pd_alloc_msg(tcpc_dev);
 	if (pd_msg == NULL) {
-		tcpci_alert_status_clear(tcpc, TCPC_REG_ALERT_RX_MASK);
+		tcpci_alert_status_clear(tcpc_dev, alert_rx);
 		return -EINVAL;
 	}
 
-	retval = tcpci_get_message(tcpc,
+	retval = tcpci_get_message(tcpc_dev,
 		pd_msg->payload, &pd_msg->msg_hdr, &type);
 	if (retval < 0) {
-		TCPC_INFO("recv_msg failed: %d\n", retval);
-		pd_free_msg(tcpc, pd_msg);
+		TCPC_INFO("recv_msg failed: %d\r\n", retval);
+		pd_free_msg(tcpc_dev, pd_msg);
 		return retval;
 	}
 
 	pd_msg->frame_type = (uint8_t) type;
-	pd_put_pd_msg_event(tcpc, pd_msg);
+	pd_put_pd_msg_event(tcpc_dev, pd_msg);
 	return 0;
 }
 
-static int tcpci_alert_rx_overflow(struct tcpc_device *tcpc)
+static int tcpci_alert_rx_overflow(struct tcpc_device *tcpc_dev)
 {
 	int rv;
 	uint32_t alert_status;
 
-	TCPC_INFO("RX_OVERFLOW\n");
+	TCPC_INFO("RX_OVERFLOW\r\n");
 
-	rv = tcpci_get_alert_status(tcpc, &alert_status);
+	rv = tcpci_get_alert_status(tcpc_dev, &alert_status);
 	if (rv)
 		return rv;
 
 	if (alert_status & TCPC_REG_ALERT_RX_STATUS)
-		return tcpci_alert_recv_msg(tcpc);
+		return tcpci_alert_recv_msg(tcpc_dev);
 
 	return 0;
 }
 
-static int tcpci_alert_recv_hard_reset(struct tcpc_device *tcpc)
+static int tcpci_alert_recv_hard_reset(struct tcpc_device *tcpc_dev)
 {
-	TCPC_INFO("HardResetAlert\n");
-	pd_put_recv_hard_reset_event(tcpc);
-	tcpci_init_alert_mask(tcpc);
+	TCPC_INFO("HardResetAlert\r\n");
+	pd_put_recv_hard_reset_event(tcpc_dev);
 	return 0;
 }
 
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
-static int tcpci_alert_vendor_defined(struct tcpc_device *tcpc)
-{
-	tcpci_alert_vendor_defined_handler(tcpc);
-	return 0;
-}
-
-static int tcpci_alert_fault(struct tcpc_device *tcpc)
+static int tcpci_alert_fault(struct tcpc_device *tcpc_dev)
 {
 	uint8_t status = 0;
 
-	tcpci_get_fault_status(tcpc, &status);
-	TCPC_INFO("FaultAlert=0x%x\n", status);
-	tcpci_fault_status_clear(tcpc, status);
+	tcpci_get_fault_status(tcpc_dev, &status);
+	TCPC_INFO("FaultAlert=0x%x\r\n", status);
+	tcpci_fault_status_clear(tcpc_dev, status);
 	return 0;
 }
 
 #ifdef CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
-static int tcpci_alert_wakeup(struct tcpc_device *tcpc)
+static int tcpci_alert_wakeup(struct tcpc_device *tcpc_dev)
 {
-	if (tcpc->tcpc_flags & TCPC_FLAGS_LPM_WAKEUP_WATCHDOG) {
-		TCPC_INFO("Wakeup\n");
+	if (tcpc_dev->tcpc_flags & TCPC_FLAGS_LPM_WAKEUP_WATCHDOG) {
+		TCPC_INFO("Wakeup\r\n");
 
-		if (tcpc->typec_remote_cc[0] == TYPEC_CC_DRP_TOGGLING)
-			tcpc_enable_wakeup_timer(tcpc, true);
+		if (tcpc_dev->typec_remote_cc[0] == TYPEC_CC_DRP_TOGGLING)
+			tcpc_enable_wakeup_timer(tcpc_dev, true);
 	}
 
 	return 0;
@@ -352,13 +267,13 @@ static int tcpci_alert_wakeup(struct tcpc_device *tcpc)
 #endif /* CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG */
 
 #ifdef CONFIG_TYPEC_CAP_RA_DETACH
-static int tcpci_alert_ra_detach(struct tcpc_device *tcpc)
+static int tcpci_alert_ra_detach(struct tcpc_device *tcpc_dev)
 {
-	if (tcpc->tcpc_flags & TCPC_FLAGS_CHECK_RA_DETACHE) {
-		TCPC_DBG("RA_DETACH\n");
+	if (tcpc_dev->tcpc_flags & TCPC_FLAGS_CHECK_RA_DETACHE) {
+		TCPC_DBG("RA_DETACH\r\n");
 
-		if (tcpc->typec_remote_cc[0] == TYPEC_CC_DRP_TOGGLING)
-			tcpc_typec_enter_lpm_again(tcpc);
+		if (tcpc_dev->typec_remote_cc[0] == TYPEC_CC_DRP_TOGGLING)
+			tcpc_typec_enter_lpm_again(tcpc_dev);
 	}
 
 	return 0;
@@ -367,7 +282,7 @@ static int tcpci_alert_ra_detach(struct tcpc_device *tcpc)
 
 struct tcpci_alert_handler {
 	uint32_t bit_mask;
-	int (*handler)(struct tcpc_device *tcpc);
+	int (*handler)(struct tcpc_device *tcpc_dev);
 };
 
 #define DECL_TCPCI_ALERT_HANDLER(xbit, xhandler) {\
@@ -376,7 +291,6 @@ struct tcpci_alert_handler {
 	}
 
 static const struct tcpci_alert_handler tcpci_alert_handlers[] = {
-	DECL_TCPCI_ALERT_HANDLER(15, tcpci_alert_vendor_defined),
 #ifdef CONFIG_USB_POWER_DELIVERY
 	DECL_TCPCI_ALERT_HANDLER(4, tcpci_alert_tx_failed),
 	DECL_TCPCI_ALERT_HANDLER(5, tcpci_alert_tx_discard),
@@ -403,63 +317,56 @@ static const struct tcpci_alert_handler tcpci_alert_handlers[] = {
 
 #ifdef CONFIG_USB_POWER_DELIVERY
 static inline bool tcpci_check_hard_reset_complete(
-	struct tcpc_device *tcpc, uint32_t alert_status)
+	struct tcpc_device *tcpc_dev, uint32_t alert_status)
 {
 	if ((alert_status & TCPC_REG_ALERT_HRESET_SUCCESS)
 			== TCPC_REG_ALERT_HRESET_SUCCESS) {
-		pd_put_sent_hard_reset_event(tcpc);
+		pd_put_sent_hard_reset_event(tcpc_dev);
 		return true;
 	}
 
 	if (alert_status & TCPC_REG_ALERT_TX_DISCARDED) {
-		TCPC_INFO("HResetFailed\n");
-		tcpci_transmit(tcpc, TCPC_TX_HARD_RESET, 0, NULL);
+		TCPC_INFO("HResetFailed\r\n");
+		tcpci_transmit(tcpc_dev, TCPC_TX_HARD_RESET, 0, NULL);
 		return false;
 	}
 
 	return false;
 }
 #endif	/* CONFIG_USB_POWER_DELIVERY */
-int tcpci_alert(struct tcpc_device *tcpc)
+static inline int __tcpci_alert(struct tcpc_device *tcpc_dev)
 {
 	int rv, i;
 	uint32_t alert_status;
 	uint32_t alert_mask;
 
-	rv = tcpci_get_alert_status(tcpc, &alert_status);
-	if (rv)
-		return rv;
-
-	rv = tcpci_get_alert_mask(tcpc, &alert_mask);
+	rv = tcpci_get_alert_status(tcpc_dev, &alert_status);
 	if (rv)
 		return rv;
 
-	/* mask all alert */
-	rv = tcpci_set_alert_mask(tcpc, 0);
+	rv = tcpci_get_alert_mask(tcpc_dev, &alert_mask);
 	if (rv)
 		return rv;
 
 #ifdef CONFIG_USB_PD_DBG_ALERT_STATUS
 	if (alert_status != 0)
-		TCPC_INFO("Alert:0x%04x, Mask:0x%04x\n",
-			  alert_status, alert_mask);
+		TCPC_INFO("Alert:0x%04x\r\n", alert_status);
 #endif /* CONFIG_USB_PD_DBG_ALERT_STATUS */
 
-	alert_status &= alert_mask;
-
-	tcpci_alert_status_clear(tcpc,
+	tcpci_alert_status_clear(tcpc_dev,
 		alert_status & (~TCPC_REG_ALERT_RX_MASK));
 
-	if (tcpc->typec_role == TYPEC_ROLE_UNKNOWN)
+	if (tcpc_dev->typec_role == TYPEC_ROLE_UNKNOWN)
 		return 0;
 
-	if ((tcpc->tcpc_flags & TCPC_FLAGS_ALERT_V10) &&
-	    (alert_status & TCPC_REG_ALERT_EXT_VBUS_80))
+	alert_status &= alert_mask;
+
+	if (alert_status & TCPC_REG_ALERT_EXT_VBUS_80)
 		alert_status |= TCPC_REG_ALERT_POWER_STATUS;
 
 #ifdef CONFIG_USB_POWER_DELIVERY
-	if (tcpc->pd_transmit_state == PD_TX_STATE_WAIT_HARD_RESET) {
-		tcpci_check_hard_reset_complete(tcpc, alert_status);
+	if (tcpc_dev->pd_transmit_state == PD_TX_STATE_WAIT_HARD_RESET) {
+		tcpci_check_hard_reset_complete(tcpc_dev, alert_status);
 		alert_status &= ~TCPC_REG_ALERT_TX_MASK;
 	}
 #endif	/* CONFIG_USB_POWER_DELIVERY */
@@ -468,22 +375,29 @@ int tcpci_alert(struct tcpc_device *tcpc)
 	for (i = 0; i < ARRAY_SIZE(tcpci_alert_handlers); i++) {
 		if (tcpci_alert_handlers[i].bit_mask & alert_status) {
 			if (tcpci_alert_handlers[i].handler != 0)
-				tcpci_alert_handlers[i].handler(tcpc);
+				tcpci_alert_handlers[i].handler(tcpc_dev);
 		}
 	}
 #endif /* CONFIG_USB_PD_DBG_SKIP_ALERT_HANDLER */
 
-	/* unmask alert */
-	rv = tcpci_set_alert_mask(tcpc, alert_mask);
-	if (rv)
-		return rv;
+	return 0;
+}
 
-	if (tcpc->tcpc_flags & TCPC_FLAGS_ALERT_V10)
-		return 0;
+int tcpci_alert(struct tcpc_device *tcpc_dev)
+{
+	int ret;
 
-	tcpci_vbus_level_refresh(tcpc);
-	tcpci_vbus_level_changed(tcpc);
-	return 0;
+#ifdef CONFIG_TCPC_IDLE_MODE
+	tcpci_idle_poll_ctrl(tcpc_dev, true, 0);
+#endif /* CONFIG_TCPC_IDLE_MODE */
+
+	ret = __tcpci_alert(tcpc_dev);
+
+#ifdef CONFIG_TCPC_IDLE_MODE
+	tcpci_idle_poll_ctrl(tcpc_dev, false, 0);
+#endif /* CONFIG_TCPC_IDLE_MODE */
+
+	return ret;
 }
 
 /*
@@ -493,10 +407,10 @@ int tcpci_alert(struct tcpc_device *tcpc)
 static inline void tcpci_attach_wake_lock(struct tcpc_device *tcpc)
 {
 #ifdef CONFIG_TCPC_ATTACH_WAKE_LOCK_TOUT
-	__pm_wakeup_event(tcpc->attach_wake_lock,
+	__pm_wakeup_event(&tcpc->attach_wake_lock,
 		CONFIG_TCPC_ATTACH_WAKE_LOCK_TOUT);
 #else
-	__pm_stay_awake(tcpc->attach_wake_lock);
+	__pm_stay_awake(&tcpc->attach_wake_lock);
 #endif	/* CONFIG_TCPC_ATTACH_WAKE_LOCK_TOUT */
 }
 
@@ -517,15 +431,15 @@ int tcpci_set_wake_lock(
 
 	if (new_lock != ori_lock) {
 		if (new_lock) {
-			TCPC_DBG("wake_lock=1\n");
+			TCPC_DBG("wake_lock=1\r\n");
 			tcpci_attach_wake_lock(tcpc);
 			if (tcpc->typec_watchdog)
 				tcpci_set_intrst(tcpc, true);
 		} else {
-			TCPC_DBG("wake_lock=0\n");
+			TCPC_DBG("wake_lock=0\r\n");
 			if (tcpc->typec_watchdog)
 				tcpci_set_intrst(tcpc, false);
-			__pm_relax(tcpc->attach_wake_lock);
+			__pm_relax(&tcpc->attach_wake_lock);
 		}
 		return 1;
 	}
@@ -548,12 +462,12 @@ static inline int tcpci_set_wake_lock_pd(
 		wake_lock_pd--;
 
 	if (wake_lock_pd == 0)
-		__pm_wakeup_event(tcpc->detach_wake_lock, 5000);
+		__pm_wakeup_event(&tcpc->dettach_temp_wake_lock, 5000);
 
 	tcpci_set_wake_lock(tcpc, wake_lock_pd, tcpc->wake_lock_user);
 
 	if (wake_lock_pd == 1)
-		__pm_relax(tcpc->detach_wake_lock);
+		__pm_relax(&tcpc->dettach_temp_wake_lock);
 
 	tcpc->wake_lock_pd = wake_lock_pd;
 	mutex_unlock(&tcpc->access_lock);
@@ -562,12 +476,11 @@ static inline int tcpci_set_wake_lock_pd(
 
 static inline int tcpci_report_usb_port_attached(struct tcpc_device *tcpc)
 {
-	TCPC_INFO("usb_port_attached\n");
+	TCPC_INFO("usb_port_attached\r\n");
+
 #ifdef CONFIG_DUAL_ROLE_USB_INTF
 	switch (tcpc->typec_attach_new) {
 	case TYPEC_ATTACHED_SNK:
-	case TYPEC_ATTACHED_CUSTOM_SRC:
-	case TYPEC_ATTACHED_NORP_SRC:
 		tcpc->dual_role_pr = DUAL_ROLE_PROP_PR_SNK;
 		tcpc->dual_role_dr = DUAL_ROLE_PROP_DR_DEVICE;
 		tcpc->dual_role_mode = DUAL_ROLE_PROP_MODE_UFP;
@@ -604,7 +517,8 @@ static inline int tcpci_report_usb_port_attached(struct tcpc_device *tcpc)
 
 static inline int tcpci_report_usb_port_detached(struct tcpc_device *tcpc)
 {
-	TCPC_INFO("usb_port_detached\n");
+	TCPC_INFO("usb_port_detached\r\n");
+
 #ifdef CONFIG_DUAL_ROLE_USB_INTF
 	tcpc->dual_role_pr = DUAL_ROLE_PROP_PR_NONE;
 	tcpc->dual_role_dr = DUAL_ROLE_PROP_DR_NONE;
@@ -636,7 +550,7 @@ int tcpci_report_usb_port_changed(struct tcpc_device *tcpc)
 	else if (tcpc->typec_attach_new == TYPEC_UNATTACHED)
 		tcpci_report_usb_port_detached(tcpc);
 	else
-		TCPC_DBG2("TCPC Attach Again\n");
+		TCPC_DBG2("TCPC Attach Again\r\n");
 
 	return 0;
 }
@@ -645,25 +559,42 @@ int tcpci_report_usb_port_changed(struct tcpc_device *tcpc)
  * [BLOCK] TYPEC power control changed
  */
 
-static inline int tcpci_report_power_control_on(struct tcpc_device *tcpc)
+int tcpci_report_power_control_on(struct tcpc_device *tcpc)
 {
 	tcpci_set_wake_lock_pd(tcpc, true);
 
-	mutex_lock(&tcpc->access_lock);
-	tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_DISCHARGE);
+#ifdef CONFIG_TYPEC_CAP_AUTO_DISCHARGE
+
+#ifdef CONFIG_TCPC_AUTO_DISCHARGE_EXT
+	tcpci_enable_ext_discharge(tcpc, false);
+#endif	/* CONFIG_TCPC_AUTO_DISCHARGE_EXT */
+
+#ifdef CONFIG_TCPC_AUTO_DISCHARGE_IC
 	tcpci_enable_auto_discharge(tcpc, true);
-	tcpci_enable_force_discharge(tcpc, false, 0);
-	mutex_unlock(&tcpc->access_lock);
+#endif	/* CONFIG_TCPC_AUTO_DISCHARGE_IC */
+
+	tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_AUTO_DISCHARGE);
+#endif	/* CONFIG_TYPEC_CAP_AUTO_DISCHARGE */
 
 	return 0;
 }
 
-static inline int tcpci_report_power_control_off(struct tcpc_device *tcpc)
+int tcpci_report_power_control_off(struct tcpc_device *tcpc)
 {
-	mutex_lock(&tcpc->access_lock);
-	tcpci_enable_force_discharge(tcpc, true, 0);
-	tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_DISCHARGE);
-	mutex_unlock(&tcpc->access_lock);
+#ifdef CONFIG_USB_POWER_DELIVERY
+#ifdef CONFIG_TCPC_FORCE_DISCHARGE_IC
+	tcpci_disable_force_discharge(tcpc);
+#endif	/* CONFIG_TCPC_FORCE_DISCHARGE_IC */
+#endif	/* CONFIG_USB_POWER_DELIVERY */
+
+#ifdef CONFIG_TYPEC_CAP_AUTO_DISCHARGE
+
+#ifdef CONFIG_TCPC_AUTO_DISCHARGE_EXT
+	tcpci_enable_ext_discharge(tcpc, true);
+#endif	/* CONFIG_TCPC_AUTO_DISCHARGE_EXT */
+
+	tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_AUTO_DISCHARGE);
+#endif	/* CONFIG_TYPEC_CAP_AUTO_DISCHARGE */
 
 	tcpci_set_wake_lock_pd(tcpc, false);
 	return 0;
diff --git a/./tcpci_alert_v20.c b/drivers/misc/mediatek/typec/tcpc/tcpci_alert_v20.c
new file mode 100644
index 0000000..939ae9b
--- /dev/null
+++ b/drivers/misc/mediatek/typec/tcpc/tcpci_alert_v20.c
@@ -0,0 +1,635 @@
+/*
+ * Copyright (C) 2018 MediaTek Inc.
+ *
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* Seehttp://www.gnu.org/licenses/gpl-2.0.htmlfor more details.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/delay.h>
+#include <linux/cpu.h>
+
+#include "inc/tcpci.h"
+#include "inc/tcpci_typec.h"
+
+#ifdef CONFIG_USB_POWER_DELIVERY
+#include "inc/tcpci_event.h"
+#endif /* CONFIG_USB_POWER_DELIVERY */
+
+#ifdef CONFIG_DUAL_ROLE_USB_INTF
+#include <linux/usb/class-dual-role.h>
+#endif /* CONFIG_DUAL_ROLE_USB_INTF */
+
+/*
+ * [BLOCK] TCPCI IRQ Handler
+ */
+
+static int tcpci_alert_cc_changed(struct tcpc_device *tcpc_dev)
+{
+	return tcpc_typec_handle_cc_change(tcpc_dev);
+}
+
+#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+
+static inline int tcpci_alert_vsafe0v(struct tcpc_device *tcpc_dev)
+{
+	tcpc_typec_handle_vsafe0v(tcpc_dev);
+
+#ifdef CONFIG_USB_POWER_DELIVERY
+#ifdef CONFIG_USB_PD_SAFE0V_DELAY
+	tcpc_enable_timer(tcpc_dev, PD_TIMER_VSAFE0V_DELAY);
+#else
+	pd_put_vbus_safe0v_event(tcpc_dev);
+#endif	/* CONFIG_USB_PD_SAFE0V_DELAY */
+#endif	/* CONFIG_USB_POWER_DELIVERY */
+
+	return 0;
+}
+
+#endif	/* CONFIG_TCPC_VSAFE0V_DETECT_IC */
+
+static inline void __tcpci_vbus_level_refresh(struct tcpc_device *tcpc_dev)
+{
+	tcpc_dev->vbus_level = tcpc_dev->vbus_present ? TCPC_VBUS_VALID :
+			       TCPC_VBUS_INVALID;
+
+#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+	if (tcpc_dev->vbus_safe0v) {
+		if (tcpc_dev->vbus_level == TCPC_VBUS_INVALID)
+			tcpc_dev->vbus_level = TCPC_VBUS_SAFE0V;
+		else
+			TCPC_INFO("ps_confused: %d\r\n", tcpc_dev->vbus_level);
+	}
+#endif	/* CONFIG_TCPC_VSAFE0V_DETECT_IC */
+}
+
+static inline void tcpci_vbus_level_refresh(struct tcpc_device *tcpc_dev)
+{
+	mutex_lock(&tcpc_dev->access_lock);
+	__tcpci_vbus_level_refresh(tcpc_dev);
+	mutex_unlock(&tcpc_dev->access_lock);
+}
+
+void tcpci_vbus_level_init(struct tcpc_device *tcpc_dev, uint16_t status)
+{
+	mutex_lock(&tcpc_dev->access_lock);
+
+	tcpc_dev->vbus_present = status & TCPC_REG_POWER_STATUS_VBUS_PRES ?
+				 true : false;
+	__tcpci_vbus_level_refresh(tcpc_dev);
+	mutex_unlock(&tcpc_dev->access_lock);
+}
+
+static inline int tcpci_vbus_level_changed(struct tcpc_device *tcpc_dev)
+{
+	int rv = 0;
+	bool show_msg = true;
+
+#ifdef CONFIG_USB_PD_DIRECT_CHARGE
+	if (tcpc_dev->pd_during_direct_charge && tcpc_dev->vbus_level != 0)
+		show_msg = false;
+#endif	/* CONFIG_USB_PD_DIRECT_CHARGE */
+
+	if (show_msg)
+		TCPC_INFO("ps_change=%d\r\n", tcpc_dev->vbus_level);
+
+	rv = tcpc_typec_handle_ps_change(tcpc_dev, tcpc_dev->vbus_level);
+	if (rv < 0)
+		return rv;
+
+#ifdef CONFIG_USB_POWER_DELIVERY
+	pd_put_vbus_changed_event(tcpc_dev, true);
+#endif /* CONFIG_USB_POWER_DELIVERY */
+
+#ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
+	if (tcpc_dev->vbus_level == TCPC_VBUS_SAFE0V)
+		rv = tcpci_alert_vsafe0v(tcpc_dev);
+#endif	/* CONFIG_TCPC_VSAFE0V_DETECT_IC */
+	return rv;
+}
+
+static int tcpci_alert_power_status_changed(struct tcpc_device *tcpc_dev)
+{
+	int rv = 0;
+	uint16_t status = 0;
+
+	rv = tcpci_get_power_status(tcpc_dev, &status);
+	if (rv < 0)
+		return rv;
+
+	tcpc_dev->vbus_present = (status & TCPC_REG_POWER_STATUS_VBUS_PRES) ?
+				 true : false;
+	return rv;
+}
+
+#ifdef CONFIG_USB_POWER_DELIVERY
+static int tcpci_alert_tx_success(struct tcpc_device *tcpc_dev)
+{
+	uint8_t tx_state;
+
+	struct pd_event evt = {
+		.event_type = PD_EVT_CTRL_MSG,
+		.msg = PD_CTRL_GOOD_CRC,
+		.pd_msg = NULL,
+	};
+
+	mutex_lock(&tcpc_dev->access_lock);
+	tx_state = tcpc_dev->pd_transmit_state;
+	tcpc_dev->pd_transmit_state = PD_TX_STATE_GOOD_CRC;
+	mutex_unlock(&tcpc_dev->access_lock);
+
+	if (tx_state == PD_TX_STATE_WAIT_CRC_VDM)
+		pd_put_vdm_event(tcpc_dev, &evt, false);
+	else
+		pd_put_event(tcpc_dev, &evt, false);
+
+	return 0;
+}
+
+static int tcpci_alert_tx_failed(struct tcpc_device *tcpc_dev)
+{
+	uint8_t tx_state;
+
+	mutex_lock(&tcpc_dev->access_lock);
+	tx_state = tcpc_dev->pd_transmit_state;
+	tcpc_dev->pd_transmit_state = PD_TX_STATE_NO_GOOD_CRC;
+	mutex_unlock(&tcpc_dev->access_lock);
+
+	if (tx_state == PD_TX_STATE_WAIT_CRC_VDM)
+		vdm_put_hw_event(tcpc_dev, PD_HW_TX_FAILED);
+	else
+		pd_put_hw_event(tcpc_dev, PD_HW_TX_FAILED);
+
+	return 0;
+}
+
+static int tcpci_alert_tx_discard(struct tcpc_device *tcpc_dev)
+{
+	uint8_t tx_state;
+	bool retry_crc_discard = false;
+
+	mutex_lock(&tcpc_dev->access_lock);
+	tx_state = tcpc_dev->pd_transmit_state;
+	tcpc_dev->pd_transmit_state = PD_TX_STATE_DISCARD;
+	mutex_unlock(&tcpc_dev->access_lock);
+
+	TCPC_INFO("Discard\r\n");
+
+	if (tx_state == PD_TX_STATE_WAIT_CRC_VDM)
+		pd_put_last_vdm_event(tcpc_dev);
+	else {
+		retry_crc_discard =
+			(tcpc_dev->tcpc_flags &
+					TCPC_FLAGS_RETRY_CRC_DISCARD) != 0;
+
+		if (retry_crc_discard) {
+#ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
+			tcpc_dev->pd_discard_pending = true;
+			tcpc_enable_timer(tcpc_dev, PD_TIMER_DISCARD);
+#else
+			TCPC_ERR("RETRY_CRC_DISCARD\r\n");
+#endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
+		} else {
+			pd_put_hw_event(tcpc_dev, PD_HW_TX_FAILED);
+		}
+	}
+	return 0;
+}
+
+static int tcpci_alert_recv_msg(struct tcpc_device *tcpc_dev)
+{
+	int retval;
+	struct pd_msg *pd_msg;
+	enum tcpm_transmit_type type;
+
+	const uint32_t alert_rx =
+		TCPC_REG_ALERT_RX_STATUS | TCPC_REG_ALERT_RX_BUF_OVF;
+
+	pd_msg = pd_alloc_msg(tcpc_dev);
+	if (pd_msg == NULL) {
+		tcpci_alert_status_clear(tcpc_dev, alert_rx);
+		return -EINVAL;
+	}
+
+	retval = tcpci_get_message(tcpc_dev,
+		pd_msg->payload, &pd_msg->msg_hdr, &type);
+	if (retval < 0) {
+		TCPC_INFO("recv_msg failed: %d\r\n", retval);
+		pd_free_msg(tcpc_dev, pd_msg);
+		return retval;
+	}
+
+	pd_msg->frame_type = (uint8_t) type;
+	pd_put_pd_msg_event(tcpc_dev, pd_msg);
+	return 0;
+}
+
+static int tcpci_alert_rx_overflow(struct tcpc_device *tcpc_dev)
+{
+	int rv;
+	uint32_t alert_status;
+
+	TCPC_INFO("RX_OVERFLOW\r\n");
+
+	rv = tcpci_get_alert_status(tcpc_dev, &alert_status);
+	if (rv)
+		return rv;
+
+	if (alert_status & TCPC_REG_ALERT_RX_STATUS)
+		return tcpci_alert_recv_msg(tcpc_dev);
+
+	return 0;
+}
+
+static int tcpci_alert_recv_hard_reset(struct tcpc_device *tcpc_dev)
+{
+	TCPC_INFO("HardResetAlert\r\n");
+	pd_put_recv_hard_reset_event(tcpc_dev);
+	tcpci_init_alert_mask(tcpc_dev);
+	return 0;
+}
+
+#endif /* CONFIG_USB_POWER_DELIVERY */
+
+static int tcpci_alert_vendor_defined(struct tcpc_device *tcpc_dev)
+{
+	tcpci_alert_vendor_defined_handler(tcpc_dev);
+	return 0;
+}
+
+static int tcpci_alert_fault(struct tcpc_device *tcpc_dev)
+{
+	uint8_t status = 0;
+
+	tcpci_get_fault_status(tcpc_dev, &status);
+	TCPC_INFO("FaultAlert=0x%x\r\n", status);
+	tcpci_fault_status_clear(tcpc_dev, status);
+	return 0;
+}
+
+#if 0 /* alert_v10 */
+#ifdef CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
+static int tcpci_alert_wakeup(struct tcpc_device *tcpc_dev)
+{
+	if (tcpc_dev->tcpc_flags & TCPC_FLAGS_LPM_WAKEUP_WATCHDOG) {
+		TCPC_INFO("Wakeup\r\n");
+
+		if (tcpc_dev->typec_remote_cc[0] == TYPEC_CC_DRP_TOGGLING)
+			tcpc_enable_wakeup_timer(tcpc_dev, true);
+	}
+
+	return 0;
+}
+#endif /* CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG */
+
+#ifdef CONFIG_TYPEC_CAP_RA_DETACH
+static int tcpci_alert_ra_detach(struct tcpc_device *tcpc_dev)
+{
+	if (tcpc_dev->tcpc_flags & TCPC_FLAGS_CHECK_RA_DETACHE) {
+		TCPC_DBG("RA_DETACH\r\n");
+
+		if (tcpc_dev->typec_remote_cc[0] == TYPEC_CC_DRP_TOGGLING)
+			tcpc_typec_enter_lpm_again(tcpc_dev);
+	}
+
+	return 0;
+}
+#endif /* CONFIG_TYPEC_CAP_RA_DETACH */
+#endif
+
+struct tcpci_alert_handler {
+	uint32_t bit_mask;
+	int (*handler)(struct tcpc_device *tcpc_dev);
+};
+
+#define DECL_TCPCI_ALERT_HANDLER(xbit, xhandler) {\
+		.bit_mask = 1 << xbit,\
+		.handler = xhandler, \
+	}
+
+static const struct tcpci_alert_handler tcpci_alert_handlers[] = {
+	DECL_TCPCI_ALERT_HANDLER(15, tcpci_alert_vendor_defined),
+#ifdef CONFIG_USB_POWER_DELIVERY
+	DECL_TCPCI_ALERT_HANDLER(4, tcpci_alert_tx_failed),
+	DECL_TCPCI_ALERT_HANDLER(5, tcpci_alert_tx_discard),
+	DECL_TCPCI_ALERT_HANDLER(6, tcpci_alert_tx_success),
+	DECL_TCPCI_ALERT_HANDLER(2, tcpci_alert_recv_msg),
+	DECL_TCPCI_ALERT_HANDLER(7, NULL),
+	DECL_TCPCI_ALERT_HANDLER(8, NULL),
+	DECL_TCPCI_ALERT_HANDLER(3, tcpci_alert_recv_hard_reset),
+	DECL_TCPCI_ALERT_HANDLER(10, tcpci_alert_rx_overflow),
+#endif /* CONFIG_USB_POWER_DELIVERY */
+
+	DECL_TCPCI_ALERT_HANDLER(9, tcpci_alert_fault),
+	DECL_TCPCI_ALERT_HANDLER(0, tcpci_alert_cc_changed),
+	DECL_TCPCI_ALERT_HANDLER(1, tcpci_alert_power_status_changed),
+};
+
+#ifdef CONFIG_USB_POWER_DELIVERY
+static inline bool tcpci_check_hard_reset_complete(
+	struct tcpc_device *tcpc_dev, uint32_t alert_status)
+{
+	if ((alert_status & TCPC_REG_ALERT_HRESET_SUCCESS)
+			== TCPC_REG_ALERT_HRESET_SUCCESS) {
+		pd_put_sent_hard_reset_event(tcpc_dev);
+		return true;
+	}
+
+	if (alert_status & TCPC_REG_ALERT_TX_DISCARDED) {
+		TCPC_INFO("HResetFailed\r\n");
+		tcpci_transmit(tcpc_dev, TCPC_TX_HARD_RESET, 0, NULL);
+		return false;
+	}
+
+	return false;
+}
+#endif	/* CONFIG_USB_POWER_DELIVERY */
+static inline int __tcpci_alert(struct tcpc_device *tcpc_dev)
+{
+	int rv, i;
+	uint32_t alert_status;
+	uint32_t alert_mask;
+
+	rv = tcpci_get_alert_status(tcpc_dev, &alert_status);
+	if (rv)
+		return rv;
+
+	rv = tcpci_get_alert_mask(tcpc_dev, &alert_mask);
+	if (rv)
+		return rv;
+
+#ifdef CONFIG_USB_PD_DBG_ALERT_STATUS
+	if (alert_status != 0)
+		TCPC_INFO("Alert:0x%04x\r\n", alert_status);
+#endif /* CONFIG_USB_PD_DBG_ALERT_STATUS */
+
+	tcpci_alert_status_clear(tcpc_dev,
+		alert_status & (~TCPC_REG_ALERT_RX_MASK));
+
+	if (tcpc_dev->typec_role == TYPEC_ROLE_UNKNOWN)
+		return 0;
+
+	alert_status &= alert_mask;
+
+#ifdef CONFIG_USB_POWER_DELIVERY
+	if (tcpc_dev->pd_transmit_state == PD_TX_STATE_WAIT_HARD_RESET) {
+		tcpci_check_hard_reset_complete(tcpc_dev, alert_status);
+		alert_status &= ~TCPC_REG_ALERT_TX_MASK;
+	}
+#endif	/* CONFIG_USB_POWER_DELIVERY */
+
+#ifndef CONFIG_USB_PD_DBG_SKIP_ALERT_HANDLER
+	for (i = 0; i < ARRAY_SIZE(tcpci_alert_handlers); i++) {
+		if (tcpci_alert_handlers[i].bit_mask & alert_status) {
+			if (tcpci_alert_handlers[i].handler != 0)
+				tcpci_alert_handlers[i].handler(tcpc_dev);
+		}
+	}
+#endif /* CONFIG_USB_PD_DBG_SKIP_ALERT_HANDLER */
+
+	tcpci_vbus_level_refresh(tcpc_dev);
+	tcpci_vbus_level_changed(tcpc_dev);
+	return 0;
+}
+
+int tcpci_alert(struct tcpc_device *tcpc_dev)
+{
+	int ret;
+
+#ifdef CONFIG_TCPC_IDLE_MODE
+	tcpci_idle_poll_ctrl(tcpc_dev, true, 0);
+#endif /* CONFIG_TCPC_IDLE_MODE */
+
+	ret = __tcpci_alert(tcpc_dev);
+
+#ifdef CONFIG_TCPC_IDLE_MODE
+	tcpci_idle_poll_ctrl(tcpc_dev, false, 0);
+#endif /* CONFIG_TCPC_IDLE_MODE */
+
+	return ret;
+}
+
+/*
+ * [BLOCK] TYPEC device changed
+ */
+
+static inline void tcpci_attach_wake_lock(struct tcpc_device *tcpc)
+{
+#ifdef CONFIG_TCPC_ATTACH_WAKE_LOCK_TOUT
+	__pm_wakeup_event(&tcpc->attach_wake_lock,
+					     CONFIG_TCPC_ATTACH_WAKE_LOCK_TOUT);
+#else
+	__pm_stay_awake(&tcpc->attach_wake_lock);
+#endif	/* CONFIG_TCPC_ATTACH_WAKE_LOCK_TOUT */
+}
+
+int tcpci_set_wake_lock(
+	struct tcpc_device *tcpc, bool pd_lock, bool user_lock)
+{
+	bool ori_lock, new_lock;
+
+	if (tcpc->wake_lock_pd && tcpc->wake_lock_user)
+		ori_lock = true;
+	else
+		ori_lock = false;
+
+	if (pd_lock && user_lock)
+		new_lock = true;
+	else
+		new_lock = false;
+
+	if (new_lock != ori_lock) {
+		if (new_lock) {
+			TCPC_DBG("wake_lock=1\r\n");
+			tcpci_attach_wake_lock(tcpc);
+			if (tcpc->typec_watchdog)
+				tcpci_set_intrst(tcpc, true);
+		} else {
+			TCPC_DBG("wake_lock=0\r\n");
+			if (tcpc->typec_watchdog)
+				tcpci_set_intrst(tcpc, false);
+			__pm_relax(&tcpc->attach_wake_lock);
+		}
+		return 1;
+	}
+
+	return 0;
+}
+
+static inline int tcpci_set_wake_lock_pd(
+	struct tcpc_device *tcpc, bool pd_lock)
+{
+	uint8_t wake_lock_pd;
+
+	mutex_lock(&tcpc->access_lock);
+
+	wake_lock_pd = tcpc->wake_lock_pd;
+
+	if (pd_lock)
+		wake_lock_pd++;
+	else if (wake_lock_pd > 0)
+		wake_lock_pd--;
+
+	if (wake_lock_pd == 0)
+		__pm_wakeup_event(&tcpc->dettach_temp_wake_lock, 5000);
+
+	tcpci_set_wake_lock(tcpc, wake_lock_pd, tcpc->wake_lock_user);
+
+	if (wake_lock_pd == 1)
+		__pm_relax(&tcpc->dettach_temp_wake_lock);
+
+	tcpc->wake_lock_pd = wake_lock_pd;
+	mutex_unlock(&tcpc->access_lock);
+	return 0;
+}
+
+static inline int tcpci_report_usb_port_attached(struct tcpc_device *tcpc)
+{
+	TCPC_INFO("usb_port_attached\r\n");
+
+#ifdef CONFIG_DUAL_ROLE_USB_INTF
+	switch (tcpc->typec_attach_new) {
+	case TYPEC_ATTACHED_SNK:
+		tcpc->dual_role_pr = DUAL_ROLE_PROP_PR_SNK;
+		tcpc->dual_role_dr = DUAL_ROLE_PROP_DR_DEVICE;
+		tcpc->dual_role_mode = DUAL_ROLE_PROP_MODE_UFP;
+		tcpc->dual_role_vconn = DUAL_ROLE_PROP_VCONN_SUPPLY_NO;
+		break;
+	case TYPEC_ATTACHED_SRC:
+		tcpc->dual_role_pr = DUAL_ROLE_PROP_PR_SRC;
+		tcpc->dual_role_dr = DUAL_ROLE_PROP_DR_HOST;
+		tcpc->dual_role_mode = DUAL_ROLE_PROP_MODE_DFP;
+		tcpc->dual_role_vconn = DUAL_ROLE_PROP_VCONN_SUPPLY_YES;
+		break;
+	default:
+		break;
+	}
+	dual_role_instance_changed(tcpc->dr_usb);
+#endif /* CONFIG_DUAL_ROLE_USB_INTF */
+
+	tcpci_set_wake_lock_pd(tcpc, true);
+
+#ifdef CONFIG_USB_POWER_DELIVERY
+
+#ifdef CONFIG_USB_PD_DISABLE_PE
+	if (tcpc->disable_pe)
+		return 0;
+#endif	/* CONFIG_USB_PD_DISABLE_PE */
+
+	/* MTK Only */
+	if (tcpc->pd_inited_flag)
+		pd_put_cc_attached_event(tcpc, tcpc->typec_attach_new);
+#endif /* CONFIG_USB_POWER_DLEIVERY */
+
+	return 0;
+}
+
+static inline int tcpci_report_usb_port_detached(struct tcpc_device *tcpc)
+{
+	TCPC_INFO("usb_port_detached\r\n");
+
+#ifdef CONFIG_DUAL_ROLE_USB_INTF
+	tcpc->dual_role_pr = DUAL_ROLE_PROP_PR_NONE;
+	tcpc->dual_role_dr = DUAL_ROLE_PROP_DR_NONE;
+	tcpc->dual_role_mode = DUAL_ROLE_PROP_MODE_NONE;
+	tcpc->dual_role_vconn = DUAL_ROLE_PROP_VCONN_SUPPLY_NO;
+	dual_role_instance_changed(tcpc->dr_usb);
+#endif /* CONFIG_DUAL_ROLE_USB_INTF */
+
+#ifdef CONFIG_USB_POWER_DELIVERY
+	/* MTK Only */
+	if (tcpc->pd_inited_flag)
+		pd_put_cc_detached_event(tcpc);
+	else {
+		pd_event_buf_reset(tcpc);
+		tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_PE_IDLE);
+	}
+#endif /* CONFIG_USB_POWER_DELIVERY */
+
+	tcpci_set_wake_lock_pd(tcpc, false);
+	return 0;
+}
+
+int tcpci_report_usb_port_changed(struct tcpc_device *tcpc)
+{
+	tcpci_notify_typec_state(tcpc);
+
+	if (tcpc->typec_attach_old == TYPEC_UNATTACHED)
+		tcpci_report_usb_port_attached(tcpc);
+	else if (tcpc->typec_attach_new == TYPEC_UNATTACHED)
+		tcpci_report_usb_port_detached(tcpc);
+	else
+		TCPC_DBG2("TCPC Attach Again\r\n");
+
+	return 0;
+}
+
+/*
+ * [BLOCK] TYPEC power control changed
+ */
+
+int tcpci_report_power_control_on(struct tcpc_device *tcpc)
+{
+	tcpci_set_wake_lock_pd(tcpc, true);
+
+#ifdef CONFIG_TYPEC_CAP_AUTO_DISCHARGE
+
+#ifdef CONFIG_TCPC_AUTO_DISCHARGE_EXT
+	tcpci_enable_ext_discharge(tcpc, false);
+#endif	/* CONFIG_TCPC_AUTO_DISCHARGE_EXT */
+
+#ifdef CONFIG_TCPC_AUTO_DISCHARGE_IC
+	tcpci_enable_auto_discharge(tcpc, true);
+#endif	/* CONFIG_TCPC_AUTO_DISCHARGE_IC */
+
+	tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_AUTO_DISCHARGE);
+#endif	/* CONFIG_TYPEC_CAP_AUTO_DISCHARGE */
+
+	return 0;
+}
+
+int tcpci_report_power_control_off(struct tcpc_device *tcpc)
+{
+#ifdef CONFIG_USB_POWER_DELIVERY
+#ifdef CONFIG_TCPC_FORCE_DISCHARGE_IC
+	tcpci_disable_force_discharge(tcpc);
+#endif	/* CONFIG_TCPC_FORCE_DISCHARGE_IC */
+#endif	/* CONFIG_USB_POWER_DELIVERY */
+
+#ifdef CONFIG_TYPEC_CAP_AUTO_DISCHARGE
+
+#ifdef CONFIG_TCPC_AUTO_DISCHARGE_EXT
+	tcpci_enable_ext_discharge(tcpc, true);
+#endif	/* CONFIG_TCPC_AUTO_DISCHARGE_EXT */
+
+	tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_AUTO_DISCHARGE);
+#endif	/* CONFIG_TYPEC_CAP_AUTO_DISCHARGE */
+
+	tcpci_set_wake_lock_pd(tcpc, false);
+	return 0;
+}
+
+int tcpci_report_power_control(struct tcpc_device *tcpc, bool en)
+{
+	if (tcpc->typec_power_ctrl == en)
+		return 0;
+
+	tcpc->typec_power_ctrl = en;
+
+	if (en)
+		tcpci_report_power_control_on(tcpc);
+	else
+		tcpci_report_power_control_off(tcpc);
+
+	return 0;
+}
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpci_core.c b/drivers/misc/mediatek/typec/tcpc/tcpci_core.c
index aebdf77..c7eabe1 100644
--- a/drivers/misc/mediatek/typec/tcpc/tcpci_core.c
+++ b/drivers/misc/mediatek/typec/tcpc/tcpci_core.c
@@ -33,7 +33,7 @@
 #endif /* CONFIG_RECV_BAT_ABSENT_NOTIFY */
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
-#define TCPC_CORE_VERSION		"2.0.17_MTK"
+#define TCPC_CORE_VERSION		"2.0.10_MTK"
 
 static ssize_t tcpc_show_property(struct device *dev,
 				  struct device_attribute *attr, char *buf);
@@ -84,7 +84,6 @@ static const struct attribute_group *tcpc_attr_groups[] = {
 };
 
 static const char * const role_text[] = {
-	"Unknown",
 	"SNK Only",
 	"SRC Only",
 	"DRP",
@@ -97,7 +96,7 @@ static ssize_t tcpc_show_property(struct device *dev,
 {
 	struct tcpc_device *tcpc = to_tcpc_device(dev);
 	const ptrdiff_t offset = attr - tcpc_device_attributes;
-	int i = 0, ret;
+	int i = 0;
 #ifdef CONFIG_USB_POWER_DELIVERY
 	struct pe_data *pe_data;
 	struct pd_port *pd_port;
@@ -109,131 +108,87 @@ static ssize_t tcpc_show_property(struct device *dev,
 	case TCPC_DESC_CAP_INFO:
 		pd_port = &tcpc->pd_port;
 		pe_data = &pd_port->pe_data;
-		ret = snprintf(buf+strlen(buf), 256, "%s = %d\n%s = %d\n",
-				"local_selected_cap",
-				pe_data->local_selected_cap,
-				"remote_selected_cap",
-				pe_data->remote_selected_cap);
-		if (ret < 0)
-			break;
-		ret = snprintf(buf+strlen(buf), 256, "%s\n",
+		snprintf(buf+strlen(buf), 256, "%s = %d\n%s = %d\n",
+			"local_selected_cap",
+			pe_data->local_selected_cap,
+			"remote_selected_cap",
+			pe_data->remote_selected_cap);
+
+		snprintf(buf+strlen(buf), 256, "%s\n",
 				"local_src_cap(type, vmin, vmax, oper)");
-		if (ret < 0)
-			break;
 		for (i = 0; i < pd_port->local_src_cap.nr; i++) {
 			tcpm_extract_power_cap_val(
 				pd_port->local_src_cap.pdos[i],
 				&cap);
-			ret = snprintf(buf+strlen(buf), 256, "%d %d %d %d\n",
-				      cap.type, cap.min_mv, cap.max_mv, cap.ma);
-			if (ret < 0)
-				break;
+			snprintf(buf+strlen(buf), 256, "%d %d %d %d\n",
+				cap.type, cap.min_mv, cap.max_mv, cap.ma);
 		}
-		ret = snprintf(buf+strlen(buf), 256, "%s\n",
+		snprintf(buf+strlen(buf), 256, "%s\n",
 				"local_snk_cap(type, vmin, vmax, ioper)");
-		if (ret < 0)
-			break;
 		for (i = 0; i < pd_port->local_snk_cap.nr; i++) {
 			tcpm_extract_power_cap_val(
 				pd_port->local_snk_cap.pdos[i],
 				&cap);
-			ret = snprintf(buf+strlen(buf), 256, "%d %d %d %d\n",
-				      cap.type, cap.min_mv, cap.max_mv, cap.ma);
-			if (ret < 0)
-				break;
+			snprintf(buf+strlen(buf), 256, "%d %d %d %d\n",
+				cap.type, cap.min_mv, cap.max_mv, cap.ma);
 		}
-		ret = snprintf(buf+strlen(buf), 256, "%s\n",
+		snprintf(buf+strlen(buf), 256, "%s\n",
 				"remote_src_cap(type, vmin, vmax, ioper)");
-		if (ret < 0)
-			break;
 		for (i = 0; i < pe_data->remote_src_cap.nr; i++) {
 			tcpm_extract_power_cap_val(
 				pe_data->remote_src_cap.pdos[i],
 				&cap);
-			ret = snprintf(buf+strlen(buf), 256, "%d %d %d %d\n",
-				      cap.type, cap.min_mv, cap.max_mv, cap.ma);
-			if (ret < 0)
-				break;
+			snprintf(buf+strlen(buf), 256, "%d %d %d %d\n",
+				cap.type, cap.min_mv, cap.max_mv, cap.ma);
 		}
-		ret = snprintf(buf+strlen(buf), 256, "%s\n",
+		snprintf(buf+strlen(buf), 256, "%s\n",
 				"remote_snk_cap(type, vmin, vmax, ioper)");
-		if (ret < 0)
-			break;
 		for (i = 0; i < pe_data->remote_snk_cap.nr; i++) {
 			tcpm_extract_power_cap_val(
 				pe_data->remote_snk_cap.pdos[i],
 				&cap);
-			ret = snprintf(buf+strlen(buf), 256, "%d %d %d %d\n",
-				      cap.type, cap.min_mv, cap.max_mv, cap.ma);
-			if (ret < 0)
-				break;
+			snprintf(buf+strlen(buf), 256, "%d %d %d %d\n",
+				cap.type, cap.min_mv, cap.max_mv, cap.ma);
 		}
 		break;
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 	case TCPC_DESC_ROLE_DEF:
-		ret = snprintf(buf, 256, "%s\n", role_text[tcpc->desc.role_def]);
-		if (ret < 0)
-			break;
+		snprintf(buf, 256, "%s\n", role_text[tcpc->desc.role_def]);
 		break;
 	case TCPC_DESC_RP_LEVEL:
-		if (tcpc->typec_local_rp_level == TYPEC_RP_DFT) {
-			ret = snprintf(buf, 256, "%s\n", "Default");
-			if (ret < 0)
-				break;
-		} else if (tcpc->typec_local_rp_level == TYPEC_RP_1_5) {
-			ret = snprintf(buf, 256, "%s\n", "1.5");
-			if (ret < 0)
-				break;
-		} else if (tcpc->typec_local_rp_level == TYPEC_RP_3_0) {
-			ret = snprintf(buf, 256, "%s\n", "3.0");
-			if (ret < 0)
-				break;
-		}
+		if (tcpc->typec_local_rp_level == TYPEC_CC_RP_DFT)
+			snprintf(buf, 256, "%s\n", "Default");
+		else if (tcpc->typec_local_rp_level == TYPEC_CC_RP_1_5)
+			snprintf(buf, 256, "%s\n", "1.5");
+		else if (tcpc->typec_local_rp_level == TYPEC_CC_RP_3_0)
+			snprintf(buf, 256, "%s\n", "3.0");
 		break;
 	case TCPC_DESC_PD_TEST:
-		ret = snprintf(buf, 256, "%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n",
-				"1: pr_swap", "2: dr_swap", "3: vconn_swap",
-				"4: soft reset", "5: hard reset",
-				"6: get_src_cap", "7: get_sink_cap",
-				"8: discover_id", "9: discover_cable");
-		if (ret < 0)
-			dev_dbg(dev, "%s: ret=%d\n", __func__, ret);
+		snprintf(buf, 256, "%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n",
+			"1: pr_swap", "2: dr_swap", "3: vconn_swap",
+			"4: soft reset", "5: hard reset",
+			"6: get_src_cap", "7: get_sink_cap",
+			"8: discover_id", "9: discover_cable");
 		break;
 	case TCPC_DESC_INFO:
 		i += snprintf(buf + i,
 			256, "|^|==( %s info )==|^|\n", tcpc->desc.name);
-		if (i < 0)
-			break;
 		i += snprintf(buf + i,
 			256, "role = %s\n", role_text[tcpc->desc.role_def]);
-		if (i < 0)
-			break;
-		if (tcpc->typec_local_rp_level == TYPEC_RP_DFT) {
+		if (tcpc->typec_local_rp_level == TYPEC_CC_RP_DFT)
 			i += snprintf(buf + i, 256, "rplvl = %s\n", "Default");
-			if (i < 0)
-				break;
-		} else if (tcpc->typec_local_rp_level == TYPEC_RP_1_5) {
+		else if (tcpc->typec_local_rp_level == TYPEC_CC_RP_1_5)
 			i += snprintf(buf + i, 256, "rplvl = %s\n", "1.5");
-			if (i < 0)
-				break;
-		} else if (tcpc->typec_local_rp_level == TYPEC_RP_3_0) {
+		else if (tcpc->typec_local_rp_level == TYPEC_CC_RP_3_0)
 			i += snprintf(buf + i, 256, "rplvl = %s\n", "3.0");
-			if (i < 0)
-				break;
-		}
 		break;
 #ifdef CONFIG_USB_POWER_DELIVERY
 	case TCPC_DESC_PE_READY:
 		pd_port = &tcpc->pd_port;
-		if (pd_port->pe_data.pe_ready) {
-			ret = snprintf(buf, 256, "%s\n", "yes");
-			if (ret < 0)
-				break;
-		} else {
-			ret = snprintf(buf, 256, "%s\n", "no");
-			if (ret < 0)
-				break;
-		}
+		if (pd_port->pe_data.pe_ready)
+			snprintf(buf, 256, "%s\n", "yes");
+		else
+			snprintf(buf, 256, "%s\n", "no");
 		break;
 #endif
 	default:
@@ -242,21 +197,28 @@ static ssize_t tcpc_show_property(struct device *dev,
 	return strlen(buf);
 }
 
-static int get_parameters(char *buf, unsigned long *param, int num_of_par)
+static int get_parameters(char *buf, long int *param1, int num_of_par)
 {
-	int cnt = 0;
-	char *token = strsep(&buf, " ");
+	char *token;
+	int base, cnt;
+
+	token = strsep(&buf, " ");
 
 	for (cnt = 0; cnt < num_of_par; cnt++) {
-		if (token) {
-			if (kstrtoul(token, 0, &param[cnt]) != 0)
+		if (token != NULL) {
+			if ((token[1] == 'x') || (token[1] == 'X'))
+				base = 16;
+			else
+				base = 10;
+
+			if (kstrtoul(token, base, &param1[cnt]) != 0)
 				return -EINVAL;
 
 			token = strsep(&buf, " ");
-		} else
+			}
+		else
 			return -EINVAL;
 	}
-
 	return 0;
 }
 
@@ -377,18 +339,19 @@ struct tcpc_device *tcpc_dev_get_by_name(const char *name)
 
 static void tcpc_device_release(struct device *dev)
 {
-	struct tcpc_device *tcpc = to_tcpc_device(dev);
+	struct tcpc_device *tcpc_dev = to_tcpc_device(dev);
 
 	pr_info("%s : %s device release\n", __func__, dev_name(dev));
-	PD_BUG_ON(tcpc == NULL);
+	PD_BUG_ON(tcpc_dev == NULL);
 	/* Un-init pe thread */
 #ifdef CONFIG_USB_POWER_DELIVERY
-	tcpci_event_deinit(tcpc);
+	tcpci_event_deinit(tcpc_dev);
 #endif /* CONFIG_USB_POWER_DELIVERY */
 	/* Un-init timer thread */
-	tcpci_timer_deinit(tcpc);
+	tcpci_timer_deinit(tcpc_dev);
 	/* Un-init Mutex */
 	/* Do initialization */
+	devm_kfree(dev, tcpc_dev);
 }
 
 static void tcpc_init_work(struct work_struct *work);
@@ -407,7 +370,6 @@ struct tcpc_device *tcpc_device_register(struct device *parent,
 		return NULL;
 	}
 
-	tcpc->evt_wq = alloc_ordered_workqueue("%s", 0, tcpc_desc->name);
 	for (i = 0; i < TCP_NOTIFY_IDX_NR; i++)
 		srcu_init_notifier_head(&tcpc->evt_nh[i]);
 
@@ -424,7 +386,7 @@ struct tcpc_device *tcpc_device_register(struct device *parent,
 	tcpc->dev.release = tcpc_device_release;
 	dev_set_drvdata(&tcpc->dev, tcpc);
 	tcpc->drv_data = drv_data;
-	dev_set_name(&tcpc->dev, "%s", tcpc_desc->name);
+	dev_set_name(&tcpc->dev, tcpc_desc->name);
 	tcpc->desc = *tcpc_desc;
 	tcpc->ops = ops;
 	tcpc->typec_local_rp_level = tcpc_desc->rp_lvl;
@@ -433,8 +395,6 @@ struct tcpc_device *tcpc_device_register(struct device *parent,
 	tcpc->tcpc_vconn_supply = tcpc_desc->vconn_supply;
 #endif	/* CONFIG_TCPC_VCONN_SUPPLY_MODE */
 
-	device_set_of_node_from_dev(&tcpc->dev, parent);
-
 	ret = device_register(&tcpc->dev);
 	if (ret) {
 		kfree(tcpc);
@@ -447,20 +407,22 @@ struct tcpc_device *tcpc_device_register(struct device *parent,
 	/* If system support "WAKE_LOCK_IDLE",
 	 * please use it instead of "WAKE_LOCK_SUSPEND"
 	 */
-	tcpc->attach_wake_lock =
-		wakeup_source_register(&tcpc->dev, "tcpc_attach_wake_lock");
-	tcpc->detach_wake_lock =
-		wakeup_source_register(&tcpc->dev, "tcpc_detach_wake_lock");
+	wakeup_source_init(&tcpc->attach_wake_lock,
+		"tcpc_attach_wakelock");
+	wakeup_source_init(&tcpc->dettach_temp_wake_lock,
+		"tcpc_detach_wakelock");
 
 	tcpci_timer_init(tcpc);
 #ifdef CONFIG_USB_POWER_DELIVERY
 	pd_core_init(tcpc);
 #endif /* CONFIG_USB_POWER_DELIVERY */
+
 #ifdef CONFIG_DUAL_ROLE_USB_INTF
 	ret = tcpc_dual_role_phy_init(tcpc);
 	if (ret < 0)
 		dev_err(&tcpc->dev, "dual role usb init fail\n");
 #endif /* CONFIG_DUAL_ROLE_USB_INTF */
+
 	return tcpc;
 }
 EXPORT_SYMBOL(tcpc_device_register);
@@ -470,28 +432,29 @@ static int tcpc_device_irq_enable(struct tcpc_device *tcpc)
 	int ret;
 
 	if (!tcpc->ops->init) {
-		pr_notice("%s Please implment tcpc ops init function\n",
-			  __func__);
+		pr_err("%s Please implment tcpc ops init function\n",
+		__func__);
 		return -EINVAL;
 	}
 
-	tcpci_lock_typec(tcpc);
 	ret = tcpci_init(tcpc, false);
 	if (ret < 0) {
-		tcpci_unlock_typec(tcpc);
 		pr_err("%s tcpc init fail\n", __func__);
 		return ret;
 	}
 
-	ret = tcpc_typec_init(tcpc, tcpc->desc.role_def);
+	tcpci_lock_typec(tcpc);
+	ret = tcpc_typec_init(tcpc, tcpc->desc.role_def + 1);
 	tcpci_unlock_typec(tcpc);
 	if (ret < 0) {
 		pr_err("%s : tcpc typec init fail\n", __func__);
 		return ret;
 	}
+	if (tcpc->ops->init_alert_mask)
+		tcpci_init_alert_mask(tcpc);
 
 	schedule_delayed_work(
-		&tcpc->event_init_work, msecs_to_jiffies(10*1000));
+		&tcpc->event_init_work, msecs_to_jiffies(4*1000));
 
 	pr_info("%s : tcpc irq enable OK!\n", __func__);
 	return 0;
@@ -531,8 +494,8 @@ static void bat_update_work_func(struct work_struct *work)
 	if (ret < 0)
 		TCPC_ERR("%s get battery charger now fail\n", __func__);
 
-	tcpm_update_bat_status_soc(tcpc,
-		PD_BAT_REF_FIXED0, tcpc->charging_status, tcpc->bat_soc * 10);
+	tcpm_update_bat_status_soc(
+		tcpc, tcpc->charging_status, tcpc->bat_soc * 10);
 }
 
 static int bat_nb_call_func(
@@ -565,7 +528,7 @@ static void tcpc_event_init_work(struct work_struct *work)
 	tcpci_lock_typec(tcpc);
 	tcpci_event_init(tcpc);
 	tcpc->pd_inited_flag = 1; /* MTK Only */
-	pr_info("%s typec attach new = %d\n",
+	pr_info("%s typec attache new = %d\n",
 			__func__, tcpc->typec_attach_new);
 	if (tcpc->typec_attach_new)
 		pd_put_cc_attached_event(tcpc, tcpc->typec_attach_new);
@@ -820,11 +783,9 @@ void tcpc_device_unregister(struct device *dev, struct tcpc_device *tcpc)
 
 	tcpc_typec_deinit(tcpc);
 
-#ifdef CONFIG_USB_PD_REV30
-	wakeup_source_unregister(tcpc->pd_port.pps_request_wake_lock);
-#endif /* CONFIG_USB_PD_REV30 */
-	wakeup_source_unregister(tcpc->detach_wake_lock);
-	wakeup_source_unregister(tcpc->attach_wake_lock);
+	wakeup_source_trash(&tcpc->dettach_temp_wake_lock);
+	wakeup_source_trash(&tcpc->attach_wake_lock);
+
 #ifdef CONFIG_DUAL_ROLE_USB_INTF
 	devm_dual_role_instance_unregister(&tcpc->dev, tcpc->dr_usb);
 #endif /* CONFIG_DUAL_ROLE_USB_INTF */
@@ -898,11 +859,12 @@ static int fg_bat_notifier_call(struct notifier_block *nb,
 				unsigned long event, void *data)
 {
 	struct pd_port *pd_port = container_of(nb, struct pd_port, fg_bat_nb);
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
 	switch (event) {
 	case EVENT_BATTERY_PLUG_OUT:
-		dev_info(&tcpc->dev, "%s: fg battery absent\n", __func__);
+		dev_info(&tcpc_dev->dev, "%s: fg battery absent\n", __func__);
+		tcpc_typec_error_recovery(tcpc_dev);
 		schedule_work(&pd_port->fg_bat_work);
 		break;
 	default:
@@ -937,9 +899,7 @@ static int __tcpc_class_complete_work(struct device *dev, void *data)
 #ifdef CONFIG_USB_POWER_DELIVERY
 #ifdef CONFIG_RECV_BAT_ABSENT_NOTIFY
 		fg_bat_nb->notifier_call = fg_bat_notifier_call;
-#if CONFIG_MTK_GAUGE_VERSION == 30
 		ret = register_battery_notifier(fg_bat_nb);
-#endif
 		if (ret < 0) {
 			pr_notice("%s: register bat notifier fail\n", __func__);
 			return -EINVAL;
@@ -967,89 +927,6 @@ MODULE_VERSION(TCPC_CORE_VERSION);
 MODULE_LICENSE("GPL");
 
 /* Release Version
- * 2.0.17_MTK
- * (1) Add CONFIG_TYPEC_LEGACY3_ALWAYS_LOCAL_RP
- * (2) Fix a synchronization/locking problem in pd_notify_pe_error_recovery()
- * (3) Add USB_VID_MQP
- * (4) Revise the return value checking of tcpc_device_register()
- *
- * 2.0.16_MTK
- * (1) Check the return value of wait_event_interruptible()
- * (2) Revise *_get_cc()
- * (3) Revise role_def
- * (4) Fix COMMON.CHECK.PD.10
- *
- * 2.0.15_MTK
- * (1) undef CONFIG_COMPATIBLE_APPLE_TA
- * (2) Fix TEST.PD.PROT.ALL.5 Unrecognized Message (PD2)
- * (3) Fix TEST.PD.PROT.ALL3.3 Invalid Manufacturer Info Target
- * (4) Fix TEST.PD.PROT.ALL3.4 Invalid Manufacturer Info Ref
- * (5) Fix TEST.PD.PROT.SRC.11 Unexpected Message Received in Ready State (PD2)
- * (6) Fix TEST.PD.PROT.SRC.13 PR_Swap - GoodCRC not sent in Response to PS_RDY
- * (7) Fix TEST.PD.VDM.SRC.2 Invalid Fields - Discover Identity (PD2)
- * (8) Revise the usages of PD_TIMER_NO_RESPONSE
- * (9) Retry to send Source_Capabilities after PR_Swap
- * (10) Fix tcpm_get_remote_power_cap() and __tcpm_inquire_select_source_cap()
- * (11) Increase the threshold to enter PE_ERROR_RECOVERY_ONCE from 2 to 4
- * (12) Change wait_event() back to wait_event_interruptible() for not being
- *	detected as hung tasks
- *
- * 2.0.14_MTK
- * (1) Move out typec_port registration and operation to rt_pd_manager.c
- * (2) Rename CONFIG_TYPEC_WAIT_BC12 to CONFIG_USB_PD_WAIT_BC12
- * (3) Not to set power/data/vconn role repeatedly
- * (4) Revise vconn highV protection
- * (5) Revise tcpc timer
- * (6) Reduce IBUS Iq for MT6371, MT6372 and MT6360
- * (7) Decrease VBUS present threshold (VBUS_CAL) by 60mV (2LSBs) for RT171x
- * (8) Replace \r\n with \n for resolving logs without newlines
- * (9) Remove the member time_stamp from struct pd_msg
- * (10) Remove NoResponseTimer as Sink for new PD spec
- * (11) Revise responses of Reject and Not_Supported
- * (12) Revise the usages of pd_traffic_control and typec_power_ctrl
- * (13) Revise the usages of wait_event_*()
- * (14) Add PD capability for TYPEC_ATTACHED_DBGACC_SNK
- * (15) Utilize rt-regmap to reduce I2C accesses
- *
- * 2.0.13_MTK
- * (1) Add TCPC flags for VCONN_SAFE5V_ONLY
- * (2) Add boolean property attemp_discover_svid in dts/dtsi
- * (3) Add a TCPM API for postponing Type-C role change until unattached
- * (4) Update VDOs according new PD spec
- * (5) Add an option for enabling/disabling the support of DebugAccessory.SRC
- * (6) Add the workaround for delayed ps_change related to PS_RDY
- *     during PR_SWAP
- * (7) Always Back to PE ready state in pd_dpm_dfp_inform_id() and
- *     pd_dpm_dfp_inform_svids()
- * (8) Re-fetch triggered_timer and enable_mask after lock acquisition
- * (9) Leave low power mode only when CC is detached
- * (10) Revise code related to pd_check_rev30()
- * (11) Bypass BC1.2 for PR_SWAP from Source to Sink
- * (12) Support charging icon for AudioAccessory
- * (13) Replace tcpc_dev with tcpc
- * (14) TCPCI Alert V10 and V20 co-exist
- * (15) Resolve DP Source/Sink Both Connected when acting as DFP_U
- * (16) Change CONFIG_TYPEC_SNK_CURR_DFT from 150 to 100 (mA)
- * (17) Define CONFIG_USB_PD_PR_SWAP_ERROR_RECOVERY by default
- * (18) Add an option for TCPC log with port name
- * (19) USB-C states go from ErrorRecovery to Unattached.SRC with Try.SRC role
- * (20) Revise dts/dtsi value for DisplayPort Alternative Mode
- * (21) Mask vSafe0V IRQ before entering low power mode
- * (22) Disable auto idle mode before entering low power mode
- * (23) Reset Protocol FSM and clear RX alerts twice before clock gating
- *
- * 2.0.12_MTK
- * (1) Fix voltage/current steps of RDO for APDO
- * (2) Non-blocking TCPC notification by default
- * (3) Fix synchronization/locking problems
- * (4) Fix NoRp.SRC support
- *
- * 2.0.11_MTK
- * (1) Fix PD compliance failures of Ellisys and MQP
- * (2) Wait the result of BC1.2 before starting PD policy engine
- * (3) Fix compile warnings
- * (4) Fix NoRp.SRC support
- *
  * 2.0.10_MTK
  * (1) fix battery noitifier plug out cause recursive locking detected in
  *     nh->srcu.
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpci_event.c b/drivers/misc/mediatek/typec/tcpc/tcpci_event.c
index f399040..0d167f4 100644
--- a/drivers/misc/mediatek/typec/tcpc/tcpci_event.c
+++ b/drivers/misc/mediatek/typec/tcpc/tcpci_event.c
@@ -30,172 +30,150 @@
 #include "inc/pd_dpm_core.h"
 
 #ifdef CONFIG_USB_PD_POSTPONE_VDM
-static void postpone_vdm_event(struct tcpc_device *tcpc)
+static void postpone_vdm_event(struct tcpc_device *tcpc_dev)
 {
 	/*
 	 * Postpone VDM retry event due to the retry reason
 	 * maybe interrupt by some PD event ....
 	 */
 
-	struct pd_event *vdm_event = &tcpc->pd_vdm_event;
+	struct pd_event *vdm_event = &tcpc_dev->pd_vdm_event;
 
-	if (tcpc->pd_pending_vdm_event && vdm_event->pd_msg) {
-		tcpc->pd_postpone_vdm_timeout = false;
-		tcpc_restart_timer(tcpc, PD_PE_VDM_POSTPONE);
+	if (tcpc_dev->pd_pending_vdm_event && vdm_event->pd_msg) {
+		tcpc_dev->pd_postpone_vdm_timeout = false;
+		tcpc_restart_timer(tcpc_dev, PD_PE_VDM_POSTPONE);
 	}
 }
 #endif	/* CONFIG_USB_PD_POSTPONE_VDM */
 
-struct pd_msg *__pd_alloc_msg(struct tcpc_device *tcpc)
+struct pd_msg *__pd_alloc_msg(struct tcpc_device *tcpc_dev)
 {
 	int i;
 	uint8_t mask;
 
 	for (i = 0, mask = 1; i < PD_MSG_BUF_SIZE; i++, mask <<= 1) {
-		if ((mask & tcpc->pd_msg_buffer_allocated) == 0) {
-			tcpc->pd_msg_buffer_allocated |= mask;
-			return tcpc->pd_msg_buffer + i;
+		if ((mask & tcpc_dev->pd_msg_buffer_allocated) == 0) {
+			tcpc_dev->pd_msg_buffer_allocated |= mask;
+			return tcpc_dev->pd_msg_buffer + i;
 		}
 	}
 
-	PD_ERR("pd_alloc_msg failed\n");
+	PD_ERR("pd_alloc_msg failed\r\n");
 	PD_BUG_ON(true);
 
 	return (struct pd_msg *)NULL;
 }
 
-struct pd_msg *pd_alloc_msg(struct tcpc_device *tcpc)
+struct pd_msg *pd_alloc_msg(struct tcpc_device *tcpc_dev)
 {
 	struct pd_msg *pd_msg = NULL;
 
-	mutex_lock(&tcpc->access_lock);
-	pd_msg = __pd_alloc_msg(tcpc);
-	mutex_unlock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
+	pd_msg = __pd_alloc_msg(tcpc_dev);
+	mutex_unlock(&tcpc_dev->access_lock);
 
 	return pd_msg;
 }
 
-static void __pd_free_msg(struct tcpc_device *tcpc, struct pd_msg *pd_msg)
+static void __pd_free_msg(struct tcpc_device *tcpc_dev, struct pd_msg *pd_msg)
 {
-	int index = pd_msg - tcpc->pd_msg_buffer;
+	int index = pd_msg - tcpc_dev->pd_msg_buffer;
 	uint8_t mask = 1 << index;
 
-	PD_BUG_ON((mask & tcpc->pd_msg_buffer_allocated) == 0);
-	tcpc->pd_msg_buffer_allocated &= (~mask);
+	PD_BUG_ON((mask & tcpc_dev->pd_msg_buffer_allocated) == 0);
+	tcpc_dev->pd_msg_buffer_allocated &= (~mask);
 }
 
 static void __pd_free_event(
-		struct tcpc_device *tcpc, struct pd_event *pd_event)
+		struct tcpc_device *tcpc_dev, struct pd_event *pd_event)
 {
 	if (pd_event->pd_msg) {
-		__pd_free_msg(tcpc, pd_event->pd_msg);
+		__pd_free_msg(tcpc_dev, pd_event->pd_msg);
 		pd_event->pd_msg = NULL;
 	}
 }
 
-bool __pd_is_msg_empty(struct tcpc_device *tcpc)
+void pd_free_msg(struct tcpc_device *tcpc_dev, struct pd_msg *pd_msg)
 {
-	int i;
-	uint8_t mask;
-
-	for (i = 0, mask = 1; i < PD_MSG_BUF_SIZE; i++, mask <<= 1) {
-		if ((mask & tcpc->pd_msg_buffer_allocated) != 0)
-			return false;
-	}
-	return true;
+	mutex_lock(&tcpc_dev->access_lock);
+	__pd_free_msg(tcpc_dev, pd_msg);
+	mutex_unlock(&tcpc_dev->access_lock);
 }
 
-bool pd_is_msg_empty(struct tcpc_device *tcpc)
+void pd_free_event(struct tcpc_device *tcpc_dev, struct pd_event *pd_event)
 {
-	bool empty;
-
-	mutex_lock(&tcpc->access_lock);
-	empty = __pd_is_msg_empty(tcpc);
-	mutex_unlock(&tcpc->access_lock);
-	return empty;
-}
-
-void pd_free_msg(struct tcpc_device *tcpc, struct pd_msg *pd_msg)
-{
-	mutex_lock(&tcpc->access_lock);
-	__pd_free_msg(tcpc, pd_msg);
-	mutex_unlock(&tcpc->access_lock);
-}
-
-void pd_free_event(struct tcpc_device *tcpc, struct pd_event *pd_event)
-{
-	mutex_lock(&tcpc->access_lock);
-	__pd_free_event(tcpc, pd_event);
-	mutex_unlock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
+	__pd_free_event(tcpc_dev, pd_event);
+	mutex_unlock(&tcpc_dev->access_lock);
 }
 
 /*----------------------------------------------------------------------------*/
 
 static bool __pd_get_event(
-	struct tcpc_device *tcpc, struct pd_event *pd_event)
+	struct tcpc_device *tcpc_dev, struct pd_event *pd_event)
 {
 	int index = 0;
 
-	if (tcpc->pd_event_count <= 0)
+	if (tcpc_dev->pd_event_count <= 0)
 		return false;
 
-	tcpc->pd_event_count--;
+	tcpc_dev->pd_event_count--;
 
 	*pd_event =
-		tcpc->pd_event_ring_buffer[tcpc->pd_event_head_index];
+		tcpc_dev->pd_event_ring_buffer[tcpc_dev->pd_event_head_index];
 
-	if (tcpc->pd_event_count) {
-		index = tcpc->pd_event_head_index + 1;
+	if (tcpc_dev->pd_event_count) {
+		index = tcpc_dev->pd_event_head_index + 1;
 		index %= PD_EVENT_BUF_SIZE;
 	}
-	tcpc->pd_event_head_index = index;
+	tcpc_dev->pd_event_head_index = index;
 	return true;
 }
 
-bool pd_get_event(struct tcpc_device *tcpc, struct pd_event *pd_event)
+bool pd_get_event(struct tcpc_device *tcpc_dev, struct pd_event *pd_event)
 {
 	bool ret;
 
-	mutex_lock(&tcpc->access_lock);
-	ret = __pd_get_event(tcpc, pd_event);
-	mutex_unlock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
+	ret = __pd_get_event(tcpc_dev, pd_event);
+	mutex_unlock(&tcpc_dev->access_lock);
 	return ret;
 }
 
-static bool __pd_put_event(struct tcpc_device *tcpc,
+static bool __pd_put_event(struct tcpc_device *tcpc_dev,
 	const struct pd_event *pd_event, bool from_port_partner)
 {
 	int index;
 
 #ifdef CONFIG_USB_PD_POSTPONE_OTHER_VDM
 	if (from_port_partner)
-		postpone_vdm_event(tcpc);
+		postpone_vdm_event(tcpc_dev);
 #endif	/* CONFIG_USB_PD_POSTPONE_OTHER_VDM */
 
-	if (tcpc->pd_event_count >= PD_EVENT_BUF_SIZE) {
-		PD_ERR("pd_put_event failed\n");
+	if (tcpc_dev->pd_event_count >= PD_EVENT_BUF_SIZE) {
+		PD_ERR("pd_put_event failed\r\n");
 		return false;
 	}
 
-	index = (tcpc->pd_event_head_index + tcpc->pd_event_count);
+	index = (tcpc_dev->pd_event_head_index + tcpc_dev->pd_event_count);
 	index %= PD_EVENT_BUF_SIZE;
 
-	tcpc->pd_event_count++;
-	tcpc->pd_event_ring_buffer[index] = *pd_event;
+	tcpc_dev->pd_event_count++;
+	tcpc_dev->pd_event_ring_buffer[index] = *pd_event;
 
-	atomic_inc(&tcpc->pending_event);
-	wake_up(&tcpc->event_wait_que);
+	atomic_inc(&tcpc_dev->pending_event);
+	wake_up_interruptible(&tcpc_dev->event_loop_wait_que);
 	return true;
 }
 
-bool pd_put_event(struct tcpc_device *tcpc, const struct pd_event *pd_event,
+bool pd_put_event(struct tcpc_device *tcpc_dev, const struct pd_event *pd_event,
 	bool from_port_partner)
 {
 	bool ret;
 
-	mutex_lock(&tcpc->access_lock);
-	ret = __pd_put_event(tcpc, pd_event, from_port_partner);
-	mutex_unlock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
+	ret = __pd_put_event(tcpc_dev, pd_event, from_port_partner);
+	mutex_unlock(&tcpc_dev->access_lock);
 
 	return ret;
 }
@@ -203,7 +181,7 @@ bool pd_put_event(struct tcpc_device *tcpc, const struct pd_event *pd_event,
 /*----------------------------------------------------------------------------*/
 
 static inline void pd_get_attention_event(
-	struct tcpc_device *tcpc, struct pd_event *pd_event)
+	struct tcpc_device *tcpc_dev, struct pd_event *pd_event)
 {
 	struct pd_event attention_evt = {
 		.event_type = PD_EVT_PD_MSG,
@@ -212,13 +190,13 @@ static inline void pd_get_attention_event(
 	};
 
 	*pd_event = attention_evt;
-	pd_event->pd_msg = __pd_alloc_msg(tcpc);
+	pd_event->pd_msg = __pd_alloc_msg(tcpc_dev);
 
 	if (pd_event->pd_msg == NULL)
 		return;
 
-	tcpc->pd_pending_vdm_attention = false;
-	*pd_event->pd_msg = tcpc->pd_attention_vdm_msg;
+	tcpc_dev->pd_pending_vdm_attention = false;
+	*pd_event->pd_msg = tcpc_dev->pd_attention_vdm_msg;
 }
 
 static inline bool pd_check_vdm_state_ready(struct pd_port *pd_port)
@@ -226,6 +204,7 @@ static inline bool pd_check_vdm_state_ready(struct pd_port *pd_port)
 	switch (pd_port->pe_vdm_state) {
 	case PE_SNK_READY:
 	case PE_SRC_READY:
+
 #ifdef CONFIG_USB_PD_CUSTOM_DBGACC
 	case PE_DBG_READY:
 #endif	/* CONFIG_USB_PD_CUSTOM_DBGACC */
@@ -236,7 +215,7 @@ static inline bool pd_check_vdm_state_ready(struct pd_port *pd_port)
 	}
 }
 
-bool pd_get_vdm_event(struct tcpc_device *tcpc, struct pd_event *pd_event)
+bool pd_get_vdm_event(struct tcpc_device *tcpc_dev, struct pd_event *pd_event)
 {
 	struct pd_event delay_evt = {
 		.event_type = PD_EVT_CTRL_MSG,
@@ -256,41 +235,41 @@ bool pd_get_vdm_event(struct tcpc_device *tcpc, struct pd_event *pd_event)
 		.pd_msg = NULL,
 	};
 
-	struct pd_event *vdm_event = &tcpc->pd_vdm_event;
+	struct pd_event *vdm_event = &tcpc_dev->pd_vdm_event;
 
-	if (tcpc->pd_pending_vdm_discard) {
-		mutex_lock(&tcpc->access_lock);
+	if (tcpc_dev->pd_pending_vdm_discard) {
+		mutex_lock(&tcpc_dev->access_lock);
 		*pd_event = discard_evt;
-		tcpc->pd_pending_vdm_discard = false;
-		mutex_unlock(&tcpc->access_lock);
+		tcpc_dev->pd_pending_vdm_discard = false;
+		mutex_unlock(&tcpc_dev->access_lock);
 		return true;
 	}
 
-	if (tcpc->pd_pending_vdm_event) {
-		if (vdm_event->pd_msg && !tcpc->pd_postpone_vdm_timeout)
+	if (tcpc_dev->pd_pending_vdm_event) {
+		if (vdm_event->pd_msg && !tcpc_dev->pd_postpone_vdm_timeout)
 			return false;
 
-		mutex_lock(&tcpc->access_lock);
-		if (tcpc->pd_pending_vdm_good_crc) {
+		mutex_lock(&tcpc_dev->access_lock);
+		if (tcpc_dev->pd_pending_vdm_good_crc) {
 			*pd_event = delay_evt;
-			tcpc->pd_pending_vdm_good_crc = false;
-		} else if (tcpc->pd_pending_vdm_reset) {
+			tcpc_dev->pd_pending_vdm_good_crc = false;
+		} else if (tcpc_dev->pd_pending_vdm_reset) {
 			*pd_event = reset_evt;
-			tcpc->pd_pending_vdm_reset = false;
+			tcpc_dev->pd_pending_vdm_reset = false;
 		} else {
 			*pd_event = *vdm_event;
-			tcpc->pd_pending_vdm_event = false;
+			tcpc_dev->pd_pending_vdm_event = false;
 		}
 
-		mutex_unlock(&tcpc->access_lock);
+		mutex_unlock(&tcpc_dev->access_lock);
 		return true;
 	}
 
-	if (tcpc->pd_pending_vdm_attention
-		&& pd_check_vdm_state_ready(&tcpc->pd_port)) {
-		mutex_lock(&tcpc->access_lock);
-		pd_get_attention_event(tcpc, pd_event);
-		mutex_unlock(&tcpc->access_lock);
+	if (tcpc_dev->pd_pending_vdm_attention
+		&& pd_check_vdm_state_ready(&tcpc_dev->pd_port)) {
+		mutex_lock(&tcpc_dev->access_lock);
+		pd_get_attention_event(tcpc_dev, pd_event);
+		mutex_unlock(&tcpc_dev->access_lock);
 		return true;
 	}
 
@@ -298,10 +277,10 @@ bool pd_get_vdm_event(struct tcpc_device *tcpc, struct pd_event *pd_event)
 }
 
 static inline bool reset_pe_vdm_state(
-		struct tcpc_device *tcpc, uint32_t vdm_hdr)
+		struct tcpc_device *tcpc_dev, uint32_t vdm_hdr)
 {
 	bool vdm_reset = false;
-	struct pd_port *pd_port = &tcpc->pd_port;
+	struct pd_port *pd_port = &tcpc_dev->pd_port;
 
 	if (PD_VDO_SVDM(vdm_hdr)) {
 		if (PD_VDO_CMDT(vdm_hdr) == CMDT_INIT)
@@ -312,19 +291,16 @@ static inline bool reset_pe_vdm_state(
 	}
 
 	if (vdm_reset)
-		tcpc->pd_pending_vdm_reset = true;
+		tcpc_dev->pd_pending_vdm_reset = true;
 
 	return vdm_reset;
 }
 
 static inline bool pd_is_init_attention_event(
-	struct tcpc_device *tcpc, struct pd_event *pd_event)
+	struct tcpc_device *tcpc_dev, struct pd_event *pd_event)
 {
 	uint32_t vdm_hdr = pd_event->pd_msg->payload[0];
 
-	if (!PD_VDO_SVDM(vdm_hdr))
-		return false;
-
 	if ((PD_VDO_CMDT(vdm_hdr) == CMDT_INIT) &&
 			PD_VDO_CMD(vdm_hdr) == CMD_ATTENTION) {
 		return true;
@@ -333,200 +309,206 @@ static inline bool pd_is_init_attention_event(
 	return false;
 }
 
-bool pd_put_vdm_event(struct tcpc_device *tcpc,
+bool pd_put_vdm_event(struct tcpc_device *tcpc_dev,
 		struct pd_event *pd_event, bool from_port_partner)
 {
 	bool ignore_evt = false;
 	struct pd_msg *pd_msg = pd_event->pd_msg;
 
-	mutex_lock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
 
 	if (from_port_partner &&
-		pd_is_init_attention_event(tcpc, pd_event)) {
-		TCPC_DBG("AttEvt\n");
+		pd_is_init_attention_event(tcpc_dev, pd_event)) {
+		TCPC_DBG("AttEvt\r\n");
 		ignore_evt = true;
-		tcpc->pd_pending_vdm_attention = true;
-		tcpc->pd_attention_vdm_msg = *pd_msg;
+		tcpc_dev->pd_pending_vdm_attention = true;
+		tcpc_dev->pd_attention_vdm_msg = *pd_msg;
 
-		atomic_inc(&tcpc->pending_event);
-		wake_up(&tcpc->event_wait_que);
+		/* do not really wake up process*/
+		atomic_inc(&tcpc_dev->pending_event);
+		wake_up_interruptible(&tcpc_dev->event_loop_wait_que);
 	}
 
-	if (tcpc->pd_pending_vdm_event && (!ignore_evt)) {
+	if (tcpc_dev->pd_pending_vdm_event && (!ignore_evt)) {
 		/* If message from port partner, we have to overwrite it */
 		/* If message from TCPM, we will reset_vdm later */
 		ignore_evt = !from_port_partner;
 
 		if (from_port_partner) {
 			if (pd_event_ctrl_msg_match(
-					&tcpc->pd_vdm_event,
+					&tcpc_dev->pd_vdm_event,
 					PD_CTRL_GOOD_CRC)) {
-				TCPC_DBG2("PostponeVDM GoodCRC\n");
-				tcpc->pd_pending_vdm_good_crc = true;
+				TCPC_DBG2("PostponeVDM GoodCRC\r\n");
+				tcpc_dev->pd_pending_vdm_good_crc = true;
 			}
 
-			__pd_free_event(tcpc, &tcpc->pd_vdm_event);
+			__pd_free_event(tcpc_dev, &tcpc_dev->pd_vdm_event);
 		}
 	}
 
 	if (ignore_evt) {
-		__pd_free_event(tcpc, pd_event);
-		mutex_unlock(&tcpc->access_lock);
+		__pd_free_event(tcpc_dev, pd_event);
+		mutex_unlock(&tcpc_dev->access_lock);
 		return false;
 	}
 
-	tcpc->pd_vdm_event = *pd_event;
-	tcpc->pd_pending_vdm_event = true;
-	tcpc->pd_postpone_vdm_timeout = true;
+	tcpc_dev->pd_vdm_event = *pd_event;
+	tcpc_dev->pd_pending_vdm_event = true;
+	tcpc_dev->pd_postpone_vdm_timeout = true;
 
 	if (from_port_partner) {
 
 		PD_BUG_ON(pd_msg == NULL);
-		tcpc->pd_last_vdm_msg = *pd_msg;
-		reset_pe_vdm_state(tcpc, pd_msg->payload[0]);
+		/* pd_msg->time_stamp = 0; */
+		tcpc_dev->pd_last_vdm_msg = *pd_msg;
+		reset_pe_vdm_state(tcpc_dev, pd_msg->payload[0]);
 
 #ifdef CONFIG_USB_PD_POSTPONE_FIRST_VDM
-		postpone_vdm_event(tcpc);
-		mutex_unlock(&tcpc->access_lock);
+		postpone_vdm_event(tcpc_dev);
+		mutex_unlock(&tcpc_dev->access_lock);
 		return true;
 #endif	/* CONFIG_USB_PD_POSTPONE_FIRST_VDM */
 	}
 
-	atomic_inc(&tcpc->pending_event);
-	wake_up(&tcpc->event_wait_que);
-	mutex_unlock(&tcpc->access_lock);
+	atomic_inc(&tcpc_dev->pending_event); /* do not really wake up process*/
+	wake_up_interruptible(&tcpc_dev->event_loop_wait_que);
+	mutex_unlock(&tcpc_dev->access_lock);
 
 	return true;
 }
 
-bool pd_put_last_vdm_event(struct tcpc_device *tcpc)
+bool pd_put_last_vdm_event(struct tcpc_device *tcpc_dev)
 {
-	struct pd_msg *pd_msg = &tcpc->pd_last_vdm_msg;
-	struct pd_event *vdm_event = &tcpc->pd_vdm_event;
+	struct pd_msg *pd_msg = &tcpc_dev->pd_last_vdm_msg;
+	struct pd_event *vdm_event = &tcpc_dev->pd_vdm_event;
 
-	mutex_lock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
 
-	tcpc->pd_pending_vdm_discard = true;
-	atomic_inc(&tcpc->pending_event);
-	wake_up(&tcpc->event_wait_que);
+	tcpc_dev->pd_pending_vdm_discard = true;
+	atomic_inc(&tcpc_dev->pending_event); /* do not really wake up process*/
+	wake_up_interruptible(&tcpc_dev->event_loop_wait_que);
 
 	/* If the last VDM event isn't INIT event, don't put it again */
-	if (!reset_pe_vdm_state(tcpc, pd_msg->payload[0])) {
-		mutex_unlock(&tcpc->access_lock);
+	if (!reset_pe_vdm_state(tcpc_dev, pd_msg->payload[0])) {
+		mutex_unlock(&tcpc_dev->access_lock);
 		return true;
 	}
 
 	vdm_event->event_type = PD_EVT_HW_MSG;
 	vdm_event->msg = PD_HW_RETRY_VDM;
 
-	if (tcpc->pd_pending_vdm_event)
-		__pd_free_event(tcpc, &tcpc->pd_vdm_event);
+	if (tcpc_dev->pd_pending_vdm_event)
+		__pd_free_event(tcpc_dev, &tcpc_dev->pd_vdm_event);
 
-	vdm_event->pd_msg = __pd_alloc_msg(tcpc);
+	vdm_event->pd_msg = __pd_alloc_msg(tcpc_dev);
 
 	if (vdm_event->pd_msg == NULL) {
-		mutex_unlock(&tcpc->access_lock);
+		mutex_unlock(&tcpc_dev->access_lock);
 		return false;
 	}
 
 	*vdm_event->pd_msg = *pd_msg;
-	tcpc->pd_pending_vdm_event = true;
-	tcpc->pd_postpone_vdm_timeout = true;
+	tcpc_dev->pd_pending_vdm_event = true;
+	tcpc_dev->pd_postpone_vdm_timeout = true;
 
 #ifdef CONFIG_USB_PD_POSTPONE_RETRY_VDM
-	postpone_vdm_event(tcpc);
+	postpone_vdm_event(tcpc_dev);
 #endif	/* CONFIG_USB_PD_POSTPONE_RETRY_VDM */
 
-	mutex_unlock(&tcpc->access_lock);
+	mutex_unlock(&tcpc_dev->access_lock);
 	return true;
 }
 
 /*----------------------------------------------------------------------------*/
 
 static bool __pd_get_deferred_tcp_event(
-	struct tcpc_device *tcpc, struct tcp_dpm_event *tcp_event)
+	struct tcpc_device *tcpc_dev, struct tcp_dpm_event *tcp_event)
 {
 	int index = 0;
 
-	if (tcpc->tcp_event_count <= 0)
+	if (tcpc_dev->tcp_event_count <= 0)
 		return false;
 
-	tcpc->tcp_event_count--;
+	tcpc_dev->tcp_event_count--;
 
 	*tcp_event =
-		tcpc->tcp_event_ring_buffer[tcpc->tcp_event_head_index];
+		tcpc_dev->tcp_event_ring_buffer[tcpc_dev->tcp_event_head_index];
 
-	if (tcpc->tcp_event_count) {
-		index = tcpc->tcp_event_head_index + 1;
+	if (tcpc_dev->tcp_event_count) {
+		index = tcpc_dev->tcp_event_head_index + 1;
 		index %= TCP_EVENT_BUF_SIZE;
 	}
-	tcpc->tcp_event_head_index = index;
+	tcpc_dev->tcp_event_head_index = index;
 	return true;
 }
 
 bool pd_get_deferred_tcp_event(
-	struct tcpc_device *tcpc, struct tcp_dpm_event *tcp_event)
+	struct tcpc_device *tcpc_dev, struct tcp_dpm_event *tcp_event)
 {
 	bool ret;
 
-	mutex_lock(&tcpc->access_lock);
-	ret = __pd_get_deferred_tcp_event(tcpc, tcp_event);
+	mutex_lock(&tcpc_dev->access_lock);
+	ret = __pd_get_deferred_tcp_event(tcpc_dev, tcp_event);
+	mutex_unlock(&tcpc_dev->access_lock);
+
 #ifdef CONFIG_USB_PD_REV30
 #ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
-	if (tcpc->tcp_event_count)
-		tcpc_restart_timer(tcpc, PD_TIMER_DEFERRED_EVT);
+	if (tcpc_dev->tcp_event_count)
+		tcpc_restart_timer(tcpc_dev, PD_TIMER_DEFERRED_EVT);
 	else
-		tcpc_disable_timer(tcpc, PD_TIMER_DEFERRED_EVT);
+		tcpc_disable_timer(tcpc_dev, PD_TIMER_DEFERRED_EVT);
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
 #endif	/* CONFIG_USB_PD_REV30 */
-	mutex_unlock(&tcpc->access_lock);
 
 	return ret;
 }
 
 static bool __pd_put_deferred_tcp_event(
-	struct tcpc_device *tcpc, const struct tcp_dpm_event *tcp_event)
+	struct tcpc_device *tcpc_dev, const struct tcp_dpm_event *tcp_event)
 {
 	int index;
 
-	index = (tcpc->tcp_event_head_index + tcpc->tcp_event_count);
+	index = (tcpc_dev->tcp_event_head_index + tcpc_dev->tcp_event_count);
 	index %= TCP_EVENT_BUF_SIZE;
 
-	tcpc->tcp_event_count++;
-	tcpc->tcp_event_ring_buffer[index] = *tcp_event;
+	tcpc_dev->tcp_event_count++;
+	tcpc_dev->tcp_event_ring_buffer[index] = *tcp_event;
 
-	atomic_inc(&tcpc->pending_event);
-	wake_up(&tcpc->event_wait_que);
+	atomic_inc(&tcpc_dev->pending_event); /* do not really wake up process*/
+	wake_up_interruptible(&tcpc_dev->event_loop_wait_que);
 	return true;
 }
 
 bool pd_put_deferred_tcp_event(
-	struct tcpc_device *tcpc, const struct tcp_dpm_event *tcp_event)
+	struct tcpc_device *tcpc_dev, const struct tcp_dpm_event *tcp_event)
 {
-	bool ret = true;
-	struct pd_port *pd_port = &tcpc->pd_port;
-
-	mutex_lock(&pd_port->pd_lock);
-	mutex_lock(&tcpc->access_lock);
+	bool ret;
+	struct pd_port *pd_port = &tcpc_dev->pd_port;
 
-	if (!tcpc->pd_pe_running || tcpc->pd_wait_pe_idle) {
-		PD_ERR("pd_put_tcp_event failed0\n");
-		ret = false;
-		goto unlock_out;
+	if (!tcpc_dev->pd_pe_running || tcpc_dev->pd_wait_pe_idle) {
+		PD_ERR("pd_put_tcp_event failed0\r\n");
+		return false;
 	}
 
-	if (tcpc->tcp_event_count >= TCP_EVENT_BUF_SIZE) {
-		PD_ERR("pd_put_tcp_event failed1\n");
-		ret = false;
-		goto unlock_out;
+	if (tcpc_dev->tcp_event_count >= TCP_EVENT_BUF_SIZE) {
+		PD_ERR("pd_put_tcp_event failed1\r\n");
+		return false;
 	}
 
-	if (tcpc->pd_wait_hard_reset_complete) {
-		PD_ERR("pd_put_tcp_event failed2\n");
-		ret = false;
-		goto unlock_out;
+	if (tcpc_dev->pd_wait_hard_reset_complete) {
+		PD_ERR("pd_put_tcp_event failed2\r\n");
+		return false;
 	}
 
+#ifdef CONFIG_USB_PD_REV30
+#ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
+	if (tcpc_dev->tcp_event_count == 0)
+		tcpc_enable_timer(tcpc_dev, PD_TIMER_DEFERRED_EVT);
+#endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
+#endif	/* CONFIG_USB_PD_REV30 */
+
+	mutex_lock(&pd_port->pd_lock);
+
 	switch (tcp_event->event_id) {
 	case TCP_DPM_EVT_DISCOVER_CABLE:
 	case TCP_DPM_EVT_CABLE_SOFTRESET:
@@ -536,20 +518,16 @@ bool pd_put_deferred_tcp_event(
 		break;
 	}
 
-	ret = __pd_put_deferred_tcp_event(tcpc, tcp_event);
-#ifdef CONFIG_USB_PD_REV30
+	mutex_lock(&tcpc_dev->access_lock);
+	ret = __pd_put_deferred_tcp_event(tcpc_dev, tcp_event);
+	mutex_unlock(&tcpc_dev->access_lock);
+
 #ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
 	if (ret)
 		pd_port->pe_data.pd_traffic_idle = false;
-	if (tcpc->tcp_event_count == 1)
-		tcpc_enable_timer(tcpc, PD_TIMER_DEFERRED_EVT);
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
-#endif	/* CONFIG_USB_PD_REV30 */
 
 	dpm_reaction_set_ready_once(pd_port);
-
-unlock_out:
-	mutex_unlock(&tcpc->access_lock);
 	mutex_unlock(&pd_port->pd_lock);
 
 	return ret;
@@ -568,7 +546,7 @@ void pd_notify_tcp_vdm_event_2nd_result(struct pd_port *pd_port, uint8_t ret)
 		return;
 
 	if (tcp_event->event_cb != NULL)
-		tcp_event->event_cb(pd_port->tcpc, ret, tcp_event);
+		tcp_event->event_cb(pd_port->tcpc_dev, ret, tcp_event);
 
 	pd_port->tcp_event_id_2nd = TCP_DPM_EVT_UNKONW;
 #endif	/* CONFIG_USB_PD_TCPM_CB_2ND */
@@ -578,7 +556,6 @@ void pd_notify_tcp_event_2nd_result(struct pd_port *pd_port, int ret)
 {
 #ifdef CONFIG_USB_PD_TCPM_CB_2ND
 	struct tcp_dpm_event *tcp_event = &pd_port->tcp_event;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (pd_port->tcp_event_id_2nd  == TCP_DPM_EVT_UNKONW)
 		return;
@@ -607,11 +584,11 @@ void pd_notify_tcp_event_2nd_result(struct pd_port *pd_port, int ret)
 		break;
 	}
 
-	TCPC_DBG2("tcp_event_2nd:evt%d=%d\n",
+	TCPC_DBG2("tcp_event_2nd:evt%d=%d\r\n",
 		pd_port->tcp_event_id_2nd, ret);
 
 	if (tcp_event->event_cb != NULL)
-		tcp_event->event_cb(tcpc, ret, tcp_event);
+		tcp_event->event_cb(pd_port->tcpc_dev, ret, tcp_event);
 
 	pd_port->tcp_event_id_2nd = TCP_DPM_EVT_UNKONW;
 #endif	/* CONFIG_USB_PD_TCPM_CB_2ND */
@@ -621,12 +598,11 @@ void pd_notify_tcp_event_1st_result(struct pd_port *pd_port, int ret)
 {
 	bool cb = true;
 	struct tcp_dpm_event *tcp_event = &pd_port->tcp_event;
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
 	if (pd_port->tcp_event_id_1st == TCP_DPM_EVT_UNKONW)
 		return;
 
-	TCPC_DBG2("tcp_event_1st:evt%d=%d\n",
+	TCPC_DBG2("tcp_event_1st:evt%d=%d\r\n",
 		pd_port->tcp_event_id_1st, ret);
 
 #ifdef CONFIG_USB_PD_TCPM_CB_2ND
@@ -637,70 +613,70 @@ void pd_notify_tcp_event_1st_result(struct pd_port *pd_port, int ret)
 #endif	/* CONFIG_USB_PD_TCPM_CB_2ND */
 
 	if (cb && tcp_event->event_cb != NULL)
-		tcp_event->event_cb(tcpc, ret, tcp_event);
+		tcp_event->event_cb(pd_port->tcpc_dev, ret, tcp_event);
 
 	pd_port->tcp_event_id_1st = TCP_DPM_EVT_UNKONW;
 }
 
 static void __tcp_event_buf_reset(
-	struct tcpc_device *tcpc, uint8_t reason)
+	struct tcpc_device *tcpc_dev, uint8_t reason)
 {
 	struct tcp_dpm_event tcp_event;
 
-	pd_notify_tcp_event_2nd_result(&tcpc->pd_port, reason);
+	pd_notify_tcp_event_2nd_result(&tcpc_dev->pd_port, reason);
 
-	while (__pd_get_deferred_tcp_event(tcpc, &tcp_event)) {
+	while (__pd_get_deferred_tcp_event(tcpc_dev, &tcp_event)) {
 		if (tcp_event.event_cb != NULL)
-			tcp_event.event_cb(tcpc, reason, &tcp_event);
+			tcp_event.event_cb(tcpc_dev, reason, &tcp_event);
 	}
 }
 
 void pd_notify_tcp_event_buf_reset(struct pd_port *pd_port, uint8_t reason)
 {
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
 	pd_notify_tcp_event_1st_result(pd_port, reason);
 
-	mutex_lock(&tcpc->access_lock);
-	__tcp_event_buf_reset(tcpc, reason);
-	mutex_unlock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
+	__tcp_event_buf_reset(tcpc_dev, reason);
+	mutex_unlock(&tcpc_dev->access_lock);
 }
 
 /*----------------------------------------------------------------------------*/
 
-static void __pd_event_buf_reset(struct tcpc_device *tcpc, uint8_t reason)
+static void __pd_event_buf_reset(struct tcpc_device *tcpc_dev, uint8_t reason)
 {
 	struct pd_event pd_event;
 
-	tcpc->pd_hard_reset_event_pending = false;
-	while (__pd_get_event(tcpc, &pd_event))
-		__pd_free_event(tcpc, &pd_event);
+	tcpc_dev->pd_hard_reset_event_pending = false;
+	while (__pd_get_event(tcpc_dev, &pd_event))
+		__pd_free_event(tcpc_dev, &pd_event);
 
-	if (tcpc->pd_pending_vdm_event) {
-		__pd_free_event(tcpc, &tcpc->pd_vdm_event);
-		tcpc->pd_pending_vdm_event = false;
+	if (tcpc_dev->pd_pending_vdm_event) {
+		__pd_free_event(tcpc_dev, &tcpc_dev->pd_vdm_event);
+		tcpc_dev->pd_pending_vdm_event = false;
 	}
 
-	tcpc->pd_pending_vdm_reset = false;
-	tcpc->pd_pending_vdm_good_crc = false;
-	tcpc->pd_pending_vdm_attention = false;
-	tcpc->pd_pending_vdm_discard = false;
+	tcpc_dev->pd_pending_vdm_reset = false;
+	tcpc_dev->pd_pending_vdm_good_crc = false;
+	tcpc_dev->pd_pending_vdm_attention = false;
+	tcpc_dev->pd_pending_vdm_discard = false;
 
-	__tcp_event_buf_reset(tcpc, reason);
-	/* PD_BUG_ON(tcpc->pd_msg_buffer_allocated != 0); */
+	__tcp_event_buf_reset(tcpc_dev, reason);
+	/* PD_BUG_ON(tcpc_dev->pd_msg_buffer_allocated != 0); */
 }
 
-void pd_event_buf_reset(struct tcpc_device *tcpc)
+void pd_event_buf_reset(struct tcpc_device *tcpc_dev)
 {
-	mutex_lock(&tcpc->access_lock);
-	__pd_event_buf_reset(tcpc, TCP_DPM_RET_DROP_CC_DETACH);
-	mutex_unlock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
+	__pd_event_buf_reset(tcpc_dev, TCP_DPM_RET_DROP_CC_DETACH);
+	mutex_unlock(&tcpc_dev->access_lock);
 }
 
 /*----------------------------------------------------------------------------*/
 
 static inline bool __pd_put_hw_event(
-	struct tcpc_device *tcpc, uint8_t hw_event)
+	struct tcpc_device *tcpc_dev, uint8_t hw_event)
 {
 	struct pd_event evt = {
 		.event_type = PD_EVT_HW_MSG,
@@ -708,11 +684,11 @@ static inline bool __pd_put_hw_event(
 		.pd_msg = NULL,
 	};
 
-	return __pd_put_event(tcpc, &evt, false);
+	return __pd_put_event(tcpc_dev, &evt, false);
 }
 
 static inline bool __pd_put_pe_event(
-	struct tcpc_device *tcpc, uint8_t pe_event)
+	struct tcpc_device *tcpc_dev, uint8_t pe_event)
 {
 	struct pd_event evt = {
 		.event_type = PD_EVT_PE_MSG,
@@ -720,11 +696,11 @@ static inline bool __pd_put_pe_event(
 		.pd_msg = NULL,
 	};
 
-	return __pd_put_event(tcpc, &evt, false);
+	return __pd_put_event(tcpc_dev, &evt, false);
 }
 
-bool __pd_put_cc_attached_event(
-		struct tcpc_device *tcpc, uint8_t type)
+bool pd_put_cc_attached_event(
+		struct tcpc_device *tcpc_dev, uint8_t type)
 {
 	struct pd_event evt = {
 		.event_type = PD_EVT_HW_MSG,
@@ -733,130 +709,100 @@ bool __pd_put_cc_attached_event(
 		.pd_msg = NULL,
 	};
 
-	switch (type) {
+	switch (tcpc_dev->typec_attach_new) {
 	case TYPEC_ATTACHED_SNK:
 	case TYPEC_ATTACHED_SRC:
+		tcpc_dev->pd_pe_running = true;
+		tcpc_dev->pd_wait_pe_idle = false;
+		break;
+#ifdef CONFIG_TYPEC_CAP_DBGACC_SNK
 	case TYPEC_ATTACHED_DBGACC_SNK:
-		tcpc->pd_pe_running = true;
-		tcpc->pd_wait_pe_idle = false;
+		tcpc_dev->pd_pe_running = true;
+		tcpc_dev->pd_wait_pe_idle = false;
 		break;
+#endif	/* CONFIG_TYPEC_CAP_DBGACC_SNK */
 	default:
 		break;
 	}
 
-	return __pd_put_event(tcpc, &evt, false);
-}
-
-bool pd_put_cc_attached_event(
-		struct tcpc_device *tcpc, uint8_t type)
-{
-	bool ret = false;
-
-	mutex_lock(&tcpc->access_lock);
-
-#ifdef CONFIG_USB_POWER_DELIVERY
-#ifdef CONFIG_USB_PD_WAIT_BC12
-	if ((type == TYPEC_ATTACHED_SNK || type == TYPEC_ATTACHED_DBGACC_SNK) &&
-		mt_get_charger_type() == CHARGER_UNKNOWN) {
-		tcpc->pd_wait_bc12_count = 1;
-		tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_PD_WAIT_BC12);
-		mutex_unlock(&tcpc->access_lock);
-		return ret;
-	}
-	tcpc->pd_wait_bc12_count = 0;
-	tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_PD_WAIT_BC12);
-#endif /* CONFIG_USB_PD_WAIT_BC12 */
-#endif /* CONFIG_USB_POWER_DELIVERY */
-
-	ret = __pd_put_cc_attached_event(tcpc, type);
-
-	mutex_unlock(&tcpc->access_lock);
-
-	return ret;
+	return pd_put_event(tcpc_dev, &evt, false);
 }
 
-void pd_put_cc_detached_event(struct tcpc_device *tcpc)
+void pd_put_cc_detached_event(struct tcpc_device *tcpc_dev)
 {
-	mutex_lock(&tcpc->access_lock);
-
-#ifdef CONFIG_USB_POWER_DELIVERY
-#ifdef CONFIG_USB_PD_WAIT_BC12
-	tcpc->pd_wait_bc12_count = 0;
-	tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_PD_WAIT_BC12);
-#endif /* CONFIG_USB_PD_WAIT_BC12 */
-#endif /* CONFIG_USB_POWER_DELIVERY */
+	mutex_lock(&tcpc_dev->access_lock);
 
 	tcpci_notify_hard_reset_state(
-		tcpc, TCP_HRESET_RESULT_FAIL);
+		tcpc_dev, TCP_HRESET_RESULT_FAIL);
 
-	__pd_event_buf_reset(tcpc, TCP_DPM_RET_DROP_CC_DETACH);
-	__pd_put_hw_event(tcpc, PD_HW_CC_DETACHED);
+	__pd_event_buf_reset(tcpc_dev, TCP_DPM_RET_DROP_CC_DETACH);
+	__pd_put_hw_event(tcpc_dev, PD_HW_CC_DETACHED);
 
-	tcpc->pd_wait_pe_idle = true;
-	tcpc->pd_pe_running = false;
-	tcpc->pd_wait_pr_swap_complete = false;
-	tcpc->pd_hard_reset_event_pending = false;
-	tcpc->pd_wait_vbus_once = PD_WAIT_VBUS_DISABLE;
-	tcpc->pd_bist_mode = PD_BIST_MODE_DISABLE;
-	tcpc->pd_ping_event_pending = false;
+	tcpc_dev->pd_wait_pe_idle = true;
+	tcpc_dev->pd_pe_running = false;
+	tcpc_dev->pd_wait_pr_swap_complete = false;
+	tcpc_dev->pd_hard_reset_event_pending = false;
+	tcpc_dev->pd_wait_vbus_once = PD_WAIT_VBUS_DISABLE;
+	tcpc_dev->pd_bist_mode = PD_BIST_MODE_DISABLE;
+	tcpc_dev->pd_ping_event_pending = false;
 
 #ifdef CONFIG_USB_PD_DIRECT_CHARGE
-	tcpc->pd_during_direct_charge = false;
+	tcpc_dev->pd_during_direct_charge = false;
 #endif	/* CONFIG_USB_PD_DIRECT_CHARGE */
 
 #ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
-	tcpc->pd_discard_pending = false;
+	tcpc_dev->pd_discard_pending = false;
 #endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
 
-	mutex_unlock(&tcpc->access_lock);
+	mutex_unlock(&tcpc_dev->access_lock);
 }
 
-void pd_put_recv_hard_reset_event(struct tcpc_device *tcpc)
+void pd_put_recv_hard_reset_event(struct tcpc_device *tcpc_dev)
 {
-	mutex_lock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
 
 	tcpci_notify_hard_reset_state(
-		tcpc, TCP_HRESET_SIGNAL_RECV);
+		tcpc_dev, TCP_HRESET_SIGNAL_RECV);
 
-	tcpc->pd_transmit_state = PD_TX_STATE_HARD_RESET;
+	tcpc_dev->pd_transmit_state = PD_TX_STATE_HARD_RESET;
 
-	if ((!tcpc->pd_hard_reset_event_pending) &&
-		(!tcpc->pd_wait_pe_idle) &&
-		tcpc->pd_pe_running) {
-		__pd_event_buf_reset(tcpc, TCP_DPM_RET_DROP_RECV_HRESET);
-		__pd_put_hw_event(tcpc, PD_HW_RECV_HARD_RESET);
-		tcpc->pd_bist_mode = PD_BIST_MODE_DISABLE;
-		tcpc->pd_hard_reset_event_pending = true;
-		tcpc->pd_ping_event_pending = false;
+	if ((!tcpc_dev->pd_hard_reset_event_pending) &&
+		(!tcpc_dev->pd_wait_pe_idle) &&
+		tcpc_dev->pd_pe_running) {
+		__pd_event_buf_reset(tcpc_dev, TCP_DPM_RET_DROP_RECV_HRESET);
+		__pd_put_hw_event(tcpc_dev, PD_HW_RECV_HARD_RESET);
+		tcpc_dev->pd_bist_mode = PD_BIST_MODE_DISABLE;
+		tcpc_dev->pd_hard_reset_event_pending = true;
+		tcpc_dev->pd_ping_event_pending = false;
 
 #ifdef CONFIG_USB_PD_DIRECT_CHARGE
-		tcpc->pd_during_direct_charge = false;
+		tcpc_dev->pd_during_direct_charge = false;
 #endif	/* CONFIG_USB_PD_DIRECT_CHARGE */
 	}
 
 #ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
-	tcpc->pd_discard_pending = false;
+	tcpc_dev->pd_discard_pending = false;
 #endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
 
-	mutex_unlock(&tcpc->access_lock);
+	mutex_unlock(&tcpc_dev->access_lock);
 }
 
-void pd_put_sent_hard_reset_event(struct tcpc_device *tcpc)
+void pd_put_sent_hard_reset_event(struct tcpc_device *tcpc_dev)
 {
-	mutex_lock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
 
-	if (tcpc->pd_wait_hard_reset_complete)
-		__pd_event_buf_reset(tcpc, TCP_DPM_RET_DROP_SENT_HRESET);
+	if (tcpc_dev->pd_wait_hard_reset_complete)
+		__pd_event_buf_reset(tcpc_dev, TCP_DPM_RET_DROP_SENT_HRESET);
 	else
-		TCPC_DBG2("[HReset] Unattached\n");
+		TCPC_DBG2("[HReset] Unattached\r\n");
 
-	tcpc->pd_transmit_state = PD_TX_STATE_GOOD_CRC;
-	__pd_put_pe_event(tcpc, PD_PE_HARD_RESET_COMPLETED);
+	tcpc_dev->pd_transmit_state = PD_TX_STATE_GOOD_CRC;
+	__pd_put_pe_event(tcpc_dev, PD_PE_HARD_RESET_COMPLETED);
 
-	mutex_unlock(&tcpc->access_lock);
+	mutex_unlock(&tcpc_dev->access_lock);
 }
 
-bool pd_put_pd_msg_event(struct tcpc_device *tcpc, struct pd_msg *pd_msg)
+bool pd_put_pd_msg_event(struct tcpc_device *tcpc_dev, struct pd_msg *pd_msg)
 {
 	uint32_t cnt, cmd, extend;
 
@@ -874,30 +820,30 @@ bool pd_put_pd_msg_event(struct tcpc_device *tcpc, struct pd_msg *pd_msg)
 	extend = PD_HEADER_EXT(pd_msg->msg_hdr);
 
 	/* bist mode */
-	mutex_lock(&tcpc->access_lock);
-	if (tcpc->pd_bist_mode != PD_BIST_MODE_DISABLE) {
-		TCPC_DBG2("BIST_MODE_RX\n");
-		__pd_free_event(tcpc, &evt);
-		mutex_unlock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
+	if (tcpc_dev->pd_bist_mode != PD_BIST_MODE_DISABLE) {
+		TCPC_DBG2("BIST_MODE_RX\r\n");
+		__pd_free_event(tcpc_dev, &evt);
+		mutex_unlock(&tcpc_dev->access_lock);
 		return 0;
 	}
 
 #ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
-	if (tcpc->pd_discard_pending &&
+	if (tcpc_dev->pd_discard_pending &&
 		(pd_msg->frame_type == TCPC_TX_SOP) &&
-		(tcpc->tcpc_flags & TCPC_FLAGS_RETRY_CRC_DISCARD)) {
+		(tcpc_dev->tcpc_flags & TCPC_FLAGS_RETRY_CRC_DISCARD)) {
 
 		discard_pending = true;
-		tcpc->pd_discard_pending = false;
+		tcpc_dev->pd_discard_pending = false;
 
 		if ((cmd == PD_CTRL_GOOD_CRC) && (cnt == 0)) {
-			TCPC_DBG2("RETRANSMIT\n");
-			__pd_free_event(tcpc, &evt);
-			mutex_unlock(&tcpc->access_lock);
+			TCPC_DBG2("RETRANSMIT\r\n");
+			__pd_free_event(tcpc_dev, &evt);
+			mutex_unlock(&tcpc_dev->access_lock);
 
 			/* TODO: check it later */
-			tcpc_disable_timer(tcpc, PD_TIMER_DISCARD);
-			tcpci_retransmit(tcpc);
+			tcpc_disable_timer(tcpc_dev, PD_TIMER_DISCARD);
+			tcpci_retransmit(tcpc_dev);
 			return 0;
 		}
 	}
@@ -906,166 +852,170 @@ bool pd_put_pd_msg_event(struct tcpc_device *tcpc, struct pd_msg *pd_msg)
 #ifdef CONFIG_USB_PD_DROP_REPEAT_PING
 	if (cnt == 0 && cmd == PD_CTRL_PING) {
 		/* reset ping_test_mode only if cc_detached */
-		if (!tcpc->pd_ping_event_pending) {
-			TCPC_INFO("ping_test_mode\n");
-			tcpc->pd_ping_event_pending = true;
-			tcpci_set_bist_test_mode(tcpc, true);
+		if (!tcpc_dev->pd_ping_event_pending) {
+			TCPC_INFO("ping_test_mode\r\n");
+			tcpc_dev->pd_ping_event_pending = true;
+			tcpci_set_bist_test_mode(tcpc_dev, true);
 		} else {
-			__pd_free_event(tcpc, &evt);
-			mutex_unlock(&tcpc->access_lock);
+			__pd_free_event(tcpc_dev, &evt);
+			mutex_unlock(&tcpc_dev->access_lock);
 			return 0;
 		}
 	}
 #endif	/* CONFIG_USB_PD_DROP_REPEAT_PING */
 
 	if (cnt != 0 && cmd == PD_DATA_BIST && extend == 0)
-		tcpc->pd_bist_mode = PD_BIST_MODE_EVENT_PENDING;
+		tcpc_dev->pd_bist_mode = PD_BIST_MODE_EVENT_PENDING;
 
-	mutex_unlock(&tcpc->access_lock);
+	mutex_unlock(&tcpc_dev->access_lock);
 
 #ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
 	if (discard_pending) {
-		tcpc_disable_timer(tcpc, PD_TIMER_DISCARD);
-		pd_put_hw_event(tcpc, PD_HW_TX_DISCARD);
+		tcpc_disable_timer(tcpc_dev, PD_TIMER_DISCARD);
+		pd_put_hw_event(tcpc_dev, PD_HW_TX_FAILED);
 	}
 #endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
 
 	if (cnt != 0 && cmd == PD_DATA_VENDOR_DEF)
-		return pd_put_vdm_event(tcpc, &evt, true);
+		return pd_put_vdm_event(tcpc_dev, &evt, true);
 
-	if (!pd_put_event(tcpc, &evt, true)) {
-		pd_free_event(tcpc, &evt);
+	if (!pd_put_event(tcpc_dev, &evt, true)) {
+		pd_free_event(tcpc_dev, &evt);
 		return false;
 	}
 
 	return true;
 }
 
-static void pd_report_vbus_present(struct tcpc_device *tcpc)
+static void pd_report_vbus_present(struct tcpc_device *tcpc_dev)
 {
-	tcpc->pd_wait_vbus_once = PD_WAIT_VBUS_DISABLE;
-	__pd_put_hw_event(tcpc, PD_HW_VBUS_PRESENT);
+	tcpc_dev->pd_wait_vbus_once = PD_WAIT_VBUS_DISABLE;
+	__pd_put_hw_event(tcpc_dev, PD_HW_VBUS_PRESENT);
 }
 
-void pd_put_vbus_changed_event(struct tcpc_device *tcpc, bool from_ic)
+void pd_put_vbus_changed_event(struct tcpc_device *tcpc_dev, bool from_ic)
 {
 	int vbus_valid;
 	bool postpone_vbus_present = false;
 
-	mutex_lock(&tcpc->access_lock);
-	vbus_valid = tcpci_check_vbus_valid(tcpc);
+	mutex_lock(&tcpc_dev->access_lock);
+	vbus_valid = tcpci_check_vbus_valid(tcpc_dev);
 
-	switch (tcpc->pd_wait_vbus_once) {
+	switch (tcpc_dev->pd_wait_vbus_once) {
 	case PD_WAIT_VBUS_VALID_ONCE:
 		if (vbus_valid) {
 #if CONFIG_USB_PD_VBUS_PRESENT_TOUT
 			postpone_vbus_present = from_ic;
 #endif	/* CONFIG_USB_PD_VBUS_PRESENT_TOUT */
 			if (!postpone_vbus_present)
-				pd_report_vbus_present(tcpc);
+				pd_report_vbus_present(tcpc_dev);
 		}
 		break;
 
 	case PD_WAIT_VBUS_INVALID_ONCE:
 		if (!vbus_valid) {
-			tcpc->pd_wait_vbus_once = PD_WAIT_VBUS_DISABLE;
-			__pd_put_hw_event(tcpc, PD_HW_VBUS_ABSENT);
+			tcpc_dev->pd_wait_vbus_once = PD_WAIT_VBUS_DISABLE;
+			__pd_put_hw_event(tcpc_dev, PD_HW_VBUS_ABSENT);
 		}
 		break;
 	}
-	mutex_unlock(&tcpc->access_lock);
+	mutex_unlock(&tcpc_dev->access_lock);
 
 #if CONFIG_USB_PD_VBUS_PRESENT_TOUT
 	if (postpone_vbus_present)
-		tcpc_enable_timer(tcpc, PD_TIMER_VBUS_PRESENT);
+		tcpc_enable_timer(tcpc_dev, PD_TIMER_VBUS_PRESENT);
 #endif	/* CONFIG_USB_PD_VBUS_PRESENT_TOUT */
 }
 
-void pd_put_vbus_safe0v_event(struct tcpc_device *tcpc)
+void pd_put_vbus_safe0v_event(struct tcpc_device *tcpc_dev)
 {
 #ifdef CONFIG_USB_PD_SAFE0V_TIMEOUT
-	tcpc_disable_timer(tcpc, PD_TIMER_VSAFE0V_TOUT);
+	tcpc_disable_timer(tcpc_dev, PD_TIMER_VSAFE0V_TOUT);
 #endif	/* CONFIG_USB_PD_SAFE0V_TIMEOUT */
 
-	mutex_lock(&tcpc->access_lock);
-	if (tcpc->pd_wait_vbus_once == PD_WAIT_VBUS_SAFE0V_ONCE) {
-		tcpc->pd_wait_vbus_once = PD_WAIT_VBUS_DISABLE;
-		tcpci_enable_force_discharge(tcpc, false, 0);
-		__pd_put_hw_event(tcpc, PD_HW_VBUS_SAFE0V);
+	if (tcpc_dev->pd_wait_vbus_once == PD_WAIT_VBUS_SAFE0V_ONCE)
+		tcpci_disable_force_discharge(tcpc_dev);
+
+	mutex_lock(&tcpc_dev->access_lock);
+	if (tcpc_dev->pd_wait_vbus_once == PD_WAIT_VBUS_SAFE0V_ONCE) {
+		tcpc_dev->pd_wait_vbus_once = PD_WAIT_VBUS_DISABLE;
+		__pd_put_hw_event(tcpc_dev, PD_HW_VBUS_SAFE0V);
 	}
-	mutex_unlock(&tcpc->access_lock);
+	mutex_unlock(&tcpc_dev->access_lock);
 }
 
-void pd_put_vbus_stable_event(struct tcpc_device *tcpc)
+void pd_put_vbus_stable_event(struct tcpc_device *tcpc_dev)
 {
-	mutex_lock(&tcpc->access_lock);
-	if (tcpc->pd_wait_vbus_once == PD_WAIT_VBUS_STABLE_ONCE) {
-		tcpc->pd_wait_vbus_once = PD_WAIT_VBUS_DISABLE;
 #ifdef CONFIG_USB_PD_SRC_HIGHCAP_POWER
-		tcpci_enable_force_discharge(tcpc, false, 0);
+	if (tcpc_dev->pd_wait_vbus_once == PD_WAIT_VBUS_STABLE_ONCE)
+		tcpci_disable_force_discharge(tcpc_dev);
 #endif	/* CONFIG_USB_PD_SRC_HIGHCAP_POWER */
-		__pd_put_hw_event(tcpc, PD_HW_VBUS_STABLE);
+
+	mutex_lock(&tcpc_dev->access_lock);
+	if (tcpc_dev->pd_wait_vbus_once == PD_WAIT_VBUS_STABLE_ONCE) {
+		tcpc_dev->pd_wait_vbus_once = PD_WAIT_VBUS_DISABLE;
+		__pd_put_hw_event(tcpc_dev, PD_HW_VBUS_STABLE);
 	}
-	mutex_unlock(&tcpc->access_lock);
+	mutex_unlock(&tcpc_dev->access_lock);
 }
 
-void pd_put_vbus_present_event(struct tcpc_device *tcpc)
+void pd_put_vbus_present_event(struct tcpc_device *tcpc_dev)
 {
-	mutex_lock(&tcpc->access_lock);
-	pd_report_vbus_present(tcpc);
-	mutex_unlock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
+	pd_report_vbus_present(tcpc_dev);
+	mutex_unlock(&tcpc_dev->access_lock);
 }
 
 /* ---- PD Notify TCPC ---- */
 
 void pd_try_put_pe_idle_event(struct pd_port *pd_port)
 {
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
-	mutex_lock(&tcpc->access_lock);
-	if (tcpc->pd_transmit_state < PD_TX_STATE_WAIT)
-		__pd_put_pe_event(tcpc, PD_PE_IDLE);
-	mutex_unlock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
+	if (tcpc_dev->pd_transmit_state < PD_TX_STATE_WAIT)
+		__pd_put_pe_event(tcpc_dev, PD_PE_IDLE);
+	mutex_unlock(&tcpc_dev->access_lock);
 }
 
 void pd_notify_pe_idle(struct pd_port *pd_port)
 {
 	bool notify_pe_idle = false;
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
-	mutex_lock(&tcpc->access_lock);
-	if (tcpc->pd_wait_pe_idle) {
+	mutex_lock(&tcpc_dev->access_lock);
+	if (tcpc_dev->pd_wait_pe_idle) {
 		notify_pe_idle = true;
-		tcpc->pd_wait_pe_idle = false;
+		tcpc_dev->pd_wait_pe_idle = false;
 	}
 
-	tcpc->pd_pe_running = false;
-	mutex_unlock(&tcpc->access_lock);
+	tcpc_dev->pd_pe_running = false;
+	mutex_unlock(&tcpc_dev->access_lock);
 
 	pd_update_connect_state(pd_port, PD_CONNECT_NONE);
 
 	if (notify_pe_idle)
-		tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_PE_IDLE);
+		tcpc_enable_timer(tcpc_dev, TYPEC_RT_TIMER_PE_IDLE);
 }
 
 void pd_notify_pe_wait_vbus_once(struct pd_port *pd_port, int wait_evt)
 {
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
-	mutex_lock(&tcpc->access_lock);
-	tcpc->pd_wait_vbus_once = wait_evt;
-	mutex_unlock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
+	tcpc_dev->pd_wait_vbus_once = wait_evt;
+	mutex_unlock(&tcpc_dev->access_lock);
 
 	switch (wait_evt) {
 	case PD_WAIT_VBUS_VALID_ONCE:
 	case PD_WAIT_VBUS_INVALID_ONCE:
-		pd_put_vbus_changed_event(tcpc, false);
+		pd_put_vbus_changed_event(tcpc_dev, false);
 		break;
 
 	case PD_WAIT_VBUS_SAFE0V_ONCE:
 #ifdef CONFIG_TCPC_VSAFE0V_DETECT
-		if (tcpci_check_vsafe0v(tcpc, true)) {
-			pd_put_vbus_safe0v_event(tcpc);
+		if (tcpci_check_vsafe0v(tcpc_dev, true)) {
+			pd_put_vbus_safe0v_event(tcpc_dev);
 			break;
 		}
 #else
@@ -1076,189 +1026,170 @@ void pd_notify_pe_wait_vbus_once(struct pd_port *pd_port, int wait_evt)
 		pd_enable_timer(pd_port, PD_TIMER_VSAFE0V_TOUT);
 #endif	/* CONFIG_USB_PD_SAFE0V_TIMEOUT */
 
-		mutex_lock(&tcpc->access_lock);
-		tcpci_enable_force_discharge(tcpc, true, 0);
-		mutex_unlock(&tcpc->access_lock);
+		tcpci_enable_force_discharge(tcpc_dev, 0);
 		break;
 	}
 }
 
 void pd_notify_pe_error_recovery(struct pd_port *pd_port)
 {
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
-	mutex_lock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
 
 	tcpci_notify_hard_reset_state(
-		tcpc, TCP_HRESET_RESULT_FAIL);
+		tcpc_dev, TCP_HRESET_RESULT_FAIL);
 
-	tcpc->pd_wait_pr_swap_complete = false;
-	__tcp_event_buf_reset(tcpc, TCP_DPM_RET_DROP_ERROR_REOCVERY);
-	mutex_unlock(&tcpc->access_lock);
+	tcpc_dev->pd_wait_pr_swap_complete = false;
+	__tcp_event_buf_reset(tcpc_dev, TCP_DPM_RET_DROP_ERROR_REOCVERY);
+	mutex_unlock(&tcpc_dev->access_lock);
 
-	tcpci_lock_typec(tcpc);
-	tcpc_typec_error_recovery(tcpc);
-	tcpci_unlock_typec(tcpc);
+	tcpc_typec_error_recovery(tcpc_dev);
 }
 
 #ifdef CONFIG_USB_PD_RECV_HRESET_COUNTER
 void pd_notify_pe_over_recv_hreset(struct pd_port *pd_port)
 {
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
-	mutex_lock(&tcpc->access_lock);
-	tcpc->pd_wait_hard_reset_complete = false;
-	tcpc->pd_wait_pr_swap_complete = false;
-	mutex_unlock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
+	tcpc_dev->pd_wait_hard_reset_complete = false;
+	tcpc_dev->pd_wait_pr_swap_complete = false;
+	mutex_unlock(&tcpc_dev->access_lock);
 
 	disable_irq(chip->irq);
-	tcpci_lock_typec(tcpc);
-	tcpci_init(tcpc, true);
-	tcpci_set_cc(tcpc, TYPEC_CC_OPEN);
-	tcpci_unlock_typec(tcpc);
-	tcpci_set_rx_enable(tcpc, PD_RX_CAP_PE_IDLE);
-	tcpc_enable_timer(tcpc, TYPEC_TIMER_ERROR_RECOVERY);
+	tcpci_init(tcpc_dev, true);
+	tcpci_set_cc(tcpc_dev, TYPEC_CC_OPEN);
+	tcpci_set_rx_enable(tcpc_dev, PD_RX_CAP_PE_IDLE);
+	tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_ERROR_RECOVERY);
 	enable_irq_wake(chip->irq);
 }
 #endif	/* CONFIG_USB_PD_RECV_HRESET_COUNTER */
 
 void pd_notify_pe_transit_to_default(struct pd_port *pd_port)
 {
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
 	pd_update_connect_state(pd_port, PD_CONNECT_HARD_RESET);
 
-	mutex_lock(&tcpc->access_lock);
-	tcpc->pd_hard_reset_event_pending = false;
-	tcpc->pd_wait_pr_swap_complete = false;
-	tcpc->pd_bist_mode = PD_BIST_MODE_DISABLE;
+	mutex_lock(&tcpc_dev->access_lock);
+	tcpc_dev->pd_hard_reset_event_pending = false;
+	tcpc_dev->pd_wait_pr_swap_complete = false;
+	tcpc_dev->pd_bist_mode = PD_BIST_MODE_DISABLE;
 
 #ifdef CONFIG_USB_PD_DIRECT_CHARGE
-	tcpc->pd_during_direct_charge = false;
+	tcpc_dev->pd_during_direct_charge = false;
 #endif	/* CONFIG_USB_PD_DIRECT_CHARGE */
-	mutex_unlock(&tcpc->access_lock);
+	mutex_unlock(&tcpc_dev->access_lock);
 }
 
 void pd_notify_pe_hard_reset_completed(struct pd_port *pd_port)
 {
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
-	mutex_lock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
 	tcpci_notify_hard_reset_state(
-		tcpc, TCP_HRESET_RESULT_DONE);
-	mutex_unlock(&tcpc->access_lock);
+		tcpc_dev, TCP_HRESET_RESULT_DONE);
+	mutex_unlock(&tcpc_dev->access_lock);
 }
 
 void pd_notify_pe_send_hard_reset(struct pd_port *pd_port)
 {
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
-	mutex_lock(&tcpc->access_lock);
-	tcpc->pd_transmit_state = PD_TX_STATE_WAIT_HARD_RESET;
-	tcpci_notify_hard_reset_state(tcpc, TCP_HRESET_SIGNAL_SEND);
-	mutex_unlock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
+	tcpc_dev->pd_transmit_state = PD_TX_STATE_WAIT_HARD_RESET;
+	tcpci_notify_hard_reset_state(tcpc_dev, TCP_HRESET_SIGNAL_SEND);
+	mutex_unlock(&tcpc_dev->access_lock);
 }
 
 void pd_notify_pe_execute_pr_swap(struct pd_port *pd_port, bool start_swap)
 {
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
 	pd_port->pe_data.during_swap = start_swap;
-	mutex_lock(&tcpc->access_lock);
-	tcpc->pd_wait_pr_swap_complete = true;
-	mutex_unlock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
+	tcpc_dev->pd_wait_pr_swap_complete = true;
+	mutex_unlock(&tcpc_dev->access_lock);
 }
 
 void pd_notify_pe_cancel_pr_swap(struct pd_port *pd_port)
 {
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
-	if (!tcpc->pd_wait_pr_swap_complete)
+	if (!tcpc_dev->pd_wait_pr_swap_complete)
 		return;
 
 	pd_port->pe_data.during_swap = false;
-	mutex_lock(&tcpc->access_lock);
-	tcpc->pd_wait_pr_swap_complete = false;
-	mutex_unlock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
+	tcpc_dev->pd_wait_pr_swap_complete = false;
+	mutex_unlock(&tcpc_dev->access_lock);
 
 	/*
 	 *	CC_Alert was ignored if pd_wait_pr_swap_complete = true
 	 *	So enable PDDebounce to detect CC_Again after cancel_pr_swap.
 	 */
 
-	tcpc_enable_timer(tcpc, TYPEC_TIMER_PDDEBOUNCE);
+	tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_PDDEBOUNCE);
 
-	if (!tcpci_check_vbus_valid(tcpc)
+	if (!tcpci_check_vbus_valid(tcpc_dev)
 		&& (pd_port->request_v >= 4000)) {
-		TCPC_DBG("cancel_pr_swap_vbus=0\n");
-		pd_put_tcp_pd_event(pd_port, TCP_DPM_EVT_ERROR_RECOVERY,
-				    PD_TCP_FROM_PE);
+		TCPC_DBG("cancel_pr_swap_vbus=0\r\n");
+		pd_put_tcp_pd_event(pd_port, TCP_DPM_EVT_ERROR_RECOVERY);
 	}
 }
 
 void pd_notify_pe_reset_protocol(struct pd_port *pd_port)
 {
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
-	mutex_lock(&tcpc->access_lock);
-	tcpc->pd_wait_pr_swap_complete = false;
-	mutex_unlock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
+	tcpc_dev->pd_wait_pr_swap_complete = false;
+	mutex_unlock(&tcpc_dev->access_lock);
 }
 
 void pd_noitfy_pe_bist_mode(struct pd_port *pd_port, uint8_t mode)
 {
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
-	mutex_lock(&tcpc->access_lock);
-	tcpc->pd_bist_mode = mode;
-	mutex_unlock(&tcpc->access_lock);
-}
-
-bool pd_is_pe_wait_pd_transmit_done(struct pd_port *pd_port)
-{
-	bool tx_wait;
-	struct tcpc_device *tcpc = pd_port->tcpc;
-
-	mutex_lock(&tcpc->access_lock);
-	tx_wait = tcpc->pd_transmit_state == PD_TX_STATE_WAIT_CRC_PD;
-	mutex_unlock(&tcpc->access_lock);
-
-	return tx_wait;
+	mutex_lock(&tcpc_dev->access_lock);
+	tcpc_dev->pd_bist_mode = mode;
+	mutex_unlock(&tcpc_dev->access_lock);
 }
 
 void pd_notify_pe_transmit_msg(
 	struct pd_port *pd_port, uint8_t type)
 {
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
-	mutex_lock(&tcpc->access_lock);
-	tcpc->pd_transmit_state = type;
-	mutex_unlock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
+	tcpc_dev->pd_transmit_state = type;
+	mutex_unlock(&tcpc_dev->access_lock);
 }
 
 void pd_notify_pe_pr_changed(struct pd_port *pd_port)
 {
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
 	/* Check mutex later, actually,
 	 * typec layer will ignore all cc-change during PR-SWAP
 	 */
 
-	/* mutex_lock(&tcpc->access_lock); */
-	tcpc_typec_handle_pe_pr_swap(tcpc);
-	/* mutex_unlock(&tcpc->access_lock); */
+	/* mutex_lock(&tcpc_dev->access_lock); */
+	tcpc_typec_handle_pe_pr_swap(tcpc_dev);
+	/* mutex_unlock(&tcpc_dev->access_lock); */
 }
 
 void pd_notify_pe_snk_explicit_contract(struct pd_port *pd_port)
 {
 #ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
 	struct pe_data *pe_data = &pd_port->pe_data;
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
 	if (pe_data->explicit_contract)
 		return;
 
-	if (tcpc->typec_remote_rp_level == TYPEC_CC_VOLT_SNK_3_0)
+	if (tcpc_dev->typec_remote_rp_level == TYPEC_CC_VOLT_SNK_3_0)
 		pe_data->pd_traffic_control = PD_SINK_TX_OK;
 	else
 		pe_data->pd_traffic_control = PD_SINK_TX_NG;
@@ -1277,7 +1208,7 @@ void pd_notify_pe_src_explicit_contract(struct pd_port *pd_port)
 	uint8_t pull = 0;
 
 	struct pe_data *pe_data = &pd_port->pe_data;
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
 	if (pe_data->explicit_contract) {
 #ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
@@ -1290,7 +1221,7 @@ void pd_notify_pe_src_explicit_contract(struct pd_port *pd_port)
 		return;
 	}
 
-	if (tcpc->typec_local_rp_level == TYPEC_RP_DFT)
+	if (tcpc_dev->typec_local_rp_level == TYPEC_CC_RP_DFT)
 		pull = TYPEC_CC_RP_1_5;
 
 #ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
@@ -1306,17 +1237,14 @@ void pd_notify_pe_src_explicit_contract(struct pd_port *pd_port)
 	}
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
 
-	if (pull) {
-		tcpci_lock_typec(tcpc);
-		tcpci_set_cc(tcpc, pull);
-		tcpci_unlock_typec(tcpc);
-	}
+	if (pull)
+		tcpci_set_cc(tcpc_dev, pull);
 }
 
 #ifdef CONFIG_USB_PD_DIRECT_CHARGE
 void pd_notify_pe_direct_charge(struct pd_port *pd_port, bool en)
 {
-	struct tcpc_device *tcpc = pd_port->tcpc;
+	struct tcpc_device *tcpc_dev = pd_port->tcpc_dev;
 
 #ifdef CONFIG_USB_PD_REV30_PPS_SINK
 	/* TODO: check it later */
@@ -1324,58 +1252,56 @@ void pd_notify_pe_direct_charge(struct pd_port *pd_port, bool en)
 		en = true;
 #endif	/* CONFIG_USB_PD_REV30_PPS_SINK */
 
-	mutex_lock(&tcpc->access_lock);
-	tcpc->pd_during_direct_charge = en;
-	mutex_unlock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
+	tcpc_dev->pd_during_direct_charge = en;
+	mutex_unlock(&tcpc_dev->access_lock);
 }
 #endif	/* CONFIG_USB_PD_DIRECT_CHARGE */
 
 /* ---- init  ---- */
-static int tcpc_event_thread_fn(void *data)
+static int tcpc_event_thread(void *param)
 {
-	struct tcpc_device *tcpc = data;
+	struct tcpc_device *tcpc_dev = param;
 	struct sched_param sch_param = {.sched_priority = MAX_RT_PRIO - 2};
-	int ret = 0;
 
 	/* set_user_nice(current, -20); */
 	/* current->flags |= PF_NOFREEZE;*/
 
-	ret = sched_setscheduler(current, SCHED_FIFO, &sch_param);
-	if (ret != 0) {
-		PD_ERR("sched_setscheduler() error!\n");
-		return ret;
-	}
+	sched_setscheduler(current, SCHED_FIFO, &sch_param);
 
 	while (true) {
-		ret = wait_event_interruptible(tcpc->event_wait_que,
-				atomic_read(&tcpc->pending_event) ||
-				kthread_should_stop());
-		if (kthread_should_stop() || ret) {
-			dev_notice(&tcpc->dev, "%s exits(%d)\n", __func__, ret);
+		wait_event_interruptible(tcpc_dev->event_loop_wait_que,
+				atomic_read(&tcpc_dev->pending_event) |
+				tcpc_dev->event_loop_thead_stop);
+		if (kthread_should_stop() || tcpc_dev->event_loop_thead_stop)
 			break;
-		}
 		do {
-			atomic_dec_if_positive(&tcpc->pending_event);
-		} while (pd_policy_engine_run(tcpc) && !kthread_should_stop());
+			atomic_dec_if_positive(&tcpc_dev->pending_event);
+		} while (pd_policy_engine_run(tcpc_dev));
 	}
 
 	return 0;
 }
 
-int tcpci_event_init(struct tcpc_device *tcpc)
+int tcpci_event_init(struct tcpc_device *tcpc_dev)
 {
-	init_waitqueue_head(&tcpc->event_wait_que);
-	atomic_set(&tcpc->pending_event, 0);
-	tcpc->event_task = kthread_run(tcpc_event_thread_fn, tcpc,
-				       "tcpc_event_%s", tcpc->desc.name);
+	tcpc_dev->event_task = kthread_create(tcpc_event_thread, tcpc_dev,
+			"tcpc_event_%s.%p", dev_name(&tcpc_dev->dev), tcpc_dev);
+	tcpc_dev->event_loop_thead_stop = false;
+
+	init_waitqueue_head(&tcpc_dev->event_loop_wait_que);
+	atomic_set(&tcpc_dev->pending_event, 0);
+	wake_up_process(tcpc_dev->event_task);
 
 	return 0;
 }
 
-int tcpci_event_deinit(struct tcpc_device *tcpc)
+int tcpci_event_deinit(struct tcpc_device *tcpc_dev)
 {
-	if (tcpc->event_task != NULL)
-		kthread_stop(tcpc->event_task);
-
+	if (tcpc_dev->event_task != NULL) {
+		tcpc_dev->event_loop_thead_stop = true;
+		wake_up_interruptible(&tcpc_dev->event_loop_wait_que);
+		kthread_stop(tcpc_dev->event_task);
+	}
 	return 0;
 }
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpci_timer.c b/drivers/misc/mediatek/typec/tcpc/tcpci_timer.c
index 0335acf..06c5230 100644
--- a/drivers/misc/mediatek/typec/tcpc/tcpci_timer.c
+++ b/drivers/misc/mediatek/typec/tcpc/tcpci_timer.c
@@ -69,6 +69,17 @@ static inline uint64_t tcpc_get_timer_enable_mask(struct tcpc_device *tcpc)
 	return data;
 }
 
+static inline void tcpc_reset_timer_enable_mask(struct tcpc_device *tcpc)
+{
+	unsigned long flags;
+
+	down(&tcpc->timer_enable_mask_lock);
+	local_irq_save(flags);
+	tcpc->timer_enable_mask = 0;
+	local_irq_restore(flags);
+	up(&tcpc->timer_enable_mask_lock);
+}
+
 static inline void tcpc_clear_timer_enable_mask(
 	struct tcpc_device *tcpc, int nr)
 {
@@ -128,8 +139,8 @@ static inline void tcpc_set_timer_tick(struct tcpc_device *tcpc, int nr)
 	spin_unlock_irqrestore(&tcpc->timer_tick_lock, flags);
 }
 
-#if TCPC_TIMER_DBG_EN || TCPC_TIMER_INFO_EN
 static const char *const tcpc_timer_name[] = {
+
 #ifdef CONFIG_USB_POWER_DELIVERY
 	"PD_TIMER_DISCOVER_ID",
 	"PD_TIMER_BIST_CONT_MODE",
@@ -140,8 +151,10 @@ static const char *const tcpc_timer_name[] = {
 	"PD_TIMER_PS_SOURCE_ON",
 	"PD_TIMER_PS_TRANSITION",
 	"PD_TIMER_SENDER_RESPONSE",
+	"PD_TIMER_SINK_ACTIVITY",
 	"PD_TIMER_SINK_REQUEST",
 	"PD_TIMER_SINK_WAIT_CAP",
+	"PD_TIMER_SOURCE_ACTIVITY",
 	"PD_TIMER_SOURCE_CAPABILITY",
 	"PD_TIMER_SOURCE_START",
 	"PD_TIMER_VCONN_ON",
@@ -154,7 +167,7 @@ static const char *const tcpc_timer_name[] = {
 	"PD_TIMER_SOURCE_TRANSITION",
 	"PD_TIMER_SRC_RECOVER",
 #ifdef CONFIG_USB_PD_REV30
-	"PD_TIMER_CK_NOT_SUPPORTED",
+	"PD_TIMER_CK_NO_SUPPORT",
 #ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
 	"PD_TIMER_SINK_TX",
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
@@ -178,10 +191,10 @@ static const char *const tcpc_timer_name[] = {
 #ifdef CONFIG_USB_PD_REV30
 #ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
 	"PD_TIMER_DEFERRED_EVT",
+#endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
 #ifdef CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
 	"PD_TIMER_SNK_FLOW_DELAY",
 #endif	/* CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP */
-#endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
 #endif	/* CONFIG_USB_PD_REV30 */
 
 	"PD_TIMER_PE_IDLE_TOUT",
@@ -200,9 +213,6 @@ static const char *const tcpc_timer_name[] = {
 	"TYPEC_RT_TIMER_LOW_POWER_MODE",
 #ifdef CONFIG_USB_POWER_DELIVERY
 	"TYPEC_RT_TIMER_PE_IDLE",
-#ifdef CONFIG_USB_PD_WAIT_BC12
-	"TYPEC_RT_TIMER_PD_WAIT_BC12",
-#endif /* CONFIG_USB_PD_WAIT_BC12 */
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 	"TYPEC_TIMER_ERROR_RECOVERY",
 /* TYPEC-TRY-TIMER */
@@ -221,7 +231,6 @@ static const char *const tcpc_timer_name[] = {
 	"TYPEC_TIMER_NORP_SRC",
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
 };
-#endif /* TCPC_TIMER_DBG_EN || TCPC_TIMER_INFO_EN */
 /* CONFIG_USB_PD_SAFE0V_DELAY */
 #ifdef CONFIG_TCPC_VSAFE0V_DETECT
 #define PD_TIMER_VSAFE0V_DLY_TOUT		50
@@ -248,8 +257,8 @@ static const char *const tcpc_timer_name[] = {
 
 static const uint32_t tcpc_timer_timeout[PD_TIMER_NR] = {
 #ifdef CONFIG_USB_POWER_DELIVERY
-DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_DISCOVER_ID, 40, 50),
-DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_BIST_CONT_MODE, 30, 60),
+DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_DISCOVER_ID, 30, 60),
+DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_BIST_CONT_MODE, 40, 50),
 DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_HARD_RESET_COMPLETE, 4, 5),
 DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_NO_RESPONSE, 4500, 5500),
 DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_PS_HARD_RESET, 25, 35),
@@ -258,8 +267,10 @@ DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_PS_SOURCE_ON, 390, 480),
 
 DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_PS_TRANSITION, 450, 550),
 DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_SENDER_RESPONSE, 24, 30),
+DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_SINK_ACTIVITY, 120, 150),
 DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_SINK_REQUEST, 100, 100),
 DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_SINK_WAIT_CAP, 310, 620),
+DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_SOURCE_ACTIVITY, 40, 50),
 DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_SOURCE_CAPABILITY, 100, 200),
 
 DECL_TCPC_TIMEOUT(PD_TIMER_SOURCE_START, 20),
@@ -277,9 +288,9 @@ DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_SOURCE_TRANSITION, 25, 35),
 DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_SRC_RECOVER, 660, 1000),
 
 #ifdef CONFIG_USB_PD_REV30
-DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_CK_NOT_SUPPORTED, 40, 50),
+DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_CK_NO_SUPPORT, 40, 50),
 #ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
-DECL_TCPC_TIMEOUT_RANGE(PD_TIMER_SINK_TX, 16, 20),
+DECL_TCPC_TIMEOUT(PD_TIMER_SINK_TX, 25),	/* 16 ~ 20 */
 #endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
 #ifdef CONFIG_USB_PD_REV30_PPS_SOURCE
 DECL_TCPC_TIMEOUT(PD_TIMER_SOURCE_PPS_TIMEOUT, 14000),
@@ -309,11 +320,11 @@ DECL_TCPC_TIMEOUT_US(PD_PE_VDM_POSTPONE, 3000),
 #ifdef CONFIG_USB_PD_REV30
 #ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
 DECL_TCPC_TIMEOUT(PD_TIMER_DEFERRED_EVT, 5000),
+#endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
 #ifdef CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
 DECL_TCPC_TIMEOUT(PD_TIMER_SNK_FLOW_DELAY,
 	CONFIG_USB_PD_UFP_FLOW_DLY),
 #endif	/* CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP */
-#endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
 #endif	/* CONFIG_USB_PD_REV30 */
 
 DECL_TCPC_TIMEOUT(PD_TIMER_PE_IDLE_TOUT, 10),
@@ -333,14 +344,12 @@ DECL_TCPC_TIMEOUT(TYPEC_RT_TIMER_NOT_LEGACY, 5000),
 DECL_TCPC_TIMEOUT(TYPEC_RT_TIMER_LEGACY_STABLE, 30*1000),
 DECL_TCPC_TIMEOUT(TYPEC_RT_TIMER_LEGACY_RECYCLE, 300*1000),
 
-DECL_TCPC_TIMEOUT(TYPEC_RT_TIMER_DISCHARGE, CONFIG_TYPEC_CAP_DISCHARGE_TOUT),
+DECL_TCPC_TIMEOUT(TYPEC_RT_TIMER_AUTO_DISCHARGE,
+	CONFIG_TYPEC_CAP_AUTO_DISCHARGE_TOUT),
 DECL_TCPC_TIMEOUT(TYPEC_RT_TIMER_LOW_POWER_MODE, 500),
 
 #ifdef CONFIG_USB_POWER_DELIVERY
 DECL_TCPC_TIMEOUT(TYPEC_RT_TIMER_PE_IDLE, 1),
-#ifdef CONFIG_USB_PD_WAIT_BC12
-DECL_TCPC_TIMEOUT(TYPEC_RT_TIMER_PD_WAIT_BC12, 50),
-#endif /* CONFIG_USB_PD_WAIT_BC12 */
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 DECL_TCPC_TIMEOUT_RANGE(TYPEC_TIMER_ERROR_RECOVERY, 25, 25),
 
@@ -354,8 +363,8 @@ DECL_TCPC_TIMEOUT_RANGE(TYPEC_TIMER_PDDEBOUNCE, 10, 10),
 #ifdef CONFIG_COMPATIBLE_APPLE_TA
 DECL_TCPC_TIMEOUT_RANGE(TYPEC_TIMER_APPLE_CC_OPEN, 200, 200),
 #endif /* CONFIG_COMPATIBLE_APPLE_TA */
-DECL_TCPC_TIMEOUT_RANGE(TYPEC_TIMER_TRYCCDEBOUNCE, 10, 20),
-DECL_TCPC_TIMEOUT_RANGE(TYPEC_TIMER_SRCDISCONNECT, 0, 20),
+DECL_TCPC_TIMEOUT_RANGE(TYPEC_TIMER_TRYCCDEBOUNCE, 10, 10),
+DECL_TCPC_TIMEOUT(TYPEC_TIMER_SRCDISCONNECT, 5),
 DECL_TCPC_TIMEOUT(TYPEC_TIMER_DRP_SRC_TOGGLE, 60),
 #ifdef CONFIG_TYPEC_CAP_NORP_SRC
 DECL_TCPC_TIMEOUT(TYPEC_TIMER_NORP_SRC, 300),
@@ -366,7 +375,7 @@ typedef enum hrtimer_restart (*tcpc_hrtimer_call)(struct hrtimer *timer);
 
 #ifdef CONFIG_USB_POWER_DELIVERY
 static inline void on_pe_timer_timeout(
-		struct tcpc_device *tcpc, uint32_t timer_id)
+		struct tcpc_device *tcpc_dev, uint32_t timer_id)
 {
 	struct pd_event pd_event = {0};
 
@@ -374,60 +383,60 @@ static inline void on_pe_timer_timeout(
 	pd_event.msg = timer_id;
 	pd_event.pd_msg = NULL;
 
-	tcpc_disable_timer(tcpc, timer_id);
+	tcpc_disable_timer(tcpc_dev, timer_id);
 
 	switch (timer_id) {
 	case PD_TIMER_VDM_MODE_ENTRY:
 	case PD_TIMER_VDM_MODE_EXIT:
 	case PD_TIMER_VDM_RESPONSE:
 	case PD_TIMER_UVDM_RESPONSE:
-		pd_put_vdm_event(tcpc, &pd_event, false);
+		pd_put_vdm_event(tcpc_dev, &pd_event, false);
 		break;
 
 	case PD_TIMER_VSAFE0V_DELAY:
-		pd_put_vbus_safe0v_event(tcpc);
+		pd_put_vbus_safe0v_event(tcpc_dev);
 		break;
 
 #ifdef CONFIG_USB_PD_SAFE0V_TIMEOUT
 	case PD_TIMER_VSAFE0V_TOUT:
-		TCPC_INFO("VSafe0V TOUT (%d)\n", tcpc->vbus_level);
-		if (!tcpci_check_vbus_valid_from_ic(tcpc))
-			pd_put_vbus_safe0v_event(tcpc);
+		TCPC_INFO("VSafe0V TOUT (%d)\r\n", tcpc_dev->vbus_level);
+		if (!tcpci_check_vbus_valid_from_ic(tcpc_dev))
+			pd_put_vbus_safe0v_event(tcpc_dev);
 		break;
 #endif	/* CONFIG_USB_PD_SAFE0V_TIMEOUT */
 
 #ifdef CONFIG_USB_PD_RETRY_CRC_DISCARD
 	case PD_TIMER_DISCARD:
-		tcpc->pd_discard_pending = false;
-		pd_put_hw_event(tcpc, PD_HW_TX_DISCARD);
+		tcpc_dev->pd_discard_pending = false;
+		pd_put_hw_event(tcpc_dev, PD_HW_TX_FAILED);
 		break;
 #endif	/* CONFIG_USB_PD_RETRY_CRC_DISCARD */
 
 #if CONFIG_USB_PD_VBUS_STABLE_TOUT
 	case PD_TIMER_VBUS_STABLE:
-		pd_put_vbus_stable_event(tcpc);
+		pd_put_vbus_stable_event(tcpc_dev);
 		break;
 #endif	/* CONFIG_USB_PD_VBUS_STABLE_TOUT */
 
 #if CONFIG_USB_PD_VBUS_PRESENT_TOUT
 	case PD_TIMER_VBUS_PRESENT:
-		pd_put_vbus_present_event(tcpc);
+		pd_put_vbus_present_event(tcpc_dev);
 		break;
 #endif	/* CONFIG_USB_PD_VBUS_PRESENT_TOUT */
 
 	case PD_PE_VDM_POSTPONE:
-		tcpc->pd_postpone_vdm_timeout = true;
-		atomic_inc(&tcpc->pending_event);
-		wake_up(&tcpc->event_wait_que);
+		tcpc_dev->pd_postpone_vdm_timeout = true;
+		atomic_inc(&tcpc_dev->pending_event);
+		wake_up_interruptible(&tcpc_dev->event_loop_wait_que);
 		break;
 
 	case PD_TIMER_PE_IDLE_TOUT:
 		TCPC_INFO("pe_idle tout\n");
-		pd_put_pe_event(&tcpc->pd_port, PD_PE_IDLE);
+		pd_put_pe_event(&tcpc_dev->pd_port, PD_PE_IDLE);
 		break;
 
 	default:
-		pd_put_event(tcpc, &pd_event, false);
+		pd_put_event(tcpc_dev, &pd_event, false);
 		break;
 	}
 }
@@ -435,15 +444,15 @@ static inline void on_pe_timer_timeout(
 
 #define TCPC_TIMER_TRIGGER()	do \
 {				\
-	tcpc_set_timer_tick(tcpc, index);	\
-	wake_up(&tcpc->timer_wait_que);	\
+	tcpc_set_timer_tick(tcpc_dev, index);	\
+	wake_up_interruptible(&tcpc_dev->timer_wait_que);	\
 } while (0)
 
 #ifdef CONFIG_USB_POWER_DELIVERY
 static enum hrtimer_restart tcpc_timer_bist_cont_mode(struct hrtimer *timer)
 {
 	int index = PD_TIMER_BIST_CONT_MODE;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -453,7 +462,7 @@ static enum hrtimer_restart tcpc_timer_bist_cont_mode(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_discover_id(struct hrtimer *timer)
 {
 	int index = PD_TIMER_DISCOVER_ID;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -464,7 +473,7 @@ static enum hrtimer_restart
 	tcpc_timer_hard_reset_complete(struct hrtimer *timer)
 {
 	int index = PD_TIMER_HARD_RESET_COMPLETE;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -474,7 +483,7 @@ static enum hrtimer_restart
 static enum hrtimer_restart tcpc_timer_no_response(struct hrtimer *timer)
 {
 	int index = PD_TIMER_NO_RESPONSE;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -484,7 +493,7 @@ static enum hrtimer_restart tcpc_timer_no_response(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_ps_hard_reset(struct hrtimer *timer)
 {
 	int index = PD_TIMER_PS_HARD_RESET;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -494,7 +503,7 @@ static enum hrtimer_restart tcpc_timer_ps_hard_reset(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_ps_source_off(struct hrtimer *timer)
 {
 	int index = PD_TIMER_PS_SOURCE_OFF;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -504,7 +513,7 @@ static enum hrtimer_restart tcpc_timer_ps_source_off(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_ps_source_on(struct hrtimer *timer)
 {
 	int index = PD_TIMER_PS_SOURCE_ON;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -514,7 +523,7 @@ static enum hrtimer_restart tcpc_timer_ps_source_on(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_ps_transition(struct hrtimer *timer)
 {
 	int index = PD_TIMER_PS_TRANSITION;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -524,7 +533,17 @@ static enum hrtimer_restart tcpc_timer_ps_transition(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_sender_response(struct hrtimer *timer)
 {
 	int index = PD_TIMER_SENDER_RESPONSE;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
+		container_of(timer, struct tcpc_device, tcpc_timer[index]);
+
+	TCPC_TIMER_TRIGGER();
+	return HRTIMER_NORESTART;
+}
+
+static enum hrtimer_restart tcpc_timer_sink_activity(struct hrtimer *timer)
+{
+	int index = PD_TIMER_SINK_ACTIVITY;
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -534,7 +553,7 @@ static enum hrtimer_restart tcpc_timer_sender_response(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_sink_request(struct hrtimer *timer)
 {
 	int index = PD_TIMER_SINK_REQUEST;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -544,7 +563,17 @@ static enum hrtimer_restart tcpc_timer_sink_request(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_sink_wait_cap(struct hrtimer *timer)
 {
 	int index = PD_TIMER_SINK_WAIT_CAP;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
+		container_of(timer, struct tcpc_device, tcpc_timer[index]);
+
+	TCPC_TIMER_TRIGGER();
+	return HRTIMER_NORESTART;
+}
+
+static enum hrtimer_restart tcpc_timer_source_activity(struct hrtimer *timer)
+{
+	int index = PD_TIMER_SOURCE_ACTIVITY;
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -554,7 +583,7 @@ static enum hrtimer_restart tcpc_timer_sink_wait_cap(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_source_capability(struct hrtimer *timer)
 {
 	int index = PD_TIMER_SOURCE_CAPABILITY;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -564,7 +593,7 @@ static enum hrtimer_restart tcpc_timer_source_capability(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_source_start(struct hrtimer *timer)
 {
 	int index = PD_TIMER_SOURCE_START;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -574,7 +603,7 @@ static enum hrtimer_restart tcpc_timer_source_start(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_vconn_on(struct hrtimer *timer)
 {
 	int index = PD_TIMER_VCONN_ON;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -585,7 +614,7 @@ static enum hrtimer_restart tcpc_timer_vconn_on(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_vconn_stable(struct hrtimer *timer)
 {
 	int index = PD_TIMER_VCONN_STABLE;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -596,7 +625,7 @@ static enum hrtimer_restart tcpc_timer_vconn_stable(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_vdm_mode_entry(struct hrtimer *timer)
 {
 	int index = PD_TIMER_VDM_MODE_ENTRY;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -606,7 +635,7 @@ static enum hrtimer_restart tcpc_timer_vdm_mode_entry(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_vdm_mode_exit(struct hrtimer *timer)
 {
 	int index = PD_TIMER_VDM_MODE_EXIT;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -616,7 +645,7 @@ static enum hrtimer_restart tcpc_timer_vdm_mode_exit(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_vdm_response(struct hrtimer *timer)
 {
 	int index = PD_TIMER_VDM_RESPONSE;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -626,7 +655,7 @@ static enum hrtimer_restart tcpc_timer_vdm_response(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_source_transition(struct hrtimer *timer)
 {
 	int index = PD_TIMER_SOURCE_TRANSITION;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -636,7 +665,7 @@ static enum hrtimer_restart tcpc_timer_source_transition(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_src_recover(struct hrtimer *timer)
 {
 	int index = PD_TIMER_SRC_RECOVER;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -646,8 +675,8 @@ static enum hrtimer_restart tcpc_timer_src_recover(struct hrtimer *timer)
 #ifdef CONFIG_USB_PD_REV30
 static enum hrtimer_restart tcpc_timer_ck_no_support(struct hrtimer *timer)
 {
-	int index = PD_TIMER_CK_NOT_SUPPORTED;
-	struct tcpc_device *tcpc =
+	int index = PD_TIMER_CK_NO_SUPPORT;
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -658,7 +687,7 @@ static enum hrtimer_restart tcpc_timer_ck_no_support(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_sink_tx(struct hrtimer *timer)
 {
 	int index = PD_TIMER_SINK_TX;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -670,7 +699,7 @@ static enum hrtimer_restart tcpc_timer_sink_tx(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_source_pps(struct hrtimer *timer)
 {
 	int index = PD_TIMER_SOURCE_PPS_TIMEOUT;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -684,7 +713,7 @@ static enum hrtimer_restart tcpc_timer_source_pps(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_vsafe0v_delay(struct hrtimer *timer)
 {
 	int index = PD_TIMER_VSAFE0V_DELAY;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -694,7 +723,7 @@ static enum hrtimer_restart tcpc_timer_vsafe0v_delay(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_vsafe0v_tout(struct hrtimer *timer)
 {
 	int index = PD_TIMER_VSAFE0V_TOUT;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -704,7 +733,7 @@ static enum hrtimer_restart tcpc_timer_vsafe0v_tout(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_pd_discard(struct hrtimer *timer)
 {
 	int index = PD_TIMER_DISCARD;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -714,7 +743,7 @@ static enum hrtimer_restart tcpc_timer_pd_discard(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_vbus_stable(struct hrtimer *timer)
 {
 	int index = PD_TIMER_VBUS_STABLE;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -724,7 +753,7 @@ static enum hrtimer_restart tcpc_timer_vbus_stable(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_vbus_present(struct hrtimer *timer)
 {
 	int index = PD_TIMER_VBUS_PRESENT;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -734,7 +763,7 @@ static enum hrtimer_restart tcpc_timer_vbus_present(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_uvdm_response(struct hrtimer *timer)
 {
 	int index = PD_TIMER_UVDM_RESPONSE;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -744,7 +773,7 @@ static enum hrtimer_restart tcpc_timer_uvdm_response(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_dfp_flow_delay(struct hrtimer *timer)
 {
 	int index = PD_TIMER_DFP_FLOW_DELAY;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -754,7 +783,7 @@ static enum hrtimer_restart tcpc_timer_dfp_flow_delay(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_ufp_flow_delay(struct hrtimer *timer)
 {
 	int index = PD_TIMER_UFP_FLOW_DELAY;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -764,7 +793,7 @@ static enum hrtimer_restart tcpc_timer_ufp_flow_delay(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_vconn_ready(struct hrtimer *timer)
 {
 	int index = PD_TIMER_VCONN_READY;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -774,7 +803,7 @@ static enum hrtimer_restart tcpc_timer_vconn_ready(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_vdm_postpone(struct hrtimer *timer)
 {
 	int index = PD_PE_VDM_POSTPONE;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -786,31 +815,31 @@ static enum hrtimer_restart tcpc_timer_vdm_postpone(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_deferred_evt(struct hrtimer *timer)
 {
 	int index = PD_TIMER_DEFERRED_EVT;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
 	return HRTIMER_NORESTART;
 }
+#endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
 
 #ifdef CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
 static enum hrtimer_restart tcpc_timer_snk_flow_delay(struct hrtimer *timer)
 {
 	int index = PD_TIMER_SNK_FLOW_DELAY;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
 	return HRTIMER_NORESTART;
 }
 #endif	/* CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP */
-#endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
 #endif	/* CONFIG_USB_PD_REV30 */
 
 static enum hrtimer_restart tcpc_timer_pe_idle_tout(struct hrtimer *timer)
 {
 	int index = PD_TIMER_PE_IDLE_TOUT;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -824,7 +853,7 @@ static enum hrtimer_restart tcpc_timer_pe_idle_tout(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_rt_vsafe0v_delay(struct hrtimer *timer)
 {
 	int index = TYPEC_RT_TIMER_SAFE0V_DELAY;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -834,7 +863,7 @@ static enum hrtimer_restart tcpc_timer_rt_vsafe0v_delay(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_rt_vsafe0v_tout(struct hrtimer *timer)
 {
 	int index = TYPEC_RT_TIMER_SAFE0V_TOUT;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -844,7 +873,7 @@ static enum hrtimer_restart tcpc_timer_rt_vsafe0v_tout(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_rt_role_swap_start(struct hrtimer *timer)
 {
 	int index = TYPEC_RT_TIMER_ROLE_SWAP_START;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -854,7 +883,7 @@ static enum hrtimer_restart tcpc_timer_rt_role_swap_start(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_rt_role_swap_stop(struct hrtimer *timer)
 {
 	int index = TYPEC_RT_TIMER_ROLE_SWAP_STOP;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -864,7 +893,7 @@ static enum hrtimer_restart tcpc_timer_rt_role_swap_stop(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_rt_legacy(struct hrtimer *timer)
 {
 	int index = TYPEC_RT_TIMER_STATE_CHANGE;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -874,7 +903,7 @@ static enum hrtimer_restart tcpc_timer_rt_legacy(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_rt_not_legacy(struct hrtimer *timer)
 {
 	int index = TYPEC_RT_TIMER_NOT_LEGACY;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -884,7 +913,7 @@ static enum hrtimer_restart tcpc_timer_rt_not_legacy(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_rt_legacy_stable(struct hrtimer *timer)
 {
 	int index = TYPEC_RT_TIMER_LEGACY_STABLE;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -894,17 +923,17 @@ static enum hrtimer_restart tcpc_timer_rt_legacy_stable(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_rt_legacy_recycle(struct hrtimer *timer)
 {
 	int index = TYPEC_RT_TIMER_LEGACY_RECYCLE;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
 	return HRTIMER_NORESTART;
 }
 
-static enum hrtimer_restart tcpc_timer_rt_discharge(struct hrtimer *timer)
+static enum hrtimer_restart tcpc_timer_rt_auto_discharge(struct hrtimer *timer)
 {
-	int index = TYPEC_RT_TIMER_DISCHARGE;
-	struct tcpc_device *tcpc =
+	int index = TYPEC_RT_TIMER_AUTO_DISCHARGE;
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -914,7 +943,7 @@ static enum hrtimer_restart tcpc_timer_rt_discharge(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_rt_low_power_mode(struct hrtimer *timer)
 {
 	int index = TYPEC_RT_TIMER_LOW_POWER_MODE;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -925,31 +954,19 @@ static enum hrtimer_restart tcpc_timer_rt_low_power_mode(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_rt_pe_idle(struct hrtimer *timer)
 {
 	int index = TYPEC_RT_TIMER_PE_IDLE;
-	struct tcpc_device *tcpc =
-		container_of(timer, struct tcpc_device, tcpc_timer[index]);
-
-	TCPC_TIMER_TRIGGER();
-	return HRTIMER_NORESTART;
-}
-
-#ifdef CONFIG_USB_PD_WAIT_BC12
-static enum hrtimer_restart tcpc_timer_rt_pd_wait_bc12(struct hrtimer *timer)
-{
-	int index = TYPEC_RT_TIMER_PD_WAIT_BC12;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
 	return HRTIMER_NORESTART;
 }
-#endif /* CONFIG_USB_PD_WAIT_BC12 */
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
 /* TYPEC-TRY-TIMER */
 static enum hrtimer_restart tcpc_timer_try_drp_try(struct hrtimer *timer)
 {
 	int index = TYPEC_TRY_TIMER_DRP_TRY;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -959,7 +976,7 @@ static enum hrtimer_restart tcpc_timer_try_drp_try(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_try_drp_trywait(struct hrtimer *timer)
 {
 	int index = TYPEC_TRY_TIMER_DRP_TRYWAIT;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -970,7 +987,7 @@ static enum hrtimer_restart tcpc_timer_try_drp_trywait(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_ccdebounce(struct hrtimer *timer)
 {
 	int index = TYPEC_TIMER_CCDEBOUNCE;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -980,29 +997,27 @@ static enum hrtimer_restart tcpc_timer_ccdebounce(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_pddebounce(struct hrtimer *timer)
 {
 	int index = TYPEC_TIMER_PDDEBOUNCE;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
 	return HRTIMER_NORESTART;
 }
 
-#ifdef CONFIG_COMPATIBLE_APPLE_TA
 static enum hrtimer_restart tcpc_timer_apple_cc_open(struct hrtimer *timer)
 {
 	int index = TYPEC_TIMER_APPLE_CC_OPEN;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
 	return HRTIMER_NORESTART;
 }
-#endif /* CONFIG_COMPATIBLE_APPLE_TA */
 
 static enum hrtimer_restart tcpc_timer_tryccdebounce(struct hrtimer *timer)
 {
 	int index = TYPEC_TIMER_TRYCCDEBOUNCE;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -1012,7 +1027,7 @@ static enum hrtimer_restart tcpc_timer_tryccdebounce(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_srcdisconnect(struct hrtimer *timer)
 {
 	int index = TYPEC_TIMER_SRCDISCONNECT;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -1022,7 +1037,7 @@ static enum hrtimer_restart tcpc_timer_srcdisconnect(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_error_recovery(struct hrtimer *timer)
 {
 	int index = TYPEC_TIMER_ERROR_RECOVERY;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -1031,37 +1046,37 @@ static enum hrtimer_restart tcpc_timer_error_recovery(struct hrtimer *timer)
 
 static void wake_up_work_func(struct work_struct *work)
 {
-	struct tcpc_device *tcpc = container_of(
+	struct tcpc_device *tcpc_dev = container_of(
 			work, struct tcpc_device, wake_up_work.work);
 
-	mutex_lock(&tcpc->typec_lock);
+	mutex_lock(&tcpc_dev->typec_lock);
 
 	TCPC_INFO("%s\n", __func__);
 #ifdef CONFIG_TYPEC_WAKEUP_ONCE_LOW_DUTY
-	tcpc->typec_wakeup_once = true;
+	tcpc_dev->typec_wakeup_once = true;
 #endif	/* CONFIG_TYPEC_WAKEUP_ONCE_LOW_DUTY */
 
-	tcpc_typec_enter_lpm_again(tcpc);
+	tcpc_typec_enter_lpm_again(tcpc_dev);
 
-	mutex_unlock(&tcpc->typec_lock);
-	__pm_relax(tcpc->wakeup_wake_lock);
+	mutex_unlock(&tcpc_dev->typec_lock);
+	__pm_relax(&tcpc_dev->wakeup_wake_lock);
 }
 
 static enum alarmtimer_restart
 	tcpc_timer_wakeup(struct alarm *alarm, ktime_t now)
 {
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(alarm, struct tcpc_device, wake_up_timer);
 
-	__pm_wakeup_event(tcpc->wakeup_wake_lock, 1000);
-	schedule_delayed_work(&tcpc->wake_up_work, 0);
+	__pm_wakeup_event(&tcpc_dev->wakeup_wake_lock, 1000);
+	schedule_delayed_work(&tcpc_dev->wake_up_work, 0);
 	return ALARMTIMER_NORESTART;
 }
 
 static enum hrtimer_restart tcpc_timer_drp_src_toggle(struct hrtimer *timer)
 {
 	int index = TYPEC_TIMER_DRP_SRC_TOGGLE;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -1072,7 +1087,7 @@ static enum hrtimer_restart tcpc_timer_drp_src_toggle(struct hrtimer *timer)
 static enum hrtimer_restart tcpc_timer_norp_src(struct hrtimer *timer)
 {
 	int index = TYPEC_TIMER_NORP_SRC;
-	struct tcpc_device *tcpc =
+	struct tcpc_device *tcpc_dev =
 		container_of(timer, struct tcpc_device, tcpc_timer[index]);
 
 	TCPC_TIMER_TRIGGER();
@@ -1091,8 +1106,10 @@ static tcpc_hrtimer_call tcpc_timer_call[PD_TIMER_NR] = {
 	tcpc_timer_ps_source_on,
 	tcpc_timer_ps_transition,
 	tcpc_timer_sender_response,
+	tcpc_timer_sink_activity,
 	tcpc_timer_sink_request,
 	tcpc_timer_sink_wait_cap,
+	tcpc_timer_source_activity,
 	tcpc_timer_source_capability,
 	tcpc_timer_source_start,
 	tcpc_timer_vconn_on,
@@ -1129,10 +1146,10 @@ static tcpc_hrtimer_call tcpc_timer_call[PD_TIMER_NR] = {
 #ifdef CONFIG_USB_PD_REV30
 #ifdef CONFIG_USB_PD_REV30_COLLISION_AVOID
 	tcpc_timer_deferred_evt,
+#endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
 #ifdef CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP
 	tcpc_timer_snk_flow_delay,
 #endif	/* CONFIG_USB_PD_REV30_SNK_FLOW_DELAY_STARTUP */
-#endif	/* CONFIG_USB_PD_REV30_COLLISION_AVOID */
 #endif	/* CONFIG_USB_PD_REV30 */
 
 	tcpc_timer_pe_idle_tout,
@@ -1147,13 +1164,10 @@ static tcpc_hrtimer_call tcpc_timer_call[PD_TIMER_NR] = {
 	tcpc_timer_rt_not_legacy,
 	tcpc_timer_rt_legacy_stable,
 	tcpc_timer_rt_legacy_recycle,
-	tcpc_timer_rt_discharge,
+	tcpc_timer_rt_auto_discharge,
 	tcpc_timer_rt_low_power_mode,
 #ifdef CONFIG_USB_POWER_DELIVERY
 	tcpc_timer_rt_pe_idle,
-#ifdef CONFIG_USB_PD_WAIT_BC12
-	tcpc_timer_rt_pd_wait_bc12,
-#endif /* CONFIG_USB_PD_WAIT_BC12 */
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 	tcpc_timer_error_recovery,
 /* TYPEC-TRY-TIMER */
@@ -1206,7 +1220,7 @@ static inline void tcpc_reset_timer_range(
 
 	mask = tcpc_get_timer_enable_mask(tcpc);
 
-	for (i = start; i < end; i++) {
+	for (i = start; i <= end; i++) {
 		if (mask & RT_MASK64(i)) {
 			hrtimer_try_to_cancel(&tcpc->tcpc_timer[i]);
 			tcpc_clear_timer_enable_mask(tcpc, i);
@@ -1219,7 +1233,13 @@ static inline void tcpc_reset_timer_range(
 
 void tcpc_restart_timer(struct tcpc_device *tcpc, uint32_t timer_id)
 {
-	tcpc_disable_timer(tcpc, timer_id);
+	uint64_t mask;
+
+	mask = tcpc_get_timer_enable_mask(tcpc);
+
+	if (mask & RT_MASK64(timer_id))
+		tcpc_disable_timer(tcpc, timer_id);
+
 	tcpc_enable_timer(tcpc, timer_id);
 }
 
@@ -1261,28 +1281,42 @@ void tcpc_enable_timer(struct tcpc_device *tcpc, uint32_t timer_id)
 				ktime_set(r, mod*1000), HRTIMER_MODE_REL);
 }
 
-void tcpc_disable_timer(struct tcpc_device *tcpc, uint32_t timer_id)
+void tcpc_disable_timer(struct tcpc_device *tcpc_dev, uint32_t timer_id)
 {
 	uint64_t mask;
 
-	mask = tcpc_get_timer_enable_mask(tcpc);
+	mask = tcpc_get_timer_enable_mask(tcpc_dev);
 
 	if (timer_id >= PD_TIMER_NR) {
 		PD_BUG_ON(1);
 		return;
 	}
 	if (mask & RT_MASK64(timer_id)) {
-		hrtimer_try_to_cancel(&tcpc->tcpc_timer[timer_id]);
-		tcpc_clear_timer_enable_mask(tcpc, timer_id);
+		hrtimer_try_to_cancel(&tcpc_dev->tcpc_timer[timer_id]);
+		tcpc_clear_timer_enable_mask(tcpc_dev, timer_id);
 	}
 }
 
+void tcpc_timer_reset(struct tcpc_device *tcpc_dev)
+{
+	uint64_t mask;
+	int i;
+
+	mask = tcpc_get_timer_enable_mask(tcpc_dev);
+
+	for (i = 0; i < PD_TIMER_NR; i++)
+		if (mask & RT_MASK64(i))
+			hrtimer_try_to_cancel(&tcpc_dev->tcpc_timer[i]);
+
+	tcpc_reset_timer_enable_mask(tcpc_dev);
+}
+
 #ifdef CONFIG_USB_POWER_DELIVERY
-void tcpc_reset_pe_timer(struct tcpc_device *tcpc)
+void tcpc_reset_pe_timer(struct tcpc_device *tcpc_dev)
 {
-	mutex_lock(&tcpc->timer_lock);
-	tcpc_reset_timer_range(tcpc, 0, PD_PE_TIMER_END_ID);
-	mutex_unlock(&tcpc->timer_lock);
+	mutex_lock(&tcpc_dev->timer_lock);
+	tcpc_reset_timer_range(tcpc_dev, 0, PD_PE_TIMER_END_ID);
+	mutex_unlock(&tcpc_dev->timer_lock);
 }
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
@@ -1301,94 +1335,105 @@ void tcpc_reset_typec_try_timer(struct tcpc_device *tcpc)
 	mutex_unlock(&tcpc->timer_lock);
 }
 
-static void tcpc_handle_timer_triggered(struct tcpc_device *tcpc)
+static void tcpc_handle_timer_triggered(struct tcpc_device *tcpc_dev)
 {
+	uint64_t enable_mask;
+	uint64_t triggered_timer;
 	int i = 0;
-	uint64_t triggered_timer = tcpc_get_timer_tick(tcpc);
-	uint64_t enable_mask = tcpc_get_timer_enable_mask(tcpc);
+
+	triggered_timer = tcpc_get_timer_tick(tcpc_dev);
+	enable_mask = tcpc_get_timer_enable_mask(tcpc_dev);
 
 #ifdef CONFIG_USB_POWER_DELIVERY
 	for (i = 0; i < PD_PE_TIMER_END_ID; i++) {
 		if (triggered_timer & RT_MASK64(i)) {
-			TCPC_TIMER_DBG(tcpc, i);
+			TCPC_TIMER_DBG(tcpc_dev, i);
 			if (enable_mask & RT_MASK64(i))
-				on_pe_timer_timeout(tcpc, i);
-			tcpc_clear_timer_tick(tcpc, i);
+				on_pe_timer_timeout(tcpc_dev, i);
+			tcpc_clear_timer_tick(tcpc_dev, i);
 		}
 	}
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
-	mutex_lock(&tcpc->typec_lock);
-	triggered_timer = tcpc_get_timer_tick(tcpc);
-	enable_mask = tcpc_get_timer_enable_mask(tcpc);
+	mutex_lock(&tcpc_dev->typec_lock);
 	for (; i < PD_TIMER_NR; i++) {
 		if (triggered_timer & RT_MASK64(i)) {
-			TCPC_TIMER_DBG(tcpc, i);
+			TCPC_TIMER_DBG(tcpc_dev, i);
 			if (enable_mask & RT_MASK64(i))
-				tcpc_typec_handle_timeout(tcpc, i);
-			tcpc_clear_timer_tick(tcpc, i);
+				tcpc_typec_handle_timeout(tcpc_dev, i);
+			tcpc_clear_timer_tick(tcpc_dev, i);
 		}
 	}
-	mutex_unlock(&tcpc->typec_lock);
+	mutex_unlock(&tcpc_dev->typec_lock);
 
 }
 
-static int tcpc_timer_thread_fn(void *data)
+static int tcpc_timer_thread(void *param)
 {
-	struct tcpc_device *tcpc = data;
+	struct tcpc_device *tcpc_dev = param;
+
+	uint64_t *timer_tick;
 	struct sched_param sch_param = {.sched_priority = MAX_RT_PRIO - 1};
-	int ret = 0;
 
-	sched_setscheduler(current, SCHED_FIFO, &sch_param);
+	timer_tick = &tcpc_dev->timer_tick;
 
+	sched_setscheduler(current, SCHED_FIFO, &sch_param);
 	while (true) {
-		ret = wait_event_interruptible(tcpc->timer_wait_que,
-					       tcpc_get_timer_tick(tcpc) ||
-					       kthread_should_stop());
-		if (kthread_should_stop() || ret) {
-			dev_notice(&tcpc->dev, "%s exits(%d)\n", __func__, ret);
+		wait_event_interruptible(tcpc_dev->timer_wait_que,
+				((*timer_tick) ? true : false) |
+				tcpc_dev->timer_thead_stop);
+		if (kthread_should_stop() || tcpc_dev->timer_thead_stop)
 			break;
-		}
-		tcpc_handle_timer_triggered(tcpc);
+		do {
+			tcpc_handle_timer_triggered(tcpc_dev);
+		} while (*timer_tick);
 	}
-
 	return 0;
 }
 
-int tcpci_timer_init(struct tcpc_device *tcpc)
+int tcpci_timer_init(struct tcpc_device *tcpc_dev)
 {
 	int i;
 
 	pr_info("PD Timer number = %d\n", PD_TIMER_NR);
+	tcpc_dev->timer_task = kthread_create(tcpc_timer_thread, tcpc_dev,
+			"tcpc_timer_%s.%p", dev_name(&tcpc_dev->dev), tcpc_dev);
+	init_waitqueue_head(&tcpc_dev->timer_wait_que);
 
-	init_waitqueue_head(&tcpc->timer_wait_que);
-	tcpc->timer_tick = 0;
-	tcpc->timer_enable_mask = 0;
-	tcpc->timer_task = kthread_run(tcpc_timer_thread_fn, tcpc,
-				       "tcpc_timer_%s", tcpc->desc.name);
+	tcpc_dev->timer_tick = 0;
+	tcpc_dev->timer_enable_mask = 0;
+
+	wake_up_process(tcpc_dev->timer_task);
 	for (i = 0; i < PD_TIMER_NR; i++) {
-		hrtimer_init(&tcpc->tcpc_timer[i],
+		hrtimer_init(&tcpc_dev->tcpc_timer[i],
 					CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-		tcpc->tcpc_timer[i].function = tcpc_timer_call[i];
+		tcpc_dev->tcpc_timer[i].function = tcpc_timer_call[i];
 	}
-	tcpc->wakeup_wake_lock =
-		wakeup_source_register(&tcpc->dev, "tcpc_wakeup_wake_lock");
-	INIT_DELAYED_WORK(&tcpc->wake_up_work, wake_up_work_func);
-	alarm_init(&tcpc->wake_up_timer, ALARM_REALTIME, tcpc_timer_wakeup);
+	wakeup_source_init(&tcpc_dev->wakeup_wake_lock,
+		"wakeup_wake_lock");
+	INIT_DELAYED_WORK(&tcpc_dev->wake_up_work, wake_up_work_func);
+	alarm_init(&tcpc_dev->wake_up_timer, ALARM_REALTIME, tcpc_timer_wakeup);
 
 	pr_info("%s : init OK\n", __func__);
 	return 0;
 }
 
-int tcpci_timer_deinit(struct tcpc_device *tcpc)
+int tcpci_timer_deinit(struct tcpc_device *tcpc_dev)
 {
-	kthread_stop(tcpc->timer_task);
-	mutex_lock(&tcpc->timer_lock);
-	tcpc_reset_timer_range(tcpc, 0, PD_TIMER_NR);
-	mutex_unlock(&tcpc->timer_lock);
-	cancel_delayed_work_sync(&tcpc->wake_up_work);
-	wakeup_source_unregister(tcpc->wakeup_wake_lock);
+	uint64_t mask;
+	int i;
+
+	mask = tcpc_get_timer_enable_mask(tcpc_dev);
+
+	mutex_lock(&tcpc_dev->timer_lock);
+	wake_up_interruptible(&tcpc_dev->timer_wait_que);
+	kthread_stop(tcpc_dev->timer_task);
+	for (i = 0; i < PD_TIMER_NR; i++) {
+		if (mask & RT_MASK64(i))
+			hrtimer_try_to_cancel(&tcpc_dev->tcpc_timer[i]);
+	}
 
 	pr_info("%s : de init OK\n", __func__);
+	mutex_unlock(&tcpc_dev->timer_lock);
 	return 0;
 }
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpci_typec.c b/drivers/misc/mediatek/typec/tcpc/tcpci_typec.c
index 25149bb..ebd4ab4 100644
--- a/drivers/misc/mediatek/typec/tcpc/tcpci_typec.c
+++ b/drivers/misc/mediatek/typec/tcpc/tcpci_typec.c
@@ -41,9 +41,6 @@ enum TYPEC_WAIT_PS_STATE {
 	TYPEC_WAIT_PS_SNK_VSAFE5V,
 	TYPEC_WAIT_PS_SRC_VSAFE0V,
 	TYPEC_WAIT_PS_SRC_VSAFE5V,
-#ifdef CONFIG_TYPEC_CAP_DBGACC
-	TYPEC_WAIT_PS_DBG_VSAFE5V,
-#endif	/* CONFIG_TYPEC_CAP_DBGACC */
 };
 
 enum TYPEC_ROLE_SWAP_STATE {
@@ -58,44 +55,49 @@ static const char *const typec_wait_ps_name[] = {
 	"SNK_VSafe5V",
 	"SRC_VSafe0V",
 	"SRC_VSafe5V",
-	"DBG_VSafe5V",
 };
 #endif	/* TYPEC_INFO2_ENABLE */
 
-extern int standard_charger_500;
-static inline void typec_wait_ps_change(struct tcpc_device *tcpc,
+static inline void typec_wait_ps_change(struct tcpc_device *tcpc_dev,
 					enum TYPEC_WAIT_PS_STATE state)
 {
 #if TYPEC_INFO2_ENABLE
-	uint8_t old_state = tcpc->typec_wait_ps_change;
+	uint8_t old_state = tcpc_dev->typec_wait_ps_change;
 	uint8_t new_state = (uint8_t) state;
 
 	if (new_state != old_state)
-		TYPEC_INFO2("wait_ps=%s\n", typec_wait_ps_name[new_state]);
+		TYPEC_INFO2("wait_ps=%s\r\n", typec_wait_ps_name[new_state]);
 #endif	/* TYPEC_INFO2_ENABLE */
 
 #ifdef CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_TIMEOUT
 	if (state == TYPEC_WAIT_PS_SRC_VSAFE0V)
-		tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_SAFE0V_TOUT);
+		tcpc_enable_timer(tcpc_dev, TYPEC_RT_TIMER_SAFE0V_TOUT);
 #endif	/* CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_TIMEOUT */
 
-	if (tcpc->typec_wait_ps_change == TYPEC_WAIT_PS_SRC_VSAFE0V
+	if (tcpc_dev->typec_wait_ps_change == TYPEC_WAIT_PS_SRC_VSAFE0V
 		&& state != TYPEC_WAIT_PS_SRC_VSAFE0V) {
-		tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_SAFE0V_DELAY);
+		tcpc_disable_timer(tcpc_dev, TYPEC_RT_TIMER_SAFE0V_DELAY);
 
 #ifdef CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_TIMEOUT
-		tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_SAFE0V_TOUT);
+		tcpc_disable_timer(tcpc_dev, TYPEC_RT_TIMER_SAFE0V_TOUT);
 #endif	/* CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_TIMEOUT */
 	}
 
-	tcpc->typec_wait_ps_change = (uint8_t) state;
+	tcpc_dev->typec_wait_ps_change = (uint8_t) state;
 }
 
 /* #define TYPEC_EXIT_ATTACHED_SRC_NO_DEBOUNCE */
 #define TYPEC_EXIT_ATTACHED_SNK_VIA_VBUS
 
 static inline int typec_enable_low_power_mode(
-	struct tcpc_device *tcpc, uint8_t pull);
+	struct tcpc_device *tcpc_dev, uint8_t pull);
+
+#define typec_get_cc1()		\
+	tcpc_dev->typec_remote_cc[0]
+#define typec_get_cc2()		\
+	tcpc_dev->typec_remote_cc[1]
+#define typec_get_cc_res()	\
+	(tcpc_dev->typec_polarity ? typec_get_cc2() : typec_get_cc1())
 
 #define typec_check_cc1(cc)	\
 	(typec_get_cc1() == cc)
@@ -128,7 +130,7 @@ static inline int typec_enable_low_power_mode(
 #define typec_is_cc_no_res()	\
 	(typec_is_drp_toggling() || typec_is_cc_open())
 
-static inline int typec_enable_vconn(struct tcpc_device *tcpc)
+static inline int typec_enable_vconn(struct tcpc_device *tcpc_dev)
 {
 #ifndef CONFIG_USB_POWER_DELIVERY
 	if (!typec_is_sink_with_emark())
@@ -136,11 +138,11 @@ static inline int typec_enable_vconn(struct tcpc_device *tcpc)
 #endif /* CONFIG_TCPC_VCONN_SUPPLY_MODE */
 
 #ifdef CONFIG_TCPC_VCONN_SUPPLY_MODE
-	if (tcpc->tcpc_vconn_supply == TCPC_VCONN_SUPPLY_NEVER)
+	if (tcpc_dev->tcpc_vconn_supply == TCPC_VCONN_SUPPLY_NEVER)
 		return 0;
 #endif /* CONFIG_TCPC_VCONN_SUPPLY_MODE */
 
-	return tcpci_set_vconn(tcpc, true);
+	return tcpci_set_vconn(tcpc_dev, true);
 }
 
 /*
@@ -196,9 +198,7 @@ enum TYPEC_CONNECTION_STATE {
 #endif	/* CONFIG_TYPEC_CAP_TRY_SINK */
 
 	typec_audioaccessory,
-#ifdef CONFIG_TYPEC_CAP_DBGACC
 	typec_debugaccessory,
-#endif	/* CONFIG_TYPEC_CAP_DBGACC */
 
 #ifdef CONFIG_TYPEC_CAP_DBGACC_SNK
 	typec_attached_dbgacc_snk,
@@ -224,7 +224,6 @@ enum TYPEC_CONNECTION_STATE {
 	typec_unattachwait_pe,	/* Wait Policy Engine go to Idle */
 };
 
-#if TYPEC_INFO_ENABLE || TCPC_INFO_ENABLE
 static const char *const typec_state_name[] = {
 	"Disabled",
 	"ErrorRecovery",
@@ -251,9 +250,7 @@ static const char *const typec_state_name[] = {
 #endif	/* CONFIG_TYPEC_CAP_TRY_SINK */
 
 	"AudioAccessory",
-#ifdef CONFIG_TYPEC_CAP_DBGACC
 	"DebugAccessory",
-#endif	/* CONFIG_TYPEC_CAP_DBGACC */
 
 #ifdef CONFIG_TYPEC_CAP_DBGACC_SNK
 	"DBGACC.SNK",
@@ -276,28 +273,24 @@ static const char *const typec_state_name[] = {
 	"WaterProtection",
 #endif /* CONFIG_WATER_DETECTION */
 
+
 	"UnattachWait.PE",
 };
-#endif /* TYPEC_INFO_ENABLE || TCPC_INFO_ENABLE */
 
-static inline void typec_transfer_state(struct tcpc_device *tcpc,
+static inline void typec_transfer_state(struct tcpc_device *tcpc_dev,
 					enum TYPEC_CONNECTION_STATE state)
 {
-#if TYPEC_INFO_ENABLE
-	if (state >= 0 && state < ARRAY_SIZE(typec_state_name))
-		TYPEC_INFO("** %s\n", typec_state_name[state]);
-#endif /* TYPEC_INFO_ENABLE */
-	tcpc->typec_state = (uint8_t) state;
+	TYPEC_INFO("** %s\r\n", typec_state_name[state]);
+	tcpc_dev->typec_state = (uint8_t) state;
 }
 
 #define TYPEC_NEW_STATE(state)  \
-	(typec_transfer_state(tcpc, state))
+	(typec_transfer_state(tcpc_dev, state))
 
 /*
  * [BLOCK] TypeC Alert Attach Status Changed
  */
 
-#if TYPEC_INFO_ENABLE || TYPEC_DBG_ENABLE
 static const char *const typec_attach_name[] = {
 	"NULL",
 	"SINK",
@@ -309,64 +302,58 @@ static const char *const typec_attach_name[] = {
 	"CUSTOM_SRC",
 	"NORP_SRC",
 };
-#endif /* TYPEC_INFO_ENABLE || TYPEC_DBG_ENABLE */
 
-static int typec_alert_attach_state_change(struct tcpc_device *tcpc)
+static int typec_alert_attach_state_change(struct tcpc_device *tcpc_dev)
 {
 	int ret = 0;
 
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
-	if (tcpc->typec_legacy_cable)
-		tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_NOT_LEGACY);
+	if (tcpc_dev->typec_legacy_cable)
+		tcpc_disable_timer(tcpc_dev, TYPEC_RT_TIMER_NOT_LEGACY);
 	else
-		tcpc_restart_timer(tcpc, TYPEC_RT_TIMER_NOT_LEGACY);
+		tcpc_restart_timer(tcpc_dev, TYPEC_RT_TIMER_NOT_LEGACY);
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE */
 
-	if (tcpc->typec_attach_old == tcpc->typec_attach_new) {
-		TYPEC_DBG("Attached-> %s(repeat)\n",
-			typec_attach_name[tcpc->typec_attach_new]);
+	if (tcpc_dev->typec_attach_old == tcpc_dev->typec_attach_new) {
+		TYPEC_DBG("Attached-> %s(repeat)\r\n",
+			typec_attach_name[tcpc_dev->typec_attach_new]);
 		return 0;
 	}
 
-	TYPEC_INFO("Attached-> %s\n",
-		   typec_attach_name[tcpc->typec_attach_new]);
-	if(!strcmp(typec_attach_name[tcpc->typec_attach_new], "NORP_SRC"))
-	{
-		standard_charger_500 = 1;
-		printk("renxianzhou: standard_charger_500 =%d  line = %d\n",standard_charger_500,__LINE__);
-	}
+	TYPEC_INFO("Attached-> %s\r\n",
+		   typec_attach_name[tcpc_dev->typec_attach_new]);
 
 	/*Report function */
-	ret = tcpci_report_usb_port_changed(tcpc);
+	ret = tcpci_report_usb_port_changed(tcpc_dev);
 
-	tcpc->typec_attach_old = tcpc->typec_attach_new;
+	tcpc_dev->typec_attach_old = tcpc_dev->typec_attach_new;
 	return ret;
 }
 
-static inline int typec_set_drp_toggling(struct tcpc_device *tcpc)
+static inline int typec_set_drp_toggling(struct tcpc_device *tcpc_dev)
 {
 	int ret;
 
-	ret = tcpci_set_cc(tcpc, TYPEC_CC_DRP);
+	ret = tcpci_set_cc(tcpc_dev, TYPEC_CC_DRP);
 	if (ret < 0)
 		return ret;
 
-	return typec_enable_low_power_mode(tcpc, TYPEC_CC_DRP);
+	return typec_enable_low_power_mode(tcpc_dev, TYPEC_CC_DRP);
 }
 
 #ifdef CONFIG_WATER_DETECTION
-static int typec_check_water_status(struct tcpc_device *tcpc)
+static int typec_check_water_status(struct tcpc_device *tcpc_dev)
 {
 	int ret;
 
-	if (!(tcpc->tcpc_flags & TCPC_FLAGS_WATER_DETECTION))
+	if (!(tcpc_dev->tcpc_flags & TCPC_FLAGS_WATER_DETECTION))
 		return 0;
 
-	ret = tcpci_is_water_detected(tcpc);
+	ret = tcpci_is_water_detected(tcpc_dev);
 	if (ret < 0)
 		return ret;
 	if (ret) {
-		tcpc_typec_handle_wd(tcpc, true);
+		tcpc_typec_handle_wd(tcpc_dev, true);
 		return 1;
 	}
 	return 0;
@@ -378,13 +365,13 @@ static int typec_check_water_status(struct tcpc_device *tcpc)
  */
 
 #ifdef CONFIG_TYPEC_CAP_NORP_SRC
-static bool typec_try_enter_norp_src(struct tcpc_device *tcpc)
+
+static bool typec_try_enter_norp_src(struct tcpc_device *tcpc_dev)
 {
-	if (tcpci_check_vbus_valid_from_ic(tcpc) &&
-	    typec_is_cc_no_res() &&
-	    tcpc->typec_state == typec_unattached_snk) {
-		TYPEC_INFO("norp_src=1\n");
-		tcpc_enable_timer(tcpc, TYPEC_TIMER_NORP_SRC);
+	if (tcpci_check_vbus_valid(tcpc_dev) &&
+	    (tcpc_dev->typec_state == typec_unattached_snk)) {
+		TYPEC_DBG("norp_src=1\r\n");
+		tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_NORP_SRC);
 		return true;
 	}
 
@@ -392,48 +379,45 @@ static bool typec_try_enter_norp_src(struct tcpc_device *tcpc)
 }
 
 static void typec_unattach_wait_pe_idle_entry(struct tcpc_device *tcpc);
-static bool typec_try_exit_norp_src(struct tcpc_device *tcpc)
-{
-	if ((!tcpci_check_vbus_valid_from_ic(tcpc) ||
-	     !typec_is_cc_no_res()) &&
-	    tcpc->typec_state == typec_attached_norp_src) {
-		TYPEC_INFO("norp_src=0\n");
-		typec_unattach_wait_pe_idle_entry(tcpc);
-		typec_alert_attach_state_change(tcpc);
+static bool typec_try_exit_norp_src(struct tcpc_device *tcpc_dev)
+{
+	if (tcpc_dev->typec_state == typec_attached_norp_src) {
+		TYPEC_DBG("norp_src=0\r\n");
+		typec_unattach_wait_pe_idle_entry(tcpc_dev);
+		typec_alert_attach_state_change(tcpc_dev);
 		return true;
 	}
 
 	return false;
 }
 
-static inline int typec_norp_src_attached_entry(struct tcpc_device *tcpc)
+static inline int typec_norp_src_attached_entry(struct tcpc_device *tcpc_dev)
 {
 #ifdef CONFIG_WATER_DETECTION
 #ifdef CONFIG_WD_POLLING_ONLY
-	if (!tcpc->typec_power_ctrl) {
-		if (get_boot_mode() == KERNEL_POWER_OFF_CHARGING_BOOT ||
-		    get_boot_mode() == LOW_POWER_OFF_CHARGING_BOOT)
-			typec_check_water_status(tcpc);
+	if (!tcpc_dev->typec_power_ctrl) {
+		if (tcpc_dev->tcpc_flags & TCPC_FLAGS_KPOC_BOOT)
+			typec_check_water_status(tcpc_dev);
 
-		tcpci_set_usbid_polling(tcpc, false);
+		tcpci_set_usbid_polling(tcpc_dev, false);
 	}
 #else
-	if (!tcpc->typec_power_ctrl && typec_check_water_status(tcpc))
+	if (!tcpc_dev->typec_power_ctrl && typec_check_water_status(tcpc_dev))
 		return 0;
 #endif /* CONFIG_WD_POLLING_ONLY */
 #endif /* CONFIG_WATER_DETECTION */
 
 	TYPEC_NEW_STATE(typec_attached_norp_src);
-	tcpc->typec_attach_new = TYPEC_ATTACHED_NORP_SRC;
+	tcpc_dev->typec_attach_new = TYPEC_ATTACHED_NORP_SRC;
 
 #ifdef CONFIG_TYPEC_CAP_A2C_C2C
-	tcpc->typec_a2c_cable = true;
+	tcpc_dev->typec_a2c_cable = true;
 #endif	/* CONFIG_TYPEC_CAP_A2C_C2C */
 
-	tcpci_report_power_control(tcpc, true);
-	tcpci_sink_vbus(tcpc, TCP_VBUS_CTRL_TYPEC, TCPC_VBUS_SINK_5V, 500);
+	tcpci_report_power_control(tcpc_dev, true);
+	tcpci_sink_vbus(tcpc_dev, TCP_VBUS_CTRL_TYPEC, TCPC_VBUS_SINK_5V, 500);
 
-	typec_alert_attach_state_change(tcpc);
+	typec_alert_attach_state_change(tcpc_dev);
 	return 0;
 }
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
@@ -442,338 +426,318 @@ static inline int typec_norp_src_attached_entry(struct tcpc_device *tcpc)
  * [BLOCK] Unattached Entry
  */
 
-static inline int typec_try_low_power_mode(struct tcpc_device *tcpc)
+static inline int typec_try_low_power_mode(struct tcpc_device *tcpc_dev)
 {
 	int ret = tcpci_set_low_power_mode(
-		tcpc, true, tcpc->typec_lpm_pull);
+		tcpc_dev, true, tcpc_dev->typec_lpm_pull);
 	if (ret < 0)
 		return ret;
 
 #ifdef CONFIG_TCPC_LPM_CONFIRM
-	ret = tcpci_is_low_power_mode(tcpc);
+	ret = tcpci_is_low_power_mode(tcpc_dev);
 	if (ret < 0)
 		return ret;
 
 	if (ret == 1)
 		return 0;
 
-	if (tcpc->typec_lpm_retry == 0) {
-		TYPEC_INFO("TryLPM Failed\n");
+	if (tcpc_dev->typec_lpm_retry == 0) {
+		TYPEC_INFO("TryLPM Failed\r\n");
 		return 0;
 	}
 
-	tcpc->typec_lpm_retry--;
-	TYPEC_DBG("RetryLPM : %d\n", tcpc->typec_lpm_retry);
-	tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_LOW_POWER_MODE);
+	tcpc_dev->typec_lpm_retry--;
+	TYPEC_DBG("RetryLPM : %d\r\n", tcpc_dev->typec_lpm_retry);
+	tcpc_enable_timer(tcpc_dev, TYPEC_RT_TIMER_LOW_POWER_MODE);
 #endif	/* CONFIG_TCPC_LPM_CONFIRM */
 
 	return 0;
 }
 
-static inline int typec_enter_low_power_mode(struct tcpc_device *tcpc)
+static inline int typec_enter_low_power_mode(struct tcpc_device *tcpc_dev)
 {
 	int ret = 0;
 
 #ifdef CONFIG_TCPC_LPM_POSTPONE
-	tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_LOW_POWER_MODE);
+	tcpc_enable_timer(tcpc_dev, TYPEC_RT_TIMER_LOW_POWER_MODE);
 #else
-	ret = typec_try_low_power_mode(tcpc);
+	ret = typec_try_low_power_mode(tcpc_dev);
 #endif	/* CONFIG_TCPC_POSTPONE_LPM */
 
 	return ret;
 }
 
 static inline int typec_enable_low_power_mode(
-	struct tcpc_device *tcpc, uint8_t pull)
+	struct tcpc_device *tcpc_dev, uint8_t pull)
 {
 	int ret = 0;
 
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
-	if (tcpc->typec_legacy_cable) {
-		TYPEC_DBG("LPM_LCOnly\n");
+	if (tcpc_dev->typec_legacy_cable) {
+		TYPEC_DBG("LPM_LCOnly\r\n");
 		return 0;
 	}
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE */
 
-	if (tcpc->typec_cable_only) {
-		TYPEC_DBG("LPM_RaOnly\n");
+	if (tcpc_dev->typec_cable_only) {
+		TYPEC_DBG("LPM_RaOnly\r\n");
 
 #ifdef CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
-		if (tcpc->tcpc_flags & TCPC_FLAGS_LPM_WAKEUP_WATCHDOG)
-			tcpc_enable_wakeup_timer(tcpc, true);
+		if (tcpc_dev->tcpc_flags & TCPC_FLAGS_LPM_WAKEUP_WATCHDOG)
+			tcpc_enable_wakeup_timer(tcpc_dev, true);
 #endif	/* CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG */
 
 		return 0;
 	}
 
-	if (tcpc->typec_lpm != true) {
-		tcpc->typec_lpm = true;
-		tcpc->typec_lpm_retry = TCPC_LOW_POWER_MODE_RETRY;
-		tcpc->typec_lpm_pull = (uint8_t) pull;
-		ret = typec_enter_low_power_mode(tcpc);
+	if (tcpc_dev->typec_lpm != true) {
+		tcpc_dev->typec_lpm = true;
+		tcpc_dev->typec_lpm_retry = TCPC_LOW_POWER_MODE_RETRY;
+		tcpc_dev->typec_lpm_pull = (uint8_t) pull;
+		ret = typec_enter_low_power_mode(tcpc_dev);
 	}
 
 	return ret;
 }
 
 static inline int typec_disable_low_power_mode(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
 	int ret = 0;
 
-	if (tcpc->typec_lpm != false) {
-		tcpc->typec_lpm = false;
-		tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_LOW_POWER_MODE);
-		tcpci_set_low_rp_duty(tcpc, false);
-		ret = tcpci_set_low_power_mode(tcpc, false, TYPEC_CC_DRP);
+	if (tcpc_dev->typec_lpm != false) {
+		tcpc_dev->typec_lpm = false;
+		tcpc_disable_timer(tcpc_dev, TYPEC_RT_TIMER_LOW_POWER_MODE);
+		tcpci_set_low_rp_duty(tcpc_dev, false);
+		ret = tcpci_set_low_power_mode(tcpc_dev, false, TYPEC_CC_DRP);
 	}
 
 #ifdef CONFIG_TYPEC_WAKEUP_ONCE_LOW_DUTY
-	tcpc->typec_wakeup_once = 0;
-	tcpc->typec_low_rp_duty_cntdown = 0;
+	tcpc_dev->typec_wakeup_once = 0;
+	tcpc_dev->typec_low_rp_duty_cntdown = 0;
 #endif	/* CONFIG_TYPEC_WAKEUP_ONCE_LOW_DUTY */
 
 	return ret;
 }
 
-static void typec_unattached_power_entry(struct tcpc_device *tcpc)
+static void typec_unattached_power_entry(struct tcpc_device *tcpc_dev)
 {
-	typec_wait_ps_change(tcpc, TYPEC_WAIT_PS_DISABLE);
+	typec_wait_ps_change(tcpc_dev, TYPEC_WAIT_PS_DISABLE);
 
-	if (tcpc->typec_power_ctrl) {
-		tcpci_set_vconn(tcpc, false);
-		tcpci_disable_vbus_control(tcpc);
-		tcpci_report_power_control(tcpc, false);
+	if (tcpc_dev->typec_power_ctrl) {
+		tcpci_set_vconn(tcpc_dev, false);
+		tcpci_disable_vbus_control(tcpc_dev);
+		tcpci_report_power_control(tcpc_dev, false);
 	}
 }
 
-static inline void typec_unattached_src_and_drp_entry(struct tcpc_device *tcpc)
-{
-	TYPEC_NEW_STATE(typec_unattached_src);
-	tcpci_set_cc(tcpc, TYPEC_CC_RP);
-	tcpc_enable_timer(tcpc, TYPEC_TIMER_DRP_SRC_TOGGLE);
-}
-
-static inline void typec_unattached_snk_and_drp_entry(struct tcpc_device *tcpc)
-{
-	TYPEC_NEW_STATE(typec_unattached_snk);
-	tcpci_set_cc(tcpc, TYPEC_CC_DRP);
-	typec_enable_low_power_mode(tcpc, TYPEC_CC_DRP);
-}
-
-static inline void typec_unattached_cc_entry(struct tcpc_device *tcpc)
+static inline void typec_unattached_cc_entry(struct tcpc_device *tcpc_dev)
 {
 #ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
-	if (tcpc->typec_during_role_swap) {
+	if (tcpc_dev->typec_during_role_swap) {
 		TYPEC_NEW_STATE(typec_role_swap);
 		return;
 	}
 #endif	/* CONFIG_TYPEC_CAP_ROLE_SWAP */
 #ifdef CONFIG_CABLE_TYPE_DETECTION
-	if (tcpc->typec_state == typec_attached_snk ||
-	    tcpc->typec_state == typec_unattachwait_pe)
-		tcpc_typec_handle_ctd(tcpc, TCPC_CABLE_TYPE_NONE);
+	tcpc_typec_handle_ctd(tcpc_dev, TCPC_CABLE_TYPE_NONE);
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
 
-	tcpc->typec_role = tcpc->typec_role_new;
-	switch (tcpc->typec_role) {
+	switch (tcpc_dev->typec_role) {
 	case TYPEC_ROLE_SNK:
 		TYPEC_NEW_STATE(typec_unattached_snk);
-		tcpci_set_cc(tcpc, TYPEC_CC_RD);
-		typec_enable_low_power_mode(tcpc, TYPEC_CC_RD);
+		tcpci_set_cc(tcpc_dev, TYPEC_CC_RD);
+		typec_enable_low_power_mode(tcpc_dev, TYPEC_CC_RD);
 		break;
 	case TYPEC_ROLE_SRC:
 #ifdef CONFIG_TYPEC_CHECK_SRC_UNATTACH_OPEN
 		if (typec_check_cc_any(TYPEC_CC_VOLT_RD)) {
-			TYPEC_DBG("typec_src_unattach not open\n");
-			tcpci_set_cc(tcpc, TYPEC_CC_OPEN);
+			TYPEC_DBG("typec_src_unattach not open\r\n");
+			tcpci_set_cc(tcpc_dev, TYPEC_CC_OPEN);
 			usleep_rnage(5000, 6000);
 		}
 #endif	/* CONFIG_TYPEC_CHECK_SRC_UNATTACH_OPEN */
 		TYPEC_NEW_STATE(typec_unattached_src);
-		tcpci_set_cc(tcpc, TYPEC_CC_RP);
-		typec_enable_low_power_mode(tcpc, TYPEC_CC_RP);
+		tcpci_set_cc(tcpc_dev, TYPEC_CC_RP);
+		typec_enable_low_power_mode(tcpc_dev, TYPEC_CC_RP);
 		break;
-	case TYPEC_ROLE_TRY_SRC:
-		if (tcpc->typec_state == typec_errorrecovery) {
-			typec_unattached_src_and_drp_entry(tcpc);
-			break;
-		}
-		/* pass through */
 	default:
-		switch (tcpc->typec_state) {
+		switch (tcpc_dev->typec_state) {
 		case typec_attachwait_snk:
 		case typec_audioaccessory:
-			typec_unattached_src_and_drp_entry(tcpc);
+			TYPEC_NEW_STATE(typec_unattached_src);
+			tcpci_set_cc(tcpc_dev, TYPEC_CC_RP);
+			tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_DRP_SRC_TOGGLE);
 			break;
 		default:
-			typec_unattached_snk_and_drp_entry(tcpc);
+			TYPEC_NEW_STATE(typec_unattached_snk);
+			tcpci_set_cc(tcpc_dev, TYPEC_CC_DRP);
+			typec_enable_low_power_mode(tcpc_dev, TYPEC_CC_DRP);
 			break;
 		}
 		break;
 	}
 
 #ifdef CONFIG_TYPEC_CAP_NORP_SRC
-	typec_try_enter_norp_src(tcpc);
+	if (typec_is_cc_no_res())
+		typec_try_enter_norp_src(tcpc_dev);
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
 }
 
-static void typec_unattached_entry(struct tcpc_device *tcpc)
+static void typec_unattached_entry(struct tcpc_device *tcpc_dev)
 {
 #ifdef CONFIG_TYPEC_CAP_CUSTOM_HV
-	tcpc->typec_during_custom_hv = false;
+	tcpc_dev->typec_during_custom_hv = false;
 #endif	/* CONFIG_TYPEC_CAP_CUSTOM_HV */
 
-	tcpc->typec_usb_sink_curr = CONFIG_TYPEC_SNK_CURR_DFT;
+	tcpc_dev->typec_usb_sink_curr = CONFIG_TYPEC_SNK_CURR_DFT;
 
-	if (tcpc->typec_power_ctrl)
-		tcpci_set_vconn(tcpc, false);
-	typec_unattached_cc_entry(tcpc);
-	typec_unattached_power_entry(tcpc);
+	if (tcpc_dev->typec_power_ctrl)
+		tcpci_set_vconn(tcpc_dev, false);
+	typec_unattached_cc_entry(tcpc_dev);
+	typec_unattached_power_entry(tcpc_dev);
 }
 
-static void typec_unattach_wait_pe_idle_entry(struct tcpc_device *tcpc)
+static void typec_unattach_wait_pe_idle_entry(struct tcpc_device *tcpc_dev)
 {
-	tcpc->typec_attach_new = TYPEC_UNATTACHED;
+	tcpc_dev->typec_attach_new = TYPEC_UNATTACHED;
 
 #ifdef CONFIG_USB_POWER_DELIVERY
-	if (tcpc->pd_pe_running) {
+	if (tcpc_dev->pd_pe_running) {
 		TYPEC_NEW_STATE(typec_unattachwait_pe);
 		return;
 	}
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
-	typec_unattached_entry(tcpc);
+	typec_unattached_entry(tcpc_dev);
 }
 
-static void typec_postpone_state_change(struct tcpc_device *tcpc)
+static void typec_postpone_state_change(struct tcpc_device *tcpc_dev)
 {
-	TYPEC_DBG("Postpone AlertChange\n");
-	tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_STATE_CHANGE);
+	TYPEC_DBG("Postpone AlertChange\r\n");
+	tcpc_enable_timer(tcpc_dev, TYPEC_RT_TIMER_STATE_CHANGE);
 }
 
-static void typec_cc_open_entry(struct tcpc_device *tcpc, uint8_t state)
+static void typec_cc_open_entry(struct tcpc_device *tcpc_dev, uint8_t state)
 {
-	mutex_lock(&tcpc->access_lock);
+	mutex_lock(&tcpc_dev->access_lock);
 	TYPEC_NEW_STATE(state);
-	tcpc->typec_attach_new = TYPEC_UNATTACHED;
-	mutex_unlock(&tcpc->access_lock);
+	tcpc_dev->typec_attach_new = TYPEC_UNATTACHED;
+	mutex_unlock(&tcpc_dev->access_lock);
 
-	tcpci_set_cc(tcpc, TYPEC_CC_OPEN);
-	typec_unattached_power_entry(tcpc);
+	tcpci_set_cc(tcpc_dev, TYPEC_CC_OPEN);
+	typec_unattached_power_entry(tcpc_dev);
 
-	typec_postpone_state_change(tcpc);
+	typec_postpone_state_change(tcpc_dev);
 }
 
-static inline void typec_error_recovery_entry(struct tcpc_device *tcpc)
+static inline void typec_error_recovery_entry(struct tcpc_device *tcpc_dev)
 {
-	typec_cc_open_entry(tcpc, typec_errorrecovery);
-	tcpc_reset_typec_debounce_timer(tcpc);
-	tcpc_enable_timer(tcpc, TYPEC_TIMER_ERROR_RECOVERY);
+	typec_cc_open_entry(tcpc_dev, typec_errorrecovery);
+	tcpc_reset_typec_debounce_timer(tcpc_dev);
+	tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_ERROR_RECOVERY);
 }
 
-static inline void typec_disable_entry(struct tcpc_device *tcpc)
+static inline void typec_disable_entry(struct tcpc_device *tcpc_dev)
 {
-	typec_cc_open_entry(tcpc, typec_disabled);
+	typec_cc_open_entry(tcpc_dev, typec_disabled);
 }
 
 /*
  * [BLOCK] Attached Entry
  */
 
-static inline int typec_set_polarity(struct tcpc_device *tcpc,
+static inline int typec_set_polarity(struct tcpc_device *tcpc_dev,
 					bool polarity)
 {
-	tcpc->typec_polarity = polarity;
-	return tcpci_set_polarity(tcpc, polarity);
+	tcpc_dev->typec_polarity = polarity;
+	return tcpci_set_polarity(tcpc_dev, polarity);
 }
 
-static inline int typec_set_plug_orient(struct tcpc_device *tcpc,
-				uint8_t pull, bool polarity)
+static inline int typec_set_plug_orient(struct tcpc_device *tcpc_dev,
+				uint8_t res, bool polarity)
 {
-	int rv = typec_set_polarity(tcpc, polarity);
+	int rv = typec_set_polarity(tcpc_dev, polarity);
 
 	if (rv)
 		return rv;
 
-	return tcpci_set_cc(tcpc, pull);
+	return tcpci_set_cc(tcpc_dev, res);
 }
 
-static void typec_source_attached_with_vbus_entry(struct tcpc_device *tcpc)
+static void typec_source_attached_with_vbus_entry(struct tcpc_device *tcpc_dev)
 {
-	tcpc->typec_attach_new = TYPEC_ATTACHED_SRC;
-	typec_wait_ps_change(tcpc, TYPEC_WAIT_PS_DISABLE);
+	tcpc_dev->typec_attach_new = TYPEC_ATTACHED_SRC;
+	typec_wait_ps_change(tcpc_dev, TYPEC_WAIT_PS_DISABLE);
 }
 
-static inline void typec_source_attached_entry(struct tcpc_device *tcpc)
+static inline void typec_source_attached_entry(struct tcpc_device *tcpc_dev)
 {
 	TYPEC_NEW_STATE(typec_attached_src);
-	tcpc->typec_is_attached_src = true;
-	typec_wait_ps_change(tcpc, TYPEC_WAIT_PS_SRC_VSAFE5V);
+	typec_wait_ps_change(tcpc_dev, TYPEC_WAIT_PS_SRC_VSAFE5V);
 
-	tcpc_disable_timer(tcpc, TYPEC_TRY_TIMER_DRP_TRY);
+	tcpc_disable_timer(tcpc_dev, TYPEC_TRY_TIMER_DRP_TRY);
 
 #ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
-	if (tcpc->typec_during_role_swap) {
-		tcpc->typec_during_role_swap = TYPEC_ROLE_SWAP_NONE;
-		tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_ROLE_SWAP_STOP);
+	if (tcpc_dev->typec_during_role_swap) {
+		tcpc_dev->typec_during_role_swap = TYPEC_ROLE_SWAP_NONE;
+		tcpc_disable_timer(tcpc_dev, TYPEC_RT_TIMER_ROLE_SWAP_STOP);
 	}
 #endif	/* CONFIG_TYPEC_CAP_ROLE_SWAP */
 
-	typec_set_plug_orient(tcpc,
-		TYPEC_CC_PULL(tcpc->typec_local_rp_level, TYPEC_CC_RP),
+	typec_set_plug_orient(tcpc_dev,
+		tcpc_dev->typec_local_rp_level,
 		typec_check_cc2(TYPEC_CC_VOLT_RD));
 
-	tcpci_report_power_control(tcpc, true);
-	typec_enable_vconn(tcpc);
-	tcpci_source_vbus(tcpc,
+	tcpci_report_power_control(tcpc_dev, true);
+	typec_enable_vconn(tcpc_dev);
+	tcpci_source_vbus(tcpc_dev,
 			TCP_VBUS_CTRL_TYPEC, TCPC_VBUS_SOURCE_5V, -1);
 }
 
-static inline void typec_sink_attached_entry(struct tcpc_device *tcpc)
+static inline void typec_sink_attached_entry(struct tcpc_device *tcpc_dev)
 {
 	TYPEC_NEW_STATE(typec_attached_snk);
-	typec_wait_ps_change(tcpc, TYPEC_WAIT_PS_DISABLE);
+	typec_wait_ps_change(tcpc_dev, TYPEC_WAIT_PS_DISABLE);
 
-	tcpc->typec_attach_new = TYPEC_ATTACHED_SNK;
+	tcpc_dev->typec_attach_new = TYPEC_ATTACHED_SNK;
 
 #ifdef CONFIG_TYPEC_CAP_TRY_STATE
-	if (tcpc->typec_role >= TYPEC_ROLE_DRP)
-		tcpc_reset_typec_try_timer(tcpc);
+	if (tcpc_dev->typec_role >= TYPEC_ROLE_DRP)
+		tcpc_reset_typec_try_timer(tcpc_dev);
 #endif	/* CONFIG_TYPEC_CAP_TRY_STATE */
 
 #ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
-	if (tcpc->typec_during_role_swap) {
-		tcpc->typec_during_role_swap = TYPEC_ROLE_SWAP_NONE;
-		tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_ROLE_SWAP_STOP);
+	if (tcpc_dev->typec_during_role_swap) {
+		tcpc_dev->typec_during_role_swap = TYPEC_ROLE_SWAP_NONE;
+		tcpc_disable_timer(tcpc_dev, TYPEC_RT_TIMER_ROLE_SWAP_STOP);
 	}
 #endif	/* CONFIG_TYPEC_CAP_ROLE_SWAP */
 
-	typec_set_plug_orient(tcpc, TYPEC_CC_RD,
+	typec_set_plug_orient(tcpc_dev, TYPEC_CC_RD,
 		!typec_check_cc2(TYPEC_CC_VOLT_OPEN));
-	tcpc->typec_remote_rp_level = typec_get_cc_res();
+	tcpc_dev->typec_remote_rp_level = typec_get_cc_res();
 
-	tcpci_report_power_control(tcpc, true);
-	tcpci_sink_vbus(tcpc, TCP_VBUS_CTRL_TYPEC, TCPC_VBUS_SINK_5V, -1);
+	tcpci_report_power_control(tcpc_dev, true);
+	tcpci_sink_vbus(tcpc_dev, TCP_VBUS_CTRL_TYPEC, TCPC_VBUS_SINK_5V, -1);
 }
 
 static inline void typec_custom_src_attached_entry(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
 #ifdef CONFIG_TYPEC_CAP_DBGACC_SNK
-	TYPEC_DBG("[Warning] Same Rp (%d)\n", typec_get_cc1());
+	TYPEC_DBG("[Warning] Same Rp (%d)\r\n", typec_get_cc1());
 #else
-	TYPEC_DBG("[Warning] CC Both Rp\n");
+	TYPEC_DBG("[Warning] CC Both Rp\r\n");
 #endif
 
 #ifdef CONFIG_TYPEC_CAP_CUSTOM_SRC
 	TYPEC_NEW_STATE(typec_attached_custom_src);
-	tcpc->typec_attach_new = TYPEC_ATTACHED_CUSTOM_SRC;
+	tcpc_dev->typec_attach_new = TYPEC_ATTACHED_CUSTOM_SRC;
 
-	tcpc->typec_remote_rp_level = typec_get_cc1();
-
-	tcpci_report_power_control(tcpc, true);
-	tcpci_sink_vbus(tcpc, TCP_VBUS_CTRL_TYPEC, TCPC_VBUS_SINK_5V, -1);
+	tcpci_report_power_control(tcpc_dev, true);
+	tcpci_sink_vbus(tcpc_dev, TCP_VBUS_CTRL_TYPEC,
+		TCPC_VBUS_SINK_5V, tcpc_dev->typec_usb_sink_curr);
 #endif	/* CONFIG_TYPEC_CAP_CUSTOM_SRC */
 }
 
@@ -789,7 +753,7 @@ static inline uint8_t typec_get_sink_dbg_acc_rp_level(
 }
 
 static inline void typec_sink_dbg_acc_attached_entry(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
 	bool polarity;
 	uint8_t rp_level;
@@ -798,13 +762,13 @@ static inline void typec_sink_dbg_acc_attached_entry(
 	uint8_t cc2 = typec_get_cc2();
 
 	if (cc1 == cc2) {
-		typec_custom_src_attached_entry(tcpc);
+		typec_custom_src_attached_entry(tcpc_dev);
 		return;
 	}
 
 	TYPEC_NEW_STATE(typec_attached_dbgacc_snk);
 
-	tcpc->typec_attach_new = TYPEC_ATTACHED_DBGACC_SNK;
+	tcpc_dev->typec_attach_new = TYPEC_ATTACHED_DBGACC_SNK;
 
 	polarity = cc2 > cc1;
 
@@ -813,17 +777,17 @@ static inline void typec_sink_dbg_acc_attached_entry(
 	else
 		rp_level = typec_get_sink_dbg_acc_rp_level(cc1, cc2);
 
-	typec_set_plug_orient(tcpc, TYPEC_CC_RD, polarity);
-	tcpc->typec_remote_rp_level = rp_level;
+	typec_set_plug_orient(tcpc_dev, TYPEC_CC_RD, polarity);
+	tcpc_dev->typec_remote_rp_level = rp_level;
 
-	tcpci_report_power_control(tcpc, true);
-	tcpci_sink_vbus(tcpc, TCP_VBUS_CTRL_TYPEC, TCPC_VBUS_SINK_5V, -1);
+	tcpci_report_power_control(tcpc_dev, true);
+	tcpci_sink_vbus(tcpc_dev, TCP_VBUS_CTRL_TYPEC, TCPC_VBUS_SINK_5V, -1);
 }
 #else
 static inline void typec_sink_dbg_acc_attached_entry(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
-	typec_custom_src_attached_entry(tcpc);
+	typec_custom_src_attached_entry(tcpc_dev);
 }
 #endif	/* CONFIG_TYPEC_CAP_DBGACC_SNK */
 
@@ -835,54 +799,54 @@ static inline void typec_sink_dbg_acc_attached_entry(
 #ifdef CONFIG_TYPEC_CAP_TRY_SOURCE
 
 static inline bool typec_role_is_try_src(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
-	if (tcpc->typec_role != TYPEC_ROLE_TRY_SRC)
+	if (tcpc_dev->typec_role != TYPEC_ROLE_TRY_SRC)
 		return false;
 
 #ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
-	if (tcpc->typec_during_role_swap)
+	if (tcpc_dev->typec_during_role_swap)
 		return false;
 #endif	/* CONFIG_TYPEC_CAP_ROLE_SWAP */
 
 	return true;
 }
 
-static inline void typec_try_src_entry(struct tcpc_device *tcpc)
+static inline void typec_try_src_entry(struct tcpc_device *tcpc_dev)
 {
 	TYPEC_NEW_STATE(typec_try_src);
-	tcpc->typec_drp_try_timeout = false;
+	tcpc_dev->typec_drp_try_timeout = false;
 
-	tcpci_set_cc(tcpc, TYPEC_CC_RP);
-	tcpc_enable_timer(tcpc, TYPEC_TRY_TIMER_DRP_TRY);
+	tcpci_set_cc(tcpc_dev, TYPEC_CC_RP);
+	tcpc_enable_timer(tcpc_dev, TYPEC_TRY_TIMER_DRP_TRY);
 }
 
-static inline void typec_trywait_snk_entry(struct tcpc_device *tcpc)
+static inline void typec_trywait_snk_entry(struct tcpc_device *tcpc_dev)
 {
 	TYPEC_NEW_STATE(typec_trywait_snk);
-	typec_wait_ps_change(tcpc, TYPEC_WAIT_PS_DISABLE);
+	typec_wait_ps_change(tcpc_dev, TYPEC_WAIT_PS_DISABLE);
 
-	tcpci_set_vconn(tcpc, false);
-	tcpci_set_cc(tcpc, TYPEC_CC_RD);
-	tcpci_source_vbus(tcpc,
+	tcpci_set_vconn(tcpc_dev, false);
+	tcpci_set_cc(tcpc_dev, TYPEC_CC_RD);
+	tcpci_source_vbus(tcpc_dev,
 			TCP_VBUS_CTRL_TYPEC, TCPC_VBUS_SOURCE_0V, 0);
-	tcpc_disable_timer(tcpc, TYPEC_TRY_TIMER_DRP_TRY);
+	tcpc_disable_timer(tcpc_dev, TYPEC_TRY_TIMER_DRP_TRY);
 
-	tcpc_enable_timer(tcpc, TYPEC_TIMER_PDDEBOUNCE);
+	tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_PDDEBOUNCE);
 }
 
-static inline void typec_trywait_snk_pe_entry(struct tcpc_device *tcpc)
+static inline void typec_trywait_snk_pe_entry(struct tcpc_device *tcpc_dev)
 {
-	tcpc->typec_attach_new = TYPEC_UNATTACHED;
+	tcpc_dev->typec_attach_new = TYPEC_UNATTACHED;
 
 #ifdef CONFIG_USB_POWER_DELIVERY
-	if (tcpc->typec_attach_old) {
+	if (tcpc_dev->typec_attach_old) {
 		TYPEC_NEW_STATE(typec_trywait_snk_pe);
 		return;
 	}
 #endif
 
-	typec_trywait_snk_entry(tcpc);
+	typec_trywait_snk_entry(tcpc_dev);
 }
 
 #endif /* CONFIG_TYPEC_CAP_TRY_SOURCE */
@@ -894,36 +858,36 @@ static inline void typec_trywait_snk_pe_entry(struct tcpc_device *tcpc)
 #ifdef CONFIG_TYPEC_CAP_TRY_SINK
 
 static inline bool typec_role_is_try_sink(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
-	if (tcpc->typec_role != TYPEC_ROLE_TRY_SNK)
+	if (tcpc_dev->typec_role != TYPEC_ROLE_TRY_SNK)
 		return false;
 
 #ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
-	if (tcpc->typec_during_role_swap)
+	if (tcpc_dev->typec_during_role_swap)
 		return false;
 #endif	/* CONFIG_TYPEC_CAP_ROLE_SWAP */
 
 	return true;
 }
 
-static inline void typec_try_snk_entry(struct tcpc_device *tcpc)
+static inline void typec_try_snk_entry(struct tcpc_device *tcpc_dev)
 {
 	TYPEC_NEW_STATE(typec_try_snk);
-	tcpc->typec_drp_try_timeout = false;
+	tcpc_dev->typec_drp_try_timeout = false;
 
-	tcpci_set_cc(tcpc, TYPEC_CC_RD);
-	tcpc_enable_timer(tcpc, TYPEC_TRY_TIMER_DRP_TRY);
+	tcpci_set_cc(tcpc_dev, TYPEC_CC_RD);
+	tcpc_enable_timer(tcpc_dev, TYPEC_TRY_TIMER_DRP_TRY);
 }
 
-static inline void typec_trywait_src_entry(struct tcpc_device *tcpc)
+static inline void typec_trywait_src_entry(struct tcpc_device *tcpc_dev)
 {
 	TYPEC_NEW_STATE(typec_trywait_src);
-	tcpc->typec_drp_try_timeout = false;
+	tcpc_dev->typec_drp_try_timeout = false;
 
-	tcpci_set_cc(tcpc, TYPEC_CC_RP);
-	tcpci_sink_vbus(tcpc, TCP_VBUS_CTRL_TYPEC, TCPC_VBUS_SINK_0V, 0);
-	tcpc_enable_timer(tcpc, TYPEC_TRY_TIMER_DRP_TRY);
+	tcpci_set_cc(tcpc_dev, TYPEC_CC_RP);
+	tcpci_sink_vbus(tcpc_dev, TCP_VBUS_CTRL_TYPEC, TCPC_VBUS_SINK_0V, 0);
+	tcpc_enable_timer(tcpc_dev, TYPEC_TRY_TIMER_DRP_TRY);
 }
 
 #endif /* CONFIG_TYPEC_CAP_TRY_SINK */
@@ -933,99 +897,97 @@ static inline void typec_trywait_src_entry(struct tcpc_device *tcpc)
  */
 
 static inline void typec_cc_snk_detect_vsafe5v_entry(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
-	typec_wait_ps_change(tcpc, TYPEC_WAIT_PS_DISABLE);
+	typec_wait_ps_change(tcpc_dev, TYPEC_WAIT_PS_DISABLE);
 
 	if (!typec_check_cc_any(TYPEC_CC_VOLT_OPEN)) {	/* Both Rp */
-		typec_sink_dbg_acc_attached_entry(tcpc);
+		typec_sink_dbg_acc_attached_entry(tcpc_dev);
 		return;
 	}
 
 #ifdef CONFIG_TYPEC_CAP_TRY_SOURCE
-	if (typec_role_is_try_src(tcpc)) {
-		if (tcpc->typec_state == typec_attachwait_snk) {
-			typec_try_src_entry(tcpc);
+	if (typec_role_is_try_src(tcpc_dev)) {
+		if (tcpc_dev->typec_state == typec_attachwait_snk) {
+			typec_try_src_entry(tcpc_dev);
 			return;
 		}
 	}
 #endif /* CONFIG_TYPEC_CAP_TRY_SOURCE */
 
-	typec_sink_attached_entry(tcpc);
+	typec_sink_attached_entry(tcpc_dev);
 }
 
-static inline void typec_cc_snk_detect_entry(struct tcpc_device *tcpc)
+static inline void typec_cc_snk_detect_entry(struct tcpc_device *tcpc_dev)
 {
 	/* If Port Partner act as Source without VBUS, wait vSafe5V */
-	if (tcpci_check_vbus_valid(tcpc))
-		typec_cc_snk_detect_vsafe5v_entry(tcpc);
+	if (tcpci_check_vbus_valid(tcpc_dev))
+		typec_cc_snk_detect_vsafe5v_entry(tcpc_dev);
 	else
-		typec_wait_ps_change(tcpc, TYPEC_WAIT_PS_SNK_VSAFE5V);
+		typec_wait_ps_change(tcpc_dev, TYPEC_WAIT_PS_SNK_VSAFE5V);
 }
 
 static inline void typec_cc_src_detect_vsafe0v_entry(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
-	typec_wait_ps_change(tcpc, TYPEC_WAIT_PS_DISABLE);
+	typec_wait_ps_change(tcpc_dev, TYPEC_WAIT_PS_DISABLE);
 
 #ifdef CONFIG_TYPEC_CAP_TRY_SINK
-	if (typec_role_is_try_sink(tcpc)) {
-		if (tcpc->typec_state == typec_attachwait_src) {
-			typec_try_snk_entry(tcpc);
+	if (typec_role_is_try_sink(tcpc_dev)) {
+		if (tcpc_dev->typec_state == typec_attachwait_src) {
+			typec_try_snk_entry(tcpc_dev);
 			return;
 		}
 	}
 #endif /* CONFIG_TYPEC_CAP_TRY_SINK */
 
-	typec_source_attached_entry(tcpc);
+	typec_source_attached_entry(tcpc_dev);
 }
 
 static inline void typec_cc_src_detect_entry(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
 	/* If Port Partner act as Sink with low VBUS, wait vSafe0v */
-	bool vbus_absent = tcpci_check_vsafe0v(tcpc, true);
+	bool vbus_absent = tcpci_check_vsafe0v(tcpc_dev, true);
 
-	if (vbus_absent || tcpc->typec_reach_vsafe0v)
-		typec_cc_src_detect_vsafe0v_entry(tcpc);
+	if (vbus_absent || tcpc_dev->typec_reach_vsafe0v)
+		typec_cc_src_detect_vsafe0v_entry(tcpc_dev);
 	else
-		typec_wait_ps_change(tcpc, TYPEC_WAIT_PS_SRC_VSAFE0V);
+		typec_wait_ps_change(tcpc_dev, TYPEC_WAIT_PS_SRC_VSAFE0V);
 }
 
-static inline void typec_cc_src_remove_entry(struct tcpc_device *tcpc)
+static inline void typec_cc_src_remove_entry(struct tcpc_device *tcpc_dev)
 {
-	typec_wait_ps_change(tcpc, TYPEC_WAIT_PS_DISABLE);
-
-	tcpc->typec_is_attached_src = false;
+	typec_wait_ps_change(tcpc_dev, TYPEC_WAIT_PS_DISABLE);
 
 #ifdef CONFIG_TYPEC_CAP_TRY_SOURCE
-	if (typec_role_is_try_src(tcpc)) {
-		switch (tcpc->typec_state) {
+	if (typec_role_is_try_src(tcpc_dev)) {
+		switch (tcpc_dev->typec_state) {
 		case typec_attached_src:
-			typec_trywait_snk_pe_entry(tcpc);
+			typec_trywait_snk_pe_entry(tcpc_dev);
 			return;
 		case typec_try_src:
-			typec_trywait_snk_entry(tcpc);
+			typec_trywait_snk_entry(tcpc_dev);
 			return;
 		}
 	}
 #endif	/* CONFIG_TYPEC_CAP_TRY_SOURCE */
 
-	typec_unattach_wait_pe_idle_entry(tcpc);
+	typec_unattach_wait_pe_idle_entry(tcpc_dev);
 }
 
-static inline void typec_cc_snk_remove_entry(struct tcpc_device *tcpc)
+static inline void typec_cc_snk_remove_entry(struct tcpc_device *tcpc_dev)
 {
-	typec_wait_ps_change(tcpc, TYPEC_WAIT_PS_DISABLE);
+	typec_wait_ps_change(tcpc_dev, TYPEC_WAIT_PS_DISABLE);
 
 #ifdef CONFIG_TYPEC_CAP_TRY_SINK
-	if (tcpc->typec_state == typec_try_snk) {
-		typec_trywait_src_entry(tcpc);
+	if (tcpc_dev->typec_state == typec_try_snk) {
+		typec_trywait_src_entry(tcpc_dev);
 		return;
 	}
 #endif	/* CONFIG_TYPEC_CAP_TRY_SINK */
 
-	typec_unattach_wait_pe_idle_entry(tcpc);
+	typec_unattach_wait_pe_idle_entry(tcpc_dev);
 }
 
 /*
@@ -1035,185 +997,187 @@ static inline void typec_cc_snk_remove_entry(struct tcpc_device *tcpc)
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
 
 static inline void typec_legacy_reset_cable_suspect(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
 #if TCPC_LEGACY_CABLE_SUSPECT_THD
-	tcpc->typec_legacy_cable_suspect = 0;
+	tcpc_dev->typec_legacy_cable_suspect = 0;
 #endif	/* TCPC_LEGACY_CABLE_SUSPECT_THD != 0 */
 }
 
 static inline void typec_legacy_reset_retry_wk(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE2
-	tcpc->typec_legacy_retry_wk = 0;
+	tcpc_dev->typec_legacy_retry_wk = 0;
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE2 */
 }
 
 static inline void typec_legacy_enable_discharge(
-	struct tcpc_device *tcpc, bool en)
+	struct tcpc_device *tcpc_dev, bool en)
 {
 #ifdef CONFIG_TYPEC_CAP_FORCE_DISCHARGE
-	if (tcpc->tcpc_flags & TCPC_FLAGS_PREFER_LEGACY2) {
-		mutex_lock(&tcpc->access_lock);
-		tcpci_enable_force_discharge(tcpc, en, 0);
-		mutex_unlock(&tcpc->access_lock);
+	if (tcpc_dev->tcpc_flags & TCPC_FLAGS_PREFER_LEGACY2) {
+		if (en)
+			tcpci_enable_force_discharge(tcpc_dev, 0);
+		else
+			tcpci_disable_force_discharge(tcpc_dev);
 	}
 #endif	/* CONFIG_TYPEC_CAP_FORCE_DISCHARGE */
 }
 
 static inline void typec_legacy_keep_default_rp(
-	struct tcpc_device *tcpc, bool en)
+	struct tcpc_device *tcpc_dev, bool en)
 {
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE2
-	typec_legacy_enable_discharge(tcpc, en);
+	typec_legacy_enable_discharge(tcpc_dev, en);
 
 	if (en) {
-		tcpci_set_cc(tcpc, TYPEC_CC_RD);
+		tcpci_set_cc(tcpc_dev, TYPEC_CC_RD);
 		usleep_range(1000, 2000);
-		tcpci_set_cc(tcpc, TYPEC_CC_RP);
+		tcpci_set_cc(tcpc_dev, TYPEC_CC_RP);
 		usleep_range(1000, 2000);
 	}
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE2 */
 }
 
 static inline bool typec_legacy_charge(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
 	int i, vbus_level = 0;
 
-	TYPEC_INFO("LC->Charge\n");
-	tcpci_source_vbus(tcpc,
+	TYPEC_INFO("LC->Charge\r\n");
+	tcpci_source_vbus(tcpc_dev,
 		TCP_VBUS_CTRL_TYPEC, TCPC_VBUS_SOURCE_5V, 100);
 
 	for (i = 0; i < 6; i++) { /* 275 ms */
-		vbus_level = tcpm_inquire_vbus_level(tcpc, true);
+		vbus_level = tcpm_inquire_vbus_level(tcpc_dev, true);
 		if (vbus_level >= TCPC_VBUS_VALID)
 			return true;
 		msleep(50);
 	}
 
-	TYPEC_INFO("LC->Charge Failed\n");
+	TYPEC_INFO("LC->Charge Failed\r\n");
 	return false;
 }
 
 static inline bool typec_legacy_discharge(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
 	int i, vbus_level = 0;
 
-	TYPEC_INFO("LC->Discharge\n");
-	tcpci_source_vbus(tcpc,
+	TYPEC_INFO("LC->Discharge\r\n");
+	tcpci_source_vbus(tcpc_dev,
 		TCP_VBUS_CTRL_TYPEC, TCPC_VBUS_SOURCE_0V, 0);
 
 	for (i = 0; i < 6; i++) { /* 275 ms */
-		vbus_level = tcpm_inquire_vbus_level(tcpc, true);
+		vbus_level = tcpm_inquire_vbus_level(tcpc_dev, true);
 		if (vbus_level < TCPC_VBUS_VALID)
 			return true;
 		msleep(50);
 	}
 
-	TYPEC_INFO("LC->Discharge Failed\n");
+	TYPEC_INFO("LC->Discharge Failed\r\n");
 	return false;
 }
 
-static inline bool typec_legacy_suspect(struct tcpc_device *tcpc)
+static inline bool typec_legacy_suspect(struct tcpc_device *tcpc_dev)
 {
 	int i = 0, vbus_level = 0;
 
-	TYPEC_INFO("LC->Suspect\n");
-	typec_legacy_reset_cable_suspect(tcpc);
+	TYPEC_INFO("LC->Suspect\r\n");
+	typec_legacy_reset_cable_suspect(tcpc_dev);
 
 	while (1) {
-		vbus_level = tcpm_inquire_vbus_level(tcpc, true);
+		vbus_level = tcpm_inquire_vbus_level(tcpc_dev, true);
 		if (vbus_level < TCPC_VBUS_VALID)
 			break;
 
 		i++;
 		if (i > 3)	{ /* 150 ms */
-			TYPEC_INFO("LC->TAIn\n");
+			TYPEC_INFO("LC->TAIn\r\n");
 			return false;
 		}
 
 		msleep(50);
 	};
 
-	tcpci_set_cc(tcpc, TYPEC_CC_RP_1_5);
+	tcpci_set_cc(tcpc_dev, TYPEC_CC_RP_1_5);
 	usleep_range(1000, 2000);
 
-	return tcpci_get_cc(tcpc) != 0;
+	return tcpci_get_cc(tcpc_dev) != 0;
 }
 
-static inline bool typec_legacy_stable1(struct tcpc_device *tcpc)
+static inline bool typec_legacy_stable1(struct tcpc_device *tcpc_dev)
 {
-	typec_legacy_charge(tcpc);
-	typec_legacy_discharge(tcpc);
-	TYPEC_INFO("LC->Stable\n");
-	tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_LEGACY_STABLE);
+	typec_legacy_charge(tcpc_dev);
+	typec_legacy_discharge(tcpc_dev);
+	TYPEC_INFO("LC->Stable\r\n");
+	tcpc_enable_timer(tcpc_dev, TYPEC_RT_TIMER_LEGACY_STABLE);
 
 	return true;
 }
 
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE2
 
-static inline bool typec_is_run_legacy_stable2(struct tcpc_device *tcpc)
+static inline bool typec_is_run_legacy_stable2(struct tcpc_device *tcpc_dev)
 {
 	bool run_legacy2;
 	uint8_t retry_max = TCPC_LEGACY_CABLE_RETRY_SOLUTION;
 
-	run_legacy2 = tcpc->tcpc_flags & TCPC_FLAGS_PREFER_LEGACY2;
+	run_legacy2 = tcpc_dev->tcpc_flags & TCPC_FLAGS_PREFER_LEGACY2;
 
-	TYPEC_INFO("LC->Retry%d\n", tcpc->typec_legacy_retry_wk++);
+	TYPEC_INFO("LC->Retry%d\r\n", tcpc_dev->typec_legacy_retry_wk++);
 
-	if (tcpc->typec_legacy_retry_wk <= retry_max)
+	if (tcpc_dev->typec_legacy_retry_wk <= retry_max)
 		return run_legacy2;
 
-	if (tcpc->typec_legacy_retry_wk > (retry_max*2))
-		typec_legacy_reset_retry_wk(tcpc);
+	if (tcpc_dev->typec_legacy_retry_wk > (retry_max*2))
+		typec_legacy_reset_retry_wk(tcpc_dev);
 
 	return !run_legacy2;
 }
 
-static inline bool typec_legacy_stable2(struct tcpc_device *tcpc)
+static inline bool typec_legacy_stable2(struct tcpc_device *tcpc_dev)
 {
-	tcpc->typec_legacy_cable = 2;
-	TYPEC_INFO("LC->Stable2\n");
-	typec_legacy_keep_default_rp(tcpc, true);
+	tcpc_dev->typec_legacy_cable = 2;
+	TYPEC_INFO("LC->Stable2\r\n");
+	typec_legacy_keep_default_rp(tcpc_dev, true);
 
-	tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_LEGACY_STABLE);
+	tcpc_enable_timer(tcpc_dev, TYPEC_RT_TIMER_LEGACY_STABLE);
 
 #ifdef CONFIG_TYPEC_LEGACY2_AUTO_RECYCLE
-	tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_LEGACY_RECYCLE);
+	tcpc_enable_timer(tcpc_dev, TYPEC_RT_TIMER_LEGACY_RECYCLE);
 #endif	/* CONFIG_TYPEC_LEGACY2_AUTO_RECYCLE */
 
 	return true;
 }
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE2 */
 
-static inline bool typec_legacy_confirm(struct tcpc_device *tcpc)
+static inline bool typec_legacy_confirm(struct tcpc_device *tcpc_dev)
 {
-	TYPEC_INFO("LC->Confirm\n");
-	tcpc->typec_legacy_cable = 1;
-	tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_NOT_LEGACY);
+	TYPEC_INFO("LC->Confirm\r\n");
+	tcpc_dev->typec_legacy_cable = 1;
+	tcpc_disable_timer(tcpc_dev, TYPEC_RT_TIMER_NOT_LEGACY);
 
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE2
-	if (typec_is_run_legacy_stable2(tcpc))
-		return typec_legacy_stable2(tcpc);
+	if (typec_is_run_legacy_stable2(tcpc_dev))
+		return typec_legacy_stable2(tcpc_dev);
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE2 */
 
-	return typec_legacy_stable1(tcpc);
+	return typec_legacy_stable1(tcpc_dev);
 }
 
-static inline bool typec_legacy_check_cable(struct tcpc_device *tcpc)
+static inline bool typec_legacy_check_cable(struct tcpc_device *tcpc_dev)
 {
 	bool check_legacy = false;
 
-	if (tcpc->tcpc_flags & TCPC_FLAGS_DISABLE_LEGACY)
+	if (tcpc_dev->tcpc_flags & TCPC_FLAGS_DISABLE_LEGACY)
 		return false;
 
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE2
-	if (tcpc->typec_legacy_cable == 2) {
-		typec_unattached_src_and_drp_entry(tcpc);
+	if (tcpc_dev->typec_legacy_cable == 2) {
+		TYPEC_NEW_STATE(typec_unattached_src);
+		tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_DRP_SRC_TOGGLE);
 		return true;
 	}
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE2 */
@@ -1223,89 +1187,89 @@ static inline bool typec_legacy_check_cable(struct tcpc_device *tcpc)
 		check_legacy = true;
 
 #if TCPC_LEGACY_CABLE_SUSPECT_THD
-	if (tcpc->typec_legacy_cable_suspect <
+	if (tcpc_dev->typec_legacy_cable_suspect <
 					TCPC_LEGACY_CABLE_SUSPECT_THD)
 		check_legacy = false;
 #endif	/* TCPC_LEGACY_CABLE_SUSPECT_THD */
 
 	if (check_legacy) {
-		if (typec_legacy_suspect(tcpc)) {
-			typec_legacy_confirm(tcpc);
+		if (typec_legacy_suspect(tcpc_dev)) {
+			typec_legacy_confirm(tcpc_dev);
 			return true;
 		}
 
-		tcpc->typec_legacy_cable = false;
-		tcpci_set_cc(tcpc, TYPEC_CC_RP);
+		tcpc_dev->typec_legacy_cable = false;
+		tcpci_set_cc(tcpc_dev, TYPEC_CC_RP);
 	}
 
 	return false;
 }
 
-static inline void typec_legacy_reset_timer(struct tcpc_device *tcpc)
+static inline void typec_legacy_reset_timer(struct tcpc_device *tcpc_dev)
 {
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE2
-	if (tcpc->typec_legacy_cable == 2)
-		tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_LEGACY_RECYCLE);
+	if (tcpc_dev->typec_legacy_cable == 2)
+		tcpc_disable_timer(tcpc_dev, TYPEC_RT_TIMER_LEGACY_RECYCLE);
 
-	tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_LEGACY_STABLE);
+	tcpc_disable_timer(tcpc_dev, TYPEC_RT_TIMER_LEGACY_STABLE);
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE2 */
 }
 
-static inline void typec_legacy_reach_vsafe5v(struct tcpc_device *tcpc)
+static inline void typec_legacy_reach_vsafe5v(struct tcpc_device *tcpc_dev)
 {
-	TYPEC_INFO("LC->Attached\n");
-	tcpc->typec_legacy_cable = false;
-	tcpci_set_cc(tcpc, TYPEC_CC_RD);
-	typec_legacy_reset_timer(tcpc);
+	TYPEC_INFO("LC->Attached\r\n");
+	tcpc_dev->typec_legacy_cable = false;
+	tcpci_set_cc(tcpc_dev, TYPEC_CC_RD);
+	typec_legacy_reset_timer(tcpc_dev);
 }
 
-static inline void typec_legacy_reach_vsafe0v(struct tcpc_device *tcpc)
+static inline void typec_legacy_reach_vsafe0v(struct tcpc_device *tcpc_dev)
 {
-	TYPEC_INFO("LC->Detached (PS)\n");
-	tcpc->typec_legacy_cable = false;
-	typec_set_drp_toggling(tcpc);
-	tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_LEGACY_STABLE);
+	TYPEC_INFO("LC->Detached (PS)\r\n");
+	tcpc_dev->typec_legacy_cable = false;
+	typec_set_drp_toggling(tcpc_dev);
+	tcpc_disable_timer(tcpc_dev, TYPEC_RT_TIMER_LEGACY_STABLE);
 }
 
 static inline void typec_legacy_handle_ps_change(
-	struct tcpc_device *tcpc, int vbus_level)
+	struct tcpc_device *tcpc_dev, int vbus_level)
 {
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE2
-	if (tcpc->typec_legacy_cable != 1)
+	if (tcpc_dev->typec_legacy_cable != 1)
 		return;
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE2 */
 
 	if (vbus_level >= TCPC_VBUS_VALID)
-		typec_legacy_reach_vsafe5v(tcpc);
+		typec_legacy_reach_vsafe5v(tcpc_dev);
 	else if (vbus_level == TCPC_VBUS_SAFE0V)
-		typec_legacy_reach_vsafe0v(tcpc);
+		typec_legacy_reach_vsafe0v(tcpc_dev);
 }
 
-static inline void typec_legacy_handle_detach(struct tcpc_device *tcpc)
+static inline void typec_legacy_handle_detach(struct tcpc_device *tcpc_dev)
 {
 #if TCPC_LEGACY_CABLE_SUSPECT_THD
 	bool suspect_legacy = false;
 
-	if (tcpc->typec_state == typec_attachwait_src)
+	if (tcpc_dev->typec_state == typec_attachwait_src)
 		suspect_legacy = true;
-	else if (tcpc->typec_state == typec_attached_src) {
-		if (tcpc->typec_attach_old != TYPEC_ATTACHED_SRC)
+	else if (tcpc_dev->typec_state == typec_attached_src) {
+		if (tcpc_dev->typec_attach_old != TYPEC_ATTACHED_SRC)
 			suspect_legacy = true;
 	}
 
 	if (suspect_legacy) {
-		tcpc->typec_legacy_cable_suspect++;
-		TYPEC_INFO2("LC->Suspect: %d\n",
-			tcpc->typec_legacy_cable_suspect);
+		tcpc_dev->typec_legacy_cable_suspect++;
+		TYPEC_INFO2("LC->Suspect: %d\r\n",
+			tcpc_dev->typec_legacy_cable_suspect);
 	}
 #endif	/* TCPC_LEGACY_CABLE_SUSPECT_THD != 0 */
 }
 
-static inline int typec_legacy_handle_cc_open(struct tcpc_device *tcpc)
+static inline int typec_legacy_handle_cc_open(struct tcpc_device *tcpc_dev)
 {
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE2
-	if (tcpc->typec_legacy_cable == 2) {
-		typec_legacy_keep_default_rp(tcpc, false);
+	if (tcpc_dev->typec_legacy_cable == 2) {
+		typec_legacy_keep_default_rp(tcpc_dev, false);
 		return 1;
 	}
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE2 */
@@ -1313,32 +1277,32 @@ static inline int typec_legacy_handle_cc_open(struct tcpc_device *tcpc)
 	return 0;
 }
 
-static inline int typec_legacy_handle_cc_present(struct tcpc_device *tcpc)
+static inline int typec_legacy_handle_cc_present(struct tcpc_device *tcpc_dev)
 {
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE2
-	return tcpc->typec_legacy_cable == 1;
+	return tcpc_dev->typec_legacy_cable == 1;
 #else
 	return 1;
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE2 */
 }
 
-static inline int typec_legacy_handle_cc_change(struct tcpc_device *tcpc)
+static inline int typec_legacy_handle_cc_change(struct tcpc_device *tcpc_dev)
 {
 	int ret = 0;
 
 	if (typec_is_cc_open() || typec_is_cable_only())
-		ret = typec_legacy_handle_cc_open(tcpc);
+		ret = typec_legacy_handle_cc_open(tcpc_dev);
 	else
-		ret = typec_legacy_handle_cc_present(tcpc);
+		ret = typec_legacy_handle_cc_present(tcpc_dev);
 
 	if (ret == 0)
 		return 0;
 
-	TYPEC_INFO("LC->Detached (CC)\n");
+	TYPEC_INFO("LC->Detached (CC)\r\n");
 
-	tcpc->typec_legacy_cable = false;
-	typec_set_drp_toggling(tcpc);
-	typec_legacy_reset_timer(tcpc);
+	tcpc_dev->typec_legacy_cable = false;
+	typec_set_drp_toggling(tcpc_dev);
+	typec_legacy_reset_timer(tcpc_dev);
 	return 1;
 }
 
@@ -1348,87 +1312,74 @@ static inline int typec_legacy_handle_cc_change(struct tcpc_device *tcpc)
  * [BLOCK] CC Change (after debounce)
  */
 
-#ifdef CONFIG_TYPEC_CAP_DBGACC
-static void typec_debug_acc_attached_with_vbus_entry(
-		struct tcpc_device *tcpc)
-{
-	tcpc->typec_attach_new = TYPEC_ATTACHED_DEBUG;
-	typec_wait_ps_change(tcpc, TYPEC_WAIT_PS_DISABLE);
-}
-#endif	/* CONFIG_TYPEC_CAP_DBGACC */
-
-static inline void typec_debug_acc_attached_entry(struct tcpc_device *tcpc)
+static inline bool typec_debug_acc_attached_entry(struct tcpc_device *tcpc_dev)
 {
-#ifdef CONFIG_TYPEC_CAP_DBGACC
 	TYPEC_NEW_STATE(typec_debugaccessory);
-	TYPEC_DBG("[Debug] CC1&2 Both Rd\n");
-	typec_wait_ps_change(tcpc, TYPEC_WAIT_PS_DBG_VSAFE5V);
-
-	tcpci_report_power_control(tcpc, true);
-	tcpci_source_vbus(tcpc,
-			TCP_VBUS_CTRL_TYPEC, TCPC_VBUS_SOURCE_5V, -1);
-#endif	/* CONFIG_TYPEC_CAP_DBGACC */
+	TYPEC_DBG("[Debug] CC1&2 Both Rd\r\n");
+	tcpc_dev->typec_attach_new = TYPEC_ATTACHED_DEBUG;
+	return true;
 }
 
 #ifdef CONFIG_TYPEC_CAP_AUDIO_ACC_SINK_VBUS
 static inline bool typec_audio_acc_sink_vbus(
-	struct tcpc_device *tcpc, bool vbus_valid)
+	struct tcpc_device *tcpc_dev, bool vbus_valid)
 {
 	if (vbus_valid) {
-		tcpci_report_power_control(tcpc, true);
-		tcpci_sink_vbus(tcpc,
+		tcpci_report_power_control(tcpc_dev, true);
+		tcpci_sink_vbus(tcpc_dev,
 			TCP_VBUS_CTRL_TYPEC, TCPC_VBUS_SINK_5V, 500);
 	} else {
-		tcpci_sink_vbus(tcpc,
+		tcpci_sink_vbus(tcpc_dev,
 			TCP_VBUS_CTRL_TYPEC, TCPC_VBUS_SINK_0V, 0);
-		tcpci_report_power_control(tcpc, false);
+		tcpci_report_power_control(tcpc_dev, false);
 	}
 
 	return true;
 }
 #endif	/* CONFIG_TYPEC_CAP_AUDIO_ACC_SINK_VBUS */
 
-static bool typec_is_fake_ra_rp30(struct tcpc_device *tcpc)
+static bool typec_is_fake_ra_rp30(struct tcpc_device *tcpc_dev)
 {
-	if (TYPEC_CC_PULL_GET_RP_LVL(tcpc->typec_local_cc) == TYPEC_RP_3_0) {
-		__tcpci_set_cc(tcpc, TYPEC_CC_RP_DFT);
+	if (tcpc_dev->typec_local_cc == TYPEC_CC_RP_3_0
+		|| tcpc_dev->typec_local_cc == TYPEC_CC_DRP_3_0) {
+		tcpci_set_cc(tcpc_dev, TYPEC_CC_RP_DFT);
 		usleep_range(1000, 2000);
-		return tcpci_get_cc(tcpc) != 0;
+		return tcpci_get_cc(tcpc_dev) != 0;
 	}
 
 	return false;
 }
 
-static inline bool typec_audio_acc_attached_entry(struct tcpc_device *tcpc)
+static inline bool typec_audio_acc_attached_entry(struct tcpc_device *tcpc_dev)
 {
 #ifdef RICHTEK_PD_COMPLIANCE_FAKE_AUDIO_ACC
-	if (typec_is_fake_ra_rp30(tcpc)) {
-		TYPEC_DBG("[Audio] Fake Both Ra\n");
+	if (typec_is_fake_ra_rp30(tcpc_dev)) {
+		TYPEC_DBG("[Audio] Fake Both Ra\r\n");
 		if (typec_check_cc_any(TYPEC_CC_VOLT_RD))
-			typec_cc_src_detect_entry(tcpc);
+			typec_cc_src_detect_entry(tcpc_dev);
 		else
-			typec_cc_src_remove_entry(tcpc);
+			typec_cc_src_remove_entry(tcpc_dev);
 		return 0;
 	}
 #endif	/* RICHTEK_PD_COMPLIANCE_FAKE_AUDIO_ACC */
 
 	TYPEC_NEW_STATE(typec_audioaccessory);
-	TYPEC_DBG("[Audio] CC1&2 Both Ra\n");
-	tcpc->typec_attach_new = TYPEC_ATTACHED_AUDIO;
+	TYPEC_DBG("[Audio] CC1&2 Both Ra\r\n");
+	tcpc_dev->typec_attach_new = TYPEC_ATTACHED_AUDIO;
 
 #ifdef CONFIG_TYPEC_CAP_AUDIO_ACC_SINK_VBUS
-	if (tcpci_check_vbus_valid(tcpc))
-		typec_audio_acc_sink_vbus(tcpc, true);
+	if (tcpci_check_vbus_valid(tcpc_dev))
+		typec_audio_acc_sink_vbus(tcpc_dev, true);
 #endif	/* CONFIG_TYPEC_CAP_AUDIO_ACC_SINK_VBUS */
 
 	return true;
 }
 
-static inline bool typec_cc_change_source_entry(struct tcpc_device *tcpc)
+static inline bool typec_cc_change_source_entry(struct tcpc_device *tcpc_dev)
 {
 	bool src_remove = false;
 
-	switch (tcpc->typec_state) {
+	switch (tcpc_dev->typec_state) {
 	case typec_attached_src:
 		if (typec_get_cc_res() != TYPEC_CC_VOLT_RD)
 			src_remove = true;
@@ -1437,68 +1388,71 @@ static inline bool typec_cc_change_source_entry(struct tcpc_device *tcpc)
 		if (!typec_check_cc_both(TYPEC_CC_VOLT_RA))
 			src_remove = true;
 		break;
-#ifdef CONFIG_TYPEC_CAP_DBGACC
 	case typec_debugaccessory:
 		if (!typec_check_cc_both(TYPEC_CC_VOLT_RD))
 			src_remove = true;
 		break;
-#endif	/* CONFIG_TYPEC_CAP_DBGACC */
 	default:
 		if (typec_check_cc_both(TYPEC_CC_VOLT_RD))
-			typec_debug_acc_attached_entry(tcpc);
+			typec_debug_acc_attached_entry(tcpc_dev);
 		else if (typec_check_cc_both(TYPEC_CC_VOLT_RA))
-			typec_audio_acc_attached_entry(tcpc);
+			typec_audio_acc_attached_entry(tcpc_dev);
 		else if (typec_check_cc_any(TYPEC_CC_VOLT_RD))
-			typec_cc_src_detect_entry(tcpc);
+			typec_cc_src_detect_entry(tcpc_dev);
 		else
 			src_remove = true;
 		break;
 	}
 
 	if (src_remove)
-		typec_cc_src_remove_entry(tcpc);
+		typec_cc_src_remove_entry(tcpc_dev);
 
 	return true;
 }
 
-static inline bool typec_attached_snk_cc_change(struct tcpc_device *tcpc)
+static inline bool typec_attached_snk_cc_change(struct tcpc_device *tcpc_dev)
 {
 	uint8_t cc_res = typec_get_cc_res();
 
-	if (cc_res != tcpc->typec_remote_rp_level) {
-		TYPEC_INFO("RpLvl Change\n");
-		tcpc->typec_remote_rp_level = cc_res;
+	if (cc_res != tcpc_dev->typec_remote_rp_level) {
+		TYPEC_INFO("RpLvl Change\r\n");
+		tcpc_dev->typec_remote_rp_level = cc_res;
+
+#ifdef CONFIG_USB_POWER_DELIVERY
+		if (tcpc_dev->pd_port.pe_data.pd_prev_connected) {
+			pd_put_sink_tx_event(tcpc_dev, cc_res);
+			return true;
+		}
+#endif	/* CONFIG_USB_POWER_DELIVERY */
 
 #ifdef CONFIG_TYPEC_CAP_CUSTOM_HV
-		if (tcpc->typec_during_custom_hv)
+		if (tcpc_dev->typec_during_custom_hv)
 			return true;
 #endif	/* CONFIG_TYPEC_CAP_CUSTOM_HV */
 
-		tcpci_sink_vbus(tcpc,
+		tcpci_sink_vbus(tcpc_dev,
 				TCP_VBUS_CTRL_TYPEC, TCPC_VBUS_SINK_5V, -1);
 	}
 
 	return true;
 }
 
-static inline bool typec_cc_change_sink_entry(struct tcpc_device *tcpc)
+static inline bool typec_cc_change_sink_entry(struct tcpc_device *tcpc_dev)
 {
 	bool snk_remove = false;
 
-	switch (tcpc->typec_state) {
+	switch (tcpc_dev->typec_state) {
 	case typec_attached_snk:
 		if (typec_get_cc_res() == TYPEC_CC_VOLT_OPEN)
 			snk_remove = true;
 		else
-			typec_attached_snk_cc_change(tcpc);
+			typec_attached_snk_cc_change(tcpc_dev);
 		break;
 
 #ifdef CONFIG_TYPEC_CAP_DBGACC_SNK
 	case typec_attached_dbgacc_snk:
 		if (typec_get_cc_res() == TYPEC_CC_VOLT_OPEN)
 			snk_remove = true;
-		else
-			typec_attached_snk_cc_change(tcpc);
 		break;
 #endif	/* CONFIG_TYPEC_CAP_DBGACC_SNK */
 
@@ -1511,23 +1465,24 @@ static inline bool typec_cc_change_sink_entry(struct tcpc_device *tcpc)
 
 	default:
 		if (!typec_is_cc_open())
-			typec_cc_snk_detect_entry(tcpc);
+			typec_cc_snk_detect_entry(tcpc_dev);
 		else
 			snk_remove = true;
 	}
 
 	if (snk_remove)
-		typec_cc_snk_remove_entry(tcpc);
+		typec_cc_snk_remove_entry(tcpc_dev);
 
 	return true;
 }
 
-bool tcpc_typec_is_act_as_sink_role(struct tcpc_device *tcpc)
+static inline bool typec_is_act_as_sink_role(
+	struct tcpc_device *tcpc_dev)
 {
 	bool as_sink = true;
 	uint8_t cc_sum;
 
-	switch (TYPEC_CC_PULL_GET_RES(tcpc->typec_local_cc)) {
+	switch (tcpc_dev->typec_local_cc & 0x07) {
 	case TYPEC_CC_RP:
 		as_sink = false;
 		break;
@@ -1543,18 +1498,18 @@ bool tcpc_typec_is_act_as_sink_role(struct tcpc_device *tcpc)
 	return as_sink;
 }
 
-static inline bool typec_handle_cc_changed_entry(struct tcpc_device *tcpc)
+static inline bool typec_handle_cc_changed_entry(struct tcpc_device *tcpc_dev)
 {
-	TYPEC_INFO("[CC_Change] %d/%d\n", typec_get_cc1(), typec_get_cc2());
+	TYPEC_INFO("[CC_Change] %d/%d\r\n", typec_get_cc1(), typec_get_cc2());
 
-	tcpc->typec_attach_new = tcpc->typec_attach_old;
+	tcpc_dev->typec_attach_new = tcpc_dev->typec_attach_old;
 
-	if (tcpc_typec_is_act_as_sink_role(tcpc))
-		typec_cc_change_sink_entry(tcpc);
+	if (typec_is_act_as_sink_role(tcpc_dev))
+		typec_cc_change_sink_entry(tcpc_dev);
 	else
-		typec_cc_change_source_entry(tcpc);
+		typec_cc_change_source_entry(tcpc_dev);
 
-	typec_alert_attach_state_change(tcpc);
+	typec_alert_attach_state_change(tcpc_dev);
 	return true;
 }
 
@@ -1562,207 +1517,195 @@ static inline bool typec_handle_cc_changed_entry(struct tcpc_device *tcpc)
  * [BLOCK] Handle cc-change event (from HW)
  */
 
-static inline void typec_attach_wait_entry(struct tcpc_device *tcpc)
+static inline void typec_attach_wait_entry(struct tcpc_device *tcpc_dev)
 {
 	bool as_sink;
-#ifdef CONFIG_USB_POWER_DELIVERY
-	struct pd_port *pd_port = &tcpc->pd_port;
-#endif	/* CONFIG_USB_POWER_DELIVERY */
 
-	if (tcpc->typec_attach_old == TYPEC_ATTACHED_SNK ||
-	    tcpc->typec_attach_old == TYPEC_ATTACHED_DBGACC_SNK) {
-#ifdef CONFIG_USB_POWER_DELIVERY
-		if (pd_port->pe_data.pd_connected && pd_check_rev30(pd_port))
-			pd_put_sink_tx_event(tcpc, typec_get_cc_res());
-#endif	/* CONFIG_USB_POWER_DELIVERY */
-		tcpc_enable_timer(tcpc, TYPEC_TIMER_PDDEBOUNCE);
-		TYPEC_DBG("RpLvl Alert\n");
+	if (tcpc_dev->typec_attach_old == TYPEC_ATTACHED_SNK) {
+		tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_PDDEBOUNCE);
+		TYPEC_DBG("RpLvl Alert\r\n");
 		return;
 	}
 
-	if (tcpc->typec_attach_old ||
-		tcpc->typec_state == typec_attached_src) {
-		tcpc_reset_typec_debounce_timer(tcpc);
-		TYPEC_DBG("Attached, Ignore cc_attach\n");
+	if (tcpc_dev->typec_attach_old ||
+		tcpc_dev->typec_state == typec_attached_src) {
+		tcpc_reset_typec_debounce_timer(tcpc_dev);
+		TYPEC_DBG("Attached, Ignore cc_attach\r\n");
 #ifndef CONFIG_USB_POWER_DELIVERY
-		typec_enable_vconn(tcpc);
+		typec_enable_vconn(tcpc_dev);
 #endif /* CONFIG_USB_POWER_DELIVERY */
 		return;
 	}
 
-	switch (tcpc->typec_state) {
+	switch (tcpc_dev->typec_state) {
 
 #ifdef CONFIG_TYPEC_CAP_TRY_SOURCE
 	case typec_try_src:
-		tcpc_enable_timer(tcpc, TYPEC_TIMER_TRYCCDEBOUNCE);
+		tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_TRYCCDEBOUNCE);
 		return;
 
 	case typec_trywait_snk:
-		tcpc_enable_timer(tcpc, TYPEC_TIMER_CCDEBOUNCE);
+		tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_CCDEBOUNCE);
 		return;
 #endif
 
 #ifdef CONFIG_TYPEC_CAP_TRY_SINK
 	case typec_try_snk:	/* typec_drp_try_timeout = true */
-		tcpc_enable_timer(tcpc, TYPEC_TIMER_TRYCCDEBOUNCE);
+		tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_TRYCCDEBOUNCE);
 		return;
 
 	case typec_trywait_src:	/* typec_drp_try_timeout = unknown */
-		tcpc_enable_timer(tcpc, TYPEC_TIMER_TRYCCDEBOUNCE);
+		tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_TRYCCDEBOUNCE);
 		return;
 #endif	/* CONFIG_TYPEC_CAP_TRY_SINK */
 
 #ifdef CONFIG_USB_POWER_DELIVERY
 	case typec_unattachwait_pe:
-		TYPEC_INFO("Force PE Idle\n");
-		tcpc->pd_wait_pe_idle = false;
-		tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_PE_IDLE);
-		typec_unattached_power_entry(tcpc);
+		TYPEC_INFO("Force PE Idle\r\n");
+		tcpc_dev->pd_wait_pe_idle = false;
+		tcpc_disable_timer(tcpc_dev, TYPEC_RT_TIMER_PE_IDLE);
+		typec_unattached_power_entry(tcpc_dev);
 		break;
 #endif
 	default:
 		break;
 	}
 
-	as_sink = tcpc_typec_is_act_as_sink_role(tcpc);
+	as_sink = typec_is_act_as_sink_role(tcpc_dev);
 
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
-	if (!as_sink && typec_legacy_check_cable(tcpc))
+	if (!as_sink && typec_legacy_check_cable(tcpc_dev))
 		return;
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE */
 
 #ifdef CONFIG_TYPEC_NOTIFY_ATTACHWAIT
-	tcpci_notify_attachwait_state(tcpc, as_sink);
+	tcpci_notify_attachwait_state(tcpc_dev, as_sink);
 #endif	/* CONFIG_TYPEC_NOTIFY_ATTACHWAIT */
 
 	if (as_sink)
 		TYPEC_NEW_STATE(typec_attachwait_snk);
 	else {
 		/* Advertise Rp level before Attached.SRC Ellisys 3.1.6359 */
-		tcpci_set_cc(tcpc,
-			TYPEC_CC_PULL(tcpc->typec_local_rp_level, TYPEC_CC_RP));
+		tcpci_set_cc(tcpc_dev, tcpc_dev->typec_local_rp_level);
 		TYPEC_NEW_STATE(typec_attachwait_src);
 	}
 
-	tcpc_enable_timer(tcpc, TYPEC_TIMER_CCDEBOUNCE);
+	tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_CCDEBOUNCE);
 }
 
 #ifdef TYPEC_EXIT_ATTACHED_SNK_VIA_VBUS
-static inline int typec_attached_snk_cc_detach(struct tcpc_device *tcpc)
+static inline int typec_attached_snk_cc_detach(struct tcpc_device *tcpc_dev)
 {
-	tcpc_reset_typec_debounce_timer(tcpc);
+	tcpc_reset_typec_debounce_timer(tcpc_dev);
 #ifdef CONFIG_USB_POWER_DELIVERY
 	/*
 	 * For Source detach during HardReset,
 	 * However Apple TA may keep cc_open about 150 ms during HardReset
 	 */
-	if (tcpc->pd_wait_hard_reset_complete) {
+	if (tcpc_dev->pd_wait_hard_reset_complete) {
 #ifdef CONFIG_COMPATIBLE_APPLE_TA
-		TYPEC_INFO2("Detach_CC (HardReset), compatible apple TA\n");
-		tcpc_enable_timer(tcpc, TYPEC_TIMER_APPLE_CC_OPEN);
+		TYPEC_INFO2("Detach_CC (HardReset), compatible apple TA\r\n");
+		tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_APPLE_CC_OPEN);
 #else
-		TYPEC_INFO2("Detach_CC (HardReset)\n");
-		tcpc_enable_timer(tcpc, TYPEC_TIMER_PDDEBOUNCE);
+		TYPEC_INFO2("Detach_CC (HardReset)\r\n");
+		tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_PDDEBOUNCE);
 #endif /* CONFIG_COMPATIBLE_APPLE_TA */
-	} else if (tcpc->pd_port.pe_data.pd_prev_connected) {
-		TYPEC_INFO2("Detach_CC (PD)\n");
-		tcpc_enable_timer(tcpc, TYPEC_TIMER_PDDEBOUNCE);
+	} else if (tcpc_dev->pd_port.pe_data.pd_prev_connected) {
+		TYPEC_INFO2("Detach_CC (PD)\r\n");
+		tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_PDDEBOUNCE);
 	}
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 	return 0;
 }
 #endif	/* TYPEC_EXIT_ATTACHED_SNK_VIA_VBUS */
 
-static inline void typec_detach_wait_entry(struct tcpc_device *tcpc)
+static inline void typec_detach_wait_entry(struct tcpc_device *tcpc_dev)
 {
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
-	typec_legacy_handle_detach(tcpc);
+	typec_legacy_handle_detach(tcpc_dev);
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE */
 
-	switch (tcpc->typec_state) {
+	switch (tcpc_dev->typec_state) {
 #ifdef TYPEC_EXIT_ATTACHED_SNK_VIA_VBUS
 	case typec_attached_snk:
-#ifdef CONFIG_TYPEC_CAP_DBGACC_SNK
-	case typec_attached_dbgacc_snk:
-#endif	/* CONFIG_TYPEC_CAP_DBGACC_SNK */
-		typec_attached_snk_cc_detach(tcpc);
+		typec_attached_snk_cc_detach(tcpc_dev);
 		break;
 #endif /* TYPEC_EXIT_ATTACHED_SNK_VIA_VBUS */
 
 	case typec_attached_src:
-		tcpc_enable_timer(tcpc, TYPEC_TIMER_SRCDISCONNECT);
+		tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_SRCDISCONNECT);
 		break;
 
 	case typec_audioaccessory:
-		tcpc_enable_timer(tcpc, TYPEC_TIMER_CCDEBOUNCE);
+		tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_CCDEBOUNCE);
 		break;
 
 #ifdef TYPEC_EXIT_ATTACHED_SRC_NO_DEBOUNCE
 	case typec_attached_src:
-		TYPEC_INFO("Exit Attached.SRC immediately\n");
-		tcpc_reset_typec_debounce_timer(tcpc);
+		TYPEC_INFO("Exit Attached.SRC immediately\r\n");
+		tcpc_reset_typec_debounce_timer(tcpc_dev);
 
 		/* force to terminate TX */
-		tcpci_init(tcpc, true);
+		tcpci_init(tcpc_dev, true);
 
-		typec_cc_src_remove_entry(tcpc);
-		typec_alert_attach_state_change(tcpc);
+		typec_cc_src_remove_entry(tcpc_dev);
+		typec_alert_attach_state_change(tcpc_dev);
 		break;
 #endif /* TYPEC_EXIT_ATTACHED_SRC_NO_DEBOUNCE */
 
 #ifdef CONFIG_TYPEC_CAP_TRY_SOURCE
 	case typec_try_src:
-		if (tcpc->typec_drp_try_timeout)
-			tcpc_enable_timer(tcpc, TYPEC_TIMER_PDDEBOUNCE);
+		if (tcpc_dev->typec_drp_try_timeout)
+			tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_PDDEBOUNCE);
 		else {
-			tcpc_reset_typec_debounce_timer(tcpc);
-			TYPEC_DBG("[Try] Ignore cc_detach\n");
+			tcpc_reset_typec_debounce_timer(tcpc_dev);
+			TYPEC_DBG("[Try] Ignore cc_detach\r\n");
 		}
 		break;
 #endif	/* CONFIG_TYPEC_CAP_TRY_SOURCE */
 
 #ifdef CONFIG_TYPEC_CAP_TRY_SINK
 	case typec_trywait_src:
-		if (tcpc->typec_drp_try_timeout)
-			tcpc_enable_timer(tcpc, TYPEC_TIMER_TRYCCDEBOUNCE);
+		if (tcpc_dev->typec_drp_try_timeout)
+			tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_TRYCCDEBOUNCE);
 		else {
-			tcpc_reset_typec_debounce_timer(tcpc);
-			TYPEC_DBG("[Try] Ignore cc_detach\n");
+			tcpc_reset_typec_debounce_timer(tcpc_dev);
+			TYPEC_DBG("[Try] Ignore cc_detach\r\n");
 		}
 		break;
 #endif	/* CONFIG_TYPEC_CAP_TRY_SINK */
 	default:
-		tcpc_enable_timer(tcpc, TYPEC_TIMER_PDDEBOUNCE);
+		tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_PDDEBOUNCE);
 		break;
 	}
 }
 
-static inline bool typec_is_cc_attach(struct tcpc_device *tcpc)
+static inline bool typec_is_cc_attach(struct tcpc_device *tcpc_dev)
 {
 	bool cc_attach = false;
 	int cc1 = typec_get_cc1();
 	int cc2 = typec_get_cc2();
 	int cc_res = typec_get_cc_res();
 
-	tcpc->typec_cable_only = false;
+	tcpc_dev->typec_cable_only = false;
 
 #ifdef RICHTEK_PD_COMPLIANCE_FAKE_RA_DETACH
-	if (tcpc->typec_attach_old == TYPEC_ATTACHED_SRC
+	if (tcpc_dev->typec_attach_old == TYPEC_ATTACHED_SRC
 		&& (cc_res == TYPEC_CC_VOLT_RA) &&
-		(tcpc->typec_local_cc == TYPEC_CC_RP_DFT)) {
+		(tcpc_dev->typec_local_cc == TYPEC_CC_RP_DFT)) {
 
-		tcpci_set_cc(tcpc, TYPEC_CC_RP_1_5);
+		tcpci_set_cc(tcpc_dev, TYPEC_CC_RP_1_5);
 		usleep_range(1000, 2000);
 
-		if (tcpci_get_cc(tcpc)) {
-			TYPEC_DBG("[Detach] Fake Ra\n");
+		if (tcpci_get_cc(tcpc_dev)) {
+			TYPEC_DBG("[Detach] Fake Ra\r\n");
 			cc1 = typec_get_cc1();
 			cc2 = typec_get_cc2();
 			cc_res = typec_get_cc_res();
 		}
 	}
 #endif	/* RICHTEK_PD_COMPLIANCE_FAKE_RA_DETACH */
-	switch (tcpc->typec_attach_old) {
+	switch (tcpc_dev->typec_attach_old) {
 	case TYPEC_ATTACHED_SNK:
 	case TYPEC_ATTACHED_SRC:
 		if ((cc_res != TYPEC_CC_VOLT_OPEN) &&
@@ -1789,12 +1732,11 @@ static inline bool typec_is_cc_attach(struct tcpc_device *tcpc)
 			cc_attach = true;
 		break;
 
-#ifdef CONFIG_TYPEC_CAP_DBGACC
 	case TYPEC_ATTACHED_DEBUG:
 		if (typec_check_cc_both(TYPEC_CC_VOLT_RD))
 			cc_attach = true;
 		break;
-#endif	/* CONFIG_TYPEC_CAP_DBGACC */
+
 	default:	/* TYPEC_UNATTACHED */
 		if (cc1 != TYPEC_CC_VOLT_OPEN)
 			cc_attach = true;
@@ -1805,16 +1747,16 @@ static inline bool typec_is_cc_attach(struct tcpc_device *tcpc)
 		/* Cable Only, no device */
 		if ((cc1+cc2) == TYPEC_CC_VOLT_RA) {
 #ifdef RICHTEK_PD_COMPLIANCE_FAKE_EMRAK_ONLY
-			if (typec_is_fake_ra_rp30(tcpc)) {
-				TYPEC_DBG("[Cable] Fake Ra\n");
+			if (typec_is_fake_ra_rp30(tcpc_dev)) {
+				TYPEC_DBG("[Cable] Fake Ra\r\n");
 				if ((cc1+cc2) == TYPEC_CC_VOLT_RD)
 					cc_attach = true;
 				break;
 			}
 #endif	/* RICHTEK_PD_COMPLIANCE_FAKE_EMRAK_ONLY */
 			cc_attach = false;
-			tcpc->typec_cable_only = true;
-			TYPEC_DBG("[Cable] Ra Only\n");
+			tcpc_dev->typec_cable_only = true;
+			TYPEC_DBG("[Cable] Ra Only\r\n");
 		}
 		break;
 	}
@@ -1836,9 +1778,9 @@ static inline bool typec_is_cc_attach(struct tcpc_device *tcpc)
  *
  */
 
-static inline bool typec_check_false_ra_detach(struct tcpc_device *tcpc)
+static inline bool typec_check_false_ra_detach(struct tcpc_device *tcpc_dev)
 {
-	bool drp = tcpc->typec_role >= TYPEC_ROLE_DRP;
+	bool drp = tcpc_dev->typec_role >= TYPEC_ROLE_DRP;
 
 	/*
 	 * If the DUT is DRP and current CC status has stopped toggle,
@@ -1848,15 +1790,15 @@ static inline bool typec_check_false_ra_detach(struct tcpc_device *tcpc)
 	 */
 
 	if (drp) {
-		tcpci_get_cc(tcpc);
+		tcpci_get_cc(tcpc_dev);
 
 		if (!typec_is_drp_toggling()) {
-			TYPEC_DBG("False_RaDetach1 (%d, %d)\n",
+			TYPEC_DBG("False_RaDetach1 (%d, %d)\r\n",
 				typec_get_cc1(), typec_get_cc2());
 			return true;
 		}
 
-		tcpci_set_cc(tcpc, TYPEC_CC_RP);
+		tcpci_set_cc(tcpc_dev, TYPEC_CC_RP);
 		usleep_range(1000, 2000);
 	}
 
@@ -1871,33 +1813,33 @@ static inline bool typec_check_false_ra_detach(struct tcpc_device *tcpc)
 	 * it will trigger low rp duty protection.
 	 */
 
-	tcpci_get_cc(tcpc);
+	tcpci_get_cc(tcpc_dev);
 
 	if (typec_is_cc_open())
-		tcpc->typec_cable_only = false;
+		tcpc_dev->typec_cable_only = false;
 	else if (typec_get_cc1() + typec_get_cc2() == TYPEC_CC_VOLT_RA) {
-		tcpc->typec_cable_only = true;
-		TYPEC_DBG("False_RaDetach2 (eMark)\n");
+		tcpc_dev->typec_cable_only = true;
+		TYPEC_DBG("False_RaDetach2 (eMark)\r\n");
 	} else {
-		tcpc->typec_cable_only = false;
-		TYPEC_DBG("False_RaDetach3 (%d, %d)\n",
+		tcpc_dev->typec_cable_only = false;
+		TYPEC_DBG("False_RaDetach3 (%d, %d)\r\n",
 			typec_get_cc1(), typec_get_cc2());
 		return true;
 	}
 
 #ifdef CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG
-	if (tcpc->typec_cable_only &&
-		tcpc->tcpc_flags & TCPC_FLAGS_LPM_WAKEUP_WATCHDOG)
-		tcpc_enable_wakeup_timer(tcpc, true);
+	if (tcpc_dev->typec_cable_only &&
+		tcpc_dev->tcpc_flags & TCPC_FLAGS_LPM_WAKEUP_WATCHDOG)
+		tcpc_enable_wakeup_timer(tcpc_dev, true);
 #endif	/* CONFIG_TYPEC_CAP_LPM_WAKEUP_WATCHDOG */
 
 #ifdef CONFIG_TYPEC_WAKEUP_ONCE_LOW_DUTY
-	if (!tcpc->typec_cable_only) {
-		if (tcpc->typec_low_rp_duty_cntdown)
-			tcpci_set_low_rp_duty(tcpc, true);
+	if (!tcpc_dev->typec_cable_only) {
+		if (tcpc_dev->typec_low_rp_duty_cntdown)
+			tcpci_set_low_rp_duty(tcpc_dev, true);
 		else {
-			tcpc->typec_wakeup_once = false;
-			tcpc->typec_low_rp_duty_cntdown = true;
+			tcpc_dev->typec_wakeup_once = false;
+			tcpc_dev->typec_low_rp_duty_cntdown = true;
 		}
 	}
 #endif	/* CONFIG_TYPEC_WAKEUP_ONCE_LOW_DUTY */
@@ -1907,27 +1849,27 @@ static inline bool typec_check_false_ra_detach(struct tcpc_device *tcpc)
 	 */
 
 	if (drp) {
-		tcpci_set_cc(tcpc, TYPEC_CC_DRP);
-		tcpci_alert_status_clear(tcpc,
+		tcpci_set_cc(tcpc_dev, TYPEC_CC_DRP);
+		tcpci_alert_status_clear(tcpc_dev,
 			TCPC_REG_ALERT_EXT_RA_DETACH);
 	}
 
-	return tcpc->typec_cable_only;
+	return tcpc_dev->typec_cable_only;
 }
 
-int tcpc_typec_enter_lpm_again(struct tcpc_device *tcpc)
+int tcpc_typec_enter_lpm_again(struct tcpc_device *tcpc_dev)
 {
-	bool check_ra = (tcpc->typec_lpm) || (tcpc->typec_cable_only);
+	bool check_ra = (tcpc_dev->typec_lpm) || (tcpc_dev->typec_cable_only);
 
-	if (check_ra && typec_check_false_ra_detach(tcpc))
+	if (check_ra && typec_check_false_ra_detach(tcpc_dev))
 		return 0;
 
-	TYPEC_DBG("RetryLPM\n");
+	TYPEC_DBG("RetryLPM\r\n");
 
-	tcpc->typec_lpm = true;
+	tcpc_dev->typec_lpm = true;
 
-	tcpci_set_low_power_mode(tcpc, true,
-		(tcpc->typec_role !=  TYPEC_ROLE_SRC) ?
+	tcpci_set_low_power_mode(tcpc_dev, true,
+		(tcpc_dev->typec_role !=  TYPEC_ROLE_SRC) ?
 		TYPEC_CC_DRP : TYPEC_CC_RP);
 
 	return 0;
@@ -1935,20 +1877,20 @@ int tcpc_typec_enter_lpm_again(struct tcpc_device *tcpc)
 
 #ifdef CONFIG_TYPEC_CAP_TRY_SINK
 static inline int typec_handle_try_sink_cc_change(
-	struct tcpc_device *tcpc)
+	struct tcpc_device *tcpc_dev)
 {
 	/*
 	 * The port shall wait for tDRPTry and only then begin
 	 * begin monitoring the CC1 and CC2 pins for the SNK.Rp state
 	 */
 
-	if (!tcpc->typec_drp_try_timeout) {
-		TYPEC_DBG("[Try.SNK] Ignore CC_Alert\n");
+	if (!tcpc_dev->typec_drp_try_timeout) {
+		TYPEC_DBG("[Try.SNK] Ignore CC_Alert\r\n");
 		return 1;
 	}
 
 	if (!typec_is_cc_open()) {
-		tcpci_notify_attachwait_state(tcpc, true);
+		tcpci_notify_attachwait_state(tcpc_dev, true);
 		return 0;
 	}
 
@@ -1956,33 +1898,33 @@ static inline int typec_handle_try_sink_cc_change(
 }
 #endif	/* CONFIG_TYPEC_CAP_TRY_SINK */
 
-static inline int typec_get_rp_present_flag(struct tcpc_device *tcpc)
+static inline int typec_get_rp_present_flag(struct tcpc_device *tcpc_dev)
 {
 	uint8_t rp_flag = 0;
 
-	if (tcpc->typec_remote_cc[0] >= TYPEC_CC_VOLT_SNK_DFT
-		&& tcpc->typec_remote_cc[0] != TYPEC_CC_DRP_TOGGLING)
+	if (tcpc_dev->typec_remote_cc[0] >= TYPEC_CC_VOLT_SNK_DFT
+		&& tcpc_dev->typec_remote_cc[0] != TYPEC_CC_DRP_TOGGLING)
 		rp_flag |= 1;
 
-	if (tcpc->typec_remote_cc[1] >= TYPEC_CC_VOLT_SNK_DFT
-		&& tcpc->typec_remote_cc[1] != TYPEC_CC_DRP_TOGGLING)
+	if (tcpc_dev->typec_remote_cc[1] >= TYPEC_CC_VOLT_SNK_DFT
+		&& tcpc_dev->typec_remote_cc[1] != TYPEC_CC_DRP_TOGGLING)
 		rp_flag |= 2;
 
 	return rp_flag;
 }
 
-static bool typec_is_cc_open_state(struct tcpc_device *tcpc)
+static bool typec_is_cc_open_state(struct tcpc_device *tcpc_dev)
 {
-	if (tcpc->typec_state == typec_errorrecovery)
+	if (tcpc_dev->typec_state == typec_errorrecovery)
 		return true;
 
-	if (tcpc->typec_state == typec_disabled)
+	if (tcpc_dev->typec_state == typec_disabled)
 		return true;
 
 #ifdef CONFIG_WATER_DETECTION
-	if ((tcpc->tcpc_flags & TCPC_FLAGS_WATER_DETECTION) &&
-	    (tcpc->typec_state == typec_water_protection_wait ||
-	    tcpc->typec_state == typec_water_protection))
+	if ((tcpc_dev->tcpc_flags & TCPC_FLAGS_WATER_DETECTION) &&
+	    (tcpc_dev->typec_state == typec_water_protection_wait ||
+	    tcpc_dev->typec_state == typec_water_protection))
 		return true;
 #endif /* CONFIG_WATER_DETECTION */
 
@@ -1990,46 +1932,46 @@ static bool typec_is_cc_open_state(struct tcpc_device *tcpc)
 }
 
 static inline bool typec_is_ignore_cc_change(
-	struct tcpc_device *tcpc, uint8_t rp_present)
+	struct tcpc_device *tcpc_dev, uint8_t rp_present)
 {
-	if (typec_is_cc_open_state(tcpc))
+	if (typec_is_cc_open_state(tcpc_dev))
 		return true;
 
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
-	if (tcpc->typec_legacy_cable &&
-		typec_legacy_handle_cc_change(tcpc)) {
+	if (tcpc_dev->typec_legacy_cable &&
+		typec_legacy_handle_cc_change(tcpc_dev)) {
 		return true;
 	}
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE */
 
 #ifdef CONFIG_USB_POWER_DELIVERY
-	if (tcpc->typec_state == typec_attachwait_snk &&
-		typec_get_rp_present_flag(tcpc) == rp_present) {
-		TYPEC_DBG("[AttachWait] Ignore RpLvl Alert\n");
+	if (tcpc_dev->typec_state == typec_attachwait_snk &&
+		typec_get_rp_present_flag(tcpc_dev) == rp_present) {
+		TYPEC_DBG("[AttachWait] Ignore RpLvl Alert\r\n");
 		return true;
 	}
 
-	if (tcpc->pd_wait_pr_swap_complete) {
-		TYPEC_DBG("[PR.Swap] Ignore CC_Alert\n");
+	if (tcpc_dev->pd_wait_pr_swap_complete) {
+		TYPEC_DBG("[PR.Swap] Ignore CC_Alert\r\n");
 		return true;
 	}
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
 #ifdef CONFIG_TYPEC_CAP_TRY_SINK
-	if (tcpc->typec_state == typec_try_snk) {
-		if (typec_handle_try_sink_cc_change(tcpc) > 0)
+	if (tcpc_dev->typec_state == typec_try_snk) {
+		if (typec_handle_try_sink_cc_change(tcpc_dev) > 0)
 			return true;
 	}
 
-	if (tcpc->typec_state == typec_trywait_src_pe) {
-		TYPEC_DBG("[Try.PE] Ignore CC_Alert\n");
+	if (tcpc_dev->typec_state == typec_trywait_src_pe) {
+		TYPEC_DBG("[Try.PE] Ignore CC_Alert\r\n");
 		return true;
 	}
 #endif	/* CONFIG_TYPEC_CAP_TRY_SINK */
 
 #ifdef CONFIG_TYPEC_CAP_TRY_SOURCE
-	if (tcpc->typec_state == typec_trywait_snk_pe) {
-		TYPEC_DBG("[Try.PE] Ignore CC_Alert\n");
+	if (tcpc_dev->typec_state == typec_trywait_snk_pe) {
+		TYPEC_DBG("[Try.PE] Ignore CC_Alert\r\n");
 		return true;
 	}
 #endif	/* CONFIG_TYPEC_CAP_TRY_SOURCE */
@@ -2037,61 +1979,59 @@ static inline bool typec_is_ignore_cc_change(
 	return false;
 }
 
-int tcpc_typec_handle_cc_change(struct tcpc_device *tcpc)
+int tcpc_typec_handle_cc_change(struct tcpc_device *tcpc_dev)
 {
 	int ret;
 	uint8_t rp_present;
 
 #ifdef CONFIG_WATER_DETECTION
 	/* For ellisys rp/rp to rp/open */
-	u8 typec_state_old = tcpc->typec_state;
+	u8 typec_state_old = tcpc_dev->typec_state;
 #endif /* CONFIG_WATER_DETECTION */
 
-	rp_present = typec_get_rp_present_flag(tcpc);
+	rp_present = typec_get_rp_present_flag(tcpc_dev);
 
-	ret = tcpci_get_cc(tcpc);
+	ret = tcpci_get_cc(tcpc_dev);
 	if (ret < 0)
 		return ret;
 
-	TYPEC_INFO("[CC_Alert] %d/%d\n", typec_get_cc1(), typec_get_cc2());
-
-	if (typec_is_cc_no_res()) {
-		TYPEC_DBG("[Warning] CC No Res\n");
-		if (tcpc->typec_lpm && !tcpc->typec_cable_only)
-			typec_enter_low_power_mode(tcpc);
-		if (typec_is_drp_toggling())
-			return 0;
+	if (typec_is_drp_toggling()) {
+		TYPEC_DBG("[Waring] DRP Toggling\r\n");
+		if (tcpc_dev->typec_lpm && !tcpc_dev->typec_cable_only)
+			typec_enter_low_power_mode(tcpc_dev);
+		return 0;
 	}
 
 #ifdef CONFIG_TYPEC_CAP_NORP_SRC
-	if (typec_try_exit_norp_src(tcpc))
-		return 0;
+	typec_try_exit_norp_src(tcpc_dev);
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
 
-	if (typec_is_ignore_cc_change(tcpc, rp_present))
+	TYPEC_INFO("[CC_Alert] %d/%d\r\n", typec_get_cc1(), typec_get_cc2());
+
+	typec_disable_low_power_mode(tcpc_dev);
+
+	if (typec_is_ignore_cc_change(tcpc_dev, rp_present))
 		return 0;
 
-	if (tcpc->typec_state == typec_attachwait_snk
-		|| tcpc->typec_state == typec_attachwait_src)
-		typec_wait_ps_change(tcpc, TYPEC_WAIT_PS_DISABLE);
+	if (tcpc_dev->typec_state == typec_attachwait_snk
+		|| tcpc_dev->typec_state == typec_attachwait_src)
+		typec_wait_ps_change(tcpc_dev, TYPEC_WAIT_PS_DISABLE);
 
-	if (typec_is_cc_attach(tcpc)) {
-		typec_disable_low_power_mode(tcpc);
-		typec_attach_wait_entry(tcpc);
+	if (typec_is_cc_attach(tcpc_dev)) {
+		typec_attach_wait_entry(tcpc_dev);
 #ifdef CONFIG_WATER_DETECTION
 		if (typec_state_old == typec_unattached_snk ||
 		    typec_state_old == typec_unattached_src) {
 #ifdef CONFIG_WD_POLLING_ONLY
-			if (get_boot_mode() == KERNEL_POWER_OFF_CHARGING_BOOT
-			    || get_boot_mode() == LOW_POWER_OFF_CHARGING_BOOT)
-				typec_check_water_status(tcpc);
+			if (tcpc_dev->tcpc_flags & TCPC_FLAGS_KPOC_BOOT)
+				typec_check_water_status(tcpc_dev);
 #else
-			typec_check_water_status(tcpc);
+			typec_check_water_status(tcpc_dev);
 #endif /* CONFIG_WD_POLLING_ONLY */
 		}
 #endif /* CONFIG_WATER_DETECTION */
 	} else
-		typec_detach_wait_entry(tcpc);
+		typec_detach_wait_entry(tcpc_dev);
 
 	return 0;
 }
@@ -2101,21 +2041,21 @@ int tcpc_typec_handle_cc_change(struct tcpc_device *tcpc)
  */
 
 #ifdef CONFIG_TYPEC_CAP_TRY_STATE
-static inline int typec_handle_drp_try_timeout(struct tcpc_device *tcpc)
+static inline int typec_handle_drp_try_timeout(struct tcpc_device *tcpc_dev)
 {
 	bool src_detect = false, en_timer;
 
-	tcpc->typec_drp_try_timeout = true;
-	tcpc_disable_timer(tcpc, TYPEC_TRY_TIMER_DRP_TRY);
+	tcpc_dev->typec_drp_try_timeout = true;
+	tcpc_disable_timer(tcpc_dev, TYPEC_TRY_TIMER_DRP_TRY);
 
 	if (typec_is_drp_toggling()) {
-		TYPEC_DBG("[Warning] DRP Toggling\n");
+		TYPEC_DBG("[Waring] DRP Toggling\r\n");
 		return 0;
 	}
 
 	src_detect = typec_check_cc_any(TYPEC_CC_VOLT_RD);
 
-	switch (tcpc->typec_state) {
+	switch (tcpc_dev->typec_state) {
 #ifdef CONFIG_TYPEC_CAP_TRY_SOURCE
 	case typec_try_src:
 		en_timer = !src_detect;
@@ -2130,7 +2070,7 @@ static inline int typec_handle_drp_try_timeout(struct tcpc_device *tcpc)
 	case typec_try_snk:
 		en_timer = true;
 		if (!typec_is_cc_open())
-			tcpci_notify_attachwait_state(tcpc, true);
+			tcpci_notify_attachwait_state(tcpc_dev, true);
 		break;
 #endif /* CONFIG_TYPEC_CAP_TRY_SINK */
 
@@ -2140,192 +2080,165 @@ static inline int typec_handle_drp_try_timeout(struct tcpc_device *tcpc)
 	}
 
 	if (en_timer)
-		tcpc_enable_timer(tcpc, TYPEC_TIMER_TRYCCDEBOUNCE);
+		tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_TRYCCDEBOUNCE);
 
 	return 0;
 }
 #endif	/* CONFIG_TYPEC_CAP_TRY_STATE */
 
-static inline int typec_handle_debounce_timeout(struct tcpc_device *tcpc)
+static inline int typec_handle_debounce_timeout(struct tcpc_device *tcpc_dev)
 {
 #ifdef CONFIG_TYPEC_CAP_NORP_SRC
-	if (typec_is_cc_no_res() && tcpci_check_vbus_valid(tcpc)
-		&& (tcpc->typec_state == typec_unattached_snk))
-		return typec_norp_src_attached_entry(tcpc);
+	if (typec_is_cc_no_res() && tcpci_check_vbus_valid(tcpc_dev)
+		&& (tcpc_dev->typec_state == typec_unattached_snk))
+		typec_norp_src_attached_entry(tcpc_dev);
 #endif
 
 	if (typec_is_drp_toggling()) {
-		TYPEC_DBG("[Warning] DRP Toggling\n");
+		TYPEC_DBG("[Waring] DRP Toggling\r\n");
 		return 0;
 	}
 
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
-	tcpc_disable_timer(tcpc, TYPEC_RT_TIMER_STATE_CHANGE);
+	tcpc_disable_timer(tcpc_dev, TYPEC_RT_TIMER_STATE_CHANGE);
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE */
 
-	typec_handle_cc_changed_entry(tcpc);
+	typec_handle_cc_changed_entry(tcpc_dev);
 	return 0;
 }
 
 static inline int typec_handle_error_recovery_timeout(
-						struct tcpc_device *tcpc)
+						struct tcpc_device *tcpc_dev)
 {
 #ifdef CONFIG_USB_POWER_DELIVERY
-	tcpc->pd_wait_pe_idle = false;
+	tcpc_dev->pd_wait_pe_idle = false;
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
-	typec_unattach_wait_pe_idle_entry(tcpc);
-	typec_alert_attach_state_change(tcpc);
+	tcpc_dev->typec_attach_new = TYPEC_UNATTACHED;
+
+	typec_unattach_wait_pe_idle_entry(tcpc_dev);
+	typec_alert_attach_state_change(tcpc_dev);
 	return 0;
 }
 
 #ifdef CONFIG_USB_POWER_DELIVERY
-static inline int typec_handle_pe_idle(struct tcpc_device *tcpc)
+static inline int typec_handle_pe_idle(struct tcpc_device *tcpc_dev)
 {
-	switch (tcpc->typec_state) {
+	switch (tcpc_dev->typec_state) {
 
 #ifdef CONFIG_TYPEC_CAP_TRY_SOURCE
 	case typec_trywait_snk_pe:
-		typec_trywait_snk_entry(tcpc);
+		typec_trywait_snk_entry(tcpc_dev);
 		break;
 #endif
 
 	case typec_unattachwait_pe:
-		typec_unattached_entry(tcpc);
+		typec_unattached_entry(tcpc_dev);
 		break;
 
 	default:
-		TYPEC_DBG("Dummy pe_idle\n");
+		TYPEC_DBG("Dummy pe_idle\r\n");
 		break;
 	}
 
 	return 0;
 }
-
-#ifdef CONFIG_USB_PD_WAIT_BC12
-static inline void typec_handle_pd_wait_bc12(struct tcpc_device *tcpc)
-{
-	uint8_t type = TYPEC_UNATTACHED;
-	enum charger_type chg_type = CHARGER_UNKNOWN;
-
-	mutex_lock(&tcpc->access_lock);
-
-	type = tcpc->typec_attach_new;
-	chg_type = mt_get_charger_type();
-	TYPEC_INFO("type=%d, chg_type=%d, count=%d\n", type, chg_type,
-		tcpc->pd_wait_bc12_count);
-
-	if (type != TYPEC_ATTACHED_SNK && type != TYPEC_ATTACHED_DBGACC_SNK)
-		goto out;
-
-	if (chg_type != CHARGER_UNKNOWN ||
-		tcpc->pd_wait_bc12_count >= 20) {
-		__pd_put_cc_attached_event(tcpc, type);
-	} else {
-		tcpc->pd_wait_bc12_count++;
-		tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_PD_WAIT_BC12);
-	}
-out:
-	mutex_unlock(&tcpc->access_lock);
-}
-#endif /* CONFIG_USB_PD_WAIT_BC12 */
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
-static inline int typec_handle_src_reach_vsafe0v(struct tcpc_device *tcpc)
+static inline int typec_handle_src_reach_vsafe0v(struct tcpc_device *tcpc_dev)
 {
 	if (typec_is_drp_toggling()) {
-		TYPEC_DBG("[Warning] DRP Toggling\n");
+		TYPEC_DBG("[Waring] DRP Toggling\r\n");
 		return 0;
 	}
 
-	tcpc->typec_reach_vsafe0v = true;
-	typec_cc_src_detect_vsafe0v_entry(tcpc);
-	typec_alert_attach_state_change(tcpc);
+	tcpc_dev->typec_reach_vsafe0v = true;
+	typec_wait_ps_change(tcpc_dev, TYPEC_WAIT_PS_DISABLE);
+	tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_CCDEBOUNCE);
 	return 0;
 }
 
-static inline int typec_handle_src_toggle_timeout(struct tcpc_device *tcpc)
+static inline int typec_handle_src_toggle_timeout(struct tcpc_device *tcpc_dev)
 {
 #ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
-	if (tcpc->typec_during_role_swap)
+	if (tcpc_dev->typec_during_role_swap)
 		return 0;
 #endif	/* CONFIG_TYPEC_CAP_ROLE_SWAP */
 
-	if (tcpc->typec_state == typec_unattached_src) {
-		typec_unattached_snk_and_drp_entry(tcpc);
-		typec_wait_ps_change(tcpc, TYPEC_WAIT_PS_DISABLE);
-#ifdef CONFIG_TYPEC_CAP_NORP_SRC
-		typec_try_enter_norp_src(tcpc);
-#endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
+	if (tcpc_dev->typec_state == typec_unattached_src) {
+		TYPEC_NEW_STATE(typec_unattached_snk);
+		tcpci_set_cc(tcpc_dev, TYPEC_CC_DRP);
+		typec_wait_ps_change(tcpc_dev, TYPEC_WAIT_PS_DISABLE);
+		typec_enable_low_power_mode(tcpc_dev, TYPEC_CC_DRP);
 	}
 
 	return 0;
 }
 
 #ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
-static inline int typec_handle_role_swap_start(struct tcpc_device *tcpc)
+static inline int typec_handle_role_swap_start(struct tcpc_device *tcpc_dev)
 {
-	uint8_t role_swap = tcpc->typec_during_role_swap;
+	uint8_t role_swap = tcpc_dev->typec_during_role_swap;
 
 	if (role_swap == TYPEC_ROLE_SWAP_TO_SNK) {
-		TYPEC_INFO("Role Swap to Sink\n");
-		tcpci_set_cc(tcpc, TYPEC_CC_RD);
-		tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_ROLE_SWAP_STOP);
+		TYPEC_INFO("Role Swap to Sink\r\n");
+		tcpci_set_cc(tcpc_dev, TYPEC_CC_RD);
+		tcpc_enable_timer(tcpc_dev, TYPEC_RT_TIMER_ROLE_SWAP_STOP);
 	} else if (role_swap == TYPEC_ROLE_SWAP_TO_SRC) {
-		TYPEC_INFO("Role Swap to Source\n");
-		tcpci_set_cc(tcpc, TYPEC_CC_RP);
-		tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_ROLE_SWAP_STOP);
+		TYPEC_INFO("Role Swap to Source\r\n");
+		tcpci_set_cc(tcpc_dev, TYPEC_CC_RP);
+		tcpc_enable_timer(tcpc_dev, TYPEC_RT_TIMER_ROLE_SWAP_STOP);
 	}
 
 	return 0;
 }
 
-static inline int typec_handle_role_swap_stop(struct tcpc_device *tcpc)
+static inline int typec_handle_role_swap_stop(struct tcpc_device *tcpc_dev)
 {
-	if (tcpc->typec_during_role_swap) {
-		TYPEC_INFO("TypeC Role Swap Failed\n");
-		tcpc->typec_during_role_swap = TYPEC_ROLE_SWAP_NONE;
-		tcpc_enable_timer(tcpc, TYPEC_TIMER_PDDEBOUNCE);
+	if (tcpc_dev->typec_during_role_swap) {
+		TYPEC_INFO("TypeC Role Swap Failed\r\n");
+		tcpc_dev->typec_during_role_swap = TYPEC_ROLE_SWAP_NONE;
+		tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_PDDEBOUNCE);
 	}
 
 	return 0;
 }
 #endif	/* CONFIG_TYPEC_CAP_ROLE_SWAP */
 
-int tcpc_typec_handle_timeout(struct tcpc_device *tcpc, uint32_t timer_id)
+int tcpc_typec_handle_timeout(struct tcpc_device *tcpc_dev, uint32_t timer_id)
 {
 	int ret = 0;
 
 #ifdef CONFIG_TYPEC_CAP_TRY_STATE
 	if (timer_id == TYPEC_TRY_TIMER_DRP_TRY)
-		return typec_handle_drp_try_timeout(tcpc);
+		return typec_handle_drp_try_timeout(tcpc_dev);
 #endif	/* CONFIG_TYPEC_CAP_TRY_STATE */
 
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
 	if (timer_id == TYPEC_TIMER_DRP_SRC_TOGGLE &&
-		(tcpc->typec_state != typec_unattached_src)) {
-		TCPC_DBG("Dummy SRC_TOGGLE\n");
+		(tcpc_dev->typec_state != typec_unattached_src)) {
+		TCPC_DBG("Dummy SRC_TOGGLE\r\n");
 		return 0;
 	}
 #endif /* CONFIG_TYPEC_CHECK_LEGACY_CABLE */
 
 	if (timer_id >= TYPEC_TIMER_START_ID)
-		tcpc_reset_typec_debounce_timer(tcpc);
+		tcpc_reset_typec_debounce_timer(tcpc_dev);
 	else if (timer_id >= TYPEC_RT_TIMER_START_ID)
-		tcpc_disable_timer(tcpc, timer_id);
+		tcpc_disable_timer(tcpc_dev, timer_id);
 
 	if (timer_id == TYPEC_TIMER_ERROR_RECOVERY)
-		return typec_handle_error_recovery_timeout(tcpc);
+		return typec_handle_error_recovery_timeout(tcpc_dev);
 	else if (timer_id == TYPEC_RT_TIMER_STATE_CHANGE)
-		return typec_alert_attach_state_change(tcpc);
-	else if (typec_is_cc_open_state(tcpc)) {
-		TYPEC_DBG("[Open] Ignore timer_evt\n");
+		return typec_alert_attach_state_change(tcpc_dev);
+	else if (typec_is_cc_open_state(tcpc_dev)) {
+		TYPEC_DBG("[Open] Ignore timer_evt\r\n");
 		return 0;
 	}
 
 #ifdef CONFIG_USB_POWER_DELIVERY
-	if (tcpc->pd_wait_pr_swap_complete) {
-		TYPEC_DBG("[PR.Swap] Ignore timer_evt\n");
+	if (tcpc_dev->pd_wait_pr_swap_complete) {
+		TYPEC_DBG("[PR.Swap] Ignore timer_evt\r\n");
 		return 0;
 	}
 #endif	/* CONFIG_USB_POWER_DELIVERY */
@@ -2344,83 +2257,78 @@ int tcpc_typec_handle_timeout(struct tcpc_device *tcpc, uint32_t timer_id)
 #ifdef CONFIG_TYPEC_CAP_NORP_SRC
 	case TYPEC_TIMER_NORP_SRC:
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
-		ret = typec_handle_debounce_timeout(tcpc);
+		ret = typec_handle_debounce_timeout(tcpc_dev);
 		break;
 
 #ifdef CONFIG_USB_POWER_DELIVERY
 	case TYPEC_RT_TIMER_PE_IDLE:
-		ret = typec_handle_pe_idle(tcpc);
-		break;
-#ifdef CONFIG_USB_PD_WAIT_BC12
-	case TYPEC_RT_TIMER_PD_WAIT_BC12:
-		typec_handle_pd_wait_bc12(tcpc);
+		ret = typec_handle_pe_idle(tcpc_dev);
 		break;
-#endif /* CONFIG_USB_PD_WAIT_BC12 */
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
 #ifdef CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_DELAY
 	case TYPEC_RT_TIMER_SAFE0V_DELAY:
-		ret = typec_handle_src_reach_vsafe0v(tcpc);
+		ret = typec_handle_src_reach_vsafe0v(tcpc_dev);
 		break;
 #endif	/* CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_DELAY */
 
 	case TYPEC_RT_TIMER_LOW_POWER_MODE:
-		if (tcpc->typec_lpm)
-			typec_try_low_power_mode(tcpc);
+		if (tcpc_dev->typec_lpm)
+			typec_try_low_power_mode(tcpc_dev);
 		break;
 
 #ifdef CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_TIMEOUT
 	case TYPEC_RT_TIMER_SAFE0V_TOUT:
-		TCPC_INFO("VSafe0V TOUT (%d)\n", tcpc->vbus_level);
+		TCPC_INFO("VSafe0V TOUT (%d)\r\n", tcpc_dev->vbus_level);
 
-		if (!tcpci_check_vbus_valid_from_ic(tcpc))
-			ret = tcpc_typec_handle_vsafe0v(tcpc);
+		if (!tcpci_check_vbus_valid_from_ic(tcpc_dev))
+			ret = tcpc_typec_handle_vsafe0v(tcpc_dev);
 		break;
 #endif	/* CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_TIMEOUT */
 
 	case TYPEC_TIMER_DRP_SRC_TOGGLE:
-		ret = typec_handle_src_toggle_timeout(tcpc);
+		ret = typec_handle_src_toggle_timeout(tcpc_dev);
 		break;
 
 #ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
 	case TYPEC_RT_TIMER_ROLE_SWAP_START:
-		typec_handle_role_swap_start(tcpc);
+		typec_handle_role_swap_start(tcpc_dev);
 		break;
 
 	case TYPEC_RT_TIMER_ROLE_SWAP_STOP:
-		typec_handle_role_swap_stop(tcpc);
+		typec_handle_role_swap_stop(tcpc_dev);
 		break;
 #endif	/* CONFIG_TYPEC_CAP_ROLE_SWAP */
 
-	case TYPEC_RT_TIMER_DISCHARGE:
-		if (!tcpc->typec_power_ctrl) {
-			mutex_lock(&tcpc->access_lock);
-			tcpci_enable_auto_discharge(tcpc, false);
-			tcpci_enable_force_discharge(tcpc, false, 0);
-			mutex_unlock(&tcpc->access_lock);
+#ifdef CONFIG_TYPEC_CAP_AUTO_DISCHARGE
+	case TYPEC_RT_TIMER_AUTO_DISCHARGE:
+		if (!tcpc_dev->typec_power_ctrl) {
+			tcpci_enable_ext_discharge(tcpc_dev, false);
+			tcpci_enable_auto_discharge(tcpc_dev, false);
 		}
 		break;
+#endif	/* CONFIG_TYPEC_CAP_AUTO_DISCHARGE */
 
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
 	case TYPEC_RT_TIMER_NOT_LEGACY:
-		tcpc->typec_legacy_cable = false;
-		typec_legacy_reset_retry_wk(tcpc);
-		typec_legacy_reset_cable_suspect(tcpc);
+		tcpc_dev->typec_legacy_cable = false;
+		typec_legacy_reset_retry_wk(tcpc_dev);
+		typec_legacy_reset_cable_suspect(tcpc_dev);
 		break;
 
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE2
 	case TYPEC_RT_TIMER_LEGACY_STABLE:
-		if (tcpc->typec_legacy_cable)
-			tcpc->typec_legacy_retry_wk--;
+		if (tcpc_dev->typec_legacy_cable)
+			tcpc_dev->typec_legacy_retry_wk--;
 		break;
 
 #ifdef CONFIG_TYPEC_LEGACY2_AUTO_RECYCLE
 	case TYPEC_RT_TIMER_LEGACY_RECYCLE:
-		if (tcpc->typec_legacy_cable == 2) {
-			TYPEC_INFO("LC->Recycle\n");
-			tcpc->typec_legacy_cable = false;
-			typec_legacy_keep_default_rp(tcpc, false);
-			typec_set_drp_toggling(tcpc);
+		if (tcpc_dev->typec_legacy_cable == 2) {
+			TYPEC_INFO("LC->Recycle\r\n");
+			tcpc_dev->typec_legacy_cable = false;
+			typec_legacy_keep_default_rp(tcpc_dev, false);
+			typec_set_drp_toggling(tcpc_dev);
 		}
 		break;
 #endif	/* CONFIG_TYPEC_LEGACY2_AUTO_RECYCLE */
@@ -2435,133 +2343,119 @@ int tcpc_typec_handle_timeout(struct tcpc_device *tcpc, uint32_t timer_id)
  * [BLOCK] Handle ps-change event
  */
 
-static inline int typec_handle_vbus_present(struct tcpc_device *tcpc)
+static inline int typec_handle_vbus_present(struct tcpc_device *tcpc_dev)
 {
-	switch (tcpc->typec_wait_ps_change) {
+	switch (tcpc_dev->typec_wait_ps_change) {
 	case TYPEC_WAIT_PS_SNK_VSAFE5V:
-		typec_cc_snk_detect_vsafe5v_entry(tcpc);
-		typec_alert_attach_state_change(tcpc);
+		typec_cc_snk_detect_vsafe5v_entry(tcpc_dev);
+		typec_alert_attach_state_change(tcpc_dev);
 		break;
 	case TYPEC_WAIT_PS_SRC_VSAFE5V:
-		typec_source_attached_with_vbus_entry(tcpc);
+		typec_source_attached_with_vbus_entry(tcpc_dev);
 
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
 		if (typec_get_cc_res() != TYPEC_CC_VOLT_RD) {
-			typec_postpone_state_change(tcpc);
+			typec_postpone_state_change(tcpc_dev);
 			break;
 		}
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE */
 
-		typec_alert_attach_state_change(tcpc);
+		typec_alert_attach_state_change(tcpc_dev);
 		break;
-#ifdef CONFIG_TYPEC_CAP_DBGACC
-	case TYPEC_WAIT_PS_DBG_VSAFE5V:
-		typec_debug_acc_attached_with_vbus_entry(tcpc);
-		typec_alert_attach_state_change(tcpc);
-		break;
-#endif	/* CONFIG_TYPEC_CAP_DBGACC */
 	}
 
 	return 0;
 }
 
-static inline int typec_attached_snk_vbus_absent(struct tcpc_device *tcpc)
+static inline int typec_attached_snk_vbus_absent(struct tcpc_device *tcpc_dev)
 {
 #ifdef TYPEC_EXIT_ATTACHED_SNK_VIA_VBUS
 #ifdef CONFIG_USB_POWER_DELIVERY
 #ifdef CONFIG_USB_PD_DIRECT_CHARGE
-	if (tcpc->pd_during_direct_charge &&
-		!tcpci_check_vsafe0v(tcpc, true)) {
-		TYPEC_DBG("Ignore vbus_absent(snk), DirectCharge\n");
+	if (tcpc_dev->pd_during_direct_charge &&
+		!tcpci_check_vsafe0v(tcpc_dev, true)) {
+		TYPEC_DBG("Ignore vbus_absent(snk), DirectCharge\r\n");
 		return 0;
 	}
 #endif	/* CONFIG_USB_PD_DIRECT_CHARGE */
 
-	if (tcpc->pd_wait_hard_reset_complete) {
+	if (tcpc_dev->pd_wait_hard_reset_complete) {
 #ifdef CONFIG_COMPATIBLE_APPLE_TA
-		TYPEC_DBG("Ignore vbus_absent(snk) and CC, HReset(apple)\n");
+		TYPEC_DBG("Ignore vbus_absent(snk) and CC, HReset(apple)\r\n");
 		return 0;
 #else
 		if (typec_get_cc_res() != TYPEC_CC_VOLT_OPEN) {
 			TYPEC_DBG(
-				 "Ignore vbus_absent(snk), HReset & CC!=0\n");
+				 "Ignore vbus_absent(snk), HReset & CC!=0\r\n");
 			return 0;
 		}
 #endif /* CONFIG_COMPATIBLE_APPLE_TA */
 	}
 #endif /* CONFIG_USB_POWER_DELIVERY */
 
-	typec_unattach_wait_pe_idle_entry(tcpc);
-	typec_alert_attach_state_change(tcpc);
+	typec_unattach_wait_pe_idle_entry(tcpc_dev);
+	typec_alert_attach_state_change(tcpc_dev);
 #endif /* TYPEC_EXIT_ATTACHED_SNK_VIA_VBUS */
 
 	return 0;
 }
 
 
-static inline int typec_handle_vbus_absent(struct tcpc_device *tcpc)
+static inline int typec_handle_vbus_absent(struct tcpc_device *tcpc_dev)
 {
 #ifdef CONFIG_USB_POWER_DELIVERY
-	if (tcpc->pd_wait_pr_swap_complete) {
-		TYPEC_DBG("[PR.Swap] Ignore vbus_absent\n");
+	if (tcpc_dev->pd_wait_pr_swap_complete) {
+		TYPEC_DBG("[PR.Swap] Ignore vbus_absent\r\n");
 		return 0;
 	}
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
-	switch (tcpc->typec_state) {
-	case typec_attached_snk:
-#ifdef CONFIG_TYPEC_CAP_DBGACC_SNK
-	case typec_attached_dbgacc_snk:
-#endif	/* CONFIG_TYPEC_CAP_DBGACC_SNK */
-		typec_attached_snk_vbus_absent(tcpc);
-		break;
-	default:
-		break;
-	}
+	if (tcpc_dev->typec_state == typec_attached_snk)
+		typec_attached_snk_vbus_absent(tcpc_dev);
 
 #ifndef CONFIG_TCPC_VSAFE0V_DETECT
-	tcpc_typec_handle_vsafe0v(tcpc);
+	tcpc_typec_handle_vsafe0v(tcpc_dev);
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT */
 
 	return 0;
 }
 
-int tcpc_typec_handle_ps_change(struct tcpc_device *tcpc, int vbus_level)
+int tcpc_typec_handle_ps_change(struct tcpc_device *tcpc_dev, int vbus_level)
 {
-	tcpc->typec_reach_vsafe0v = false;
+	tcpc_dev->typec_reach_vsafe0v = false;
 
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
-	if (tcpc->typec_legacy_cable) {
-		typec_legacy_handle_ps_change(tcpc, vbus_level);
+	if (tcpc_dev->typec_legacy_cable) {
+		typec_legacy_handle_ps_change(tcpc_dev, vbus_level);
 		return 0;
 	}
 #endif /* CONFIG_TYPEC_CHECK_LEGACY_CABLE */
 
 #ifdef CONFIG_TYPEC_CAP_NORP_SRC
-	if (!typec_try_enter_norp_src(tcpc))
-		if (typec_try_exit_norp_src(tcpc))
-			return 0;
+	if (typec_is_cc_no_res()) {
+		if (!typec_try_enter_norp_src(tcpc_dev))
+			typec_try_exit_norp_src(tcpc_dev);
+	}
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
 
-	if (typec_is_cc_no_res()) {
-		TYPEC_DBG("[Warning] CC No Res\n");
-		if (tcpc->typec_lpm && !tcpc->typec_cable_only)
-			typec_enter_low_power_mode(tcpc);
-		if (typec_is_drp_toggling())
-			return 0;
+	if (typec_is_drp_toggling()) {
+		TYPEC_DBG("[Waring] DRP Toggling\r\n");
+		if (tcpc_dev->typec_lpm && !tcpc_dev->typec_cable_only)
+			typec_enter_low_power_mode(tcpc_dev);
+		return 0;
 	}
 
 #ifdef CONFIG_TYPEC_CAP_AUDIO_ACC_SINK_VBUS
-	if (tcpc->typec_state == typec_audioaccessory) {
+	if (tcpc_dev->typec_state == typec_audioaccessory) {
 		return typec_audio_acc_sink_vbus(
-			tcpc, vbus_level >= TCPC_VBUS_VALID);
+			tcpc_dev, vbus_level >= TCPC_VBUS_VALID);
 	}
 #endif	/* CONFIG_TYPEC_CAP_AUDIO_ACC_SINK_VBUS */
 
 	if (vbus_level >= TCPC_VBUS_VALID)
-		return typec_handle_vbus_present(tcpc);
+		return typec_handle_vbus_present(tcpc_dev);
 
-	return typec_handle_vbus_absent(tcpc);
+	return typec_handle_vbus_absent(tcpc_dev);
 }
 
 /*
@@ -2570,31 +2464,28 @@ int tcpc_typec_handle_ps_change(struct tcpc_device *tcpc, int vbus_level)
 
 #ifdef CONFIG_USB_POWER_DELIVERY
 
-int tcpc_typec_handle_pe_pr_swap(struct tcpc_device *tcpc)
+int tcpc_typec_handle_pe_pr_swap(struct tcpc_device *tcpc_dev)
 {
 	int ret = 0;
 
-	mutex_lock(&tcpc->typec_lock);
-	switch (tcpc->typec_state) {
+	mutex_lock(&tcpc_dev->typec_lock);
+	switch (tcpc_dev->typec_state) {
 	case typec_attached_snk:
 		TYPEC_NEW_STATE(typec_attached_src);
-		tcpc->typec_is_attached_src = true;
-		tcpc->typec_attach_new = TYPEC_ATTACHED_SRC;
-		tcpci_set_cc(tcpc,
-			TYPEC_CC_PULL(tcpc->typec_local_rp_level, TYPEC_CC_RP));
+		tcpc_dev->typec_attach_new = TYPEC_ATTACHED_SRC;
+		tcpci_set_cc(tcpc_dev, tcpc_dev->typec_local_rp_level);
 		break;
 	case typec_attached_src:
 		TYPEC_NEW_STATE(typec_attached_snk);
-		tcpc->typec_is_attached_src = false;
-		tcpc->typec_attach_new = TYPEC_ATTACHED_SNK;
-		tcpci_set_cc(tcpc, TYPEC_CC_RD);
+		tcpc_dev->typec_attach_new = TYPEC_ATTACHED_SNK;
+		tcpci_set_cc(tcpc_dev, TYPEC_CC_RD);
 		break;
 	default:
 		break;
 	}
 
-	typec_alert_attach_state_change(tcpc);
-	mutex_unlock(&tcpc->typec_lock);
+	typec_alert_attach_state_change(tcpc_dev);
+	mutex_unlock(&tcpc_dev->typec_lock);
 	return ret;
 }
 
@@ -2604,22 +2495,22 @@ int tcpc_typec_handle_pe_pr_swap(struct tcpc_device *tcpc)
  * [BLOCK] Handle reach vSafe0V event
  */
 
-int tcpc_typec_handle_vsafe0v(struct tcpc_device *tcpc)
+int tcpc_typec_handle_vsafe0v(struct tcpc_device *tcpc_dev)
 {
 #ifdef CONFIG_WATER_DETECTION
-	if ((tcpc->tcpc_flags & TCPC_FLAGS_WATER_DETECTION) &&
-	    tcpc->typec_state == typec_water_protection_wait) {
+	if ((tcpc_dev->tcpc_flags & TCPC_FLAGS_WATER_DETECTION) &&
+	    tcpc_dev->typec_state == typec_water_protection_wait) {
 		TYPEC_NEW_STATE(typec_water_protection);
-		tcpci_set_water_protection(tcpc, true);
+		tcpci_set_water_protection(tcpc_dev, true);
 		return 0;
 	}
 #endif /* CONFIG_WATER_DETECTION */
 
-	if (tcpc->typec_wait_ps_change == TYPEC_WAIT_PS_SRC_VSAFE0V) {
+	if (tcpc_dev->typec_wait_ps_change == TYPEC_WAIT_PS_SRC_VSAFE0V) {
 #ifdef CONFIG_TYPEC_ATTACHED_SRC_SAFE0V_DELAY
-		tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_SAFE0V_DELAY);
+		tcpc_enable_timer(tcpc_dev, TYPEC_RT_TIMER_SAFE0V_DELAY);
 #else
-		typec_handle_src_reach_vsafe0v(tcpc);
+		typec_handle_src_reach_vsafe0v(tcpc_dev);
 #endif
 	}
 
@@ -2630,7 +2521,6 @@ int tcpc_typec_handle_vsafe0v(struct tcpc_device *tcpc)
  * [BLOCK] TCPCI TypeC I/F
  */
 
-#if TYPEC_INFO_ENABLE
 static const char *const typec_role_name[] = {
 	"UNKNOWN",
 	"SNK",
@@ -2639,30 +2529,29 @@ static const char *const typec_role_name[] = {
 	"TrySRC",
 	"TrySNK",
 };
-#endif /* TYPEC_INFO_ENABLE */
 
 #ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
-int tcpc_typec_swap_role(struct tcpc_device *tcpc)
+int tcpc_typec_swap_role(struct tcpc_device *tcpc_dev)
 {
-	if (tcpc->typec_role < TYPEC_ROLE_DRP)
+	if (tcpc_dev->typec_role < TYPEC_ROLE_DRP)
 		return TCPM_ERROR_NOT_DRP_ROLE;
 
-	if (tcpc->typec_during_role_swap)
+	if (tcpc_dev->typec_during_role_swap)
 		return TCPM_ERROR_DURING_ROLE_SWAP;
 
-	switch (tcpc->typec_attach_old) {
+	switch (tcpc_dev->typec_attach_old) {
 	case TYPEC_ATTACHED_SNK:
-		tcpc->typec_during_role_swap = TYPEC_ROLE_SWAP_TO_SRC;
+		tcpc_dev->typec_during_role_swap = TYPEC_ROLE_SWAP_TO_SRC;
 		break;
 	case TYPEC_ATTACHED_SRC:
-		tcpc->typec_during_role_swap = TYPEC_ROLE_SWAP_TO_SNK;
+		tcpc_dev->typec_during_role_swap = TYPEC_ROLE_SWAP_TO_SNK;
 		break;
 	}
 
-	if (tcpc->typec_during_role_swap) {
-		TYPEC_INFO("TypeC Role Swap Start\n");
-		tcpci_set_cc(tcpc, TYPEC_CC_OPEN);
-		tcpc_enable_timer(tcpc, TYPEC_RT_TIMER_ROLE_SWAP_START);
+	if (tcpc_dev->typec_during_role_swap) {
+		TYPEC_INFO("TypeC Role Swap Start\r\n");
+		tcpci_set_cc(tcpc_dev, TYPEC_CC_OPEN);
+		tcpc_enable_timer(tcpc_dev, TYPEC_RT_TIMER_ROLE_SWAP_START);
 		return TCPM_SUCCESS;
 	}
 
@@ -2670,81 +2559,108 @@ int tcpc_typec_swap_role(struct tcpc_device *tcpc)
 }
 #endif /* CONFIG_TYPEC_CAP_ROLE_SWAP */
 
-int tcpc_typec_set_rp_level(struct tcpc_device *tcpc, uint8_t rp_lvl)
+int tcpc_typec_set_rp_level(struct tcpc_device *tcpc_dev, uint8_t res)
 {
-	switch (rp_lvl) {
-	case TYPEC_RP_DFT:
-	case TYPEC_RP_1_5:
-	case TYPEC_RP_3_0:
-		TYPEC_INFO("TypeC-Rp: %d\n", rp_lvl);
-		tcpc->typec_local_rp_level = rp_lvl;
+	switch (res) {
+	case TYPEC_CC_RP_DFT:
+	case TYPEC_CC_RP_1_5:
+	case TYPEC_CC_RP_3_0:
+		TYPEC_INFO("TypeC-Rp: %d\r\n", res);
+		tcpc_dev->typec_local_rp_level = res;
 		break;
+
 	default:
-		TYPEC_INFO("TypeC-Unknown-Rp (%d)\n", rp_lvl);
+		TYPEC_INFO("TypeC-Unknown-Rp (%d)\r\n", res);
 		return -EINVAL;
 	}
 
+#ifdef CONFIG_USB_PD_DBG_ALWAYS_LOCAL_RP
+	tcpci_set_cc(tcpc_dev, tcpc_dev->typec_local_rp_level);
+#else
+	if ((tcpc_dev->typec_attach_old != TYPEC_UNATTACHED) &&
+		(tcpc_dev->typec_attach_new != TYPEC_UNATTACHED)) {
+		return tcpci_set_cc(tcpc_dev, res);
+	}
+#endif
+
 	return 0;
 }
 
-int tcpc_typec_error_recovery(struct tcpc_device *tcpc)
+int tcpc_typec_error_recovery(struct tcpc_device *tcpc_dev)
 {
-	if (tcpc->typec_state != typec_errorrecovery)
-		typec_error_recovery_entry(tcpc);
+	if (tcpc_dev->typec_state != typec_errorrecovery)
+		typec_error_recovery_entry(tcpc_dev);
 
 	return 0;
 }
 
-int tcpc_typec_disable(struct tcpc_device *tcpc)
+int tcpc_typec_disable(struct tcpc_device *tcpc_dev)
 {
-	if (tcpc->typec_state != typec_disabled)
-		typec_disable_entry(tcpc);
+	if (tcpc_dev->typec_state != typec_disabled)
+		typec_disable_entry(tcpc_dev);
 
 	return 0;
 }
 
-int tcpc_typec_enable(struct tcpc_device *tcpc)
+int tcpc_typec_enable(struct tcpc_device *tcpc_dev)
 {
-	if (tcpc->typec_state == typec_disabled)
-		typec_unattached_entry(tcpc);
+	if (tcpc_dev->typec_state == typec_disabled)
+		typec_unattached_entry(tcpc_dev);
 
 	return 0;
 }
 
 int tcpc_typec_change_role(
-	struct tcpc_device *tcpc, uint8_t typec_role, bool postpone)
+	struct tcpc_device *tcpc_dev, uint8_t typec_role)
 {
+	uint8_t local_cc;
+	bool force_unattach = false;
+
 	if (typec_role == TYPEC_ROLE_UNKNOWN ||
 		typec_role >= TYPEC_ROLE_NR) {
-		TYPEC_INFO("Wrong TypeC-Role: %d\n", typec_role);
+		TYPEC_INFO("Wrong TypeC-Role: %d\r\n", typec_role);
 		return -EINVAL;
 	}
 
-	if (tcpc->typec_role_new == typec_role) {
-		TYPEC_INFO("typec_new_role: %s is the same\n",
-			typec_role_name[typec_role]);
-		return 0;
-	}
-	tcpc->typec_role_new = typec_role;
+	mutex_lock(&tcpc_dev->access_lock);
 
-	TYPEC_INFO("typec_new_role: %s\n", typec_role_name[typec_role]);
+	tcpc_dev->typec_role = typec_role;
+	TYPEC_INFO("typec_new_role: %s\r\n", typec_role_name[typec_role]);
 
-	if (!postpone || tcpc->typec_attach_old == TYPEC_UNATTACHED)
-		return tcpc_typec_error_recovery(tcpc);
-	else
+	local_cc = tcpc_dev->typec_local_cc & 0x07;
+
+	if (typec_role == TYPEC_ROLE_SNK && local_cc == TYPEC_CC_RP)
+		force_unattach = true;
+
+	if (typec_role == TYPEC_ROLE_SRC && local_cc == TYPEC_CC_RD)
+		force_unattach = true;
+
+	if (tcpc_dev->typec_attach_new == TYPEC_UNATTACHED)
+		force_unattach = true;
+
+	if (force_unattach) {
+		TYPEC_DBG("force_unattach\r\n");
+		tcpci_set_cc(tcpc_dev, TYPEC_CC_OPEN);
+		mutex_unlock(&tcpc_dev->access_lock);
+		typec_disable_low_power_mode(tcpc_dev);
+		tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_PDDEBOUNCE);
 		return 0;
+	}
+
+	mutex_unlock(&tcpc_dev->access_lock);
+	return 0;
 }
 
 #ifdef CONFIG_TYPEC_CAP_POWER_OFF_CHARGE
-static int typec_init_power_off_charge(struct tcpc_device *tcpc)
+static int typec_init_power_off_charge(struct tcpc_device *tcpc_dev)
 {
 	bool cc_open;
-	int ret = tcpci_get_cc(tcpc);
+	int ret = tcpci_get_cc(tcpc_dev);
 
 	if (ret < 0)
 		return ret;
 
-	if (tcpc->typec_role == TYPEC_ROLE_SRC)
+	if (tcpc_dev->typec_role == TYPEC_ROLE_SRC)
 		return 0;
 
 	cc_open = typec_is_cc_open();
@@ -2754,194 +2670,187 @@ static int typec_init_power_off_charge(struct tcpc_device *tcpc)
 		return 0;
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
 
-	if (!tcpci_check_vbus_valid(tcpc))
+	if (!tcpci_check_vbus_valid(tcpc_dev))
 		return 0;
 
-	TYPEC_INFO2("PowerOffCharge\n");
+	TYPEC_INFO2("PowerOffCharge\r\n");
 
 	TYPEC_NEW_STATE(typec_unattached_snk);
-	typec_wait_ps_change(tcpc, TYPEC_WAIT_PS_DISABLE);
+	typec_wait_ps_change(tcpc_dev, TYPEC_WAIT_PS_DISABLE);
 
-	tcpci_set_cc(tcpc, TYPEC_CC_DRP);
-	typec_enable_low_power_mode(tcpc, TYPEC_CC_DRP);
+	tcpci_set_cc(tcpc_dev, TYPEC_CC_DRP);
+	typec_enable_low_power_mode(tcpc_dev, TYPEC_CC_DRP);
 	usleep_range(1000, 2000);
 
 #ifdef CONFIG_TYPEC_CAP_NORP_SRC
 	if (cc_open) {
-		tcpc_enable_timer(tcpc, TYPEC_TIMER_PDDEBOUNCE);
+		tcpc_enable_timer(tcpc_dev, TYPEC_TIMER_PDDEBOUNCE);
 		return 1;
 	}
 #endif	/* CONFIG_TYPEC_CAP_NORP_SRC */
 
-	tcpci_set_cc(tcpc, TYPEC_CC_RD);
+	tcpci_set_cc(tcpc_dev, TYPEC_CC_RD);
 
 	return 1;
 }
 #endif	/* CONFIG_TYPEC_CAP_POWER_OFF_CHARGE */
 
-int tcpc_typec_init(struct tcpc_device *tcpc, uint8_t typec_role)
+int tcpc_typec_init(struct tcpc_device *tcpc_dev, uint8_t typec_role)
 {
 	int ret = 0;
 
-	if (typec_role == TYPEC_ROLE_UNKNOWN ||
-		typec_role >= TYPEC_ROLE_NR) {
-		TYPEC_INFO("Wrong TypeC-Role: %d\n", typec_role);
+	if (typec_role >= TYPEC_ROLE_NR) {
+		TYPEC_INFO("Wrong TypeC-Role: %d\r\n", typec_role);
 		return -EINVAL;
 	}
 
-	TYPEC_INFO("typec_init: %s\n", typec_role_name[typec_role]);
+	TYPEC_INFO("typec_init: %s\r\n", typec_role_name[typec_role]);
 
-	tcpc->typec_role = typec_role;
-	tcpc->typec_role_new = typec_role;
-	tcpc->typec_attach_new = TYPEC_UNATTACHED;
-	tcpc->typec_attach_old = TYPEC_UNATTACHED;
+	tcpc_dev->typec_role = typec_role;
+	tcpc_dev->typec_attach_new = TYPEC_UNATTACHED;
+	tcpc_dev->typec_attach_old = TYPEC_UNATTACHED;
 
-	tcpc->typec_remote_cc[0] = TYPEC_CC_VOLT_OPEN;
-	tcpc->typec_remote_cc[1] = TYPEC_CC_VOLT_OPEN;
+	tcpc_dev->typec_remote_cc[0] = TYPEC_CC_VOLT_OPEN;
+	tcpc_dev->typec_remote_cc[1] = TYPEC_CC_VOLT_OPEN;
 
-	mutex_lock(&tcpc->access_lock);
-	tcpc->wake_lock_pd = 0;
-	tcpc->wake_lock_user = true;
-	mutex_unlock(&tcpc->access_lock);
-	tcpc->typec_usb_sink_curr = CONFIG_TYPEC_SNK_CURR_DFT;
+	tcpc_dev->wake_lock_pd = 0;
+	tcpc_dev->wake_lock_user = true;
+	tcpc_dev->typec_usb_sink_curr = CONFIG_TYPEC_SNK_CURR_DFT;
 
 #ifdef CONFIG_TYPEC_CAP_CUSTOM_HV
-	tcpc->typec_during_custom_hv = false;
+	tcpc_dev->typec_during_custom_hv = false;
 #endif	/* CONFIG_TYPEC_CAP_CUSTOM_HV */
 
 #ifdef CONFIG_TYPEC_CHECK_LEGACY_CABLE
-	tcpc->typec_legacy_cable = false;
-	typec_legacy_reset_retry_wk(tcpc);
-	typec_legacy_reset_cable_suspect(tcpc);
+	tcpc_dev->typec_legacy_cable = false;
+	typec_legacy_reset_retry_wk(tcpc_dev);
+	typec_legacy_reset_cable_suspect(tcpc_dev);
 #endif	/* CONFIG_TYPEC_CHECK_LEGACY_CABLE */
 
 #ifdef CONFIG_TYPEC_CAP_POWER_OFF_CHARGE
-	ret = typec_init_power_off_charge(tcpc);
+	ret = typec_init_power_off_charge(tcpc_dev);
 	if (ret != 0)
 		return ret;
 #endif	/* CONFIG_TYPEC_CAP_POWER_OFF_CHARGE */
 
 #ifdef CONFIG_TYPEC_POWER_CTRL_INIT
-	tcpc->typec_power_ctrl = true;
+	tcpc_dev->typec_power_ctrl = true;
 #endif	/* CONFIG_TYPEC_POWER_CTRL_INIT */
 
-	typec_unattached_entry(tcpc);
+	typec_unattached_entry(tcpc_dev);
 	return ret;
 }
 
-void  tcpc_typec_deinit(struct tcpc_device *tcpc)
+void  tcpc_typec_deinit(struct tcpc_device *tcpc_dev)
 {
 }
 
 #ifdef CONFIG_WATER_DETECTION
-int tcpc_typec_handle_wd(struct tcpc_device *tcpc, bool wd)
+int tcpc_typec_handle_wd(struct tcpc_device *tcpc_dev, bool wd)
 {
 	int ret = 0;
 
-	pr_info("%s: wd = %d\n", __func__, wd);
-	if (!(tcpc->tcpc_flags & TCPC_FLAGS_WATER_DETECTION))
+	if (!(tcpc_dev->tcpc_flags & TCPC_FLAGS_WATER_DETECTION))
 		return 0;
 
-	TYPEC_INFO("%s %d\n", __func__, wd);
+	TYPEC_INFO("%s %d\r\n", __func__, wd);
 	if (!wd) {
-		tcpci_set_water_protection(tcpc, false);
-		tcpc_typec_error_recovery(tcpc);
+		tcpci_set_water_protection(tcpc_dev, false);
+		tcpc_typec_error_recovery(tcpc_dev);
 		goto out;
 	}
 
 #ifdef CONFIG_MTK_KERNEL_POWER_OFF_CHARGING
-	ret = get_boot_mode();
-	if (ret == KERNEL_POWER_OFF_CHARGING_BOOT ||
-	    ret == LOW_POWER_OFF_CHARGING_BOOT) {
-		TYPEC_INFO("KPOC does not enter water protection\n");
+	if (tcpc_dev->tcpc_flags & TCPC_FLAGS_KPOC_BOOT) {
+		TYPEC_INFO("KPOC does not enter water protection\r\n");
 		goto out;
 	}
 #endif /* CONFIG_MTK_KERNEL_POWER_OFF_CHARGING */
 
-	tcpc->typec_attach_new = TYPEC_UNATTACHED;
-	ret = tcpci_set_cc(tcpc, TYPEC_CC_OPEN);
+	tcpc_dev->typec_attach_new = TYPEC_UNATTACHED;
+	ret = tcpci_set_cc(tcpc_dev, TYPEC_CC_OPEN);
 #ifdef CONFIG_TCPC_VSAFE0V_DETECT_IC
-	ret = tcpci_is_vsafe0v(tcpc);
+	ret = tcpci_is_vsafe0v(tcpc_dev);
 	if (ret == 0) {
 		TYPEC_NEW_STATE(typec_water_protection_wait);
-		typec_wait_ps_change(tcpc, TYPEC_WAIT_PS_SRC_VSAFE0V);
+		typec_wait_ps_change(tcpc_dev, TYPEC_WAIT_PS_SRC_VSAFE0V);
 	} else {
 		TYPEC_NEW_STATE(typec_water_protection);
-		tcpci_set_water_protection(tcpc, true);
+		tcpci_set_water_protection(tcpc_dev, true);
 	}
 #else
 	/* TODO: Wait ps change ? */
 #endif /* CONFIG_TCPC_VSAFE0V_DETECT_IC */
 
 out:
-	tcpci_notify_wd_status(tcpc, wd);
-	if (tcpc->typec_state == typec_water_protection ||
-	    tcpc->typec_state == typec_water_protection_wait) {
-		typec_alert_attach_state_change(tcpc);
-		tcpc->typec_attach_old = tcpc->typec_attach_new;
+	tcpci_notify_wd_status(tcpc_dev, wd);
+	if (tcpc_dev->typec_state == typec_water_protection ||
+	    tcpc_dev->typec_state == typec_water_protection_wait) {
+		typec_alert_attach_state_change(tcpc_dev);
+		tcpc_dev->typec_attach_old = tcpc_dev->typec_attach_new;
 	}
 	return ret;
 }
 #endif /* CONFIG_WATER_DETECTION */
 
+#ifdef CONFIG_TYPEC_OTP
+int tcpc_typec_handle_otp(struct tcpc_device *tcpc_dev, bool otp)
+{
+	TCPC_INFO("%s otp (%d, %d)\n", __func__, tcpc_dev->typec_otp, otp);
+
+	if (!(tcpc_dev->tcpc_flags & TCPC_FLAGS_TYPEC_OTP))
+		return 0;
+
+	if (tcpc_dev->typec_otp == otp)
+		return 0;
+
+	tcpc_dev->typec_otp = otp;
+	tcpci_notify_typec_otp(tcpc_dev);
+
+	return 0;
+}
+#endif /* CONFIG_TYPEC_OTP */
+
 #ifdef CONFIG_CABLE_TYPE_DETECTION
-int tcpc_typec_handle_ctd(struct tcpc_device *tcpc,
+int tcpc_typec_handle_ctd(struct tcpc_device *tcpc_dev,
 			  enum tcpc_cable_type cable_type)
 {
 	int ret;
 
-	TCPC_INFO("%s: cable_type = %d\n", __func__, cable_type);
-	if (!(tcpc->tcpc_flags & TCPC_FLAGS_CABLE_TYPE_DETECTION))
+	if (!(tcpc_dev->tcpc_flags & TCPC_FLAGS_CABLE_TYPE_DETECTION))
 		return 0;
 
+
 	/* Filter out initial no cable */
 	if (cable_type == TCPC_CABLE_TYPE_C2C) {
-		ret = tcpci_get_cc(tcpc);
+		ret = tcpci_get_cc(tcpc_dev);
 		if (ret >= 0) {
 			if (typec_is_cc_no_res() &&
-			    (tcpc->typec_state == typec_unattached_snk ||
-			     tcpc->typec_state == typec_unattached_src)) {
+			    (tcpc_dev->typec_state == typec_unattached_snk ||
+			     tcpc_dev->typec_state == typec_unattached_src)) {
 				TCPC_INFO("%s toggling or open\n", __func__);
 				cable_type = TCPC_CABLE_TYPE_NONE;
 			}
 		}
 	}
 
-	TCPC_INFO("%s: typec_state=%s, pre_ct=%d, ct=%d, typec_ct=%d\n",
-		  __func__, typec_state_name[tcpc->typec_state],
-		  tcpc->pre_typec_cable_type,
-		  cable_type,  tcpc->typec_cable_type);
-
-	if (tcpc->typec_state == typec_attachwait_snk) {
-		TCPC_INFO("%s during attachwait_snk\n", __func__);
-		tcpc->pre_typec_cable_type = cable_type;
-	} else if (tcpc->typec_state == typec_try_snk ||
-		   (tcpc->typec_state == typec_attached_snk &&
-			cable_type != TCPC_CABLE_TYPE_NONE)) {
-		if (tcpc->pre_typec_cable_type != TCPC_CABLE_TYPE_NONE) {
-			TCPC_INFO("%s try_snk cable(%d, %d)\n", __func__,
-				  tcpc->pre_typec_cable_type, cable_type);
-			cable_type = tcpc->pre_typec_cable_type;
-			tcpc->pre_typec_cable_type = TCPC_CABLE_TYPE_NONE;
-		}
-	}
-	TCPC_INFO("%s cable (%d, %d)\n", __func__, tcpc->typec_cable_type,
+	TCPC_INFO("%s cable (%d, %d)\n", __func__, tcpc_dev->typec_cable_type,
 		  cable_type);
 
-	if (tcpc->typec_cable_type == cable_type)
+	if (tcpc_dev->typec_cable_type == cable_type)
 		return 0;
 
-	if (tcpc->typec_cable_type != TCPC_CABLE_TYPE_NONE &&
+	if (tcpc_dev->typec_cable_type != TCPC_CABLE_TYPE_NONE &&
 	    cable_type != TCPC_CABLE_TYPE_NONE) {
 		TCPC_INFO("%s ctd done once %d\n", __func__,
-			  tcpc->typec_cable_type);
+			  tcpc_dev->typec_cable_type);
 		return 0;
 	}
 
-	tcpc->typec_cable_type = cable_type;
+	tcpc_dev->typec_cable_type = cable_type;
 
-	TCPC_INFO("%s cable type %d\n", __func__, tcpc->typec_cable_type);
-	tcpci_notify_cable_type(tcpc);
+	TCPC_INFO("%s cable type %d\n", __func__, tcpc_dev->typec_cable_type);
+	tcpci_notify_cable_type(tcpc_dev);
 	return 0;
 }
 #endif /* CONFIG_CABLE_TYPE_DETECTION */
diff --git a/drivers/misc/mediatek/typec/tcpc/tcpm.c b/drivers/misc/mediatek/typec/tcpc/tcpm.c
index 9f68dab..412aa00 100644
--- a/drivers/misc/mediatek/typec/tcpc/tcpm.c
+++ b/drivers/misc/mediatek/typec/tcpc/tcpm.c
@@ -27,6 +27,7 @@
 
 
 /* Check status */
+
 static int tcpm_check_typec_attached(struct tcpc_device *tcpc)
 {
 	if (tcpc->typec_attach_old == TYPEC_UNATTACHED ||
@@ -39,83 +40,71 @@ static int tcpm_check_typec_attached(struct tcpc_device *tcpc)
 #ifdef CONFIG_USB_POWER_DELIVERY
 static int tcpm_check_pd_attached(struct tcpc_device *tcpc)
 {
-	int ret = TCPM_SUCCESS;
-	struct pd_port *pd_port = &tcpc->pd_port;
-	struct pe_data *pe_data = &pd_port->pe_data;
-
-	tcpci_lock_typec(tcpc);
+	struct pe_data *pe_data;
+	int ret = tcpm_check_typec_attached(tcpc);
 
-	if (!tcpc->pd_inited_flag) {
-		ret = TCPM_ERROR_PE_NOT_READY;
-		goto unlock_typec_out;
-	}
+	if (!tcpc->pd_inited_flag)
+		return TCPM_ERROR_PE_NOT_READY;
 
-	ret = tcpm_check_typec_attached(tcpc);
-
-unlock_typec_out:
-	tcpci_unlock_typec(tcpc);
 	if (ret != TCPM_SUCCESS)
 		return ret;
 
-	mutex_lock(&pd_port->pd_lock);
+#ifdef CONFIG_TYPEC_CAP_CUSTOM_SRC
+	if (tcpc->typec_attach_old == TYPEC_ATTACHED_CUSTOM_SRC)
+		return TCPM_ERROR_CUSTOM_SRC;
+#endif	/* CONFIG_TYPEC_CAP_CUSTOM_SRC */
 
-	if (!pe_data->pd_prev_connected) {
-		ret = TCPM_ERROR_NO_PD_CONNECTED;
-		goto unlock_pd_out;
-	}
+	pe_data = &tcpc->pd_port.pe_data;
+
+	if (!pe_data->pd_prev_connected)
+		return TCPM_ERROR_NO_PD_CONNECTED;
 
 	if (!pe_data->pe_ready)
-		ret = TCPM_ERROR_PE_NOT_READY;
+		return TCPM_ERROR_PE_NOT_READY;
 
-unlock_pd_out:
-	mutex_unlock(&pd_port->pd_lock);
-	return ret;
+	return TCPM_SUCCESS;
 }
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
 
 /* Inquire TCPC status */
 
-int tcpm_shutdown(struct tcpc_device *tcpc)
+int tcpm_shutdown(struct tcpc_device *tcpc_dev)
 {
 #ifdef CONFIG_TCPC_SHUTDOWN_VBUS_DISABLE
-	if (tcpc->typec_power_ctrl)
-		tcpci_disable_vbus_control(tcpc);
+	if (tcpc_dev->typec_power_ctrl)
+		tcpci_disable_vbus_control(tcpc_dev);
 #endif	/* CONFIG_TCPC_SHUTDOWN_VBUS_DISABLE */
 
-	if (tcpc->ops->deinit)
-		tcpc->ops->deinit(tcpc);
+	if (tcpc_dev->ops->deinit)
+		tcpc_dev->ops->deinit(tcpc_dev);
 
 	return 0;
 }
 
-int tcpm_inquire_remote_cc(struct tcpc_device *tcpc,
+int tcpm_inquire_remote_cc(struct tcpc_device *tcpc_dev,
 	uint8_t *cc1, uint8_t *cc2, bool from_ic)
 {
 	int rv = 0;
 
-	tcpci_lock_typec(tcpc);
 	if (from_ic) {
-		rv = tcpci_get_cc(tcpc);
+		rv = tcpci_get_cc(tcpc_dev);
 		if (rv < 0)
-			goto out;
+			return rv;
 	}
 
-	*cc1 = tcpc->typec_remote_cc[0];
-	*cc2 = tcpc->typec_remote_cc[1];
-out:
-	tcpci_unlock_typec(tcpc);
-	return rv;
+	*cc1 = tcpc_dev->typec_remote_cc[0];
+	*cc2 = tcpc_dev->typec_remote_cc[1];
+	return 0;
 }
 
-int tcpm_inquire_typec_remote_rp_curr(struct tcpc_device *tcpc)
+int tcpm_inquire_typec_remote_rp_curr(struct tcpc_device *tcpc_dev)
 {
 	int rp_lvl, ret = 0;
 
-	if (tcpm_check_typec_attached(tcpc))
+	if (tcpm_check_typec_attached(tcpc_dev))
 		return 0;
-
-	rp_lvl = tcpc->typec_remote_rp_level;
+	rp_lvl = tcpc_dev->typec_remote_rp_level;
 	switch (rp_lvl) {
 	case TYPEC_CC_VOLT_SNK_DFT:
 		ret = 500;
@@ -129,45 +118,67 @@ int tcpm_inquire_typec_remote_rp_curr(struct tcpc_device *tcpc)
 	default:
 		break;
 	}
-
 	return ret;
 }
 
-int tcpm_inquire_vbus_level(struct tcpc_device *tcpc, bool from_ic)
+int tcpm_inquire_vbus_level(
+	struct tcpc_device *tcpc_dev, bool from_ic)
 {
 	int rv = 0;
 	uint16_t power_status = 0;
 
 	if (from_ic) {
-		rv = tcpci_get_power_status(tcpc, &power_status);
+		rv = tcpci_get_power_status(tcpc_dev, &power_status);
 		if (rv < 0)
 			return rv;
 	}
 
-	return tcpc->vbus_level;
+	return tcpc_dev->vbus_level;
 }
 
-bool tcpm_inquire_cc_polarity(struct tcpc_device *tcpc)
+bool tcpm_inquire_cc_polarity(
+	struct tcpc_device *tcpc_dev)
 {
-	return tcpc->typec_polarity;
+	return tcpc_dev->typec_polarity;
 }
 
-uint8_t tcpm_inquire_typec_attach_state(struct tcpc_device *tcpc)
+uint8_t tcpm_inquire_typec_attach_state(
+	struct tcpc_device *tcpc_dev)
 {
-	return tcpc->typec_attach_new;
+	return tcpc_dev->typec_attach_new;
 }
 
-uint8_t tcpm_inquire_typec_role(struct tcpc_device *tcpc)
+uint8_t tcpm_inquire_typec_role(
+	struct tcpc_device *tcpc_dev)
 {
-	return tcpc->typec_role;
+	return tcpc_dev->typec_role;
 }
 
-uint8_t tcpm_inquire_typec_local_rp(struct tcpc_device *tcpc)
+uint8_t tcpm_inquire_typec_local_rp(
+	struct tcpc_device *tcpc_dev)
 {
-	return tcpc->typec_local_rp_level;
+	uint8_t level;
+
+	switch (tcpc_dev->typec_local_rp_level) {
+	case TYPEC_CC_RP_1_5:
+		level = 1;
+		break;
+
+	case TYPEC_CC_RP_3_0:
+		level = 2;
+		break;
+
+	default:
+	case TYPEC_CC_RP_DFT:
+		level = 0;
+		break;
+	}
+
+	return level;
 }
 
-int tcpm_typec_set_wake_lock(struct tcpc_device *tcpc, bool user_lock)
+int tcpm_typec_set_wake_lock(
+	struct tcpc_device *tcpc, bool user_lock)
 {
 	int ret;
 
@@ -180,54 +191,62 @@ int tcpm_typec_set_wake_lock(struct tcpc_device *tcpc, bool user_lock)
 	return ret;
 }
 
-int tcpm_typec_set_usb_sink_curr(struct tcpc_device *tcpc, int curr)
+int tcpm_typec_set_usb_sink_curr(
+	struct tcpc_device *tcpc_dev, int curr)
 {
 	bool force_sink_vbus = true;
 
 #ifdef CONFIG_USB_POWER_DELIVERY
-	struct pd_port *pd_port = &tcpc->pd_port;
+	struct pd_port *pd_port = &tcpc_dev->pd_port;
+
+	mutex_lock(&pd_port->pd_lock);
 
 	if (pd_port->pe_data.pd_prev_connected)
 		force_sink_vbus = false;
 #endif	/* CONFIG_USB_POWER_DELIVERY */
 
-	tcpci_lock_typec(tcpc);
-	tcpc->typec_usb_sink_curr = curr;
+	tcpc_dev->typec_usb_sink_curr = curr;
 
-	if (tcpc->typec_remote_rp_level != TYPEC_CC_VOLT_SNK_DFT)
+	if (tcpc_dev->typec_remote_rp_level != TYPEC_CC_VOLT_SNK_DFT)
 		force_sink_vbus = false;
 
 	if (force_sink_vbus) {
-		tcpci_sink_vbus(tcpc,
+		tcpci_sink_vbus(tcpc_dev,
 			TCP_VBUS_CTRL_TYPEC, TCPC_VBUS_SINK_5V, -1);
 	}
-	tcpci_unlock_typec(tcpc);
+
+#ifdef CONFIG_USB_POWER_DELIVERY
+	mutex_unlock(&pd_port->pd_lock);
+#endif	/* CONFIG_USB_POWER_DELIVERY */
 
 	return 0;
 }
 
-int tcpm_typec_set_rp_level(struct tcpc_device *tcpc, uint8_t level)
+int tcpm_typec_set_rp_level(
+	struct tcpc_device *tcpc_dev, uint8_t level)
 {
-	int ret = 0;
+	uint8_t res;
 
-	tcpci_lock_typec(tcpc);
-	ret = tcpc_typec_set_rp_level(tcpc, level);
-	tcpci_unlock_typec(tcpc);
+	if (level == 2)
+		res = TYPEC_CC_RP_3_0;
+	else if (level == 1)
+		res = TYPEC_CC_RP_1_5;
+	else
+		res = TYPEC_CC_RP_DFT;
 
-	return ret;
+	return tcpc_typec_set_rp_level(tcpc_dev, res);
 }
 
 int tcpm_typec_set_custom_hv(struct tcpc_device *tcpc, bool en)
 {
 #ifdef CONFIG_TYPEC_CAP_CUSTOM_HV
-	int ret = tcpm_check_typec_attached(tcpc);
-
-	if (ret != TCPM_SUCCESS)
-		return ret;
+	int ret;
 
-	tcpci_lock_typec(tcpc);
-	tcpc->typec_during_custom_hv = en;
-	tcpci_unlock_typec(tcpc);
+	mutex_lock(&tcpc->access_lock);
+	ret = tcpm_check_typec_attached(tcpc);
+	if (ret == TCPM_SUCCESS)
+		tcpc->typec_during_custom_hv = en;
+	mutex_unlock(&tcpc->access_lock);
 
 	return ret;
 #else
@@ -235,118 +254,94 @@ int tcpm_typec_set_custom_hv(struct tcpc_device *tcpc, bool en)
 #endif	/* CONFIG_TYPEC_CAP_CUSTOM_HV */
 }
 
-int tcpm_typec_role_swap(struct tcpc_device *tcpc)
+int tcpm_typec_role_swap(struct tcpc_device *tcpc_dev)
 {
 #ifdef CONFIG_TYPEC_CAP_ROLE_SWAP
-	int ret = tcpm_check_typec_attached(tcpc);
+	int ret = tcpm_check_typec_attached(tcpc_dev);
 
 	if (ret != TCPM_SUCCESS)
 		return ret;
 
-	tcpci_lock_typec(tcpc);
-	ret = tcpc_typec_swap_role(tcpc);
-	tcpci_unlock_typec(tcpc);
-
-	return ret;
+	return tcpc_typec_swap_role(tcpc_dev);
 #else
 	return TCPM_ERROR_NO_SUPPORT;
 #endif /* CONFIG_TYPEC_CAP_ROLE_SWAP */
 }
 
 int tcpm_typec_change_role(
-	struct tcpc_device *tcpc, uint8_t typec_role)
+	struct tcpc_device *tcpc_dev, uint8_t typec_role)
 {
-	int ret = 0;
-
-	tcpci_lock_typec(tcpc);
-	ret = tcpc_typec_change_role(tcpc, typec_role, false);
-	tcpci_unlock_typec(tcpc);
-
-	return ret;
+	return tcpc_typec_change_role(tcpc_dev, typec_role);
 }
 
-/* @postpone: whether to postpone Type-C role change until unattached */
-int tcpm_typec_change_role_postpone(
-	struct tcpc_device *tcpc, uint8_t typec_role, bool postpone)
+int tcpm_typec_error_recovery(struct tcpc_device *tcpc_dev)
 {
-	int ret = 0;
-
-	tcpci_lock_typec(tcpc);
-	ret = tcpc_typec_change_role(tcpc, typec_role, postpone);
-	tcpci_unlock_typec(tcpc);
-
-	return ret;
-}
-
-int tcpm_typec_error_recovery(struct tcpc_device *tcpc)
-{
-	int ret = 0;
-
-	tcpci_lock_typec(tcpc);
-	ret = tcpc_typec_error_recovery(tcpc);
-	tcpci_unlock_typec(tcpc);
-
-	return ret;
+	return tcpc_typec_error_recovery(tcpc_dev);
 }
 
-int tcpm_typec_disable_function(struct tcpc_device *tcpc, bool disable)
+int tcpm_typec_disable_function(
+	struct tcpc_device *tcpc_dev, bool disable)
 {
-	int ret = 0;
-
-	tcpci_lock_typec(tcpc);
-	ret = (disable ? tcpc_typec_disable : tcpc_typec_enable)(tcpc);
-	tcpci_unlock_typec(tcpc);
-
-	return ret;
+	if (disable)
+		return tcpc_typec_disable(tcpc_dev);
+	else
+		return tcpc_typec_enable(tcpc_dev);
 }
 
 #ifdef CONFIG_USB_POWER_DELIVERY
 
-bool tcpm_inquire_pd_connected(struct tcpc_device *tcpc)
+bool tcpm_inquire_pd_connected(
+	struct tcpc_device *tcpc_dev)
 {
-	struct pd_port *pd_port = &tcpc->pd_port;
+	struct pd_port *pd_port = &tcpc_dev->pd_port;
 
 	return pd_port->pe_data.pd_connected;
 }
 
-bool tcpm_inquire_pd_prev_connected(struct tcpc_device *tcpc)
+bool tcpm_inquire_pd_prev_connected(
+	struct tcpc_device *tcpc_dev)
 {
-	struct pd_port *pd_port = &tcpc->pd_port;
+	struct pd_port *pd_port = &tcpc_dev->pd_port;
 
 	return pd_port->pe_data.pd_prev_connected;
 }
 
-uint8_t tcpm_inquire_pd_data_role(struct tcpc_device *tcpc)
+uint8_t tcpm_inquire_pd_data_role(
+	struct tcpc_device *tcpc_dev)
 {
-	struct pd_port *pd_port = &tcpc->pd_port;
+	struct pd_port *pd_port = &tcpc_dev->pd_port;
 
 	return pd_port->data_role;
 }
 
-uint8_t tcpm_inquire_pd_power_role(struct tcpc_device *tcpc)
+uint8_t tcpm_inquire_pd_power_role(
+	struct tcpc_device *tcpc_dev)
 {
-	struct pd_port *pd_port = &tcpc->pd_port;
+	struct pd_port *pd_port = &tcpc_dev->pd_port;
 
 	return pd_port->power_role;
 }
 
-uint8_t tcpm_inquire_pd_vconn_role(struct tcpc_device *tcpc)
+uint8_t tcpm_inquire_pd_vconn_role(
+	struct tcpc_device *tcpc_dev)
 {
-	struct pd_port *pd_port = &tcpc->pd_port;
+	struct pd_port *pd_port = &tcpc_dev->pd_port;
 
 	return pd_port->vconn_role;
 }
 
-uint8_t tcpm_inquire_pd_pe_ready(struct tcpc_device *tcpc)
+uint8_t tcpm_inquire_pd_pe_ready(
+	struct tcpc_device *tcpc_dev)
 {
-	struct pd_port *pd_port = &tcpc->pd_port;
+	struct pd_port *pd_port = &tcpc_dev->pd_port;
 
 	return pd_port->pe_data.pe_ready;
 }
 
-uint8_t tcpm_inquire_cable_current(struct tcpc_device *tcpc)
+uint8_t tcpm_inquire_cable_current(
+	struct tcpc_device *tcpc_dev)
 {
-	struct pd_port *pd_port = &tcpc->pd_port;
+	struct pd_port *pd_port = &tcpc_dev->pd_port;
 
 	if (pd_port->pe_data.power_cable_present)
 		return pd_get_cable_curr_lvl(pd_port)+1;
@@ -354,23 +349,23 @@ uint8_t tcpm_inquire_cable_current(struct tcpc_device *tcpc)
 	return PD_CABLE_CURR_UNKNOWN;
 }
 
-uint32_t tcpm_inquire_dpm_flags(struct tcpc_device *tcpc)
+uint32_t tcpm_inquire_dpm_flags(struct tcpc_device *tcpc_dev)
 {
-	struct pd_port *pd_port = &tcpc->pd_port;
+	struct pd_port *pd_port = &tcpc_dev->pd_port;
 
 	return pd_port->pe_data.dpm_flags;
 }
 
-uint32_t tcpm_inquire_dpm_caps(struct tcpc_device *tcpc)
+uint32_t tcpm_inquire_dpm_caps(struct tcpc_device *tcpc_dev)
 {
-	struct pd_port *pd_port = &tcpc->pd_port;
+	struct pd_port *pd_port = &tcpc_dev->pd_port;
 
 	return pd_port->dpm_caps;
 }
 
-void tcpm_set_dpm_caps(struct tcpc_device *tcpc, uint32_t caps)
+void tcpm_set_dpm_caps(struct tcpc_device *tcpc_dev, uint32_t caps)
 {
-	struct pd_port *pd_port = &tcpc->pd_port;
+	struct pd_port *pd_port = &tcpc_dev->pd_port;
 
 	mutex_lock(&pd_port->pd_lock);
 	pd_port->dpm_caps = caps;
@@ -379,7 +374,8 @@ void tcpm_set_dpm_caps(struct tcpc_device *tcpc, uint32_t caps)
 
 /* Inquire TCPC to get PD Information */
 
-int tcpm_inquire_pd_contract(struct tcpc_device *tcpc, int *mv, int *ma)
+int tcpm_inquire_pd_contract(
+	struct tcpc_device *tcpc, int *mv, int *ma)
 {
 	int ret;
 	struct pd_port *pd_port = &tcpc->pd_port;
@@ -403,7 +399,8 @@ int tcpm_inquire_pd_contract(struct tcpc_device *tcpc, int *mv, int *ma)
 
 }
 
-int tcpm_inquire_cable_inform(struct tcpc_device *tcpc, uint32_t *vdos)
+int tcpm_inquire_cable_inform(
+	struct tcpc_device *tcpc, uint32_t *vdos)
 {
 	int ret;
 	struct pd_port *pd_port = &tcpc->pd_port;
@@ -426,7 +423,8 @@ int tcpm_inquire_cable_inform(struct tcpc_device *tcpc, uint32_t *vdos)
 	return ret;
 }
 
-int tcpm_inquire_pd_partner_inform(struct tcpc_device *tcpc, uint32_t *vdos)
+int tcpm_inquire_pd_partner_inform(
+	struct tcpc_device *tcpc, uint32_t *vdos)
 {
 #ifdef CONFIG_USB_PD_KEEP_PARTNER_ID
 	int ret;
@@ -488,7 +486,7 @@ int tcpm_inquire_pd_partner_modes(
 {
 #ifdef CONFIG_USB_PD_ALT_MODE
 	int ret = TCPM_SUCCESS;
-	struct svdm_svid_data *svid_data = NULL;
+	struct svdm_svid_data *svid_data;
 	struct pd_port *pd_port = &tcpc->pd_port;
 
 	mutex_lock(&pd_port->pd_lock);
@@ -565,7 +563,8 @@ int tcpm_inquire_pd_sink_cap(
 	return ret;
 }
 
-bool tcpm_extract_power_cap_val(uint32_t pdo, struct tcpm_power_cap_val *cap)
+bool tcpm_extract_power_cap_val(
+	uint32_t pdo, struct tcpm_power_cap_val *cap)
 {
 	struct dpm_pdo_info_t info;
 
@@ -605,35 +604,30 @@ extern bool tcpm_extract_power_cap_list(
 	return true;
 }
 
-int tcpm_get_remote_power_cap(struct tcpc_device *tcpc,
+int tcpm_get_remote_power_cap(struct tcpc_device *tcpc_dev,
 		struct tcpm_remote_power_cap *remote_cap)
 {
-	struct pd_port *pd_port = &tcpc->pd_port;
 	struct tcpm_power_cap_val cap;
 	int i;
 
-	mutex_lock(&pd_port->pd_lock);
-	remote_cap->selected_cap_idx = pd_port->pe_data.remote_selected_cap;
-	remote_cap->nr = pd_port->pe_data.remote_src_cap.nr;
+	remote_cap->selected_cap_idx =
+		tcpc_dev->pd_port.pe_data.remote_selected_cap;
+	remote_cap->nr = tcpc_dev->pd_port.pe_data.remote_src_cap.nr;
 	for (i = 0; i < remote_cap->nr; i++) {
 		tcpm_extract_power_cap_val(
-			pd_port->pe_data.remote_src_cap.pdos[i], &cap);
+			tcpc_dev->pd_port.pe_data.remote_src_cap.pdos[i], &cap);
 		remote_cap->max_mv[i] = cap.max_mv;
 		remote_cap->min_mv[i] = cap.min_mv;
-		if (cap.type == DPM_PDO_TYPE_BAT)
-			remote_cap->ma[i] = cap.uw / cap.min_mv;
-		else
-			remote_cap->ma[i] = cap.ma;
+		remote_cap->ma[i] = cap.ma;
 		remote_cap->type[i] = cap.type;
 	}
-	mutex_unlock(&pd_port->pd_lock);
-
 	return TCPM_SUCCESS;
 }
 
-int tcpm_set_remote_power_cap(struct tcpc_device *tcpc, int mv, int ma)
+int tcpm_set_remote_power_cap(struct tcpc_device *tcpc_dev,
+				int mv, int ma)
 {
-	return tcpm_dpm_pd_request(tcpc, mv, ma, NULL);
+	return tcpm_dpm_pd_request(tcpc_dev, mv, ma, NULL);
 }
 
 static inline int __tcpm_inquire_select_source_cap(
@@ -646,7 +640,7 @@ static inline int __tcpm_inquire_select_source_cap(
 		return TCPM_ERROR_POWER_ROLE;
 
 	sel = RDO_POS(pd_port->last_rdo) - 1;
-	if (sel >= pe_data->remote_src_cap.nr)
+	if (sel > pe_data->remote_src_cap.nr)
 		return TCPM_ERROR_NO_SOURCE_CAP;
 
 	if (!tcpm_extract_power_cap_val(
@@ -801,6 +795,7 @@ int tcpm_dpm_pd_request(struct tcpc_device *tcpc,
 {
 	struct tcp_dpm_event tcp_event = {
 		.event_id = TCP_DPM_EVT_REQUEST,
+
 		.tcp_dpm_data.pd_req.mv = mv,
 		.tcp_dpm_data.pd_req.ma = ma,
 	};
@@ -816,13 +811,16 @@ int tcpm_dpm_pd_request_ex(struct tcpc_device *tcpc,
 	struct tcp_dpm_event tcp_event = {
 		.event_id = TCP_DPM_EVT_REQUEST_EX,
 		.tcp_dpm_data.pd_req_ex.pos = pos,
-		.tcp_dpm_data.pd_req_ex.max = max,
-		.tcp_dpm_data.pd_req_ex.oper = oper,
+
+
 	};
 
 	if (oper > max)
 		return TCPM_ERROR_PARAMETER;
 
+	tcp_event.tcp_dpm_data.pd_req_ex.max = max;
+	tcp_event.tcp_dpm_data.pd_req_ex.oper = oper;
+
 	return tcpm_put_tcp_dpm_event_cbk1(
 		tcpc, &tcp_event, cb_data, TCPM_BK_REQUEST_TOUT);
 }
@@ -896,7 +894,7 @@ int tcpm_dpm_pd_get_pps_status_raw(struct tcpc_device *tcpc,
 
 	return tcpm_put_tcp_dpm_event_cbk2(
 		tcpc, &tcp_event, cb_data, TCPM_BK_PD_CMD_TOUT,
-		(uint8_t *) pps_status, PD_PPSSDB_SIZE);
+		(uint8_t *)pps_status, PD_PPSSDB_SIZE);
 }
 
 int tcpm_dpm_pd_get_pps_status(struct tcpc_device *tcpc,
@@ -1138,7 +1136,8 @@ int tcpm_dpm_vdm_attention(struct tcpc_device *tcpc,
 
 #ifdef CONFIG_USB_PD_ALT_MODE
 
-int tcpm_inquire_dp_ufp_u_state(struct tcpc_device *tcpc, uint8_t *state)
+int tcpm_inquire_dp_ufp_u_state(
+	struct tcpc_device *tcpc, uint8_t *state)
 {
 	int ret;
 	struct pd_port *pd_port = &tcpc->pd_port;
@@ -1173,7 +1172,8 @@ int tcpm_dpm_dp_attention(struct tcpc_device *tcpc,
 
 #ifdef CONFIG_USB_PD_ALT_MODE_DFP
 
-int tcpm_inquire_dp_dfp_u_state(struct tcpc_device *tcpc, uint8_t *state)
+int tcpm_inquire_dp_dfp_u_state(
+	struct tcpc_device *tcpc, uint8_t *state)
 {
 	int ret;
 	struct pd_port *pd_port = &tcpc->pd_port;
@@ -1231,7 +1231,6 @@ int tcpm_dpm_send_custom_vdm(
 	const struct tcp_dpm_event_cb_data *cb_data)
 {
 	int ret;
-	struct pd_port *pd_port = &tcpc->pd_port;
 	struct tcp_dpm_event tcp_event = {
 		.event_id = TCP_DPM_EVT_UVDM,
 	};
@@ -1249,12 +1248,11 @@ int tcpm_dpm_send_custom_vdm(
 #ifdef CONFIG_USB_PD_TCPM_CB_2ND
 	if ((ret == TCP_DPM_RET_SUCCESS)
 		&& (cb_data == NULL) && vdm_data->wait_resp) {
-		mutex_lock(&pd_port->pd_lock);
+
 		vdm_data->cnt = tcpc->pd_port.uvdm_cnt;
 		memcpy(vdm_data->vdos,
 			tcpc->pd_port.uvdm_data,
 			sizeof(uint32_t) * vdm_data->cnt);
-		mutex_unlock(&pd_port->pd_lock);
 	}
 #endif	/* CONFIG_USB_PD_TCPM_CB_2ND */
 
@@ -1299,8 +1297,7 @@ int tcpm_put_tcp_dpm_event(
 		return ret;
 
 	if (imme) {
-		ret = pd_put_tcp_pd_event(pd_port, event->event_id,
-					  PD_TCP_FROM_TCPM);
+		ret = pd_put_tcp_pd_event(pd_port, event->event_id);
 
 #ifdef CONFIG_USB_PD_TCPM_CB_2ND
 		if (ret)
@@ -1315,13 +1312,14 @@ int tcpm_put_tcp_dpm_event(
 	return TCPM_SUCCESS;
 }
 
-int tcpm_notify_vbus_stable(struct tcpc_device *tcpc)
+int tcpm_notify_vbus_stable(
+	struct tcpc_device *tcpc_dev)
 {
 #if CONFIG_USB_PD_VBUS_STABLE_TOUT
-	tcpc_disable_timer(tcpc, PD_TIMER_VBUS_STABLE);
+	tcpc_disable_timer(tcpc_dev, PD_TIMER_VBUS_STABLE);
 #endif
 
-	pd_put_vbus_stable_event(tcpc);
+	pd_put_vbus_stable_event(tcpc_dev);
 	return TCPM_SUCCESS;
 }
 
@@ -1371,16 +1369,14 @@ int tcpm_set_pd_charging_policy(struct tcpc_device *tcpc,
 
 	struct pd_port *pd_port = &tcpc->pd_port;
 
+	if (pd_port->dpm_charging_policy == policy)
+		return TCPM_SUCCESS;
+
 	/* PPS should call another function ... */
 	if ((policy & DPM_CHARGING_POLICY_MASK) >= DPM_CHARGING_POLICY_PPS)
 		return TCPM_ERROR_PARAMETER;
 
 	mutex_lock(&pd_port->pd_lock);
-	if (pd_port->dpm_charging_policy == policy) {
-		mutex_unlock(&pd_port->pd_lock);
-		return TCPM_SUCCESS;
-	}
-
 	pd_port->dpm_charging_policy = policy;
 	mutex_unlock(&pd_port->pd_lock);
 
@@ -1423,9 +1419,7 @@ int tcpm_dpm_set_vconn_supply_mode(struct tcpc_device *tcpc, uint8_t mode)
 
 	mutex_lock(&pd_port->pd_lock);
 	tcpc->tcpc_vconn_supply = mode;
-	dpm_reaction_set(pd_port,
-		DPM_REACTION_DYNAMIC_VCONN |
-		DPM_REACTION_VCONN_STABLE_DELAY);
+	dpm_reaction_set(pd_port, DPM_REACTION_DYNAMIC_VCONN);
 	mutex_unlock(&pd_port->pd_lock);
 
 	return tcpm_put_tcp_dummy_event(tcpc);
@@ -1445,17 +1439,17 @@ int tcpm_set_apdo_charging_policy(struct tcpc_device *tcpc,
 
 	struct pd_port *pd_port = &tcpc->pd_port;
 
+	if (pd_port->dpm_charging_policy == policy) {
+		TCPC_INFO("BUG!!! FIX IT!!!\r\n");
+		return tcpm_dpm_pd_request(tcpc, mv, ma, NULL);
+		/* return TCPM_ERROR_REPEAT_POLICY; */
+	}
+
 	/* Not PPS should call another function ... */
 	if ((policy & DPM_CHARGING_POLICY_MASK) < DPM_CHARGING_POLICY_PPS)
 		return TCPM_ERROR_PARAMETER;
 
 	mutex_lock(&pd_port->pd_lock);
-	if (pd_port->dpm_charging_policy == policy) {
-		mutex_unlock(&pd_port->pd_lock);
-		TCPC_INFO("BUG!!! FIX IT!!!\n");
-		return tcpm_dpm_pd_request(tcpc, mv, ma, NULL);
-		/* return TCPM_ERROR_REPEAT_POLICY; */
-	}
 
 	if (pd_port->pd_connect_state != PD_CONNECT_PE_READY_SNK_APDO) {
 		mutex_unlock(&pd_port->pd_lock);
@@ -1521,7 +1515,7 @@ static void tcpm_alert_bat_changed(
 #ifdef CONFIG_USB_PD_REV30_ALERT_LOCAL
 	uint8_t fixed = 0, swap = 0;
 
-	if (ref >= PD_BAT_REF_SWAP0)
+	if (ref > PD_BAT_REF_SWAP0)
 		swap = 1 << (ref - PD_BAT_REF_SWAP0);
 	else
 		fixed = 1 << (ref - PD_BAT_REF_FIXED0);
@@ -1602,26 +1596,32 @@ int tcpm_update_bat_status_wh_no_mutex(struct tcpc_device *tcpc,
 }
 
 int tcpm_update_bat_status_soc(struct tcpc_device *tcpc,
-	enum pd_battery_reference ref, uint8_t status, uint16_t soc)
+	uint8_t status, uint16_t soc)
 {
 	int ret;
 
 	mutex_lock(&tcpc->pd_port.pd_lock);
-	ret = tcpm_update_bat_status_soc_no_mutex(tcpc, ref, status, soc);
+	ret = tcpm_update_bat_status_soc_no_mutex(tcpc, status, soc);
 	mutex_unlock(&tcpc->pd_port.pd_lock);
 
-	if (ret == TCPM_ALERT) {
-		ret = TCPM_SUCCESS;
-		tcpm_put_tcp_dummy_event(tcpc);
-	}
-
 	return ret;
 }
 
 int tcpm_update_bat_status_soc_no_mutex(struct tcpc_device *tcpc,
-	enum pd_battery_reference ref, uint8_t status, uint16_t soc)
+	uint8_t status, uint16_t soc)
 {
-	return tcpm_update_bsdo(&tcpc->pd_port, ref, soc, 0, status);
+	int ret;
+	uint8_t i;
+	enum pd_battery_reference ref;
+
+	for (i = 0; i < pd_get_fix_battery_nr(&tcpc->pd_port); i++) {
+		ref = PD_BAT_REF_FIXED0 + i;
+		ret = tcpm_update_bsdo(&tcpc->pd_port, ref, soc, 0, status);
+		if (ret != TCPM_SUCCESS)
+			return ret;
+	}
+
+	return TCPM_SUCCESS;
 }
 
 int tcpm_update_bat_last_full(struct tcpc_device *tcpc,
@@ -1757,7 +1757,8 @@ int tcpm_update_pd_status_bat_input(
 	return TCPM_SUCCESS;
 }
 
-int tcpm_update_pd_status_event(struct tcpc_device *tcpc, uint8_t evt)
+int tcpm_update_pd_status_event(
+	struct tcpc_device *tcpc, uint8_t evt)
 {
 	uint8_t ado_type = 0;
 	struct pd_port *pd_port = &tcpc->pd_port;
@@ -1788,7 +1789,6 @@ int tcpm_update_pd_status_event(struct tcpc_device *tcpc, uint8_t evt)
 
 #ifdef CONFIG_USB_PD_BLOCK_TCPM
 
-#if TCPM_DBG_ENABLE
 static const char * const bk_event_ret_name[] = {
 	"OK",
 	"Unknown",	/* or not support by TCPM */
@@ -1809,8 +1809,6 @@ static const char * const bk_event_ret_name[] = {
 	"Recovery",
 	"BIST",
 	"PEBusy",
-	"Discard",
-	"Unexpected",
 
 	"Wait",
 	"Reject",
@@ -1821,7 +1819,6 @@ static const char * const bk_event_ret_name[] = {
 	"BKTOUT",
 	"NoResponse",
 };
-#endif /* TCPM_DBG_ENABLE */
 
 #ifdef CONFIG_USB_PD_TCPM_CB_2ND
 static inline void tcpm_dpm_bk_copy_data(struct pd_port *pd_port)
@@ -1844,7 +1841,7 @@ int tcpm_dpm_bk_event_cb(
 	struct pd_port *pd_port = &tcpc->pd_port;
 
 	if (pd_port->tcpm_bk_event_id != event->event_id) {
-		TCPM_DBG("bk_event_cb_dummy: expect:%d real:%d\n",
+		TCPM_DBG("bk_event_cb_dummy: expect:%d real:%d\r\n",
 			pd_port->tcpm_bk_event_id, event->event_id);
 		return 0;
 	}
@@ -1857,7 +1854,7 @@ int tcpm_dpm_bk_event_cb(
 		tcpm_dpm_bk_copy_data(pd_port);
 #endif	/* CONFIG_USB_PD_TCPM_CB_2ND */
 
-	wake_up(&pd_port->tcpm_bk_wait_que);
+	wake_up_interruptible(&pd_port->tcpm_bk_wait_que);
 	return 0;
 }
 
@@ -1866,8 +1863,9 @@ static inline int __tcpm_dpm_wait_bk_event(
 {
 	int ret = TCP_DPM_RET_BK_TIMEOUT;
 
-	wait_event_timeout(pd_port->tcpm_bk_wait_que, pd_port->tcpm_bk_done,
-			   msecs_to_jiffies(tout_ms));
+	wait_event_interruptible_timeout(pd_port->tcpm_bk_wait_que,
+				pd_port->tcpm_bk_done,
+				msecs_to_jiffies(tout_ms));
 
 	if (pd_port->tcpm_bk_done)
 		return pd_port->tcpm_bk_ret;
@@ -1887,13 +1885,9 @@ static inline int __tcpm_dpm_wait_bk_event(
 int tcpm_dpm_wait_bk_event(struct pd_port *pd_port, uint32_t tout_ms)
 {
 	int ret = __tcpm_dpm_wait_bk_event(pd_port, tout_ms);
-#if TCPM_DBG_ENABLE
-	struct tcpc_device __maybe_unused *tcpc = pd_port->tcpc;
 
-	if (ret < TCP_DPM_RET_NR && ret >= 0
-		&& ret < ARRAY_SIZE(bk_event_ret_name))
-		TCPM_DBG("bk_event_cb -> %s\n", bk_event_ret_name[ret]);
-#endif /* TCPM_DBG_ENABLE */
+	if (ret < TCP_DPM_RET_NR)
+		TCPM_DBG("bk_event_cb -> %s\r\n", bk_event_ret_name[ret]);
 
 	return ret;
 }
@@ -1953,14 +1947,11 @@ static int tcpm_put_tcp_dpm_event_bk(
 	while (1) {
 		ret = __tcpm_put_tcp_dpm_event_bk(
 			tcpc, event, tout_ms, data, size);
-		if (retry > 0 &&
-		    (ret == TCP_DPM_RET_TIMEOUT ||
-		    ret == TCP_DPM_RET_DROP_DISCARD ||
-		    ret == TCP_DPM_RET_DROP_UNEXPECTED)) {
-			retry--;
-			continue;
-		}
-		break;
+
+		if ((ret != TCP_DPM_RET_TIMEOUT) || (retry == 0))
+			break;
+
+		retry--;
 	}
 
 	mutex_unlock(&pd_port->tcpm_bk_lock);
diff --git a/drivers/misc/mediatek/typec/Kconfig b/Kconfig
index ab43a74..5f7cc22 100644
--- a/drivers/misc/mediatek/typec/Kconfig
+++ b/drivers/misc/mediatek/typec/Kconfig
@@ -4,6 +4,7 @@
 
 config MTK_USB_TYPEC
 	bool "Mediatek USB TYPE-C Driver"
+	default n
 	---help---
 	  Enables to support usb-c. So the usb device and host driver register
 	  the callback func to the usb-c driver. When the usb-c driver detect
@@ -11,17 +12,9 @@ config MTK_USB_TYPEC
 	  by callback func.
 	  If unsure, say N.
 
-config MTK_USB_TYPEC_DP_MUX
-	bool "Mediatek USB TYPE-C USB DP Mux"
-	---help---
-	  Enables to support USB DP mux in usb-c.
-	  To support TYPE-C USB DP must have a MUX to switch
-	  SSRX1/SSTX1/SSRX2/SSTX2 pins.
-	  Say Y to enable TYPEC DP Mux
-	  If unsure, say N.
-
 config MTK_USB_TYPEC_U3_MUX
 	bool "Mediatek USB TYPE-C USB 3.0 Mux"
+	default n
 	---help---
 	  Enables to support USB3.0 mux in usb-c.
 	  To support TYPE-C USB3.0 must have a MUX to switch
@@ -29,26 +22,30 @@ config MTK_USB_TYPEC_U3_MUX
 	  Say Y to enable TYPEC USB3.0 Mux
 	  If unsure, say N.
 
-config MTK_USB_TYPEC_U3_MUX_V2
-	bool "Mediatek USB TYPE-C USB 3.0 Mux V2"
-	select MTK_USB_TYPEC_U3_MUX
-	help
-	  Enable to support Mediatek Type-c mux driver v2 version.
-	  The v2 version depends on v1 version configration.
-	  It is more easily for customer to manager and add mux
-	  module driver.
-
 config TCPC_MT6360
 	bool "MediaTek MT6360 TypeC port Controller Driver"
 	depends on TCPC_CLASS
+	default n
+	select TCPC_ALERT_V20
 	help
 	  Say Y to enable MediaTek MT6370
 	  TypeC port Controller
 	  Also Support Power Delivery
 	  Say N to disable
 
+config TCPC_ALERT_V20
+	bool "TCPCI Alert v2.0"
+	depends on TCPC_CLASS
+	default n
+	help
+	  Say Y to use tcpci_alert_v20
+	  Vendor defined interrupts
+	  should be handled by
+	  tcpc driver itself
+
 config MTK_TYPEC_WATER_DETECT
 	bool "Water detection function for type-c connector"
+	default n
 	depends on TCPC_CLASS
 	help
 	  Say Yes to enable water detection on type-c connector.
@@ -58,10 +55,11 @@ config MTK_TYPEC_WATER_DETECT
 
 config MTK_TYPEC_WATER_DETECT_BY_PCB
 	bool "Let PCB decides enabling water detection or not"
+	default n
 	depends on MTK_TYPEC_WATER_DETECT
 	help
-	  Query GPIO on PCB to judge whether type-c water detection
-	  need to be enabled.
+	  Query GPIO on PCB to judge whether type-C water detection
+	  need to be enabled. (0: EVB; 1: Phone)
 	  Say Yes to let PCB decides enabling water detection or not.
 	  If unsure, say N.
 
diff --git a/drivers/misc/mediatek/typec/u3_switch/Makefile b/drivers/misc/mediatek/typec/u3_switch/Makefile
index b68db7f..f5bf5b5 100644
--- a/drivers/misc/mediatek/typec/u3_switch/Makefile
+++ b/drivers/misc/mediatek/typec/u3_switch/Makefile
@@ -3,12 +3,4 @@ ccflags-y += -I$(srctree)/drivers/misc/mediatek/base/power/$(MTK_PLATFORM)
 ccflags-y += -I$(srctree)/drivers/misc/mediatek/base/power/include
 ccflags-y += -I$(srctree)/drivers/misc/mediatek/include/mt-plat
 ccflags-y += -I$(srctree)/drivers/misc/mediatek/typec/tcpc/inc
-ifeq ($(CONFIG_MTK_USB_TYPEC_U3_MUX_V2), y)
-obj-y += mux.o
-obj-y += mux_switch.o
-obj-y += fusb340.o
-obj-y += ps5169.o
-obj-y += ptn36241g.o
-else
 obj-y += usb_switch.o
-endif
diff --git a/drivers/misc/mediatek/typec/u3_switch/fusb340.c b/drivers/misc/mediatek/typec/u3_switch/fusb340.c
deleted file mode 100644
index 00bf7e6..0000000
--- a/drivers/misc/mediatek/typec/u3_switch/fusb340.c
+++ /dev/null
@@ -1,174 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (c) 2020 MediaTek Inc.
- */
-#include <linux/gpio.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/of_platform.h>
-#include <linux/platform_device.h>
-
-#include "mux.h"
-#include "usb_switch.h"
-
-struct fusb340 {
-	struct device *dev;
-	struct typec_switch *sw;
-	struct pinctrl *pinctrl;
-	struct pinctrl_state *sel_up;
-	struct pinctrl_state *sel_down;
-	struct pinctrl_state *enable;
-	struct pinctrl_state *disable;
-	struct mutex lock;
-};
-
-static int fusb340_switch_set(struct typec_switch *sw,
-			      enum typec_orientation orientation)
-{
-	struct fusb340 *fusb = typec_switch_get_drvdata(sw);
-
-	dev_info(fusb->dev, "%s %d\n", __func__, orientation);
-
-	switch (orientation) {
-	case TYPEC_ORIENTATION_NONE:
-		/* switch off */
-		if (fusb->disable)
-			pinctrl_select_state(fusb->pinctrl, fusb->disable);
-		break;
-	case TYPEC_ORIENTATION_NORMAL:
-		/* switch cc1 side */
-		if (fusb->enable)
-			pinctrl_select_state(fusb->pinctrl, fusb->enable);
-		if (fusb->sel_up)
-			pinctrl_select_state(fusb->pinctrl, fusb->sel_up);
-		break;
-	case TYPEC_ORIENTATION_REVERSE:
-		/* switch cc2 side */
-		if (fusb->enable)
-			pinctrl_select_state(fusb->pinctrl, fusb->enable);
-		if (fusb->sel_down)
-			pinctrl_select_state(fusb->pinctrl, fusb->sel_down);
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static int fusb340_pinctrl_init(struct fusb340 *fusb)
-{
-	struct device *dev = fusb->dev;
-	int ret = 0;
-
-	fusb->pinctrl = devm_pinctrl_get(dev);
-	if (IS_ERR(fusb->pinctrl)) {
-		ret = PTR_ERR(fusb->pinctrl);
-		dev_info(dev, "failed to get pinctrl, ret=%d\n", ret);
-		return ret;
-	}
-
-	fusb->sel_up =
-		pinctrl_lookup_state(fusb->pinctrl, "sel_up");
-
-	if (IS_ERR(fusb->sel_up)) {
-		dev_info(dev, "Can *NOT* find sel_up\n");
-		fusb->sel_up = NULL;
-	} else
-		dev_info(dev, "Find sel_up\n");
-
-	fusb->sel_down =
-		pinctrl_lookup_state(fusb->pinctrl, "sel_down");
-
-	if (IS_ERR(fusb->sel_down)) {
-		dev_info(dev, "Can *NOT* find sel_down\n");
-		fusb->sel_down = NULL;
-	} else
-		dev_info(dev, "Find sel_down\n");
-
-	fusb->enable =
-		pinctrl_lookup_state(fusb->pinctrl, "enable");
-
-	if (IS_ERR(fusb->enable)) {
-		dev_info(dev, "Can *NOT* find enable\n");
-		fusb->enable = NULL;
-	} else
-		dev_info(dev, "Find enable\n");
-
-	fusb->disable =
-		pinctrl_lookup_state(fusb->pinctrl, "disable");
-
-	if (IS_ERR(fusb->disable)) {
-		dev_info(dev, "Can *NOT* find disable\n");
-		fusb->disable = NULL;
-	} else
-		dev_info(dev, "Find disable\n");
-
-	return ret;
-}
-
-static int fusb340_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct fusb340 *fusb;
-	struct typec_switch_desc sw_desc;
-	int ret = 0;
-
-	fusb = devm_kzalloc(&pdev->dev, sizeof(*fusb), GFP_KERNEL);
-	if (!fusb)
-		return -ENOMEM;
-
-	fusb->dev = dev;
-
-	sw_desc.drvdata = fusb;
-	sw_desc.fwnode = dev->fwnode;
-	sw_desc.set = fusb340_switch_set;
-
-	fusb->sw = mtk_typec_switch_register(dev, &sw_desc);
-	if (IS_ERR(fusb->sw)) {
-		dev_info(dev, "error registering typec switch: %ld\n",
-			PTR_ERR(fusb->sw));
-		return PTR_ERR(fusb->sw);
-	}
-
-	platform_set_drvdata(pdev, fusb);
-
-	ret = fusb340_pinctrl_init(fusb);
-	if (ret < 0)
-		mtk_typec_switch_unregister(fusb->sw);
-
-	/* switch off after init done */
-	fusb340_switch_set(fusb->sw, TYPEC_ORIENTATION_NONE);
-
-	dev_info(dev, "%s done\n", __func__);
-	return ret;
-}
-
-static int fusb340_remove(struct platform_device *pdev)
-{
-	struct fusb340 *fusb = platform_get_drvdata(pdev);
-
-	mtk_typec_switch_unregister(fusb->sw);
-	return 0;
-}
-
-static const struct of_device_id fusb340_ids[] = {
-	{.compatible = "mediatek,fusb340",},
-	{},
-};
-
-static struct platform_driver fusb340_driver = {
-	.driver = {
-		.name = "fusb340",
-		.of_match_table = fusb340_ids,
-	},
-	.probe = fusb340_probe,
-	.remove = fusb340_remove,
-};
-
-module_platform_driver(fusb340_driver);
-
-MODULE_DESCRIPTION("FUSB340 Type-C switch driver");
-MODULE_LICENSE("GPL v2");
-
diff --git a/drivers/misc/mediatek/typec/u3_switch/mux.c b/drivers/misc/mediatek/typec/u3_switch/mux.c
deleted file mode 100644
index a75d74c..0000000
--- a/drivers/misc/mediatek/typec/u3_switch/mux.c
+++ /dev/null
@@ -1,178 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/**
- * USB Type-C Multiplexer/DeMultiplexer Switch support
- *
- * Copyright (C) 2018 Intel Corporation
- * Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
- *         Hans de Goede <hdegoede@redhat.com>
- */
-/*
- * Copyright (c) 2020 MediaTek Inc.
- */
-
-#include <linux/device.h>
-#include <linux/list.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/property.h>
-#include <linux/slab.h>
-
-#include "mux.h"
-
-static void typec_switch_release(struct device *dev)
-{
-	kfree(to_typec_switch(dev));
-}
-
-static const struct device_type typec_switch_dev_type = {
-	.name = "orientation_switch",
-	.release = typec_switch_release,
-};
-
-/**
- * typec_switch_register - Register USB Type-C orientation switch
- * @parent: Parent device
- * @desc: Orientation switch description
- *
- * This function registers a switch that can be used for routing the correct
- * data pairs depending on the cable plug orientation from the USB Type-C
- * connector to the USB controllers. USB Type-C plugs can be inserted
- * right-side-up or upside-down.
- */
-struct typec_switch *
-typec_switch_register(struct device *parent,
-		      const struct typec_switch_desc *desc)
-{
-	struct typec_switch *sw;
-	int ret;
-
-	if (!desc || !desc->set)
-		return ERR_PTR(-EINVAL);
-
-	sw = kzalloc(sizeof(*sw), GFP_KERNEL);
-	if (!sw)
-		return ERR_PTR(-ENOMEM);
-
-	sw->set = desc->set;
-
-	device_initialize(&sw->dev);
-	sw->dev.parent = parent;
-	sw->dev.fwnode = desc->fwnode;
-	sw->dev.type = &typec_switch_dev_type;
-	sw->dev.driver_data = desc->drvdata;
-	dev_set_name(&sw->dev, "%s-switch", dev_name(parent));
-
-	ret = device_add(&sw->dev);
-	if (ret) {
-		dev_info(parent, "failed to register switch (%d)\n", ret);
-		put_device(&sw->dev);
-		return ERR_PTR(ret);
-	}
-
-	return sw;
-}
-EXPORT_SYMBOL_GPL(typec_switch_register);
-
-/**
- * typec_switch_unregister - Unregister USB Type-C orientation switch
- * @sw: USB Type-C orientation switch
- *
- * Unregister switch that was registered with typec_switch_register().
- */
-void typec_switch_unregister(struct typec_switch *sw)
-{
-	if (!IS_ERR_OR_NULL(sw))
-		device_unregister(&sw->dev);
-}
-EXPORT_SYMBOL_GPL(typec_switch_unregister);
-
-void typec_switch_set_drvdata(struct typec_switch *sw, void *data)
-{
-	dev_set_drvdata(&sw->dev, data);
-}
-EXPORT_SYMBOL_GPL(typec_switch_set_drvdata);
-
-void *typec_switch_get_drvdata(struct typec_switch *sw)
-{
-	return dev_get_drvdata(&sw->dev);
-}
-EXPORT_SYMBOL_GPL(typec_switch_get_drvdata);
-
-static void typec_mux_release(struct device *dev)
-{
-	kfree(to_typec_mux(dev));
-}
-
-static const struct device_type typec_mux_dev_type = {
-	.name = "mode_switch",
-	.release = typec_mux_release,
-};
-
-/**
- * typec_mux_register - Register Multiplexer routing USB Type-C pins
- * @parent: Parent device
- * @desc: Multiplexer description
- *
- * USB Type-C connectors can be used for alternate modes of operation besides
- * USB when Accessory/Alternate Modes are supported. With some of those modes,
- * the pins on the connector need to be reconfigured. This function registers
- * multiplexer switches routing the pins on the connector.
- */
-struct typec_mux *
-typec_mux_register(struct device *parent, const struct typec_mux_desc *desc)
-{
-	struct typec_mux *mux;
-	int ret;
-
-	if (!desc || !desc->set)
-		return ERR_PTR(-EINVAL);
-
-	mux = kzalloc(sizeof(*mux), GFP_KERNEL);
-	if (!mux)
-		return ERR_PTR(-ENOMEM);
-
-	mux->set = desc->set;
-
-	device_initialize(&mux->dev);
-	mux->dev.parent = parent;
-	mux->dev.fwnode = desc->fwnode;
-	mux->dev.type = &typec_mux_dev_type;
-	mux->dev.driver_data = desc->drvdata;
-	dev_set_name(&mux->dev, "%s-mux", dev_name(parent));
-
-	ret = device_add(&mux->dev);
-	if (ret) {
-		dev_info(parent, "failed to register mux (%d)\n", ret);
-		put_device(&mux->dev);
-		return ERR_PTR(ret);
-	}
-
-	return mux;
-}
-EXPORT_SYMBOL_GPL(typec_mux_register);
-
-/**
- * typec_mux_unregister - Unregister Multiplexer Switch
- * @mux: USB Type-C Connector Multiplexer/DeMultiplexer
- *
- * Unregister mux that was registered with typec_mux_register().
- */
-void typec_mux_unregister(struct typec_mux *mux)
-{
-	if (!IS_ERR_OR_NULL(mux))
-		device_unregister(&mux->dev);
-}
-EXPORT_SYMBOL_GPL(typec_mux_unregister);
-
-void typec_mux_set_drvdata(struct typec_mux *mux, void *data)
-{
-	dev_set_drvdata(&mux->dev, data);
-}
-EXPORT_SYMBOL_GPL(typec_mux_set_drvdata);
-
-void *typec_mux_get_drvdata(struct typec_mux *mux)
-{
-	return dev_get_drvdata(&mux->dev);
-}
-EXPORT_SYMBOL_GPL(typec_mux_get_drvdata);
-
diff --git a/drivers/misc/mediatek/typec/u3_switch/mux.h b/drivers/misc/mediatek/typec/u3_switch/mux.h
deleted file mode 100644
index 9f13569..0000000
--- a/drivers/misc/mediatek/typec/u3_switch/mux.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (c) 2020 MediaTek Inc.
- */
-#ifndef __USB_TYPEC_MUX
-#define __USB_TYPEC_MUX
-
-#include <linux/device.h>
-
-struct typec_mux;
-struct typec_switch;
-
-enum typec_orientation {
-	TYPEC_ORIENTATION_NONE,
-	TYPEC_ORIENTATION_NORMAL,
-	TYPEC_ORIENTATION_REVERSE,
-};
-
-typedef int (*typec_switch_set_fn_t)(struct typec_switch *sw,
-				     enum typec_orientation orientation);
-struct typec_switch_desc {
-	struct fwnode_handle *fwnode;
-	typec_switch_set_fn_t set;
-	void *drvdata;
-};
-
-struct typec_switch *
-typec_switch_register(struct device *parent,
-		      const struct typec_switch_desc *desc);
-void typec_switch_unregister(struct typec_switch *sw);
-
-void typec_switch_set_drvdata(struct typec_switch *sw, void *data);
-void *typec_switch_get_drvdata(struct typec_switch *sw);
-
-typedef int (*typec_mux_set_fn_t)(struct typec_mux *mux, int state);
-
-struct typec_mux_desc {
-	struct fwnode_handle *fwnode;
-	typec_mux_set_fn_t set;
-	void *drvdata;
-};
-
-struct typec_mux *
-typec_mux_register(struct device *parent, const struct typec_mux_desc *desc);
-void typec_mux_unregister(struct typec_mux *mux);
-
-void typec_mux_set_drvdata(struct typec_mux *mux, void *data);
-void *typec_mux_get_drvdata(struct typec_mux *mux);
-
-struct typec_switch {
-	struct device dev;
-	typec_switch_set_fn_t set;
-};
-
-struct typec_mux {
-	struct device dev;
-	typec_mux_set_fn_t set;
-};
-
-#define to_typec_switch(_dev_) container_of(_dev_, struct typec_switch, dev)
-#define to_typec_mux(_dev_) container_of(_dev_, struct typec_mux, dev)
-
-#endif /* __USB_TYPEC_MUX */
-
diff --git a/drivers/misc/mediatek/typec/u3_switch/mux_switch.c b/drivers/misc/mediatek/typec/u3_switch/mux_switch.c
deleted file mode 100644
index 4b58b1d..0000000
--- a/drivers/misc/mediatek/typec/u3_switch/mux_switch.c
+++ /dev/null
@@ -1,347 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (c) 2020 MediaTek Inc.
- */
-#include <linux/debugfs.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/of_platform.h>
-#include <linux/platform_device.h>
-#include <linux/slab.h>
-
-#include "typec.h"
-#include "usb_switch.h"
-
-/* struct typec_mux_switch */
-struct typec_mux_switch {
-	struct device *dev;
-	struct typec_switch *sw;
-	struct typec_mux *mux;
-	int orientation;
-	int state;
-#if IS_ENABLED(CONFIG_DEBUG_FS)
-	struct dentry *root;
-#endif
-};
-
-/* struct mtk_typec_switch */
-struct mtk_typec_switch {
-	struct device *dev;
-	struct typec_switch *sw;
-	struct list_head list;
-};
-
-/* struct mtk_typec_mux */
-struct mtk_typec_mux {
-	struct device *dev;
-	struct typec_mux *mux;
-	struct list_head list;
-};
-
-static LIST_HEAD(mux_list);
-static LIST_HEAD(switch_list);
-static DEFINE_MUTEX(mux_lock);
-static DEFINE_MUTEX(switch_lock);
-
-static struct typec_mux_switch *g_mux_sw;
-
-/* MUX */
-struct typec_mux *mtk_typec_mux_register(struct device *dev,
-			const struct typec_mux_desc *desc)
-{
-	struct mtk_typec_mux *typec_mux;
-	struct typec_mux *mux;
-
-	mutex_lock(&mux_lock);
-	list_for_each_entry(typec_mux, &mux_list, list) {
-		if (typec_mux->dev == dev) {
-			mux = ERR_PTR(-EEXIST);
-			goto out;
-		}
-	}
-
-	typec_mux = kzalloc(sizeof(*typec_mux), GFP_KERNEL);
-	if (!typec_mux) {
-		mux = ERR_PTR(-ENOMEM);
-		goto out;
-	}
-
-	mux = typec_mux_register(dev, desc);
-	if (IS_ERR(mux)) {
-		kfree(typec_mux);
-		mux = ERR_PTR(-EINVAL);
-		goto out;
-	}
-	typec_mux->mux = mux;
-	list_add_tail(&typec_mux->list, &mux_list);
-out:
-	mutex_unlock(&mux_lock);
-	return mux;
-}
-EXPORT_SYMBOL_GPL(mtk_typec_mux_register);
-
-void mtk_typec_mux_unregister(struct typec_mux *mux)
-{
-	struct mtk_typec_mux *typec_mux;
-
-	mutex_lock(&mux_lock);
-	list_for_each_entry(typec_mux, &mux_list, list) {
-		if (typec_mux->mux == mux)
-			break;
-	}
-
-	list_del(&typec_mux->list);
-	kfree(typec_mux);
-	mutex_unlock(&mux_lock);
-
-	typec_mux_unregister(mux);
-}
-EXPORT_SYMBOL_GPL(mtk_typec_mux_unregister);
-
-static int mtk_typec_mux_set(struct typec_mux *mux, int state)
-{
-	struct typec_mux_switch *mux_sw = typec_mux_get_drvdata(mux);
-	struct mtk_typec_mux *typec_mux;
-	int ret = 0;
-
-	dev_info(mux_sw->dev, "%s %d %d\n", __func__,
-		 mux_sw->state, state);
-
-	if (mux_sw->state == state)
-		return ret;
-
-	mutex_lock(&mux_lock);
-
-	list_for_each_entry(typec_mux, &mux_list, list) {
-		if (!IS_ERR_OR_NULL(typec_mux->mux))
-			typec_mux->mux->set(typec_mux->mux, state);
-	}
-
-	mux_sw->state = state;
-
-	mutex_unlock(&mux_lock);
-
-	return ret;
-}
-
-/* SWITCH */
-struct typec_switch *mtk_typec_switch_register(struct device *dev,
-			const struct typec_switch_desc *desc)
-{
-	struct mtk_typec_switch *typec_sw;
-	struct typec_switch *sw;
-
-	mutex_lock(&switch_lock);
-	list_for_each_entry(typec_sw, &switch_list, list) {
-		if (typec_sw->dev == dev) {
-			sw = ERR_PTR(-EEXIST);
-			goto out;
-		}
-	}
-
-	typec_sw = kzalloc(sizeof(*typec_sw), GFP_KERNEL);
-	if (!typec_sw) {
-		sw = ERR_PTR(-ENOMEM);
-		goto out;
-	}
-
-	sw = typec_switch_register(dev, desc);
-	if (IS_ERR(sw)) {
-		kfree(typec_sw);
-		sw = ERR_PTR(-EINVAL);
-		goto out;
-	}
-	typec_sw->sw = sw;
-	list_add_tail(&typec_sw->list, &switch_list);
-out:
-	mutex_unlock(&switch_lock);
-	return sw;
-}
-EXPORT_SYMBOL_GPL(mtk_typec_switch_register);
-
-void mtk_typec_switch_unregister(struct typec_switch *sw)
-{
-	struct mtk_typec_switch *typec_sw;
-
-	mutex_lock(&switch_lock);
-	list_for_each_entry(typec_sw, &switch_list, list) {
-		if (typec_sw->sw == sw)
-			break;
-	}
-	list_del(&typec_sw->list);
-	kfree(typec_sw);
-	mutex_unlock(&switch_lock);
-
-	typec_switch_unregister(sw);
-}
-EXPORT_SYMBOL_GPL(mtk_typec_switch_unregister);
-
-static int mtk_typec_switch_set(struct typec_switch *sw,
-			      enum typec_orientation orientation)
-{
-	struct typec_mux_switch *mux_sw = typec_switch_get_drvdata(sw);
-	struct mtk_typec_switch *typec_sw;
-	int ret = 0;
-
-	dev_info(mux_sw->dev, "%s %d %d\n", __func__,
-		 mux_sw->orientation, orientation);
-
-	if (mux_sw->orientation == orientation)
-		return ret;
-
-	mutex_lock(&switch_lock);
-
-	list_for_each_entry(typec_sw, &switch_list, list) {
-		if (!IS_ERR_OR_NULL(typec_sw->sw))
-			typec_sw->sw->set(typec_sw->sw, orientation);
-	}
-
-	mux_sw->orientation = orientation;
-
-	mutex_unlock(&switch_lock);
-
-	return ret;
-}
-
-void usb3_switch_ctrl_sel(int sel)
-{
-	if (!g_mux_sw)
-		return;
-
-	if (sel == CC1_SIDE)
-		mtk_typec_switch_set(g_mux_sw->sw, TYPEC_ORIENTATION_NORMAL);
-	else
-		mtk_typec_switch_set(g_mux_sw->sw, TYPEC_ORIENTATION_REVERSE);
-}
-EXPORT_SYMBOL_GPL(usb3_switch_ctrl_sel);
-
-void usb3_switch_ctrl_en(bool en)
-{
-}
-EXPORT_SYMBOL_GPL(usb3_switch_ctrl_en);
-
-void usb3_switch_dps_en(bool enable)
-{
-	if (!g_mux_sw)
-		return;
-
-	if (enable)
-		mtk_typec_switch_set(g_mux_sw->sw, TYPEC_ORIENTATION_NONE);
-	else
-		mtk_typec_switch_set(g_mux_sw->sw, TYPEC_ORIENTATION_NORMAL);
-}
-EXPORT_SYMBOL_GPL(usb3_switch_dps_en);
-
-#if IS_ENABLED(CONFIG_DEBUG_FS)
-static int mux_sw_smt_set(void *data, u64 val)
-{
-	struct typec_mux_switch *mux_sw = data;
-	int sel = val;
-
-	dev_info(mux_sw->dev, "%s %d\n", __func__, sel);
-
-	if (sel == 0)
-		mtk_typec_switch_set(mux_sw->sw, TYPEC_ORIENTATION_NONE);
-	else if (sel == 1)
-		mtk_typec_switch_set(mux_sw->sw, TYPEC_ORIENTATION_NORMAL);
-	else
-		mtk_typec_switch_set(mux_sw->sw, TYPEC_ORIENTATION_REVERSE);
-
-	return 0;
-}
-DEFINE_SIMPLE_ATTRIBUTE(mux_sw_smt_fops, NULL, mux_sw_smt_set, "%llu\n");
-
-static int typec_mux_switch_debugfs_init(struct typec_mux_switch *mux_sw)
-{
-	struct dentry *file;
-
-	mux_sw->root = debugfs_create_dir("usb_c", NULL);
-	if (IS_ERR_OR_NULL(mux_sw->root)) {
-		dev_info(mux_sw->dev, "%s debugfs_create_dir fail\n", __func__);
-		goto err;
-	}
-
-	file = debugfs_create_file("smt", 0200, mux_sw->root, mux_sw,
-			&mux_sw_smt_fops);
-	if (IS_ERR_OR_NULL(file)) {
-		dev_info(mux_sw->dev, "%s debugfs_create_file fail\n", __func__);
-		goto err;
-	}
-
-	return 0;
-err:
-	dev_info(mux_sw->dev, "%s fail\n", __func__);
-	debugfs_remove_recursive(mux_sw->root);
-	return -ENOMEM;
-}
-#endif
-
-static int typec_mux_switch_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct typec_mux_switch *mux_sw;
-	struct typec_switch_desc sw_desc;
-	struct typec_mux_desc mux_desc;
-	int ret = 0;
-
-	dev_info(dev, "%s\n", __func__);
-
-	mux_sw = kzalloc(sizeof(*mux_sw), GFP_KERNEL);
-	if (!mux_sw)
-		return -ENOMEM;
-
-	mux_sw->dev = dev;
-
-	sw_desc.drvdata = mux_sw;
-	sw_desc.fwnode = dev->fwnode;
-	sw_desc.set = mtk_typec_switch_set;
-
-	mux_sw->sw = typec_switch_register(dev, &sw_desc);
-	if (IS_ERR(mux_sw->sw)) {
-		dev_info(dev, "error registering typec switch: %ld\n",
-			PTR_ERR(mux_sw->sw));
-		return PTR_ERR(mux_sw->sw);
-	}
-
-	mux_desc.drvdata = mux_sw;
-	mux_desc.fwnode = dev->fwnode;
-	mux_desc.set = mtk_typec_mux_set;
-
-	mux_sw->mux = typec_mux_register(dev, &mux_desc);
-	if (IS_ERR(mux_sw->mux)) {
-		typec_switch_unregister(mux_sw->sw);
-		dev_info(dev, "error registering typec mux: %ld\n",
-			PTR_ERR(mux_sw->mux));
-		return PTR_ERR(mux_sw->mux);
-	}
-
-	g_mux_sw = mux_sw;
-
-#if IS_ENABLED(CONFIG_DEBUG_FS)
-	typec_mux_switch_debugfs_init(mux_sw);
-#endif
-	platform_set_drvdata(pdev, mux_sw);
-
-	dev_info(dev, "%s done\n", __func__);
-	return ret;
-}
-
-static const struct of_device_id typec_mux_switch_ids[] = {
-	{.compatible = "mediatek,typec_mux_switch",},
-	{},
-};
-
-static struct platform_driver typec_mux_switch_driver = {
-	.probe = typec_mux_switch_probe,
-	.driver = {
-		.name = "mtk-typec-mux-switch",
-		.of_match_table = typec_mux_switch_ids,
-	},
-};
-
-module_platform_driver(typec_mux_switch_driver);
-
-MODULE_DESCRIPTION("Mediatek Type-C mux switch driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/misc/mediatek/typec/u3_switch/ps5169.c b/drivers/misc/mediatek/typec/u3_switch/ps5169.c
deleted file mode 100644
index c354a67..0000000
--- a/drivers/misc/mediatek/typec/u3_switch/ps5169.c
+++ /dev/null
@@ -1,181 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (c) 2020 MediaTek Inc.
- */
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/i2c.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/of_platform.h>
-#include <linux/platform_device.h>
-
-#include "mux.h"
-#include "usb_switch.h"
-
-struct ps5169 {
-	struct device *dev;
-	struct i2c_client *i2c;
-	struct typec_switch *sw;
-	struct pinctrl *pinctrl;
-	struct pinctrl_state *enable;
-	struct pinctrl_state *disable;
-	struct mutex lock;
-};
-
-#define PS5169_ORIENTATION_NONE                 0x80
-#define PS5169_ORIENTATION_NORMAL               0xc0
-#define PS5169_ORIENTATION_FLIP                 0xd0
-
-static int ps5169_init(struct ps5169 *ps)
-{
-	/* do thing now */
-	return 0;
-}
-
-static int ps5169_switch_set(struct typec_switch *sw,
-			enum typec_orientation orientation)
-{
-	struct ps5169 *ps = typec_switch_get_drvdata(sw);
-
-	dev_info(ps->dev, "%s %d\n", __func__, orientation);
-
-	switch (orientation) {
-	case TYPEC_ORIENTATION_NONE:
-		/* switch off */
-		if (ps->disable)
-			pinctrl_select_state(ps->pinctrl, ps->disable);
-		break;
-	case TYPEC_ORIENTATION_NORMAL:
-		/* switch cc1 side */
-		if (ps->enable) {
-			pinctrl_select_state(ps->pinctrl, ps->enable);
-			mdelay(20);
-		}
-		ps5169_init(ps);
-		i2c_smbus_write_byte_data(ps->i2c, 0x40,
-			PS5169_ORIENTATION_NORMAL);
-		break;
-	case TYPEC_ORIENTATION_REVERSE:
-		/* switch cc2 side */
-		if (ps->enable) {
-			pinctrl_select_state(ps->pinctrl, ps->enable);
-			mdelay(20);
-		}
-		ps5169_init(ps);
-		i2c_smbus_write_byte_data(ps->i2c, 0x40,
-			PS5169_ORIENTATION_FLIP);
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static int ps5169_pinctrl_init(struct ps5169 *ps)
-{
-	struct device *dev = ps->dev;
-	int ret = 0;
-
-	ps->pinctrl = devm_pinctrl_get(dev);
-	if (IS_ERR(ps->pinctrl)) {
-		ret = PTR_ERR(ps->pinctrl);
-		dev_info(dev, "failed to get pinctrl, ret=%d\n", ret);
-		return ret;
-	}
-
-	ps->enable =
-		pinctrl_lookup_state(ps->pinctrl, "enable");
-
-	if (IS_ERR(ps->enable)) {
-		dev_info(dev, "Can *NOT* find enable\n");
-		ps->enable = NULL;
-	} else
-		dev_info(dev, "Find enable\n");
-
-	ps->disable =
-		pinctrl_lookup_state(ps->pinctrl, "disable");
-
-	if (IS_ERR(ps->disable)) {
-		dev_info(dev, "Can *NOT* find disable\n");
-		ps->disable = NULL;
-	} else
-		dev_info(dev, "Find disable\n");
-
-	return ret;
-}
-
-static int ps5169_probe(struct i2c_client *client)
-{
-	struct device *dev = &client->dev;
-	struct ps5169 *ps;
-	struct typec_switch_desc sw_desc;
-	int ret = 0;
-
-	ps = devm_kzalloc(dev, sizeof(*ps), GFP_KERNEL);
-	if (!ps)
-		return -ENOMEM;
-
-	ps->i2c = client;
-	ps->dev = dev;
-
-	sw_desc.drvdata = ps;
-	sw_desc.fwnode = dev->fwnode;
-	sw_desc.set = ps5169_switch_set;
-
-	ps->sw = mtk_typec_switch_register(dev, &sw_desc);
-	if (IS_ERR(ps->sw)) {
-		dev_info(dev, "error registering typec switch: %ld\n",
-			PTR_ERR(ps->sw));
-		return PTR_ERR(ps->sw);
-	}
-
-	i2c_set_clientdata(client, ps);
-
-	ret = ps5169_pinctrl_init(ps);
-	if (ret < 0)
-		mtk_typec_switch_unregister(ps->sw);
-
-	/* switch off after init done */
-	ps5169_switch_set(ps->sw, TYPEC_ORIENTATION_NONE);
-
-	dev_info(dev, "%s done\n", __func__);
-	return ret;
-}
-
-static int ps5169_remove(struct i2c_client *client)
-{
-	struct ps5169 *ps = i2c_get_clientdata(client);
-
-	mtk_typec_switch_unregister(ps->sw);
-	return 0;
-}
-
-static const struct i2c_device_id ps5169_table[] = {
-	{ "ps5169" },
-	{ }
-};
-MODULE_DEVICE_TABLE(i2c, ps5169_table);
-
-static const struct of_device_id ps5169_of_match[] = {
-	{.compatible = "parade,ps5169"},
-	{ },
-};
-MODULE_DEVICE_TABLE(of, ps5169_of_match);
-
-static struct i2c_driver ps5169_driver = {
-	.driver = {
-		.name = "ps5169",
-		.of_match_table = ps5169_of_match,
-	},
-	.probe_new = ps5169_probe,
-	.remove	= ps5169_remove,
-	.id_table = ps5169_table,
-};
-module_i2c_driver(ps5169_driver);
-
-MODULE_DESCRIPTION("PS5169 Type-C switch driver");
-MODULE_LICENSE("GPL v2");
-
diff --git a/drivers/misc/mediatek/typec/u3_switch/ptn36241g.c b/drivers/misc/mediatek/typec/u3_switch/ptn36241g.c
deleted file mode 100644
index a097ba1..0000000
--- a/drivers/misc/mediatek/typec/u3_switch/ptn36241g.c
+++ /dev/null
@@ -1,169 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (c) 2020 MediaTek Inc.
- */
-#include <linux/gpio.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/of_platform.h>
-#include <linux/platform_device.h>
-
-#include "mux.h"
-#include "usb_switch.h"
-
-struct ptn36241g {
-	struct device *dev;
-	struct typec_switch *sw;
-	struct pinctrl *pinctrl;
-	struct pinctrl_state *c1_active;
-	struct pinctrl_state *c1_sleep;
-	struct pinctrl_state *c2_active;
-	struct pinctrl_state *c2_sleep;
-	struct mutex lock;
-};
-
-static int ptn36241g_switch_set(struct typec_switch *sw,
-			      enum typec_orientation orientation)
-{
-	struct ptn36241g *ptn = typec_switch_get_drvdata(sw);
-
-	dev_info(ptn->dev, "%s %d\n", __func__, orientation);
-
-	switch (orientation) {
-	case TYPEC_ORIENTATION_NONE:
-		/* enter sleep mode */
-		if (ptn->c1_sleep)
-			pinctrl_select_state(ptn->pinctrl, ptn->c1_sleep);
-		if (ptn->c2_sleep)
-			pinctrl_select_state(ptn->pinctrl, ptn->c2_sleep);
-		break;
-	case TYPEC_ORIENTATION_NORMAL:
-	case TYPEC_ORIENTATION_REVERSE:
-		/* enter work mode */
-		if (ptn->c1_active)
-			pinctrl_select_state(ptn->pinctrl, ptn->c1_active);
-		if (ptn->c2_active)
-			pinctrl_select_state(ptn->pinctrl, ptn->c2_active);
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static int ptn36241g_pinctrl_init(struct ptn36241g *ptn)
-{
-	struct device *dev = ptn->dev;
-	int ret = 0;
-
-	ptn->pinctrl = devm_pinctrl_get(dev);
-	if (IS_ERR(ptn->pinctrl)) {
-		ret = PTR_ERR(ptn->pinctrl);
-		dev_info(dev, "failed to get pinctrl, ret=%d\n", ret);
-		return ret;
-	}
-
-	ptn->c1_active =
-		pinctrl_lookup_state(ptn->pinctrl, "c1_active");
-
-	if (IS_ERR(ptn->c1_active)) {
-		dev_info(dev, "Can *NOT* find c1_active\n");
-		ptn->c1_active = NULL;
-	} else
-		dev_info(dev, "Find c1_active\n");
-
-	ptn->c1_sleep =
-		pinctrl_lookup_state(ptn->pinctrl, "c1_sleep");
-
-	if (IS_ERR(ptn->c1_sleep)) {
-		dev_info(dev, "Can *NOT* find c1_sleep\n");
-		ptn->c1_sleep = NULL;
-	} else
-		dev_info(dev, "Find c1_sleep\n");
-
-	ptn->c2_active =
-		pinctrl_lookup_state(ptn->pinctrl, "c2_active");
-
-	if (IS_ERR(ptn->c2_active)) {
-		dev_info(dev, "Can *NOT* find c2_active\n");
-		ptn->c2_active = NULL;
-	} else
-		dev_info(dev, "Find c2_active\n");
-
-	ptn->c2_sleep =
-		pinctrl_lookup_state(ptn->pinctrl, "c2_sleep");
-
-	if (IS_ERR(ptn->c2_sleep)) {
-		dev_info(dev, "Can *NOT* find c2_sleep\n");
-		ptn->c2_sleep = NULL;
-	} else
-		dev_info(dev, "Find c2_sleep\n");
-
-	return ret;
-}
-
-static int ptn36241g_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct ptn36241g *ptn;
-	struct typec_switch_desc sw_desc;
-	int ret = 0;
-
-	ptn = devm_kzalloc(&pdev->dev, sizeof(*ptn), GFP_KERNEL);
-	if (!ptn)
-		return -ENOMEM;
-
-	ptn->dev = dev;
-
-	sw_desc.drvdata = ptn;
-	sw_desc.fwnode = dev->fwnode;
-	sw_desc.set = ptn36241g_switch_set;
-
-	ptn->sw = mtk_typec_switch_register(dev, &sw_desc);
-	if (IS_ERR(ptn->sw)) {
-		dev_info(dev, "error registering typec switch: %ld\n",
-			PTR_ERR(ptn->sw));
-		return PTR_ERR(ptn->sw);
-	}
-
-	platform_set_drvdata(pdev, ptn);
-
-	ret = ptn36241g_pinctrl_init(ptn);
-	if (ret < 0)
-		mtk_typec_switch_unregister(ptn->sw);
-
-	ptn36241g_switch_set(ptn->sw, TYPEC_ORIENTATION_NONE);
-
-	dev_info(dev, "%s done\n", __func__);
-	return ret;
-}
-
-static int ptn36241g_remove(struct platform_device *pdev)
-{
-	struct ptn36241g *ptn = platform_get_drvdata(pdev);
-
-	mtk_typec_switch_unregister(ptn->sw);
-	return 0;
-}
-
-static const struct of_device_id ptn36241g_ids[] = {
-	{.compatible = "mediatek,ptn36241g",},
-	{},
-};
-
-static struct platform_driver ptn36241g_driver = {
-	.driver = {
-		.name = "ptn36241g",
-		.of_match_table = ptn36241g_ids,
-	},
-	.probe = ptn36241g_probe,
-	.remove = ptn36241g_remove,
-};
-
-module_platform_driver(ptn36241g_driver);
-
-MODULE_DESCRIPTION("PTN36241G USB redriver driver");
-MODULE_LICENSE("GPL v2");
-
diff --git a/drivers/misc/mediatek/typec/u3_switch/usb_switch.c b/drivers/misc/mediatek/typec/u3_switch/usb_switch.c
index fc0dbda..d287877 100644
--- a/drivers/misc/mediatek/typec/u3_switch/usb_switch.c
+++ b/drivers/misc/mediatek/typec/u3_switch/usb_switch.c
@@ -14,7 +14,7 @@
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
-#include <linux/proc_fs.h>
+#include <linux/debugfs.h>
 #include <linux/seq_file.h>
 #include <linux/uaccess.h>
 #include <typec.h>
@@ -46,11 +46,7 @@
 
 static u32 debug_level = (255 - K_DEBUG);
 static struct usbtypc *g_exttypec;
-
-#define DIR_MTK_TYPEC "mtk_typec"
-#define FILE_GPIO "mtk_typec/gpio"
-#define FILE_SMT "mtk_typec/smt"
-#define FILE_SMT_U2_CC_MODE "mtk_typec/smt_u2_cc_mode"
+static struct dentry *root;
 
 static int usb3_switch_en(struct usbtypc *typec, int on)
 {
@@ -237,9 +233,8 @@ end:
 	return retval;
 }
 
-#if IS_ENABLED(CONFIG_PROC_FS)
 /*Print U3 switch & Redriver*/
-static int usb_gpio_procfs_show(struct seq_file *s, void *unused)
+static int usb_gpio_debugfs_show(struct seq_file *s, void *unused)
 {
 	struct usbtypc *typec = s->private;
 	int pin = 0;
@@ -289,12 +284,13 @@ static int usb_gpio_procfs_show(struct seq_file *s, void *unused)
 
 	return 0;
 }
-static int usb_gpio_procfs_open(struct inode *inode, struct file *file)
+
+static int usb_gpio_debugfs_open(struct inode *inode, struct file *file)
 {
-	return single_open(file, usb_gpio_procfs_show, PDE_DATA(inode));
+	return single_open(file, usb_gpio_debugfs_show, inode->i_private);
 }
 
-static ssize_t usb_gpio_procfs_write(struct file *file,
+static ssize_t usb_gpio_debugfs_write(struct file *file,
 	const char __user *ubuf, size_t count, loff_t *ppos)
 {
 	struct seq_file *s = file->private_data;
@@ -344,62 +340,41 @@ static ssize_t usb_gpio_procfs_write(struct file *file,
 	return count;
 }
 
-static const struct file_operations usb_gpio_procfs_fops = {
-	.open = usb_gpio_procfs_open,
-	.write = usb_gpio_procfs_write,
+static const struct file_operations usb_gpio_debugfs_fops = {
+	.open = usb_gpio_debugfs_open,
+	.write = usb_gpio_debugfs_write,
 	.read = seq_read,
 	.llseek = seq_lseek,
 	.release = single_release,
 };
 
-static int usb_switch_procfs_show(struct seq_file *s, void *unused)
-{
-	return 0;
-}
-static int usb_switch_procfs_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, usb_switch_procfs_show, PDE_DATA(inode));
-}
-static ssize_t usb_switch_procfs_write(struct file *file,
-	const char __user *ubuf, size_t count, loff_t *ppos)
+static int usb_switch_set(void *data, u64 val)
 {
-	struct seq_file *s = file->private_data;
-	struct usbtypc *typec = s->private;
-	char buf[20];
-	unsigned int val;
+	struct usbtypc *typec = data;
+	int sel = val;
 
-	memset(buf, 0x00, sizeof(buf));
-	if (copy_from_user(buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
-		return -EFAULT;
+	usbc_dbg(K_INFO, "%s %d\n", __func__, sel);
 
-	if (kstrtouint(buf, 10, &val) == 0) {
-		if (val == 0)
-			usb3_switch_en(typec, DISABLE);
-		else {
-			usb3_switch_en(typec, ENABLE);
-			if (val == 1)
-				usb3_switch_sel(typec, CC1_SIDE);
-			else
-				usb3_switch_sel(typec, CC2_SIDE);
-		}
-		return count;
-	} else
-		return -EINVAL;
+	if (sel == 0) {
+		usb3_switch_en(typec, DISABLE);
+	} else {
+		usb3_switch_en(typec, ENABLE);
+
+		if (sel == 1)
+			usb3_switch_sel(typec, CC1_SIDE);
+		else
+			usb3_switch_sel(typec, CC2_SIDE);
+	}
+
+	return 0;
 }
-static const struct file_operations usb_switch_procfs_fops = {
-	.open = usb_switch_procfs_open,
-	.write = usb_switch_procfs_write,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
+DEFINE_SIMPLE_ATTRIBUTE(usb_debugfs_fops, NULL, usb_switch_set, "%llu\n");
 
 #ifdef CONFIG_TCPC_CLASS
-static int usb_cc_smt_procfs_show(struct seq_file *s, void *unused)
+static int usb_cc_smt_status(void *data, u64 *val)
 {
 	struct tcpc_device *tcpc_dev;
 	uint8_t cc1, cc2;
-	char buf[2];
 
 	tcpc_dev = tcpc_dev_get_by_name("type_c_port0");
 	if (!tcpc_dev) {
@@ -411,48 +386,49 @@ static int usb_cc_smt_procfs_show(struct seq_file *s, void *unused)
 	pr_info("[TYPEC] cc1=%d, cc2=%d\n", cc1, cc2);
 
 	if (cc1 == TYPEC_CC_VOLT_OPEN || cc1 == TYPEC_CC_DRP_TOGGLING)
-		seq_puts(s, "0\n");
+		*val = 0;
 	else if (cc2 == TYPEC_CC_VOLT_OPEN || cc2 == TYPEC_CC_DRP_TOGGLING)
-		seq_puts(s, "0\n");
+		*val = 0;
 	else
-		seq_puts(s, "1\n");
-	buf[1] = '\0';
+		*val = 1;
 
 	return 0;
 }
 #else
-static int usb_cc_smt_procfs_show(struct seq_file *s, void *input)
+static int usb_check_cc_smt_status(void *data, u64 *val)
 {
 	return 0;
 }
 #endif
-static int usb_cc_smt_procfs_open(struct inode *inode, struct file *file)
+DEFINE_SIMPLE_ATTRIBUTE(usb_cc_smt_fops, usb_cc_smt_status, NULL, "%llu\n");
+
+static int usb_typec_pinctrl_debugfs(struct usbtypc *typec)
 {
-	return single_open(file, usb_cc_smt_procfs_show, PDE_DATA(inode));
+	struct dentry *file;
+
+	if (!root)
+		return -ENOMEM;
+
+	file = debugfs_create_file("gpio", 0644, root,
+			typec, &usb_gpio_debugfs_fops);
+	file = debugfs_create_file("smt", 0200, root, typec,
+			&usb_debugfs_fops);
+
+	return 0;
 }
-static const struct file_operations usb_cc_smt_procfs_fops = {
-	.open = usb_cc_smt_procfs_open,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
 
-static int usb_typec_pinctrl_procfs(struct usbtypc *typec)
+static int usb_typec_cc_debugfs(struct usbtypc *typec)
 {
-	struct proc_dir_entry *file;
+	struct dentry *file;
 
-	proc_mkdir(DIR_MTK_TYPEC, NULL);
+	if (!root)
+		return -ENOMEM;
 
-	file = proc_create_data(FILE_GPIO, 0644, NULL,
-			&usb_gpio_procfs_fops, typec);
-	file = proc_create_data(FILE_SMT, 0200, NULL,
-			&usb_switch_procfs_fops, typec);
-	file = proc_create_data(FILE_SMT_U2_CC_MODE, 0400, NULL,
-			&usb_cc_smt_procfs_fops, typec);
+	file = debugfs_create_file("smt_u2_cc_mode", 0400, root, typec,
+			&usb_cc_smt_fops);
 
 	return 0;
 }
-#endif
 
 struct usbtypc *get_usbtypec(void)
 {
@@ -792,10 +768,7 @@ static int usbc_pinctrl_probe(struct platform_device *pdev)
 	usb_redriver_init(typec);
 	usb3_switch_init(typec);
 
-#if IS_ENABLED(CONFIG_PROC_FS)
-	usb_typec_pinctrl_procfs(typec);
-#endif
-
+	usb_typec_pinctrl_debugfs(typec);
 	g_exttypec = typec;
 
 	return ret;
@@ -819,6 +792,15 @@ static struct platform_driver usb_switch_pinctrl_driver = {
 int __init usbc_pinctrl_init(void)
 {
 	int ret = 0;
+	struct usbtypc *typec;
+
+	typec = get_usbtypec();
+
+	root = debugfs_create_dir("usb_c", NULL);
+	if (!root)
+		ret = -ENOMEM;
+
+	usb_typec_cc_debugfs(typec);
 
 	if (!platform_driver_register(&usb_switch_pinctrl_driver))
 		usbc_dbg(K_DEBUG, "register usbc pinctrl succeed!!\n");
diff --git a/drivers/misc/mediatek/typec/u3_switch/usb_switch.h b/drivers/misc/mediatek/typec/u3_switch/usb_switch.h
index 4157e1d..b090e79 100644
--- a/drivers/misc/mediatek/typec/u3_switch/usb_switch.h
+++ b/drivers/misc/mediatek/typec/u3_switch/usb_switch.h
@@ -13,10 +13,6 @@
 #ifndef USB_SWITCH_H
 #define USB_SWITCH_H
 
-#if IS_ENABLED(CONFIG_MTK_USB_TYPEC_U3_MUX_V2)
-#include "mux.h"
-#endif
-
 struct usb3_switch {
 	int sel_gpio;
 	int en_gpio;
@@ -62,18 +58,8 @@ struct usbtypc {
 	struct usb_redriver *u_rd;
 };
 
-#if IS_ENABLED(CONFIG_MTK_USB_TYPEC_U3_MUX_V2)
-struct typec_switch *mtk_typec_switch_register(struct device *dev,
-			const struct typec_switch_desc *desc);
-void mtk_typec_switch_unregister(struct typec_switch *sw);
-struct typec_mux *mtk_typec_mux_register(struct device *dev,
-			const struct typec_mux_desc *desc);
-void mtk_typec_mux_unregister(struct typec_mux *mux);
-#endif
+#endif	/* USB_SWITCH_H */
 
 extern void usb3_switch_ctrl_sel(int sel);
 extern void usb3_switch_ctrl_en(bool en);
 extern void usb3_switch_dps_en(bool en);
-
-#endif	/* USB_SWITCH_H */
-
