--- /dev/null	2025-06-02 17:12:30.007328094 +0300
+++ b/vendor/mediatek/kernel_modules/connectivity/common/common_main/linux/hif_sdio.c	2025-06-04 19:39:16.282164583 +0300
@@ -0,0 +1,2924 @@
+/*
+ * Copyright (C) 2016 MediaTek Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
+ */
+
+/*
+ *
+ * 07 25 2010 george.kuo
+ *
+ * Move hif_sdio driver to linux directory.
+ *
+ * 07 23 2010 george.kuo
+ *
+ * Add MT6620 driver source tree
+ * , including char device driver (wmt, bt, gps), stp driver,
+ * interface driver (tty ldisc and hif_sdio), and bt hci driver.
+**
+**
+*/
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+#define HIF_SDIO_UPDATE (1)
+#define HIF_SDIO_SUPPORT_SUSPEND (1)
+#define HIF_SDIO_SUPPORT_WAKEUP (0)
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+
+#include <linux/proc_fs.h>
+#include "hif_sdio.h"
+#include "wmt_gpio.h"
+/* #include "hif_sdio_chrdev.h" */
+#include <connectivity_build_in_adapter.h>
+#include <wmt_build_in_adapter.h>
+#include <linux/mmc/card.h>
+
+#define mmc_power_up_ext(x)
+#define mmc_power_off_ext(x)
+MTK_WCN_BOOL g_hif_deep_sleep_flag = MTK_WCN_BOOL_FALSE;
+
+#ifndef MMC_CARD_REMOVED
+#define MMC_CARD_REMOVED	(1<<4)
+#endif
+
+#ifndef mmc_card_removed
+#define mmc_card_removed(c)	((c) && ((c)->state & MMC_CARD_REMOVED))
+#endif
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+/* #define DRV_NAME "[hif_sdio]" */
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+
+
+/*******************************************************************************
+*                   F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+#if HIF_SDIO_SUPPORT_SUSPEND
+static INT32 hif_sdio_suspend(struct device *dev);
+
+static INT32 hif_sdio_resume(struct device *dev);
+#endif
+static INT32 hif_sdio_probe(struct sdio_func *func, const struct sdio_device_id *id);
+
+static VOID hif_sdio_remove(struct sdio_func *func);
+
+static VOID hif_sdio_irq(struct sdio_func *func);
+
+static _osal_inline_ INT32 hif_sdio_clt_probe_func(MTK_WCN_HIF_SDIO_REGISTINFO *registinfo_p,
+		INT8 probe_idx);
+
+static VOID hif_sdio_clt_probe_worker(struct work_struct *work);
+
+static _osal_inline_ INT32 hif_sdio_find_probed_list_index_by_func(struct sdio_func *func);
+
+#if 0				/* TODO:[ChangeFeature][George] remove obsolete function? */
+static INT32 hif_sdio_find_probed_list_index_by_clt_index(INT32 clt_index);
+#endif
+
+static _osal_inline_ INT32 hif_sdio_find_probed_list_index_by_id_func(UINT16 vendor, UINT16 device,
+		UINT16 func_num);
+
+static _osal_inline_ VOID hif_sdio_init_clt_list(INT32 index);
+
+static _osal_inline_ INT32 hif_sdio_find_clt_list_index(UINT16 vendor, UINT16 device, UINT16 func_num);
+
+static _osal_inline_ INT32 hif_sdio_check_supported_sdio_id(UINT16 vendor, UINT16 device);
+
+static _osal_inline_ INT32 hif_sdio_check_duplicate_sdio_id(UINT16 vendor, UINT16 device, UINT16 func_num);
+
+static _osal_inline_ INT32 hif_sdio_add_clt_list(PINT32 clt_index_p, const MTK_WCN_HIF_SDIO_CLTINFO *pinfo,
+		UINT32 tbl_index);
+
+static _osal_inline_ INT32 hif_sdio_stp_on(VOID);
+
+static _osal_inline_ INT32 hif_sdio_stp_off(VOID);
+
+static _osal_inline_ INT32 hif_sdio_wifi_on(VOID);
+
+static _osal_inline_ INT32 hif_sdio_wifi_off(VOID);
+
+static _osal_inline_ INT32 hif_sdio_deep_sleep_info_init(VOID);
+
+static _osal_inline_ INT32 hif_sdio_deep_sleep_info_set_act(UINT32 chipid, UINT16 func_num,
+		MTK_WCN_HIF_SDIO_CLTCTX ctx, UINT8 act_flag);
+
+static INT32 _hif_sdio_wake_up_ctrl(MTK_WCN_HIF_SDIO_CLTCTX ctx);
+
+static _osal_inline_ INT32 wmt_tra_sdio_update(VOID);
+
+static _osal_inline_ INT32 hif_sdio_deep_sleep_info_dmp(MTK_WCN_HIF_SDIO_DS_INFO *p_ds_info);
+
+static _osal_inline_ VOID hif_sdio_dump_probe_list(VOID);
+
+static _osal_inline_ VOID hif_sdio_init_probed_list(INT32 index);
+
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+/* Supported SDIO device table */
+static const struct sdio_device_id mtk_sdio_id_tbl[] = {
+	/* MT6618 *//* Not an SDIO standard class device */
+	{SDIO_DEVICE(0x037A, 0x018A)},	/* SDIO1:WIFI */
+	{SDIO_DEVICE(0x037A, 0x018B)},	/* SDIO2:FUNC1:BT+FM */
+	{SDIO_DEVICE(0x037A, 0x018C)},	/* 2-function (SDIO2:FUNC1:BT+FM, FUNC2:WIFI) */
+
+	/* MT6619 *//* Not an SDIO standard class device */
+	{SDIO_DEVICE(0x037A, 0x6619)},	/* SDIO2:FUNC1:BT+FM+GPS */
+
+	/* MT6620 *//* Not an SDIO standard class device */
+	{SDIO_DEVICE(0x037A, 0x020A)},	/* SDIO1:FUNC1:WIFI */
+	{SDIO_DEVICE(0x037A, 0x020B)},	/* SDIO2:FUNC1:BT+FM+GPS */
+	{SDIO_DEVICE(0x037A, 0x020C)},	/* 2-function (SDIO2:FUNC1:BT+FM+GPS, FUNC2:WIFI) */
+
+	/* MT5921 *//* Not an SDIO standard class device */
+	{SDIO_DEVICE(0x037A, 0x5921)},
+
+	/* MT6628 *//* SDIO1: Wi-Fi, SDIO2: BGF */
+	{SDIO_DEVICE(0x037A, 0x6628)},
+
+	/* MT6630 *//* SDIO1: Wi-Fi, SDIO2: BGF */
+	{SDIO_DEVICE(0x037A, 0x6630)},
+
+	/* MT6632 *//* SDIO1: Wi-Fi */
+	{SDIO_DEVICE(0x037A, 0x6602)},
+
+	/* MT6632 *//* SDIO2: BGF */
+	{SDIO_DEVICE(0x037A, 0x6632)},
+
+	{ /* end: all zeroes */ },
+};
+
+#if HIF_SDIO_SUPPORT_SUSPEND
+static const struct dev_pm_ops mtk_sdio_pmops = {
+	.suspend = hif_sdio_suspend,
+	.resume = hif_sdio_resume,
+};
+#endif
+
+static struct sdio_driver mtk_sdio_client_drv = {
+	.name = "mtk_sdio_client",	/* MTK SDIO Client Driver */
+	.id_table = mtk_sdio_id_tbl,	/* all supported struct sdio_device_id table */
+	.probe = hif_sdio_probe,
+	.remove = hif_sdio_remove,
+#if HIF_SDIO_SUPPORT_SUSPEND
+	.drv = {
+		.pm = &mtk_sdio_pmops,
+		},
+#endif
+};
+
+/* Registered client driver list */
+/* static list g_hif_sdio_clt_drv_list */
+static MTK_WCN_HIF_SDIO_REGISTINFO g_hif_sdio_clt_drv_list[CFG_CLIENT_COUNT];
+
+/* MMC probed function list */
+/* static list g_hif_sdio_probed_func_list */
+static MTK_WCN_HIF_SDIO_PROBEINFO g_hif_sdio_probed_func_list[CFG_CLIENT_COUNT];
+
+/* spin lock info for g_hif_sdio_clt_drv_list and g_hif_sdio_probed_func_list */
+static MTK_WCN_HIF_SDIO_LOCKINFO g_hif_sdio_lock_info;
+
+/* reference count, debug information? */
+static INT32 gRefCount;
+static INT32 (*fp_wmt_tra_sdio_update)(VOID);
+static atomic_t hif_sdio_irq_enable_flag = ATOMIC_INIT(0);
+
+/*deep sleep related information*/
+MTK_WCN_HIF_SDIO_DS_INFO g_hif_sdio_ds_info_list[] = {
+	{
+	 .chip_id = 0x6630,
+	 .reg_offset = 0xF1,
+	 .value = 0x1,
+	 },
+	{
+	 .chip_id = 0x6632,
+	 .reg_offset = 0xF1,
+	 .value = 0x1,
+	 },
+	{ /* end: all zeroes */ }
+};
+
+
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("MediaTek Inc WCN_SE_CS3");
+MODULE_DESCRIPTION("MediaTek MT6620 HIF SDIO Driver");
+
+MODULE_DEVICE_TABLE(sdio, mtk_sdio_id_tbl);
+
+INT32 gHifSdioDbgLvl = HIF_SDIO_LOG_INFO;
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+#if 0
+INT32 __weak mtk_wcn_sdio_irq_flag_set(INT32 falg)
+{
+	HIF_SDIO_INFO_FUNC("mtk_wcn_sdio_irq_flag_set is not define!!!!!\n");
+
+	return 0;
+}
+#endif
+
+INT32 mtk_wcn_hif_sdio_irq_flag_set(INT32 flag)
+{
+
+	if (flag == 0) {
+		atomic_dec(&hif_sdio_irq_enable_flag);
+		if (atomic_read(&hif_sdio_irq_enable_flag) == 0)
+			wmt_export_mtk_wcn_sdio_irq_flag_set(0);
+	} else {
+		atomic_inc(&hif_sdio_irq_enable_flag);
+		if (atomic_read(&hif_sdio_irq_enable_flag) == 1)
+			wmt_export_mtk_wcn_sdio_irq_flag_set(1);
+	}
+
+	return 0;
+}
+
+
+/*!
+ * \brief register the callback funciton for record the timestamp of sdio access
+ *
+ * \param  callback function
+ *
+ * \retval -EINVAL, when registered callback is invalid
+ * \retval 0, when registered callback is valid
+ */
+INT32 mtk_wcn_hif_sdio_update_cb_reg(INT32(*ts_update) (VOID))
+{
+	if (ts_update) {
+		fp_wmt_tra_sdio_update = ts_update;
+		return 0;
+	} else {
+		return -EINVAL;
+	}
+}
+EXPORT_SYMBOL(mtk_wcn_hif_sdio_update_cb_reg);
+
+/*!
+ * \brief update the accessing time of SDIO via callback function
+ *
+ * \param  void
+ *
+ * \retval -EINVAL, when callback is not registered
+ * \retval returned value of callback
+ */
+static _osal_inline_ INT32 wmt_tra_sdio_update(VOID)
+{
+	if (fp_wmt_tra_sdio_update)
+		return (*fp_wmt_tra_sdio_update) ();
+	/* HIF_SDIO_WARN_FUNC("wmt_tra_sdio_update == NULL\n"); */
+	return -EINVAL;
+}
+
+/*!
+ * \brief Translate CLTCTX into a pointer to struct sdio_func if it is valid
+ *
+ * Translate a CLTCTX into a pointer to struct sdio_func if it is
+ *  1) probed by mmc_core, and
+ *  2) client driver is registered, and
+ *  3) clt_idx of client driver is valid
+ *
+ * \param ctx a context provided by client driver
+ *
+ * \retval null if any condition is not valie
+ * \retval a pointer to a struct sdio_func mapped by provided ctx
+ */
+static _osal_inline_ struct sdio_func *hif_sdio_ctx_to_func(MTK_WCN_HIF_SDIO_CLTCTX ctx)
+{
+	UINT32 probe_index;
+
+	/* 4 <1> check if ctx is valid, registered, and probed */
+	probe_index = CLTCTX_IDX(ctx);
+	if (unlikely(!CLTCTX_UIDX_VALID(probe_index))) {	/* invalid index in CLTCTX */
+		HIF_SDIO_WARN_FUNC("invalid ctx(0x%x)\n", ctx);
+		return NULL;
+	}
+	/* the client has not been registered */
+	if (unlikely(g_hif_sdio_probed_func_list[probe_index].clt_idx < 0)) {
+		HIF_SDIO_WARN_FUNC
+			("can't find client idx in probed list!ctx(0x%x) prob_idx(%d) clt_idx(%d)\n",
+			 ctx, probe_index, g_hif_sdio_probed_func_list[probe_index].clt_idx);
+		return NULL;
+	}
+	return g_hif_sdio_probed_func_list[probe_index].func;
+}
+
+static _osal_inline_ INT32 hif_sdio_deep_sleep_info_dmp(MTK_WCN_HIF_SDIO_DS_INFO *p_ds_info)
+{
+	UINT32 i = 0;
+	MTK_WCN_HIF_SDIO_DS_CLT_INFO *ctl_info = NULL;
+	UINT32 ctl_info_array_size = ARRAY_SIZE(p_ds_info->clt_info);
+
+	mutex_lock(&p_ds_info->lock);
+	HIF_SDIO_DBG_FUNC("p_ds_info: %p, chipid:0x%x, reg_offset:0x%x, value:0x%x\n",
+			p_ds_info, p_ds_info->chip_id, p_ds_info->reg_offset, p_ds_info->value);
+
+	for (i = 0; i < ctl_info_array_size; i++) {
+		ctl_info = &p_ds_info->clt_info[i];
+
+		HIF_SDIO_DBG_FUNC
+		    ("ctl_info[%d]--ctx:0x%08x, func_num:%d, act_flag:%d, en_flag:%d\n", i,
+		     ctl_info->ctx, ctl_info->func_num, ctl_info->act_flag, ctl_info->ds_en_flag);
+	}
+	mutex_unlock(&p_ds_info->lock);
+	return 0;
+}
+
+static _osal_inline_ INT32 hif_sdio_deep_sleep_info_init(VOID)
+{
+	UINT32 array_size = 0;
+	UINT32 clt_info_size = 0;
+	UINT32 i = 0;
+	UINT32 j = 0;
+
+	array_size = ARRAY_SIZE(g_hif_sdio_ds_info_list);
+
+	/*set clt_info segment to 0 by default, when do stp/wifi on, write real information back */
+	for (i = 0; i < array_size; i++) {
+		mutex_init(&g_hif_sdio_ds_info_list[i].lock);
+		clt_info_size = ARRAY_SIZE(g_hif_sdio_ds_info_list[i].clt_info);
+
+		mutex_lock(&g_hif_sdio_ds_info_list[i].lock);
+		for (j = 0; j < clt_info_size; j++)
+			memset(&g_hif_sdio_ds_info_list[i].clt_info[j],
+					0, sizeof(MTK_WCN_HIF_SDIO_DS_CLT_INFO));
+		mutex_unlock(&g_hif_sdio_ds_info_list[i].lock);
+
+		hif_sdio_deep_sleep_info_dmp(&g_hif_sdio_ds_info_list[i]);
+	}
+
+	return 0;
+}
+
+static _osal_inline_ INT32 hif_sdio_deep_sleep_info_set_act(UINT32 chipid, UINT16 func_num,
+					       MTK_WCN_HIF_SDIO_CLTCTX ctx, UINT8 act_flag)
+{
+	UINT32 i = 0;
+	UINT32 array_size = 0;
+	UINT32 clt_info_size = 0;
+	UINT32 idx = 0;
+	MTK_WCN_HIF_SDIO_DS_CLT_INFO *p_ds_clt_info = NULL;
+
+	array_size = ARRAY_SIZE(g_hif_sdio_ds_info_list);
+
+	/*search write index */
+	for (i = 0; i < array_size; i++) {
+		if (g_hif_sdio_ds_info_list[i].chip_id == chipid)
+			break;
+	}
+	if (i >= array_size) {
+		HIF_SDIO_WARN_FUNC("no valid ds info found for 0x%x\n", chipid);
+		return -1;
+	}
+	HIF_SDIO_DBG_FUNC("valid ds info found for 0x%x\n", chipid);
+
+	clt_info_size = ARRAY_SIZE(g_hif_sdio_ds_info_list[i].clt_info);
+
+	if (func_num > clt_info_size) {
+		HIF_SDIO_WARN_FUNC("func num <%d> exceed max clt info size <%d>\n", func_num,
+				   clt_info_size);
+		return -2;
+	}
+	idx = func_num - 1;
+	p_ds_clt_info = &g_hif_sdio_ds_info_list[i].clt_info[idx];
+
+	mutex_lock(&g_hif_sdio_ds_info_list[i].lock);
+	p_ds_clt_info->func_num = func_num;
+	p_ds_clt_info->ctx = ctx;
+	p_ds_clt_info->act_flag = act_flag;
+	p_ds_clt_info->ds_en_flag = 0;
+	mutex_unlock(&g_hif_sdio_ds_info_list[i].lock);
+
+	HIF_SDIO_DBG_FUNC("set act_flag to %d for ctx:0x%x whose chipid:0x%x, func_num:%d done\n",
+			   act_flag, ctx, chipid, func_num);
+	/* hif_sdio_deep_sleep_info_dmp(&g_hif_sdio_ds_info_list[0]); */
+
+	return 0;
+}
+
+static INT32 _hif_sdio_wake_up_ctrl(MTK_WCN_HIF_SDIO_CLTCTX ctx)
+{
+	INT32 ret = 0;
+	INT32 gpio_state = -1;
+	INT32 sec_old = 0;
+	INT32 usec_old = 0;
+	INT32 sec = 0;
+	INT32 usec = 0;
+	INT32 polling_counter = 0;
+	UINT8 cccr_value = 0x0;
+	UINT32 cpupcr_value = 0x00;
+	INT32 i = 0;
+	UINT32 delay_us = 500;
+	WMT_GPIO_STATE_INFO gpio_state_list[2];
+
+	HIF_SDIO_DBG_FUNC("wakeup  chip from deep sleep!\n");
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_CHIP_WAKE_UP_PIN].gpio_num != DEFAULT_PIN_ID) {
+		gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_CHIP_WAKE_UP_PIN].gpio_num, 1);
+		HIF_SDIO_DBG_FUNC("wmt_gpio:set GPIO_CHIP_WAKE_UP_PIN out to 1: %d!\n",
+		gpio_get_value(gpio_ctrl_info.gpio_ctrl_state[GPIO_CHIP_WAKE_UP_PIN].gpio_num));
+	} else {
+		HIF_SDIO_ERR_FUNC("wmt_gpio:get GPIO_CHIP_WAKE_UP_PIN number error!\n");
+		return -2;
+	}
+	/*1.pull GPIO_CHIP_WAKE_UP_PIN  out 0*/
+	gpio_state_list[0].gpio_num =  gpio_ctrl_info.gpio_ctrl_state[GPIO_CHIP_WAKE_UP_PIN].gpio_num-280;
+	_wmt_gpio_pre_regs(gpio_state_list[0].gpio_num,  &gpio_state_list[0]);
+	gpio_state_list[1].gpio_num =  gpio_ctrl_info.gpio_ctrl_state[GPIO_CHIP_DEEP_SLEEP_PIN].gpio_num-280;
+	_wmt_gpio_pre_regs(gpio_state_list[1].gpio_num,  &gpio_state_list[1]);
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_CHIP_WAKE_UP_PIN].gpio_num != DEFAULT_PIN_ID) {
+		gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_CHIP_WAKE_UP_PIN].gpio_num, 0);
+		HIF_SDIO_DBG_FUNC("wmt_gpio:set GPIO_CHIP_WAKE_UP_PIN out to 0: %d!\n",
+			gpio_get_value(gpio_ctrl_info.gpio_ctrl_state[GPIO_CHIP_WAKE_UP_PIN].gpio_num));
+	} else {
+		HIF_SDIO_ERR_FUNC("wmt_gpio:get GPIO_CHIP_WAKE_UP_PIN number error!\n");
+		return -2;
+	}
+	/*2.waiting for DEEP_SLEEP_PIN   become high*/
+	osal_gettimeofday(&sec_old, &usec_old);
+	HIF_SDIO_DBG_FUNC("wakeup flow, prepare polling DEEP_SLEEP_PIN high state, timing: %d us\n", usec_old);
+	while (1) {
+		osal_gettimeofday(&sec, &usec);
+		gpio_state =
+			gpio_get_value(gpio_ctrl_info.gpio_ctrl_state[GPIO_CHIP_DEEP_SLEEP_PIN].gpio_num);
+		if (gpio_state == 0) {
+			HIF_SDIO_DBG_FUNC("wmt_gpio:Polling GPIO_CHIP_DEEP_SLEEP_PIN low success!\n");
+			if (polling_counter >= 20)
+				HIF_SDIO_WARN_FUNC
+					("polling ACK_B pin low success but over 20 count, time:%dus, count:%d\n",
+					(usec - usec_old), polling_counter);
+			polling_counter = 0;
+			break;
+		}
+		if (polling_counter >= 60) {
+			HIF_SDIO_ERR_FUNC
+				("wake up fail!, polling ACK_B pin low over 60 count, time:%dus, count:%d\n",
+				(usec - usec_old), polling_counter);
+			HIF_SDIO_INFO_FUNC("Dump EINT_B, ACT_B history states!\n");
+			_wmt_dump_gpio_pre_regs(gpio_state_list[0]);
+			_wmt_dump_gpio_pre_regs(gpio_state_list[1]);
+			HIF_SDIO_INFO_FUNC("Dump EINT_B, ACT_B current states!\n");
+			_wmt_dump_gpio_regs(gpio_state_list[0].gpio_num);
+			_wmt_dump_gpio_regs(gpio_state_list[1].gpio_num);
+
+			HIF_SDIO_INFO_FUNC("read cccr info !\n");
+			for (i = 0; i < 8; i++) {
+				ret = mtk_wcn_hif_sdio_f0_readb(ctx, CCCR_F8 + i, &cccr_value);
+			  if (ret)
+				  HIF_SDIO_ERR_FUNC("read CCCR fail(%d), address(0x%x)\n", ret, CCCR_F8 + i);
+			  else
+				  HIF_SDIO_INFO_FUNC("read CCCR value(0x%x), address(0x%x)\n",
+						   cccr_value, CCCR_F8 + i);
+			  cccr_value = 0x0;
+		  }
+
+			HIF_SDIO_INFO_FUNC("read cpupcr info !\n");
+			for (i = 0; i < 5; i++) {
+				ret = mtk_wcn_hif_sdio_readl(ctx, SWPCDBGR, &cpupcr_value);
+				if (ret)
+					HIF_SDIO_ERR_FUNC("read cpupcr fail, ret(%d)\n", ret);
+				else
+				HIF_SDIO_ERR_FUNC("read cpupcr value (0x%x)\n", cpupcr_value);
+				msleep(20);
+			}
+			_wmt_dump_gpio_regs(gpio_state_list[0].gpio_num);
+			_wmt_dump_gpio_regs(gpio_state_list[1].gpio_num);
+			ret = -11;
+			break;
+		}
+		polling_counter++;
+		osal_usleep_range(delay_us, 2 * delay_us);
+	}
+	/*3.pull GPIO_CHIP_WAKE_UP_PIN high, clear interrupt*/
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_CHIP_WAKE_UP_PIN].gpio_num != DEFAULT_PIN_ID) {
+		gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_CHIP_WAKE_UP_PIN].gpio_num, 1);
+		HIF_SDIO_DBG_FUNC("wmt_gpio:set GPIO_CHIP_WAKE_UP_PIN out to 1: %d!\n",
+			gpio_get_value(gpio_ctrl_info.gpio_ctrl_state[GPIO_CHIP_WAKE_UP_PIN].gpio_num));
+	} else {
+		HIF_SDIO_ERR_FUNC("wmt_gpio:get GPIO_CHIP_WAKE_UP_PIN number error!\n");
+		return -3;
+	}
+
+	return ret;
+}
+#ifdef CONFIG_MTK_COMBO_CHIP_DEEP_SLEEP_SUPPORT
+INT32 mtk_wcn_hif_sdio_deep_sleep_flag_set(MTK_WCN_BOOL flag)
+{
+	g_hif_deep_sleep_flag = flag;
+	return 0;
+}
+#endif
+INT32 hif_sdio_wake_up_ctrl(MTK_WCN_HIF_SDIO_CLTCTX ctx)
+{
+	UINT32 i = 0;
+	UINT32 j = 0;
+	INT32 ret = 0;
+	UINT32 array_size = 0;
+	UINT32 clt_info_size = 0;
+	MTK_WCN_HIF_SDIO_DS_CLT_INFO *p_ds_clt_info = NULL;
+	MTK_WCN_HIF_SDIO_DS_INFO *p_ds_info = NULL;
+	UINT8 do_ds_op_flag = 0;
+
+	array_size = ARRAY_SIZE(g_hif_sdio_ds_info_list);
+	/*search write index */
+	for (i = 0; i < array_size; i++) {
+		mutex_lock(&(g_hif_sdio_ds_info_list[i].lock));
+		clt_info_size = ARRAY_SIZE(g_hif_sdio_ds_info_list[i].clt_info);
+
+		for (j = 0; j < clt_info_size; j++) {
+			if (g_hif_sdio_ds_info_list[i].clt_info[j].ctx == ctx) {
+				do_ds_op_flag = 1;
+				break;
+			}
+		}
+
+		if (do_ds_op_flag != 0)
+			break;
+		mutex_unlock(&(g_hif_sdio_ds_info_list[i].lock));
+	}
+
+	if ((i >= array_size) || (j >= clt_info_size)) {
+		HIF_SDIO_ERR_FUNC("mtk_wcn_hif_sdio_wake_up_ctrl, no valid ds info found for ctx 0x%08x\n", ctx);
+		return -1;
+	}
+	HIF_SDIO_DBG_FUNC("mtk_wcn_hif_sdio_wake_up_ctrl, valid ds info found for ctx 0x%08x\n", ctx);
+	p_ds_info = &g_hif_sdio_ds_info_list[i];
+	p_ds_clt_info = &p_ds_info->clt_info[j];
+	HIF_SDIO_DBG_FUNC("mtk_wcn_hif_sdio_wake_up_ctrl, func_num:(%d), chid(%x)\n",
+		p_ds_clt_info->func_num, p_ds_info->chip_id);
+	if (g_hif_deep_sleep_flag) {
+		HIF_SDIO_DBG_FUNC("deep sleep feature is enable!\n");
+		ret = _hif_sdio_wake_up_ctrl(ctx);
+		if (ret == -11) {
+			HIF_SDIO_DBG_FUNC("wake up chip from deep sleep fail, retry wake up operation\n");
+			ret = _hif_sdio_wake_up_ctrl(ctx);
+			if (ret == 0)
+				HIF_SDIO_INFO_FUNC("retry wake up from deep sleep success\n");
+			else if (ret == -11)
+				HIF_SDIO_INFO_FUNC("retry wake up from deep sleep fail!\n");
+		}
+	} else
+		HIF_SDIO_DBG_FUNC("deep sleep feature is disable!\n");
+	mutex_unlock(&(g_hif_sdio_ds_info_list[i].lock));
+	return ret;
+}
+
+/*!
+ * \brief MTK hif sdio client registration function
+ *
+ * Client uses this function to register itself to hif_sdio driver
+ *
+ * \param pinfo a pointer of client's information
+ *
+ * \retval 0 register successfully
+ * \retval < 0 list error code here
+ */
+INT32 mtk_wcn_hif_sdio_client_reg(const MTK_WCN_HIF_SDIO_CLTINFO *pinfo)
+{
+	INT32 ret = -HIF_SDIO_ERR_FAIL;
+	INT32 clt_index = -1;
+	UINT32 i = 0;
+	UINT32 j = 0;
+	MTK_WCN_HIF_SDIO_CLT_PROBE_WORKERINFO *clt_probe_worker_info = 0;
+
+	HIF_SDIO_DBG_FUNC("start!\n");
+	/* 4 <1> check input pointer is valid */
+	HIF_SDIO_ASSERT(pinfo);
+
+	/* 4 <2> check if input parameters are all supported and valid */
+	for (i = 0; i < pinfo->func_tbl_size; i++) {
+		ret =
+		    hif_sdio_check_supported_sdio_id(pinfo->func_tbl[i].manf_id,
+						     pinfo->func_tbl[i].card_id);
+		if (ret) {
+			HIF_SDIO_WARN_FUNC
+			    ("vendor id(0x%x) and device id(0x%x) of sdio_func are not supported!\n",
+			     pinfo->func_tbl[i].manf_id, pinfo->func_tbl[i].card_id);
+			goto out;
+		}
+	}
+	HIF_SDIO_DBG_FUNC("hif_sdio_check_supported_sdio_id() done!\n");
+
+	/* 4 <3> check if the specific {manf id, card id, function number} tuple is */
+	/* 4 already resigstered */
+	for (i = 0; i < pinfo->func_tbl_size; i++) {
+		ret =
+		    hif_sdio_check_duplicate_sdio_id(pinfo->func_tbl[i].manf_id,
+						     pinfo->func_tbl[i].card_id,
+						     pinfo->func_tbl[i].func_num);
+		if (ret) {
+			HIF_SDIO_WARN_FUNC("vendor id(0x%x), device id(0x%x), and fun_num(%d) of\n",
+					pinfo->func_tbl[i].manf_id, pinfo->func_tbl[i].card_id,
+					pinfo->func_tbl[i].func_num);
+			HIF_SDIO_WARN_FUNC("sdio_func are duplicated in g_hif_sdio_clt_drv_list!\n");
+			goto out;
+		}
+	}
+	HIF_SDIO_DBG_FUNC("hif_sdio_check_duplicate_sdio_id() done!\n");
+
+	/*
+	 * 4 <4> add the specified {manf id, card id, function number}
+	 * tuple to registered client list
+	 */
+	HIF_SDIO_DBG_FUNC("pinfo->func_tbl_size:%d\n", pinfo->func_tbl_size);
+	for (i = 0; i < pinfo->func_tbl_size; i++) {
+		ret = hif_sdio_add_clt_list(&clt_index, pinfo, i);
+		if (ret) {
+			HIF_SDIO_WARN_FUNC
+			    ("client's info are added in registed client list failed (buffer is full)!\n");
+			goto out;
+		}
+		HIF_SDIO_DBG_FUNC("hif_sdio_add_clt_list() done (gRefCount=%d)!\n", gRefCount);
+
+		/* 4 <5> if the specific {manf id, card id, function number} tuple has already */
+		/* 4 been probed by mmc, schedule another task to call client's .hif_clt_probe() */
+		for (j = 0; j < CFG_CLIENT_COUNT; j++) {
+			/* probed spin lock */
+			spin_lock_bh(&g_hif_sdio_lock_info.probed_list_lock);
+			if (g_hif_sdio_probed_func_list[j].func == 0) {
+				/* probed spin unlock */
+				spin_unlock_bh(&g_hif_sdio_lock_info.probed_list_lock);
+				continue;
+			}
+			/* the function has been probed */
+			if ((g_hif_sdio_clt_drv_list[clt_index].func_info->manf_id ==
+			     g_hif_sdio_probed_func_list[j].func->vendor)
+			    && (g_hif_sdio_clt_drv_list[clt_index].func_info->card_id ==
+				g_hif_sdio_probed_func_list[j].func->device)
+			    && (g_hif_sdio_clt_drv_list[clt_index].func_info->func_num ==
+				g_hif_sdio_probed_func_list[j].func->num)) {
+				g_hif_sdio_probed_func_list[j].clt_idx = clt_index;
+				/* probed spin unlock */
+				spin_unlock_bh(&g_hif_sdio_lock_info.probed_list_lock);
+				if (g_hif_sdio_probed_func_list[j].func->num != 1
+					|| (g_hif_sdio_probed_func_list[j].on_by_wmt == MTK_WCN_BOOL_TRUE
+					&& g_hif_sdio_probed_func_list[j].func->num == 1)) {
+					/* use worker thread to perform the client's .hif_clt_probe() */
+					clt_probe_worker_info =
+						vmalloc(sizeof(MTK_WCN_HIF_SDIO_CLT_PROBE_WORKERINFO));
+					if (clt_probe_worker_info) {
+						INIT_WORK(&clt_probe_worker_info->probe_work,
+							  hif_sdio_clt_probe_worker);
+						clt_probe_worker_info->registinfo_p =
+							&g_hif_sdio_clt_drv_list[clt_index];
+						clt_probe_worker_info->probe_idx = j;
+						schedule_work(&clt_probe_worker_info->probe_work);
+					}
+					/* 4 <5.1> remember to do claim_irq for the */
+					/* func if it's irq had been released. */
+					if (!(g_hif_sdio_probed_func_list[j].func->irq_handler)) {
+						sdio_claim_host(g_hif_sdio_probed_func_list[j].func);
+						ret =
+							sdio_claim_irq(g_hif_sdio_probed_func_list[j].func,
+								   hif_sdio_irq);
+						mtk_wcn_hif_sdio_irq_flag_set(1);
+						sdio_release_host(g_hif_sdio_probed_func_list[j].func);
+						HIF_SDIO_INFO_FUNC
+							("sdio_claim_irq for func(0x%p) j(%d) v(0x%x) d(0x%x) ok\n",
+							 g_hif_sdio_probed_func_list[j].func, j,
+							 g_hif_sdio_probed_func_list[j].func->vendor,
+							 g_hif_sdio_probed_func_list[j].func->device);
+					}
+					/* 4 <5.2> Reset the block size of the function provided by client */
+					HIF_SDIO_INFO_FUNC("Reset sdio block size: %d!\n",
+							   g_hif_sdio_clt_drv_list[clt_index].
+							   func_info->blk_sz);
+					sdio_claim_host(g_hif_sdio_probed_func_list[j].func);
+					ret = sdio_set_block_size(g_hif_sdio_probed_func_list[j].func,
+								  g_hif_sdio_clt_drv_list
+								  [clt_index].func_info->blk_sz);
+					sdio_release_host(g_hif_sdio_probed_func_list[j].func);
+				}
+			} else {
+				/* probed spin unlock */
+				spin_unlock_bh(&g_hif_sdio_lock_info.probed_list_lock);
+			}
+		}
+		HIF_SDIO_DBG_FUNC
+		    ("map g_hif_sdio_clt_drv_list to g_hif_sdio_probed_func_list done!\n");
+	}
+	ret = HIF_SDIO_ERR_SUCCESS;
+	gRefCount++;
+
+out:
+	/* 4 <last> error handling */
+
+	HIF_SDIO_DBG_FUNC("end!\n");
+	return ret;
+}				/* end of mtk_wcn_hif_sdio_client_reg() */
+EXPORT_SYMBOL(mtk_wcn_hif_sdio_client_reg);
+
+/*!
+ * \brief MTK hif sdio client un-registration function
+ *
+ * Client uses this function to un-register itself
+ *
+ * \param pinfo a pointer of client's information
+ *
+ * \retval 0    register successfully
+ * \retval < 0  list error code here
+ */
+INT32 mtk_wcn_hif_sdio_client_unreg(const MTK_WCN_HIF_SDIO_CLTINFO *pinfo)
+{
+	INT32 ret = -HIF_SDIO_ERR_FAIL;
+	INT32 clt_list_index = 0;
+	UINT32 i = 0;
+	UINT32 j = 0;
+
+	HIF_SDIO_INFO_FUNC("start!\n");
+
+	/* 4 <1> check if input pointer is valid */
+	HIF_SDIO_ASSERT(pinfo);
+
+	/* 4 <2> check if input parameters are all supported and valid */
+	for (i = 0; i < pinfo->func_tbl_size; i++) {
+		ret =
+		    hif_sdio_check_supported_sdio_id(pinfo->func_tbl[i].manf_id,
+						     pinfo->func_tbl[i].card_id);
+		if (ret) {
+			HIF_SDIO_WARN_FUNC
+			    ("vendor id(0x%x) and device id(0x%x) of sdio_func are not supported in mtk_sdio_id_tbl!\n",
+			     pinfo->func_tbl[i].manf_id, pinfo->func_tbl[i].card_id);
+			goto out;
+		}
+	}
+
+	/* 4 <3> check if the specific {manf id, card id, function number} tuple is already resigstered */
+	/* 4 and find the corresponding client ctx and call client's .hif_clt_remove() in THIS context */
+	for (i = 0; i < pinfo->func_tbl_size; i++) {
+		clt_list_index =
+		    hif_sdio_find_clt_list_index(pinfo->func_tbl[i].manf_id,
+						 pinfo->func_tbl[i].card_id,
+						 pinfo->func_tbl[i].func_num);
+		if (clt_list_index < 0) {
+			HIF_SDIO_WARN_FUNC("vendor id(0x%x),", pinfo->func_tbl[i].manf_id);
+			HIF_SDIO_WARN_FUNC(" device id(0x%x),", pinfo->func_tbl[i].card_id);
+			HIF_SDIO_WARN_FUNC(" and fun_num(%d)", pinfo->func_tbl[i].func_num);
+			HIF_SDIO_WARN_FUNC(" client info is not in the client's registed list!\n");
+			ret = -HIF_SDIO_ERR_FAIL;
+			goto out;
+		}
+		/* 4 <4> mark the specified {manf id, card id, function number} tuple as */
+		/* 4 un-registered and invalidate client's context */
+		hif_sdio_init_clt_list(clt_list_index);
+
+		/* un-map g_hif_sdio_clt_drv_list index in g_hif_sdio_probed_func_list */
+		for (j = 0; j < CFG_CLIENT_COUNT; j++) {
+			if (g_hif_sdio_probed_func_list[j].clt_idx == clt_list_index)
+				g_hif_sdio_probed_func_list[j].clt_idx = -1;
+		}
+	}
+	gRefCount--;
+
+	ret = HIF_SDIO_ERR_SUCCESS;
+out:
+	HIF_SDIO_INFO_FUNC("end (gRefCount=%d) !\n", gRefCount);
+	return ret;
+}				/* end of mtk_wcn_hif_sdio_client_unreg() */
+EXPORT_SYMBOL(mtk_wcn_hif_sdio_client_unreg);
+
+/*!
+ * \brief
+ *
+ * detailed descriptions
+ *
+ * \param ctx client's context variable
+ *
+ * \retval 0    register successfully
+ * \retval < 0  list error code here
+ */
+INT32 mtk_wcn_hif_sdio_readb(MTK_WCN_HIF_SDIO_CLTCTX ctx, UINT32 offset, PUINT8 pvb)
+{
+#if HIF_SDIO_UPDATE
+	INT32 ret;
+	struct sdio_func *func = NULL;
+#else
+	INT32 ret = -HIF_SDIO_ERR_FAIL;
+	INT32 probe_index = -1;
+	struct sdio_func *func = 0;
+#endif
+
+	HIF_SDIO_DBG_FUNC("start!\n");
+	HIF_SDIO_ASSERT(pvb);
+
+	/* 4 <1> check if ctx is valid, registered, and probed */
+#if HIF_SDIO_UPDATE
+	ret = -HIF_SDIO_ERR_FAIL;
+	func = hif_sdio_ctx_to_func(ctx);
+	if (!func) {
+		ret = -HIF_SDIO_ERR_FAIL;
+		goto out;
+	}
+#else
+	probe_index = CLTCTX_IDX(ctx);
+	if (unlikely(!CLTCTX_IDX_VALID(probe_index))) {	/* invalid index in CLTCTX */
+		HIF_SDIO_WARN_FUNC("invalid ctx(0x%x)\n", ctx);
+		goto out;
+	}
+	if (probe_index < 0 || probe_index >= CFG_CLIENT_COUNT) {	/* the function has not been probed */
+		HIF_SDIO_WARN_FUNC("can't find client in probed list!\n");
+		ret = -HIF_SDIO_ERR_FAIL;
+		goto out;
+	} else {
+		if (g_hif_sdio_probed_func_list[probe_index].clt_idx < 0) {	/* the client has not been registered */
+			HIF_SDIO_WARN_FUNC("can't find client in registered list!\n");
+			ret = -HIF_SDIO_ERR_FAIL;
+			goto out;
+		}
+	}
+	func = g_hif_sdio_probed_func_list[probe_index].func;
+#endif
+
+	/* 4 <2> */
+	osal_ftrace_print("%s|S\n", __func__);
+	sdio_claim_host(func);
+	*pvb = sdio_readb(func, offset, &ret);
+	sdio_release_host(func);
+	osal_ftrace_print("%s|E\n", __func__);
+
+	/* 4 <3> check result code and return proper error code */
+
+out:
+	HIF_SDIO_DBG_FUNC("end!\n");
+	return ret;
+}				/* end of mtk_wcn_hif_sdio_client_unreg() */
+EXPORT_SYMBOL(mtk_wcn_hif_sdio_readb);
+
+/*!
+ * \brief
+ *
+ * detailed descriptions
+ *
+ * \param ctx client's context variable
+ *
+ * \retval 0    register successfully
+ * \retval < 0  list error code here
+ */
+INT32 mtk_wcn_hif_sdio_writeb(MTK_WCN_HIF_SDIO_CLTCTX ctx, UINT32 offset, UINT8 vb)
+{
+#if HIF_SDIO_UPDATE
+	INT32 ret;
+	struct sdio_func *func = NULL;
+#else
+	INT32 ret = -HIF_SDIO_ERR_FAIL;
+	INT32 probe_index = -1;
+	struct sdio_func *func = 0;
+#endif
+
+	HIF_SDIO_DBG_FUNC("start!\n");
+
+	/* 4 <1> check if ctx is valid, registered, and probed */
+#if HIF_SDIO_UPDATE
+	ret = -HIF_SDIO_ERR_FAIL;
+	func = hif_sdio_ctx_to_func(ctx);
+	if (!func) {
+		ret = -HIF_SDIO_ERR_FAIL;
+		goto out;
+	}
+#else
+	probe_index = CLTCTX_IDX(ctx);
+	if (unlikely(!CLTCTX_IDX_VALID(probe_index))) {	/* invalid index in CLTCTX */
+		HIF_SDIO_WARN_FUNC("invalid ctx(0x%x)\n", ctx);
+		goto out;
+	}
+	if (probe_index < 0 || probe_index >= CFG_CLIENT_COUNT) {	/* the function has not been probed */
+		HIF_SDIO_WARN_FUNC("can't find client in probed list!\n");
+		ret = -HIF_SDIO_ERR_FAIL;
+		goto out;
+	} else {
+		if (g_hif_sdio_probed_func_list[probe_index].clt_idx < 0) {	/* the client has not been registered */
+			HIF_SDIO_WARN_FUNC("can't find client in registered list!\n");
+			ret = -HIF_SDIO_ERR_FAIL;
+			goto out;
+		}
+	}
+	func = g_hif_sdio_probed_func_list[probe_index].func;
+#endif
+
+	/* 4 <1.1> check if input parameters are valid */
+
+	/* 4 <2> */
+	wmt_tra_sdio_update();
+	osal_ftrace_print("%s|S\n", __func__);
+	sdio_claim_host(func);
+	sdio_writeb(func, vb, offset, &ret);
+	sdio_release_host(func);
+	osal_ftrace_print("%s|E\n", __func__);
+
+	/* 4 <3> check result code and return proper error code */
+
+out:
+	HIF_SDIO_DBG_FUNC("end!\n");
+	return ret;
+}				/* end of mtk_wcn_hif_sdio_client_unreg() */
+EXPORT_SYMBOL(mtk_wcn_hif_sdio_writeb);
+
+/*!
+ * \brief
+ *
+ * detailed descriptions
+ *
+ * \param ctx client's context variable
+ *
+ * \retval 0    register successfully
+ * \retval < 0  list error code here
+ */
+INT32 mtk_wcn_hif_sdio_readl(MTK_WCN_HIF_SDIO_CLTCTX ctx, UINT32 offset, PUINT32 pvl)
+{
+#if HIF_SDIO_UPDATE
+	INT32 ret;
+	struct sdio_func *func = NULL;
+#else
+	INT32 ret = -HIF_SDIO_ERR_FAIL;
+	INT32 probe_index = -1;
+	struct sdio_func *func = 0;
+#endif
+
+	HIF_SDIO_DBG_FUNC("start!\n");
+	HIF_SDIO_ASSERT(pvl);
+
+	/* 4 <1> check if ctx is valid, registered, and probed */
+#if HIF_SDIO_UPDATE
+	ret = -HIF_SDIO_ERR_FAIL;
+	func = hif_sdio_ctx_to_func(ctx);
+	if (!func) {
+		ret = -HIF_SDIO_ERR_FAIL;
+		goto out;
+	}
+#else
+	probe_index = CLTCTX_IDX(ctx);
+	if (unlikely(!CLTCTX_IDX_VALID(probe_index))) {	/* invalid index in CLTCTX */
+		HIF_SDIO_WARN_FUNC("invalid ctx(0x%x)\n", ctx);
+		goto out;
+	}
+	if (probe_index < 0 || probe_index >= CFG_CLIENT_COUNT) {	/* the function has not been probed */
+		HIF_SDIO_WARN_FUNC("can't find client in probed list!\n");
+		ret = -HIF_SDIO_ERR_FAIL;
+		goto out;
+	} else {
+		if (g_hif_sdio_probed_func_list[probe_index].clt_idx < 0) {	/* the client has not been registered */
+			HIF_SDIO_WARN_FUNC("can't find client in registered list!\n");
+			ret = -HIF_SDIO_ERR_FAIL;
+			goto out;
+		}
+	}
+	func = g_hif_sdio_probed_func_list[probe_index].func;
+#endif
+	/* 4 <1.1> check if input parameters are valid */
+
+	/* 4 <2> */
+	osal_ftrace_print("%s|S\n", __func__);
+	sdio_claim_host(func);
+	*pvl = sdio_readl(func, offset, &ret);
+	sdio_release_host(func);
+	osal_ftrace_print("%s|E\n", __func__);
+
+	/* 4 <3> check result code and return proper error code */
+
+out:
+	HIF_SDIO_DBG_FUNC("end!\n");
+	return ret;
+}				/* end of mtk_wcn_hif_sdio_client_unreg() */
+EXPORT_SYMBOL(mtk_wcn_hif_sdio_readl);
+
+/*!
+ * \brief
+ *
+ * detailed descriptions
+ *
+ * \param ctx client's context variable
+ *
+ * \retval 0    register successfully
+ * \retval < 0  list error code here
+ */
+INT32 mtk_wcn_hif_sdio_writel(MTK_WCN_HIF_SDIO_CLTCTX ctx, UINT32 offset, UINT32 vl)
+{
+#if HIF_SDIO_UPDATE
+	INT32 ret;
+	struct sdio_func *func = NULL;
+#else
+	INT32 ret = -HIF_SDIO_ERR_FAIL;
+	INT32 probe_index = -1;
+	struct sdio_func *func = 0;
+#endif
+
+	HIF_SDIO_DBG_FUNC("start!\n");
+
+	/* 4 <1> check if ctx is valid, registered, and probed */
+#if HIF_SDIO_UPDATE
+	ret = -HIF_SDIO_ERR_FAIL;
+	func = hif_sdio_ctx_to_func(ctx);
+	if (!func) {
+		ret = -HIF_SDIO_ERR_FAIL;
+		goto out;
+	}
+#else
+	probe_index = CLTCTX_IDX(ctx);
+	if (unlikely(!CLTCTX_IDX_VALID(probe_index))) {	/* invalid index in CLTCTX */
+		HIF_SDIO_WARN_FUNC("invalid ctx(0x%x)\n", ctx);
+		goto out;
+	}
+	if (probe_index < 0 || probe_index >= CFG_CLIENT_COUNT) {	/* the function has not been probed */
+		HIF_SDIO_WARN_FUNC("can't find client in probed list!\n");
+		ret = -HIF_SDIO_ERR_FAIL;
+		goto out;
+	} else {
+		if (g_hif_sdio_probed_func_list[probe_index].clt_idx < 0) {	/* the client has not been registered */
+			HIF_SDIO_WARN_FUNC("can't find client in registered list!\n");
+			ret = -HIF_SDIO_ERR_FAIL;
+			goto out;
+		}
+	}
+	func = g_hif_sdio_probed_func_list[probe_index].func;
+#endif
+	/* 4 <1.1> check if input parameters are valid */
+
+	/* 4 <2> */
+	wmt_tra_sdio_update();
+	osal_ftrace_print("%s|S\n", __func__);
+	sdio_claim_host(func);
+	sdio_writel(func, vl, offset, &ret);
+	sdio_release_host(func);
+	osal_ftrace_print("%s|E\n", __func__);
+
+	/* 4 <3> check result code and return proper error code */
+
+out:
+	HIF_SDIO_DBG_FUNC("end!\n");
+	return ret;
+}				/* end of mtk_wcn_hif_sdio_client_unreg() */
+EXPORT_SYMBOL(mtk_wcn_hif_sdio_writel);
+
+/*!
+ * \brief
+ *
+ * detailed descriptions
+ *
+ * \param ctx client's context variable
+ *
+ * \retval 0    register successfully
+ * \retval < 0  list error code here
+ */
+INT32 mtk_wcn_hif_sdio_read_buf(MTK_WCN_HIF_SDIO_CLTCTX ctx,
+				UINT32 offset, PUINT32 pbuf, UINT32 len)
+{
+#if HIF_SDIO_UPDATE
+	INT32 ret;
+	struct sdio_func *func = NULL;
+#else
+	INT32 ret = -HIF_SDIO_ERR_FAIL;
+	INT32 probe_index = -1;
+	struct sdio_func *func = 0;
+#endif
+
+	HIF_SDIO_DBG_FUNC("start!\n");
+	HIF_SDIO_ASSERT(pbuf);
+
+	/* 4 <1> check if ctx is valid, registered, and probed */
+#if HIF_SDIO_UPDATE
+	ret = -HIF_SDIO_ERR_FAIL;
+	func = hif_sdio_ctx_to_func(ctx);
+	if (!func) {
+		ret = -HIF_SDIO_ERR_FAIL;
+		goto out;
+	}
+#else
+	probe_index = CLTCTX_IDX(ctx);
+	if (unlikely(!CLTCTX_IDX_VALID(probe_index))) {	/* invalid index in CLTCTX */
+		HIF_SDIO_WARN_FUNC("invalid ctx(0x%x)\n", ctx);
+		goto out;
+	}
+	if (probe_index < 0 || probe_index >= CFG_CLIENT_COUNT) {	/* the function has not been probed */
+		HIF_SDIO_WARN_FUNC("can't find client in probed list!\n");
+		ret = -HIF_SDIO_ERR_FAIL;
+		goto out;
+	} else {
+		if (g_hif_sdio_probed_func_list[probe_index].clt_idx < 0) {	/* the client has not been registered */
+			HIF_SDIO_WARN_FUNC("can't find client in registered list!\n");
+			ret = -HIF_SDIO_ERR_FAIL;
+			goto out;
+		}
+	}
+	func = g_hif_sdio_probed_func_list[probe_index].func;
+#endif
+	/* 4 <1.1> check if input parameters are valid */
+
+	/* 4 <2> */
+	osal_ftrace_print("%s|S|L|%d\n", __func__, len);
+	sdio_claim_host(func);
+	ret = sdio_readsb(func, pbuf, offset, len);
+	sdio_release_host(func);
+	osal_ftrace_print("%s|E|L|%d\n", __func__, len);
+
+	/* 4 <3> check result code and return proper error code */
+
+out:
+	HIF_SDIO_DBG_FUNC("end!\n");
+	return ret;
+}				/* end of mtk_wcn_hif_sdio_read_buf() */
+EXPORT_SYMBOL(mtk_wcn_hif_sdio_read_buf);
+
+
+/*!
+ * \brief
+ *
+ * detailed descriptions
+ *
+ * \param ctx client's context variable
+ *
+ * \retval 0    register successfully
+ * \retval < 0  list error code here
+ */
+INT32 mtk_wcn_hif_sdio_write_buf(MTK_WCN_HIF_SDIO_CLTCTX ctx,
+				 UINT32 offset, PUINT32 pbuf, UINT32 len)
+{
+#if HIF_SDIO_UPDATE
+	INT32 ret;
+	struct sdio_func *func = NULL;
+#else
+	INT32 ret = -HIF_SDIO_ERR_FAIL;
+	INT32 probe_index = -1;
+	struct sdio_func *func = 0;
+#endif
+
+	HIF_SDIO_DBG_FUNC("start!\n");
+	HIF_SDIO_ASSERT(pbuf);
+
+	/* 4 <1> check if ctx is valid, registered, and probed */
+#if HIF_SDIO_UPDATE
+	ret = -HIF_SDIO_ERR_FAIL;
+	func = hif_sdio_ctx_to_func(ctx);
+	if (!func) {
+		ret = -HIF_SDIO_ERR_FAIL;
+		goto out;
+	}
+#else
+	probe_index = CLTCTX_IDX(ctx);
+	if (unlikely(!CLTCTX_IDX_VALID(probe_index))) {	/* invalid index in CLTCTX */
+		HIF_SDIO_WARN_FUNC("invalid ctx(0x%x)\n", ctx);
+		goto out;
+	}
+	if (probe_index < 0 || probe_index >= CFG_CLIENT_COUNT) {	/* the function has not been probed */
+		HIF_SDIO_WARN_FUNC("can't find client in probed list!\n");
+		ret = -HIF_SDIO_ERR_FAIL;
+		goto out;
+	} else {
+		if (g_hif_sdio_probed_func_list[probe_index].clt_idx < 0) {	/* the client has not been registered */
+			HIF_SDIO_WARN_FUNC("can't find client in registered list!\n");
+			ret = -HIF_SDIO_ERR_FAIL;
+			goto out;
+		}
+	}
+	func = g_hif_sdio_probed_func_list[probe_index].func;
+#endif
+	/* 4 <1.1> check if input parameters are valid */
+
+	/* 4 <2> */
+	wmt_tra_sdio_update();
+	osal_ftrace_print("%s|S|L|%d\n", __func__, len);
+	sdio_claim_host(func);
+	ret = sdio_writesb(func, offset, pbuf, len);
+	sdio_release_host(func);
+	osal_ftrace_print("%s|E|L|%d\n", __func__, len);
+
+	/* 4 <3> check result code and return proper error code */
+
+out:
+	HIF_SDIO_DBG_FUNC("ret(%d) end!\n", ret);
+
+	return ret;
+}				/* end of mtk_wcn_hif_sdio_write_buf() */
+EXPORT_SYMBOL(mtk_wcn_hif_sdio_write_buf);
+
+/*!
+ * \brief
+ *
+ * detailed descriptions
+ *
+ * \param ctx client's context variable
+ *
+ * \retval 0    register successfully
+ * \retval < 0  list error code here
+ */
+INT32 mtk_wcn_hif_sdio_abort(MTK_WCN_HIF_SDIO_CLTCTX ctx)
+{
+#if HIF_SDIO_UPDATE
+	INT32 ret;
+	struct sdio_func *func = NULL;
+#else
+	INT32 ret = -HIF_SDIO_ERR_FAIL;
+	INT32 probe_index = -1;
+	struct sdio_func *func = 0;
+#endif
+
+	HIF_SDIO_DBG_FUNC("start!\n");
+	HIF_SDIO_ASSERT(pbuf);
+
+	/* 4 <1> check if ctx is valid, registered, and probed */
+#if HIF_SDIO_UPDATE
+	ret = -HIF_SDIO_ERR_FAIL;
+	func = hif_sdio_ctx_to_func(ctx);
+	if (!func) {
+		ret = -HIF_SDIO_ERR_FAIL;
+		goto out;
+	}
+#else
+	probe_index = CLTCTX_IDX(ctx);
+	if (unlikely(!CLTCTX_IDX_VALID(probe_index))) {	/* invalid index in CLTCTX */
+		HIF_SDIO_WARN_FUNC("invalid ctx(0x%x)\n", ctx);
+		goto out;
+	}
+	if (probe_index < 0 || probe_index >= CFG_CLIENT_COUNT) {	/* the function has not been probed */
+		HIF_SDIO_WARN_FUNC("can't find client in probed list!\n");
+		ret = -HIF_SDIO_ERR_FAIL;
+		goto out;
+	} else {
+		if (g_hif_sdio_probed_func_list[probe_index].clt_idx < 0) {	/* the client has not been registered */
+			HIF_SDIO_WARN_FUNC("can't find client in registered list!\n");
+			ret = -HIF_SDIO_ERR_FAIL;
+			goto out;
+		}
+	}
+	func = g_hif_sdio_probed_func_list[probe_index].func;
+#endif
+	/* 4 <1.1> check if input parameters are valid */
+
+	/* 4 <2> */
+	osal_ftrace_print("%s|S|L|\n", __func__);
+	sdio_claim_host(func);
+	/* SDIO Control must be switched to function 2 before the abort command send
+	 * firmware can receive function 2 abort interrupt
+	 * read CTMDPCR1(0xBC) to switch function 2
+	 */
+	sdio_readl(func, 0xBC, &ret);
+	ret = KERNEL_mmc_io_rw_direct(func->card, 1, 0, SDIO_CCCR_ABORT, func->num, NULL);
+	sdio_release_host(func);
+	osal_ftrace_print("%s|E|L|\n", __func__);
+
+	/* 4 <3> check result code and return proper error code */
+
+out:
+	HIF_SDIO_DBG_FUNC("ret(%d) end!\n", ret);
+
+	return ret;
+}				/* end of mtk_wcn_hif_sdio_write_buf() */
+EXPORT_SYMBOL(mtk_wcn_hif_sdio_abort);
+
+/*!
+ * \brief store client driver's private data function.
+ *
+ *
+ * \param clent's MTK_WCN_HIF_SDIO_CLTCTX.
+ *
+ * \retval none.
+ */
+VOID mtk_wcn_hif_sdio_set_drvdata(MTK_WCN_HIF_SDIO_CLTCTX ctx, PVOID private_data_p)
+{
+	UINT8 probed_idx = CLTCTX_IDX(ctx);
+
+	if (unlikely(!CLTCTX_UIDX_VALID(probed_idx))) {	/* invalid index in CLTCTX */
+		HIF_SDIO_WARN_FUNC("invalid idx in ctx(0x%x), private_data_p not stored!\n", ctx);
+	} else {
+		/* store client driver's private data to dev driver */
+		g_hif_sdio_probed_func_list[probed_idx].private_data_p = private_data_p;
+		HIF_SDIO_DBG_FUNC("private_data_p(0x%p) for ctx(0x%x) probed idx(%d) stored!\n",
+				  private_data_p, ctx, probed_idx);
+	}
+}
+EXPORT_SYMBOL(mtk_wcn_hif_sdio_set_drvdata);
+
+/*!
+ * \brief get client driver's private data function.
+ *
+ *
+ * \param clent's MTK_WCN_HIF_SDIO_CLTCTX.
+ *
+ * \retval private data pointer.
+ */
+PVOID mtk_wcn_hif_sdio_get_drvdata(MTK_WCN_HIF_SDIO_CLTCTX ctx)
+{
+	UINT8 probed_idx = CLTCTX_IDX(ctx);
+
+	/* get client driver's private data to dev driver */
+	if (likely(CLTCTX_UIDX_VALID(probed_idx)))
+		return g_hif_sdio_probed_func_list[probed_idx].private_data_p;
+	/* invalid index in CLTCTX */
+	HIF_SDIO_WARN_FUNC("invalid idx in ctx(0x%x), return null!\n", ctx);
+	return NULL;
+}
+EXPORT_SYMBOL(mtk_wcn_hif_sdio_get_drvdata);
+
+/*!
+ * \brief control stp/wifi on/off from wmt.
+ *
+ *
+ * \param (1)control function type, (2)on/off control.
+ *
+ * \retval (1)control results ,(2)unknown type: -5.
+ * \retval 0:success, -11:not probed, -12:already on, -13:not registered, other errors.
+ */
+INT32 mtk_wcn_hif_sdio_wmt_control(WMT_SDIO_FUNC_TYPE func_type, MTK_WCN_BOOL is_on)
+{
+	/* TODO:[FixMe][George]: return value of this function shall distinguish */
+	/* 1) not probed by mmc_core yet or */
+	/* 2) probed by mmc_core but init fail... */
+	switch (func_type) {
+	case WMT_SDIO_FUNC_STP:
+		if (is_on == MTK_WCN_BOOL_TRUE)
+			return hif_sdio_stp_on();
+		else
+			return hif_sdio_stp_off();
+		break;
+
+	case WMT_SDIO_FUNC_WIFI:
+		if (is_on == MTK_WCN_BOOL_TRUE)
+			return hif_sdio_wifi_on();
+		else
+			return hif_sdio_wifi_off();
+		break;
+
+	default:
+		HIF_SDIO_WARN_FUNC("unknown type(%d)\n", func_type);
+		return HIF_SDIO_ERR_INVALID_PARAM;
+	}
+}
+EXPORT_SYMBOL(mtk_wcn_hif_sdio_wmt_control);
+
+/*!
+ * \brief ???
+ *
+ * \detail ???
+ *
+ * \param ctx a context provided by client driver
+ * \param struct device ** ???
+ *
+ * \retval none
+ */
+VOID mtk_wcn_hif_sdio_get_dev(MTK_WCN_HIF_SDIO_CLTCTX ctx, struct device **dev)
+{
+#if HIF_SDIO_UPDATE
+	struct sdio_func *func = NULL;
+#else
+	UINT8 probe_index = CLTCTX_IDX(ctx);
+#endif
+
+#if HIF_SDIO_UPDATE
+	*dev = NULL;		/* ensure we does not return any invalid value back. */
+	func = hif_sdio_ctx_to_func(ctx);
+	if (unlikely(!func)) {
+		HIF_SDIO_WARN_FUNC("no valid *func with ctx(0x%x)\n", ctx);
+		return;
+	}
+	*dev = &(func->dev);
+	HIF_SDIO_DBG_FUNC("return *dev(0x%p) for ctx(0x%x)\n", *dev, ctx);
+#else
+	if (probe_index < 0) {
+		HIF_SDIO_WARN_FUNC("func not probed, probe_index = %d", probe_index);
+		return;
+	}
+	*dev = &g_hif_sdio_probed_func_list[probe_index].func->dev;
+#endif
+}
+EXPORT_SYMBOL(mtk_wcn_hif_sdio_get_dev);
+
+/*!
+ * \brief client's probe() function.
+ *
+ *
+ * \param work queue structure.
+ *
+ * \retval none.
+ */
+static _osal_inline_ INT32 hif_sdio_clt_probe_func(MTK_WCN_HIF_SDIO_REGISTINFO *registinfo_p, INT8 probe_idx)
+{
+	UINT16 card_id = 0;
+	UINT16 func_num = 0;
+	UINT16 blk_sz = 0;
+	INT32 ret;
+
+	HIF_SDIO_DBG_FUNC("start!\n");
+	HIF_SDIO_ASSERT(registinfo_p);
+	if (!registinfo_p) {
+		HIF_SDIO_WARN_FUNC("registinfo_p NULL!!!\n");
+		return -1;
+	}
+
+	/* special case handling: if the clt's unregister is called during probe procedures */
+	if (!registinfo_p->func_info || !registinfo_p->sdio_cltinfo) {
+		HIF_SDIO_WARN_FUNC("client's registinfo_p is cleared !!!\n");
+		return -1;
+	}
+
+	card_id = registinfo_p->func_info->card_id;
+	func_num = registinfo_p->func_info->func_num;
+	blk_sz = registinfo_p->func_info->blk_sz;
+	ret =
+	    registinfo_p->sdio_cltinfo->hif_clt_probe(CLTCTX(card_id, func_num, blk_sz, probe_idx),
+						      registinfo_p->func_info);
+
+	HIF_SDIO_DBG_FUNC
+	    ("clt_probe_func card_id(%x) func_num(%x) blk_sz(%d) prob_idx(%x) ret(%d) %s\n",
+	     card_id, func_num, blk_sz, probe_idx, ret, (ret) ? "fail" : "ok");
+
+	return ret;
+}
+
+/*!
+ * \brief client's probe() worker.
+ *
+ *
+ * \param work queue structure.
+ *
+ * \retval none.
+ */
+static VOID hif_sdio_clt_probe_worker(struct work_struct *work)
+{
+	MTK_WCN_HIF_SDIO_CLT_PROBE_WORKERINFO *clt_worker_info_p = 0;
+	UINT16 card_id = 0;
+	UINT16 func_num = 0;
+	UINT16 blk_sz = 0;
+	INT8 prob_idx = 0;
+
+	HIF_SDIO_DBG_FUNC("start!\n");
+
+	HIF_SDIO_ASSERT(work);
+
+	/* get client's information */
+	clt_worker_info_p = container_of(work, MTK_WCN_HIF_SDIO_CLT_PROBE_WORKERINFO, probe_work);
+	HIF_SDIO_ASSERT(clt_worker_info_p);
+	HIF_SDIO_ASSERT(clt_worker_info_p->registinfo_p);
+
+	/* special case handling: if the clt's unregister is called during probe procedures */
+	if ((clt_worker_info_p->registinfo_p->func_info == 0)
+	    || (clt_worker_info_p->registinfo_p->sdio_cltinfo == 0)) {
+		HIF_SDIO_WARN_FUNC("client's registinfo_p is cleared !!!\n");
+		vfree(clt_worker_info_p);
+		return;
+	}
+
+	card_id = clt_worker_info_p->registinfo_p->func_info->card_id;
+	func_num = clt_worker_info_p->registinfo_p->func_info->func_num;
+	blk_sz = clt_worker_info_p->registinfo_p->func_info->blk_sz;
+	prob_idx = clt_worker_info_p->probe_idx;
+
+	/* Execute client's probe() func */
+	clt_worker_info_p->registinfo_p->
+	    sdio_cltinfo->hif_clt_probe(CLTCTX(card_id, func_num, blk_sz, prob_idx),
+					clt_worker_info_p->registinfo_p->func_info);
+
+	vfree(clt_worker_info_p);
+
+	HIF_SDIO_DBG_FUNC("card_id(0x%x) func_num(0x%x) blk_sz(0x%x) prob_idx(0x%x)\n", card_id,
+			  func_num, blk_sz, prob_idx);
+	HIF_SDIO_DBG_FUNC("end!\n");
+}
+
+/*!
+ * \brief client's probe() worker.
+ *
+ *
+ * \param work queue structure.
+ *
+ * \retval none.
+ */
+static _osal_inline_ VOID hif_sdio_dump_probe_list(VOID)
+{
+	INT32 i;
+
+	HIF_SDIO_DBG_FUNC("== DUMP probed list start ==\n");
+
+	for (i = 0; i < CFG_CLIENT_COUNT; i++) {
+		if (g_hif_sdio_probed_func_list[i].func) {
+			HIF_SDIO_DBG_FUNC("index(%d) func(0x%p) clt_idx(%d)\n",
+					  i, g_hif_sdio_probed_func_list[i].func,
+					  g_hif_sdio_probed_func_list[i].clt_idx);
+
+			HIF_SDIO_DBG_FUNC("vendor(0x%x) device(0x%x) num(0x%x) state(%d)\n",
+					  g_hif_sdio_probed_func_list[i].func->vendor,
+					  g_hif_sdio_probed_func_list[i].func->device,
+					  g_hif_sdio_probed_func_list[i].func->num,
+					  g_hif_sdio_probed_func_list[i].on_by_wmt);
+
+		}
+	}
+
+	HIF_SDIO_DBG_FUNC("== DUMP probed list end ==\n");
+}
+
+
+/*!
+ * \brief Initialize g_hif_sdio_probed_func_list
+ *
+ *
+ * \param index of g_hif_sdio_probed_func_list.
+ *
+ * \retval none.
+ */
+static _osal_inline_ VOID hif_sdio_init_probed_list(INT32 index)
+{
+	if ((index >= 0) && (index < CFG_CLIENT_COUNT)) {
+		/* probed spin lock */
+		spin_lock_bh(&g_hif_sdio_lock_info.probed_list_lock);
+		g_hif_sdio_probed_func_list[index].func = 0;
+		g_hif_sdio_probed_func_list[index].clt_idx = -1;
+		g_hif_sdio_probed_func_list[index].private_data_p = 0;
+		g_hif_sdio_probed_func_list[index].on_by_wmt = MTK_WCN_BOOL_FALSE;
+		/* probed spin unlock */
+		spin_unlock_bh(&g_hif_sdio_lock_info.probed_list_lock);
+	} else
+		HIF_SDIO_ERR_FUNC("index is out of g_hif_sdio_probed_func_list[] boundary!\n");
+}
+
+
+/*!
+ * \brief Initialize g_hif_sdio_clt_drv_list
+ *
+ *
+ * \param index of g_hif_sdio_clt_drv_list.
+ *
+ * \retval none.
+ */
+static _osal_inline_ VOID hif_sdio_init_clt_list(INT32 index)
+{
+	/* client list spin lock */
+	spin_lock_bh(&g_hif_sdio_lock_info.clt_list_lock);
+	if ((index >= 0) && (index < CFG_CLIENT_COUNT)) {
+		g_hif_sdio_clt_drv_list[index].sdio_cltinfo = 0;
+		g_hif_sdio_clt_drv_list[index].func_info = 0;
+	} else
+		HIF_SDIO_ERR_FUNC("index is out of g_hif_sdio_clt_drv_list[] boundary!\n");
+	/* client list spin unlock */
+	spin_unlock_bh(&g_hif_sdio_lock_info.clt_list_lock);
+}
+
+
+/*!
+ * \brief find matched g_hif_sdio_probed_func_list index from sdio function handler
+ *
+ *
+ * \param sdio function handler
+ *
+ * \retval -1    index not found
+ * \retval >= 0  return found index
+ */
+static _osal_inline_ INT32 hif_sdio_find_probed_list_index_by_func(struct sdio_func *func)
+{
+	INT32 i = 0;
+
+	HIF_SDIO_ASSERT(func);
+
+	for (i = 0; i < CFG_CLIENT_COUNT; i++) {
+		if (g_hif_sdio_probed_func_list[i].func == func)
+			return i;
+	}
+
+	return -1;
+}
+
+/*!
+ * \brief find matched g_hif_sdio_probed_func_list from vendor_id, device_id, and function number
+ *
+ *
+ * \param vendor id, device id, and function number of the sdio card.
+ *
+ * \retval -1    index not found
+ * \retval >= 0  return found index
+ */
+static _osal_inline_ INT32 hif_sdio_find_probed_list_index_by_id_func(UINT16 vendor, UINT16 device,
+							UINT16 func_num)
+{
+	INT32 i;
+
+	for (i = 0; i < CFG_CLIENT_COUNT; i++) {
+		if (g_hif_sdio_probed_func_list[i].func) {
+			HIF_SDIO_DBG_FUNC("probed entry: vendor(0x%x) device(0x%x) num(0x%x)\n",
+					  g_hif_sdio_probed_func_list[i].func->vendor,
+					  g_hif_sdio_probed_func_list[i].func->device,
+					  g_hif_sdio_probed_func_list[i].func->num);
+		}
+	}
+	for (i = 0; i < CFG_CLIENT_COUNT; i++) {
+		if (!g_hif_sdio_probed_func_list[i].func) {
+			continue;
+		} else if ((g_hif_sdio_probed_func_list[i].func->vendor == vendor) &&
+			   (g_hif_sdio_probed_func_list[i].func->device == device) &&
+			   (g_hif_sdio_probed_func_list[i].func->num == func_num)) {
+			return i;
+		}
+	}
+
+	if (i == CFG_CLIENT_COUNT) {
+		/*
+		 * pr_warn(DRV_NAME "Cannot find vendor:0x%x, device:0x%x, func_num:0x%x, i=%d\n",
+		 * vendor, device, func_num, i);
+		 */
+		/* client func has not been probed */
+		return -1;
+	}
+	return -1;
+}
+
+/*!
+ * \brief find matched g_hif_sdio_clt_drv_list index
+ *
+ * find the matched g_hif_sdio_clt_drv_list index from card_id and function number.
+ *
+ * \param vendor id, device id, and function number of the sdio card
+ *
+ * \retval -1    index not found
+ * \retval >= 0  return found index
+ */
+static _osal_inline_ INT32 hif_sdio_find_clt_list_index(UINT16 vendor, UINT16 device, UINT16 func_num)
+{
+	INT32 i = 0;
+
+	for (i = 0; i < CFG_CLIENT_COUNT; i++) {
+		if (g_hif_sdio_clt_drv_list[i].func_info != 0) {
+			if ((g_hif_sdio_clt_drv_list[i].func_info->manf_id == vendor) &&
+			    (g_hif_sdio_clt_drv_list[i].func_info->card_id == device) &&
+			    (g_hif_sdio_clt_drv_list[i].func_info->func_num == func_num)) {
+				return i;
+			}
+		}
+	}
+
+	return -1;
+}
+
+
+/*!
+ * \brief check if the vendor, device ids are supported in mtk_sdio_id_tbl.
+ *
+ *
+ * \param vendor id and device id of the sdio card
+ *
+ * \retval (-HIF_SDIO_ERR_FAIL)  vendor, device ids are not supported
+ * \retval HIF_SDIO_ERR_SUCCESS  vendor, device ids are supported
+ */
+static _osal_inline_ INT32 hif_sdio_check_supported_sdio_id(UINT16 vendor, UINT16 device)
+{
+	INT32 i = 0;
+
+	for (i = 0; i < CFG_CLIENT_COUNT; i++) {
+		if ((mtk_sdio_id_tbl[i].vendor == vendor) && (mtk_sdio_id_tbl[i].device == device))
+			return HIF_SDIO_ERR_SUCCESS;	/* mtk_sdio_id is supported */
+	}
+	return -HIF_SDIO_ERR_FAIL;	/* mtk_sdio_id is not supported */
+}
+
+
+/*!
+ * \brief check if the vendor, device ids are duplicated in g_hif_sdio_clt_drv_list.
+ *
+ *
+ * \param vendor id, device id, and function number of the sdio card
+ *
+ * \retval (-HIF_SDIO_ERR_DUPLICATED)  vendor, device, func_num are duplicated
+ * \retval HIF_SDIO_ERR_SUCCESS        vendor, device, func_num are not duplicated
+ */
+static _osal_inline_ INT32 hif_sdio_check_duplicate_sdio_id(UINT16 vendor, UINT16 device, UINT16 func_num)
+{
+	INT32 i = 0;
+
+	for (i = 0; i < CFG_CLIENT_COUNT; i++) {
+		if (g_hif_sdio_clt_drv_list[i].func_info != 0) {
+			if ((g_hif_sdio_clt_drv_list[i].func_info->manf_id == vendor) &&
+			    (g_hif_sdio_clt_drv_list[i].func_info->card_id == device) &&
+			    (g_hif_sdio_clt_drv_list[i].func_info->func_num == func_num)) {
+				return -HIF_SDIO_ERR_DUPLICATED;	/* duplicated */
+			}
+		}
+	}
+	return HIF_SDIO_ERR_SUCCESS;	/* Not duplicated */
+}
+
+
+/*!
+ * \brief Add the client info into g_hif_sdio_clt_drv_list.
+ *
+ *
+ * \param [output] client's index pointer.
+ * \param MTK_WCN_HIF_SDIO_CLTINFO of client's contex.
+ *
+ * \retval (-HIF_SDIO_ERR_FAIL)  Add to clt_list successfully
+ * \retval HIF_SDIO_ERR_SUCCESS  Add to clt_list failed (buffer is full)
+ */
+static _osal_inline_ INT32 hif_sdio_add_clt_list(PINT32 clt_index_p,
+				   const MTK_WCN_HIF_SDIO_CLTINFO *pinfo, UINT32 tbl_index)
+{
+	INT32 i = 0;
+
+	HIF_SDIO_ASSERT(clt_index_p);
+	HIF_SDIO_ASSERT(pinfo);
+
+	for (i = 0; i < CFG_CLIENT_COUNT; i++) {
+		/* client list spin lock */
+		spin_lock_bh(&g_hif_sdio_lock_info.clt_list_lock);
+		if (g_hif_sdio_clt_drv_list[i].func_info == 0) {
+			g_hif_sdio_clt_drv_list[i].func_info = &(pinfo->func_tbl[tbl_index]);
+			g_hif_sdio_clt_drv_list[i].sdio_cltinfo = pinfo;
+			/* client list spin unlock */
+			spin_unlock_bh(&g_hif_sdio_lock_info.clt_list_lock);
+			*clt_index_p = i;
+			return HIF_SDIO_ERR_SUCCESS;	/* Add to client list successfully */
+		}
+		/* client list spin unlock */
+		spin_unlock_bh(&g_hif_sdio_lock_info.clt_list_lock);
+	}
+	return -HIF_SDIO_ERR_FAIL;	/* Add to client list failed (buffer is full) */
+}
+
+#if HIF_SDIO_SUPPORT_SUSPEND
+static INT32 hif_sdio_suspend(struct device *dev)
+{
+	struct sdio_func *func = NULL;
+	mmc_pm_flag_t flag;
+	INT32 ret;
+
+	if (!dev)
+		return -EINVAL;
+
+	func = dev_to_sdio_func(dev);
+	HIF_SDIO_DBG_FUNC("prepare for func(0x%p)\n", func);
+	flag = sdio_get_host_pm_caps(func);
+#if HIF_SDIO_SUPPORT_WAKEUP
+	if (!(flag & MMC_PM_KEEP_POWER) || !(flag & MMC_PM_WAKE_SDIO_IRQ)) {
+		HIF_SDIO_WARN_FUNC
+		    ("neither MMC_PM_KEEP_POWER or MMC_PM_WAKE_SDIO_IRQ is supported by host, return -ENOTSUPP\n");
+		return -ENOTSUPP;
+	}
+
+	/* set both */
+	flag |= MMC_PM_KEEP_POWER | MMC_PM_WAKE_SDIO_IRQ;
+#else
+	if (!(flag & MMC_PM_KEEP_POWER)) {
+		HIF_SDIO_WARN_FUNC
+		    ("neither MMC_PM_KEEP_POWER is supported by host, return -ENOTSUPP\n");
+		return -ENOTSUPP;
+	}
+	flag |= MMC_PM_KEEP_POWER;
+#endif
+	ret = sdio_set_host_pm_flags(func, flag);
+	if (ret) {
+		HIF_SDIO_INFO_FUNC
+		    ("set MMC_PM_KEEP_POWER to host fail(%d)\n", ret);
+		return -EFAULT;
+	}
+#if HIF_SDIO_SUPPORT_WAKEUP
+	sdio_claim_host(func);
+#endif
+	HIF_SDIO_INFO_FUNC("set MMC_PM_KEEP_POWER ok\n");
+	return 0;
+}
+
+static INT32 hif_sdio_resume(struct device *dev)
+{
+#if HIF_SDIO_SUPPORT_WAKEUP
+	struct sdio_func *func = NULL;
+#endif
+	if (!dev) {
+		HIF_SDIO_WARN_FUNC("null dev!\n");
+		return -EINVAL;
+	}
+#if HIF_SDIO_SUPPORT_WAKEUP
+	func = dev_to_sdio_func(dev);
+	sdio_release_host(func);
+#endif
+	HIF_SDIO_INFO_FUNC("do nothing\n");
+
+	return 0;
+}
+#endif
+
+/*!
+ * \brief hif_sdio probe function
+ *
+ * hif_sdio probe function called by mmc driver when any matched SDIO function
+ * is detected by it.
+ *
+ * \param func
+ * \param id
+ *
+ * \retval 0    register successfully
+ * \retval < 0  list error code here
+ */
+static INT32 hif_sdio_probe(struct sdio_func *func, const struct sdio_device_id *id)
+{
+	INT32 ret = 0;
+	INT32 i = 0;
+	MTK_WCN_HIF_SDIO_PROBEINFO *hif_sdio_probed_funcp = 0;
+	INT32 probe_index = -1;
+	INT32 idx;
+#if 0
+	INT32 clt_index = -1;
+	MTK_WCN_HIF_SDIO_CLT_PROBE_WORKERINFO *clt_probe_worker_info = 0;
+#endif
+
+	HIF_SDIO_DBG_FUNC("start!\n");
+	HIF_SDIO_ASSERT(func);
+#if !(DELETE_HIF_SDIO_CHRDEV)
+	hif_sdio_match_chipid_by_dev_id(id);
+#endif
+	/* 4 <0> display debug information */
+	HIF_SDIO_INFO_FUNC("vendor(0x%x) device(0x%x) num(0x%x)\n", func->vendor, func->device,
+			   func->num);
+	for (i = 0; i < func->card->num_info; i++)
+		HIF_SDIO_DBG_FUNC("card->info[%d]: %s\n", i, func->card->info[i]);
+
+	/* 4 <1> Check if this  is supported by us (mtk_sdio_id_tbl) */
+	ret = hif_sdio_check_supported_sdio_id(func->vendor, func->device);
+	if (ret) {
+		HIF_SDIO_WARN_FUNC
+		    ("vendor id and device id of sdio_func are not supported in mtk_sdio_id_tbl!\n");
+		goto out;
+	}
+	/* 4 <2> Add this struct sdio_func *func to g_hif_sdio_probed_func_list */
+	for (i = 0; i < CFG_CLIENT_COUNT; i++) {
+		/* probed spin lock */
+		spin_lock_bh(&g_hif_sdio_lock_info.probed_list_lock);
+		if (g_hif_sdio_probed_func_list[i].func == 0) {
+			hif_sdio_probed_funcp = &g_hif_sdio_probed_func_list[i];
+			hif_sdio_probed_funcp->func = func;
+			hif_sdio_probed_funcp->clt_idx =
+			    hif_sdio_find_clt_list_index(func->vendor, func->device, func->num);
+			hif_sdio_probed_funcp->on_by_wmt = MTK_WCN_BOOL_FALSE;
+			hif_sdio_probed_funcp->sdio_irq_enabled = MTK_WCN_BOOL_FALSE;
+			/* probed spin unlock */
+			spin_unlock_bh(&g_hif_sdio_lock_info.probed_list_lock);
+			probe_index = i;
+			break;
+		}
+		/* probed spin unlock */
+		spin_unlock_bh(&g_hif_sdio_lock_info.probed_list_lock);
+	}
+	if ((probe_index < 0) || (probe_index >= CFG_CLIENT_COUNT)) {
+		HIF_SDIO_ERR_FUNC("probe function list if full!\n");
+		goto out;
+	}
+	/* 4 <3> Initialize this function */
+	if (g_hif_sdio_probed_func_list[probe_index].clt_idx < 0) {
+		for (i = 0; i < CFG_CLIENT_COUNT; i++) {
+			/* client list spin lock */
+			spin_lock_bh(&g_hif_sdio_lock_info.clt_list_lock);
+			if (g_hif_sdio_clt_drv_list[i].func_info == 0) {
+				/* client list spin unlock */
+				spin_unlock_bh(&g_hif_sdio_lock_info.clt_list_lock);
+				continue;
+			}
+			HIF_SDIO_INFO_FUNC("manf_id:%x, card_id:%x, func_num:%d\n",
+					   g_hif_sdio_clt_drv_list[i].func_info->manf_id,
+					   g_hif_sdio_clt_drv_list[i].func_info->card_id,
+					   g_hif_sdio_clt_drv_list[i].func_info->func_num);
+			if ((g_hif_sdio_clt_drv_list[i].func_info->manf_id ==
+			     g_hif_sdio_probed_func_list[probe_index].func->vendor)
+			    && (g_hif_sdio_clt_drv_list[i].func_info->card_id ==
+				g_hif_sdio_probed_func_list[probe_index].func->device)
+			    && (g_hif_sdio_clt_drv_list[i].func_info->func_num ==
+				g_hif_sdio_probed_func_list[probe_index].func->num)) {
+				g_hif_sdio_probed_func_list[probe_index].clt_idx = i;
+				/* client list spin unlock */
+				spin_unlock_bh(&g_hif_sdio_lock_info.clt_list_lock);
+				break;
+			}
+			/* client list spin unlock */
+			spin_unlock_bh(&g_hif_sdio_lock_info.clt_list_lock);
+		}
+		HIF_SDIO_INFO_FUNC("map to g_hif_sdio_clt_drv_list[] done: %d\n",
+				   g_hif_sdio_probed_func_list[probe_index].clt_idx);
+	}
+	/* 4 <3.1> enable this function */
+	sdio_claim_host(func);
+	ret = sdio_enable_func(func);
+	sdio_release_host(func);
+	if (ret) {
+		HIF_SDIO_ERR_FUNC("sdio_enable_func failed!\n");
+		goto out;
+	}
+
+	/* 4 <3.2> set block size according to the table storing function characteristics */
+	if (hif_sdio_probed_funcp == 0) {
+		HIF_SDIO_ERR_FUNC("hif_sdio_probed_funcp is null!\n");
+		goto out;
+	}
+	if (hif_sdio_probed_funcp->clt_idx >= 0 &&
+		hif_sdio_probed_funcp->clt_idx < CFG_CLIENT_COUNT) {
+		/* The clt contex has been registed */
+		sdio_claim_host(func);
+		idx = hif_sdio_probed_funcp->clt_idx;
+		ret = sdio_set_block_size(func, g_hif_sdio_clt_drv_list[idx].func_info->blk_sz);
+		sdio_release_host(func);
+	} else {		/* The clt contex has not been registed */
+
+		sdio_claim_host(func);
+		ret = sdio_set_block_size(func, HIF_DEFAULT_BLK_SIZE);
+		sdio_release_host(func);
+	}
+	if (ret) {
+		HIF_SDIO_ERR_FUNC("set sdio block size failed!\n");
+		goto out;
+	}
+
+	HIF_SDIO_DBG_FUNC("cur_blksize(%d) max(%d), host max blk_size(%d) blk_count(%d)\n",
+			   func->cur_blksize, func->max_blksize,
+			   func->card->host->max_blk_size, func->card->host->max_blk_count);
+
+
+	hif_sdio_dump_probe_list();
+
+out:
+	/* 4 <last> error handling */
+	return ret;
+}
+
+
+/*!
+ * \brief hif_sdio remove function
+ *
+ * hif_sdio probe function called by mmc driver when the probed func should be
+ * removed.
+ *
+ * \param func
+ *
+ */
+static VOID hif_sdio_remove(struct sdio_func *func)
+{
+	INT32 probed_list_index = 0;
+#if 0
+	INT32 registed_list_index = 0;
+#endif
+
+	HIF_SDIO_DBG_FUNC("start!\n");
+	HIF_SDIO_ASSERT(func);
+
+	/* 4 <1> check input parameter is valid and has been probed previously */
+	if (func == NULL) {
+		HIF_SDIO_ERR_FUNC("func null(%p)\n", func);
+		return;
+	}
+	/* 4 <2> if this function has been initialized by any client driver, */
+	/* 4 call client's .hif_clt_remove() call back in THIS context. */
+	probed_list_index = hif_sdio_find_probed_list_index_by_func(func);
+	if (probed_list_index < 0) {
+		HIF_SDIO_WARN_FUNC
+		    ("sdio function pointer is not in g_hif_sdio_probed_func_list!\n");
+		return;
+	}
+#if 0
+	registed_list_index = g_hif_sdio_probed_func_list[probed_list_index].clt_idx;
+	if (registed_list_index >= 0) {
+		g_hif_sdio_clt_drv_list[registed_list_index].sdio_cltinfo->hif_clt_remove(CLTCTX
+											  (func->
+											   device,
+											   func->
+											   num,
+											   func->
+											   cur_blksize,
+											   probed_list_index));
+	}
+#endif
+
+	/* 4 <3> mark this function as de-initialized and invalidate client's context */
+	hif_sdio_init_probed_list(probed_list_index);
+
+#if 0
+	/* 4 <4> release irq for this function */
+	sdio_claim_host(func);
+	sdio_release_irq(func);
+	sdio_release_host(func);
+#endif
+
+	/* 4 <5> disable this function */
+	sdio_claim_host(func);
+	sdio_disable_func(func);
+	sdio_release_host(func);
+
+	/* 4 <6> mark this function as removed */
+
+	HIF_SDIO_DBG_FUNC("sdio func(0x%p) is removed successfully!\n", func);
+}
+
+/*!
+ * \brief hif_sdio interrupt handler
+ *
+ * detailed descriptions
+ *
+ * \param ctx client's context variable
+ *
+ */
+static VOID hif_sdio_irq(struct sdio_func *func)
+{
+	INT32 probed_list_index = -1;
+	INT32 registed_list_index = -1;
+	INT32 ret;
+
+	HIF_SDIO_DBG_FUNC("start!\n");
+
+	osal_ftrace_print("%s|S\n", __func__);
+	/* 4 <1> check if func is valid */
+	HIF_SDIO_ASSERT(func);
+
+	/* 4 <2> if func has valid corresponding hif_sdio client's context, mark it */
+	/* 4 host-locked, use it to call client's .hif_clt_irq() callback function in */
+	/* 4 THIS context. */
+	probed_list_index = hif_sdio_find_probed_list_index_by_func(func);
+	if ((probed_list_index < 0) || (probed_list_index >= CFG_CLIENT_COUNT)) {
+		HIF_SDIO_ERR_FUNC("probed_list_index not found!\n");
+		return;
+	}
+	/* [George] added for sdio irq sync and mmc single_irq workaround. It's set
+	 * enabled later by client driver call mtk_wcn_hif_sdio_enable_irq()
+	 */
+	/* skip smp_rmb() here */
+	if (g_hif_sdio_probed_func_list[probed_list_index].sdio_irq_enabled == MTK_WCN_BOOL_FALSE) {
+		HIF_SDIO_WARN_FUNC("func(0x%p),probed_idx(%d) sdio irq not enabled yet\n",
+				   func, probed_list_index);
+		return;
+	}
+
+	registed_list_index = g_hif_sdio_probed_func_list[probed_list_index].clt_idx;
+/* g_hif_sdio_probed_func_list[probed_list_index].interrupted = MTK_WCN_BOOL_TRUE; */
+	if ((registed_list_index >= 0)
+	    && (registed_list_index < CFG_CLIENT_COUNT)) {
+		HIF_SDIO_DBG_FUNC("[%d]SDIO IRQ (func:0x%p) v(0x%x) d(0x%x) n(0x%x)\n",
+				  probed_list_index, func, func->vendor, func->device, func->num);
+
+		g_hif_sdio_clt_drv_list[registed_list_index].sdio_cltinfo->hif_clt_irq(CLTCTX
+										       (func->
+											device,
+											func->num,
+											func->
+											cur_blksize,
+											probed_list_index));
+	} else {
+		/* 4 <3> if func has no VALID hif_sdio client's context, release irq for this */
+		/* 4 func and mark it in g_hif_sdio_probed_func_list (remember: donnot claim host in irq contex). */
+		HIF_SDIO_WARN_FUNC("release irq (func:0x%p) v(0x%x) d(0x%x) n(0x%x)\n",
+				   func, func->vendor, func->device, func->num);
+		mtk_wcn_hif_sdio_irq_flag_set(0);
+		ret = sdio_release_irq(func);
+		if (ret)
+			HIF_SDIO_WARN_FUNC("sdio_release_irq() fail(%d)\n", ret);
+	}
+	osal_ftrace_print("%s|E\n", __func__);
+}
+
+/*!
+ * \brief hif_sdio init function
+ *
+ * detailed descriptions
+ *
+ * \retval
+ */
+static INT32 hif_sdio_init(VOID)
+{
+	INT32 ret = 0;
+	INT32 i = 0;
+
+	HIF_SDIO_INFO_FUNC("start!\n");
+
+	/* 4 <1> init all private variables */
+	/* init reference count to 0 */
+	gRefCount = 0;
+
+	atomic_set(&hif_sdio_irq_enable_flag, 0);
+	/* init spin lock information */
+	spin_lock_init(&g_hif_sdio_lock_info.probed_list_lock);
+	spin_lock_init(&g_hif_sdio_lock_info.clt_list_lock);
+
+	/* init probed function list and g_hif_sdio_clt_drv_list */
+	for (i = 0; i < CFG_CLIENT_COUNT; i++) {
+		hif_sdio_init_probed_list(i);
+		hif_sdio_init_clt_list(i);
+	}
+
+	/* 4 <2> register to mmc driver */
+	ret = sdio_register_driver(&mtk_sdio_client_drv);
+	if (ret != 0)
+		HIF_SDIO_INFO_FUNC("sdio_register_driver() fail, ret=%d\n", ret);
+
+#if !(DELETE_HIF_SDIO_CHRDEV)
+	/* 4 <3> create thread for query chip id and device node for launcher to access */
+	if (hifsdiod_start() == 0)
+		hif_sdio_create_dev_node();
+#endif
+	hif_sdio_deep_sleep_info_init();
+	HIF_SDIO_DBG_FUNC("end!\n");
+	return ret;
+}
+
+/*!
+ * \brief hif_sdio init function
+ *
+ * detailed descriptions
+ *
+ * \retval
+ */
+static VOID hif_sdio_exit(VOID)
+{
+	HIF_SDIO_INFO_FUNC("start!\n");
+
+#if !(DELETE_HIF_SDIO_CHRDEV)
+	hif_sdio_remove_dev_node();
+	hifsdiod_stop();
+#endif
+
+	/* 4 <0> if client driver is not removed yet, we shall NOT be called... */
+
+	/* 4 <1> check reference count */
+	if (gRefCount != 0)
+		HIF_SDIO_WARN_FUNC("gRefCount=%d !!!\n", gRefCount);
+	/* 4 <2> check if there is any hif_sdio-registered clients. There should be */
+	/* 4 no registered client... */
+
+	/* 4 <3> Reregister with mmc driver. Our remove handler hif_sdio_remove() */
+	/* 4 will be called later by mmc_core. Clean up driver resources there. */
+	sdio_unregister_driver(&mtk_sdio_client_drv);
+	atomic_set(&hif_sdio_irq_enable_flag, 0);
+	HIF_SDIO_DBG_FUNC("end!\n");
+}				/* end of exitWlan() */
+
+/*!
+ * \brief stp on by wmt (probe client driver).
+ *
+ *
+ * \param none.
+ *
+ * \retval 0:success, -11:not probed, -12:already on, -13:not registered, other errors.
+ */
+static _osal_inline_ INT32 hif_sdio_stp_on(VOID)
+{
+#if 0
+	MTK_WCN_HIF_SDIO_CLT_PROBE_WORKERINFO *clt_probe_worker_info = 0;
+#endif
+	INT32 clt_index = -1;
+	INT32 probe_index = -1;
+	INT32 ret = -1;
+	INT32 ret2 = -1;
+	struct sdio_func *func = NULL;
+	UINT32 chip_id = 0;
+	UINT16 func_num = 0;
+
+	const MTK_WCN_HIF_SDIO_FUNCINFO *func_info = NULL;
+
+	HIF_SDIO_DBG_FUNC("hif_sdio_stp_on, start!\n");
+
+	/* 4 <1> If stp client drv has not been probed, return error code */
+	/* MT6620 */
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x020B, 1);
+	if (probe_index >= 0)
+		goto stp_on_exist;
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x020C, 1);
+	if (probe_index >= 0)
+		goto stp_on_exist;
+
+	/* MT6628 */
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x6628, 2);
+	if (probe_index >= 0)
+		goto stp_on_exist;
+	/* MT6630 */
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x6630, 2);
+	if (probe_index >= 0) {
+		chip_id = 0x6630;
+		func_num = 2;
+		goto stp_on_exist;
+	}
+	/* MT6632 */
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x6632, 2);
+	if (probe_index >= 0) {
+		chip_id = 0x6632;
+		func_num = 2;
+		goto stp_on_exist;
+	}
+	/* MT6619 */
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x6619, 1);
+	if (probe_index >= 0)
+		goto stp_on_exist;
+
+	/* MT6618 */
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x018B, 1);
+	if (probe_index >= 0)
+		goto stp_on_exist;
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x018C, 1);
+	if (probe_index >= 0)
+		goto stp_on_exist;
+	else {
+		/* 4 <2> If stp client drv has not been probed, return error code */
+		/* client func has not been probed */
+		HIF_SDIO_INFO_FUNC("no supported func probed\n");
+		return HIF_SDIO_ERR_NOT_PROBED;
+	}
+
+stp_on_exist:
+	/* 4 <3> If stp client drv has been on by wmt, return error code */
+	if (g_hif_sdio_probed_func_list[probe_index].on_by_wmt != MTK_WCN_BOOL_FALSE) {
+		HIF_SDIO_INFO_FUNC("already on...\n");
+		return HIF_SDIO_ERR_ALRDY_ON;
+	}
+	g_hif_sdio_probed_func_list[probe_index].on_by_wmt = MTK_WCN_BOOL_TRUE;
+
+	clt_index = g_hif_sdio_probed_func_list[probe_index].clt_idx;
+	if (clt_index >= 0) {	/* the function has been registered */
+		g_hif_sdio_probed_func_list[probe_index].sdio_irq_enabled = MTK_WCN_BOOL_FALSE;
+		/* 4 <4> claim irq for this function */
+		func = g_hif_sdio_probed_func_list[probe_index].func;
+		if (unlikely(!(func) || !(func->card) || !(func->card->host)
+			     || mmc_card_removed(func->card))) {
+			HIF_SDIO_ERR_FUNC("sdio host is missing\n");
+			return HIF_SDIO_ERR_NOT_PROBED;
+		}
+		sdio_claim_host(func);
+		ret = sdio_claim_irq(func, hif_sdio_irq);
+		mtk_wcn_hif_sdio_irq_flag_set(1);
+		sdio_release_host(func);
+		if (ret) {
+			HIF_SDIO_WARN_FUNC("sdio_claim_irq() for stp fail(%d)\n", ret);
+			return ret;
+		}
+		HIF_SDIO_DBG_FUNC("sdio_claim_irq() for stp ok\n");
+
+		/* 4 <5> If this struct sdio_func *func is supported by any driver in */
+		/* 4 g_hif_sdio_clt_drv_list, schedule another task to call client's .hif_clt_probe() */
+		/* TODO: [FixMe][George] WHY probe worker is removed??? */
+#if 1
+		/* Call client's .hif_clt_probe() */
+		ret = hif_sdio_clt_probe_func(&g_hif_sdio_clt_drv_list[clt_index], probe_index);
+		if (ret) {
+			HIF_SDIO_WARN_FUNC("clt_probe_func() for stp fail(%d) release irq\n", ret);
+			sdio_claim_host(func);
+			mtk_wcn_hif_sdio_irq_flag_set(0);
+			ret2 = sdio_release_irq(func);
+			sdio_release_host(func);
+			if (ret2)
+				HIF_SDIO_WARN_FUNC("sdio_release_irq() for stp fail(%d)\n", ret2);
+
+			g_hif_sdio_probed_func_list[probe_index].on_by_wmt = MTK_WCN_BOOL_FALSE;
+			return ret;
+		}
+		g_hif_sdio_probed_func_list[probe_index].sdio_irq_enabled = MTK_WCN_BOOL_TRUE;
+
+		/*set deep sleep information to global data struct */
+		func_info = g_hif_sdio_clt_drv_list[clt_index].func_info;
+		hif_sdio_deep_sleep_info_set_act(chip_id, func_num,
+						  CLTCTX(func_info->card_id, func_info->func_num,
+							 func_info->blk_sz, probe_index), 1);
+
+
+		HIF_SDIO_DBG_FUNC("hif_sdio_stp_on, ok!\n");
+
+		return 0;
+#else
+		/* use worker thread to perform the client's .hif_clt_probe() */
+		clt_probe_worker_info = vmalloc(sizeof(MTK_WCN_HIF_SDIO_CLT_PROBE_WORKERINFO));
+		INIT_WORK(&clt_probe_worker_info->probe_work, hif_sdio_clt_probe_worker);
+		clt_probe_worker_info->registinfo_p = &g_hif_sdio_clt_drv_list[clt_index];
+		clt_probe_worker_info->probe_idx = probe_index;
+		schedule_work(&clt_probe_worker_info->probe_work);
+#endif
+	} else {
+		/* TODO: [FixMe][George] check if clt_index is cleared in client's unregister function */
+		HIF_SDIO_WARN_FUNC("probed but not registered yet (%d)\n", ret);
+		return HIF_SDIO_ERR_CLT_NOT_REG;
+	}
+}
+
+/*!
+ * \brief stp off by wmt (remove client driver).
+ *
+ *
+ * \param none.
+ *
+ * \retval 0:success, -11:not probed, -12:already off, -13:not registered, other errors.
+ */
+static _osal_inline_ INT32 hif_sdio_stp_off(VOID)
+{
+	INT32 clt_index = -1;
+	INT32 probe_index = -1;
+	INT32 ret = -1;
+	INT32 ret2 = -1;
+	struct sdio_func *func = NULL;
+	UINT32 chip_id = 0;
+	UINT16 func_num = 0;
+	const MTK_WCN_HIF_SDIO_FUNCINFO *func_info = NULL;
+
+	HIF_SDIO_DBG_FUNC("hif_sdio_stp_off, start!\n");
+
+	/* 4 <1> If stp client drv has not been probed, return error code */
+	/* MT6620 */
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x020B, 1);
+	if (probe_index >= 0)
+		goto stp_off_exist;
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x020C, 1);
+	if (probe_index >= 0)
+		goto stp_off_exist;
+
+	/* MT6628 */
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x6628, 2);
+	if (probe_index >= 0)
+		goto stp_off_exist;
+	/* MT6630 */
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x6630, 2);
+	if (probe_index >= 0) {
+		chip_id = 0x6630;
+		func_num = 2;
+		goto stp_off_exist;
+	}
+	/* MT6632 */
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x6632, 2);
+	if (probe_index >= 0) {
+		chip_id = 0x6632;
+		func_num = 2;
+		goto stp_off_exist;
+	}
+
+	/* MT6619 */
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x6619, 1);
+	if (probe_index >= 0)
+		goto stp_off_exist;
+
+	/* MT6618 */
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x018B, 1);
+	if (probe_index >= 0)
+		goto stp_off_exist;
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x018C, 1);
+	if (probe_index >= 0)
+		goto stp_off_exist;
+	else {
+		/* 4 <2> If stp client drv has not been probed, return error code */
+		/* client func has not been probed */
+		return HIF_SDIO_ERR_NOT_PROBED;
+	}
+
+stp_off_exist:
+	/* 4 <3> If stp client drv has been off by wmt, return error code */
+	if (g_hif_sdio_probed_func_list[probe_index].on_by_wmt == MTK_WCN_BOOL_FALSE) {
+		HIF_SDIO_WARN_FUNC("already off...\n");
+		return HIF_SDIO_ERR_ALRDY_OFF;
+	}
+	g_hif_sdio_probed_func_list[probe_index].on_by_wmt = MTK_WCN_BOOL_FALSE;
+
+#if 0				/* TODO: [FixMe][George] moved below as done in stp_on. */
+	/* 4 <4> release irq for this function */
+	func = g_hif_sdio_probed_func_list[probe_index].func;
+	sdio_claim_host(func);
+	ret = sdio_release_irq(func);
+	sdio_release_host(func);
+	if (ret)
+		pr_warn(DRV_NAME "sdio_release_irq for stp fail(%d)\n", ret);
+	else
+		pr_warn(DRV_NAME "sdio_release_irq for stp ok\n");
+#endif
+	clt_index = g_hif_sdio_probed_func_list[probe_index].clt_idx;
+	if (clt_index >= 0) {	/* the function has been registered */
+		func = g_hif_sdio_probed_func_list[probe_index].func;
+
+		if (unlikely(!(func) || !(func->card) || !(func->card->host)
+			     || mmc_card_removed(func->card))) {
+			HIF_SDIO_ERR_FUNC("sdio host is missing\n");
+			return HIF_SDIO_ERR_ALRDY_OFF;
+		}
+		/* 4 <4> release irq for this function */
+		sdio_claim_host(func);
+		mtk_wcn_hif_sdio_irq_flag_set(0);
+		ret2 = sdio_release_irq(func);
+		sdio_release_host(func);
+
+		if (ret2)
+			HIF_SDIO_WARN_FUNC("sdio_release_irq() for stp fail(%d)\n", ret2);
+		else
+			HIF_SDIO_DBG_FUNC("sdio_release_irq() for stp ok\n");
+
+		/* 4 <5> Callback to client driver's remove() func */
+		ret =
+		    g_hif_sdio_clt_drv_list[clt_index].
+		    sdio_cltinfo->hif_clt_remove(CLTCTX
+						 (func->device, func->num, func->cur_blksize,
+						  probe_index));
+		if (ret)
+			HIF_SDIO_WARN_FUNC("clt_remove for stp fail(%d)\n", ret);
+		else
+			HIF_SDIO_DBG_FUNC("hif_sdio_stp_off, ok!\n");
+
+		/*set deep sleep information to global data struct */
+		func_info = g_hif_sdio_clt_drv_list[clt_index].func_info;
+		hif_sdio_deep_sleep_info_set_act(chip_id, func_num,
+						  CLTCTX(func_info->card_id, func_info->func_num,
+							 func_info->blk_sz, probe_index), 0);
+		return ret + ret2;
+	}
+	/* TODO: [FixMe][George] check if clt_index is cleared in client's unregister function */
+	HIF_SDIO_WARN_FUNC("probed but not registered yet (%d)\n", ret);
+	return HIF_SDIO_ERR_CLT_NOT_REG;
+}
+
+/*!
+ * \brief wifi on by wmt (probe client driver).
+ *
+ *
+ * \param none.
+ *
+ * \retval 0:success, -11:not probed, -12:already on, -13:not registered, other errors.
+ */
+static _osal_inline_ INT32 hif_sdio_wifi_on(VOID)
+{
+#if 0
+	MTK_WCN_HIF_SDIO_CLT_PROBE_WORKERINFO *clt_probe_worker_info = 0;
+#endif
+	INT32 clt_index = -1;
+	INT32 probe_index = -1;
+	INT32 ret = 0;
+	INT32 ret2 = 0;
+	struct sdio_func *func = NULL;
+	UINT32 chip_id = 0;
+	UINT16 func_num = 0;
+	const MTK_WCN_HIF_SDIO_FUNCINFO *func_info = NULL;
+
+	HIF_SDIO_DBG_FUNC("start!\n");
+
+	/* 4 <1> If wifi client drv has not been probed, return error code */
+	/* MT6620 */
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x020A, 1);
+	if (probe_index >= 0)
+		goto wifi_on_exist;
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x020C, 2);
+	if (probe_index >= 0)
+		goto wifi_on_exist;
+	/* MT6628 */
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x6628, 1);
+	if (probe_index == 0)
+		goto wifi_on_exist;
+	/* MT6630 */
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x6630, 1);
+	 if (probe_index >= 0) {
+		chip_id = 0x6630;
+		func_num = 1;
+		goto wifi_on_exist;
+	}
+	/* MT6632 */
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x6602, 1);
+	 if (probe_index >= 0) {
+		chip_id = 0x6632;
+		func_num = 1;
+		goto wifi_on_exist;
+	}
+
+	/* MT6618 */
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x018A, 1);
+	if (probe_index == 0)
+		goto wifi_on_exist;
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x018C, 2);
+	if (probe_index >= 0)
+		goto wifi_on_exist;
+	else {
+		/* 4 <2> If wifi client drv has not been probed, return error code */
+		/* client func has not been probed */
+		return HIF_SDIO_ERR_NOT_PROBED;
+	}
+
+wifi_on_exist:
+	/* 4 <3> If wifi client drv has been on by wmt, return error code */
+	if (g_hif_sdio_probed_func_list[probe_index].on_by_wmt) {
+		HIF_SDIO_INFO_FUNC("probe_index (%d), already on...\n", probe_index);
+		return HIF_SDIO_ERR_ALRDY_ON;
+	}
+	clt_index = g_hif_sdio_probed_func_list[probe_index].clt_idx;
+	if (clt_index >= 0) {	/* the function has been registered */
+		g_hif_sdio_probed_func_list[probe_index].sdio_irq_enabled = MTK_WCN_BOOL_FALSE;
+		/* 4 <4> claim irq for this function */
+		func = g_hif_sdio_probed_func_list[probe_index].func;
+		if (unlikely(!(func) || !(func->card) || !(func->card->host)
+			     || mmc_card_removed(func->card))) {
+			HIF_SDIO_ERR_FUNC("sdio host is missing\n");
+			return HIF_SDIO_ERR_NOT_PROBED;
+		}
+		sdio_claim_host(func);
+		ret = sdio_claim_irq(func, hif_sdio_irq);
+		mtk_wcn_hif_sdio_irq_flag_set(1);
+		sdio_release_host(func);
+		if (ret) {
+			HIF_SDIO_WARN_FUNC("sdio_claim_irq() for wifi fail(%d)\n", ret);
+			return ret;
+		}
+		HIF_SDIO_INFO_FUNC("sdio_claim_irq() for wifi ok\n");
+
+		/* 4 <5> If this struct sdio_func *func is supported by any driver in */
+		/* 4 g_hif_sdio_clt_drv_list, schedule another task to call client's .hif_clt_probe() */
+		/* TODO: [FixMe][George] WHY probe worker is removed??? */
+#if 1
+		/*set deep sleep information to global data struct */
+		func_info = g_hif_sdio_clt_drv_list[clt_index].func_info;
+		hif_sdio_deep_sleep_info_set_act(chip_id, func_num,
+						  CLTCTX(func_info->card_id, func_info->func_num,
+							 func_info->blk_sz, probe_index), 1);
+
+		/* Call client's .hif_clt_probe() */
+		ret = hif_sdio_clt_probe_func(&g_hif_sdio_clt_drv_list[clt_index], probe_index);
+		if (ret) {
+			HIF_SDIO_WARN_FUNC("clt_probe_func() for wifi fail(%d) release irq\n", ret);
+			sdio_claim_host(func);
+			mtk_wcn_hif_sdio_irq_flag_set(0);
+			ret2 = sdio_release_irq(func);
+			sdio_release_host(func);
+			if (ret2)
+				HIF_SDIO_WARN_FUNC("sdio_release_irq() for wifi fail(%d)\n", ret2);
+
+			hif_sdio_deep_sleep_info_set_act(chip_id, func_num,
+							  CLTCTX(func_info->card_id,
+								 func_info->func_num,
+								 func_info->blk_sz, probe_index),
+							  0);
+			g_hif_sdio_probed_func_list[probe_index].on_by_wmt = MTK_WCN_BOOL_FALSE;
+			return ret;
+		}
+		g_hif_sdio_probed_func_list[probe_index].on_by_wmt = MTK_WCN_BOOL_TRUE;
+
+		HIF_SDIO_DBG_FUNC("ok!\n");
+		return 0;
+#else
+		/* use worker thread to perform the client's .hif_clt_probe() */
+		clt_probe_worker_info = vmalloc(sizeof(MTK_WCN_HIF_SDIO_CLT_PROBE_WORKERINFO));
+		INIT_WORK(&clt_probe_worker_info->probe_work, hif_sdio_clt_probe_worker);
+		clt_probe_worker_info->registinfo_p = &g_hif_sdio_clt_drv_list[clt_index];
+		clt_probe_worker_info->probe_idx = probe_index;
+		schedule_work(&clt_probe_worker_info->probe_work);
+#endif
+	} else {
+		/* TODO: [FixMe][George] check if clt_index is cleared in client's unregister function */
+		HIF_SDIO_WARN_FUNC("probed but not registered yet (%d)\n", ret);
+		g_hif_sdio_probed_func_list[probe_index].on_by_wmt = MTK_WCN_BOOL_TRUE;
+		return HIF_SDIO_ERR_CLT_NOT_REG;
+	}
+}
+
+/*!
+ * \brief wifi off by wmt (remove client driver).
+ *
+ *
+ * \param none.
+ *
+ * \retval 0:success, -11:not probed, -12:already off, -13:not registered, other errors.
+ */
+static _osal_inline_ INT32 hif_sdio_wifi_off(VOID)
+{
+	INT32 clt_index = -1;
+	INT32 probe_index = -1;
+	INT32 ret = -1;
+	INT32 ret2 = -1;
+	struct sdio_func *func = NULL;
+	UINT32 chip_id = 0;
+	UINT16 func_num = 0;
+	const MTK_WCN_HIF_SDIO_FUNCINFO *func_info = NULL;
+
+	HIF_SDIO_INFO_FUNC("start!\n");
+
+	/* 4 <1> If wifi client drv has not been probed, return error code */
+	/* MT6620 */
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x020A, 1);
+	if (probe_index >= 0)
+		goto wifi_off_exist;
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x020C, 2);
+	if (probe_index >= 0)
+		goto wifi_off_exist;
+
+	/* MT6628 */
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x6628, 1);
+	if (probe_index >= 0)
+		goto wifi_off_exist;
+	/* MT6630 */
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x6630, 1);
+	if (probe_index >= 0) {
+		chip_id = 0x6630;
+		func_num = 1;
+		goto wifi_off_exist;
+	}
+	/* MT6632 */
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x6602, 1);
+	if (probe_index >= 0) {
+		chip_id = 0x6632;
+		func_num = 1;
+		goto wifi_off_exist;
+	}
+
+	/* MT6618 */
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x018A, 1);
+	if (probe_index >= 0)
+		goto wifi_off_exist;
+	probe_index = hif_sdio_find_probed_list_index_by_id_func(0x037A, 0x018C, 2);
+	if (probe_index >= 0)
+		goto wifi_off_exist;
+	else {
+		/* 4 <2> If wifi client drv has not been probed, return error code */
+		/* client func has not been probed */
+		return HIF_SDIO_ERR_NOT_PROBED;
+	}
+
+wifi_off_exist:
+	/* 4 <3> If wifi client drv has been off by wmt, return error code */
+	if (g_hif_sdio_probed_func_list[probe_index].on_by_wmt == MTK_WCN_BOOL_FALSE) {
+		HIF_SDIO_WARN_FUNC("already off...\n");
+		return HIF_SDIO_ERR_ALRDY_OFF;
+	}
+	g_hif_sdio_probed_func_list[probe_index].on_by_wmt = MTK_WCN_BOOL_FALSE;
+
+
+#if 0				/* TODO: [FixMe][George] moved below as done in wifi_on. */
+	/* 4 <4> release irq for this function */
+	func = g_hif_sdio_probed_func_list[probe_index].func;
+	sdio_claim_host(func);
+	ret = sdio_release_irq(func);
+	sdio_release_host(func);
+	if (ret)
+		pr_warn(DRV_NAME "sdio_release_irq for wifi fail(%d)\n", ret);
+	else
+		pr_warn(DRV_NAME "sdio_release_irq for wifi ok\n");
+
+#endif
+	clt_index = g_hif_sdio_probed_func_list[probe_index].clt_idx;
+	if (clt_index >= 0) {	/* the function has been registered */
+		func = g_hif_sdio_probed_func_list[probe_index].func;
+
+		/* 4 <4> Callback to client driver's remove() func */
+		ret =
+		    g_hif_sdio_clt_drv_list[clt_index].
+		    sdio_cltinfo->hif_clt_remove(CLTCTX
+						 (func->device, func->num, func->cur_blksize,
+						  probe_index));
+		if (ret)
+			HIF_SDIO_WARN_FUNC("clt_remove for wifi fail(%d)\n", ret);
+		else
+			HIF_SDIO_INFO_FUNC("ok!\n");
+
+		if (unlikely(!(func) || !(func->card) || !(func->card->host)
+			     || mmc_card_removed(func->card))) {
+			HIF_SDIO_ERR_FUNC("sdio host is missing\n");
+			return HIF_SDIO_ERR_ALRDY_OFF;
+		}
+		/* 4 <5> release irq for this function */
+		sdio_claim_host(func);
+		mtk_wcn_hif_sdio_irq_flag_set(0);
+		ret2 = sdio_release_irq(func);
+		sdio_release_host(func);
+		g_hif_sdio_probed_func_list[probe_index].sdio_irq_enabled = MTK_WCN_BOOL_FALSE;
+		if (ret2)
+			HIF_SDIO_WARN_FUNC("sdio_release_irq() for wifi fail(%d)\n", ret2);
+		else
+			HIF_SDIO_INFO_FUNC("sdio_release_irq() for wifi ok\n");
+
+		/*set deep sleep information to global data struct */
+		func_info = g_hif_sdio_clt_drv_list[clt_index].func_info;
+		hif_sdio_deep_sleep_info_set_act(chip_id, func_num,
+						  CLTCTX(func_info->card_id, func_info->func_num,
+							 func_info->blk_sz, probe_index), 0);
+
+		return ret + ret2;
+	}
+	/* TODO: [FixMe][George] check if clt_index is cleared in client's unregister function */
+	HIF_SDIO_WARN_FUNC("probed but not registered yet (%d)\n", ret);
+	return HIF_SDIO_ERR_CLT_NOT_REG;
+}
+
+/*!
+ * \brief set mmc power up/off
+ *
+ * detailed descriptions
+ *
+ * \param: 1. ctx client's context variable, 2.power state: 1:power up, other:power off
+ *
+ * \retval 0:success, -1:fail
+ */
+INT32 mtk_wcn_hif_sdio_bus_set_power(MTK_WCN_HIF_SDIO_CLTCTX ctx, UINT32 pwrState)
+{
+	INT32 probe_index = -1;
+	struct sdio_func *func = 0;
+
+	HIF_SDIO_INFO_FUNC("turn Bus Power to: %d\n", pwrState);
+
+	probe_index = CLTCTX_IDX(ctx);
+	if (unlikely(!CLTCTX_IDX_VALID(probe_index))) {	/* invalid index in CLTCTX */
+		HIF_SDIO_WARN_FUNC("invalid ctx(0x%x)\n", ctx);
+		return -1;
+	}
+	func = g_hif_sdio_probed_func_list[probe_index].func;
+
+	if (!func) {
+		HIF_SDIO_WARN_FUNC("Cannot find sdio_func !!!\n");
+		return -1;
+	}
+
+	if (pwrState == 1) {
+		sdio_claim_host(func);
+		mmc_power_up_ext(func->card->host);
+		sdio_release_host(func);
+		HIF_SDIO_WARN_FUNC("SDIO BUS Power UP\n");
+	} else {
+		sdio_claim_host(func);
+		mmc_power_off_ext(func->card->host);
+		sdio_release_host(func);
+		HIF_SDIO_WARN_FUNC("SDIO BUS Power OFF\n");
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(mtk_wcn_hif_sdio_bus_set_power);
+
+VOID mtk_wcn_hif_sdio_enable_irq(MTK_WCN_HIF_SDIO_CLTCTX ctx, MTK_WCN_BOOL enable)
+{
+	UINT8 probed_idx = CLTCTX_IDX(ctx);
+
+	if (unlikely(!CLTCTX_UIDX_VALID(probed_idx))) {	/* invalid index in CLTCTX */
+		HIF_SDIO_WARN_FUNC("invalid idx in ctx(0x%x), sdio_irq no change\n", ctx);
+		return;
+	}
+	if (unlikely(!CLTCTX_UIDX_VALID(probed_idx))) {	/* invalid index in CLTCTX */
+		HIF_SDIO_WARN_FUNC("invalid ctx(0x%x)\n", ctx);
+		return;
+	}
+	/* store client driver's private data to dev driver */
+	g_hif_sdio_probed_func_list[probed_idx].sdio_irq_enabled = enable;
+	smp_wmb();
+	HIF_SDIO_DBG_FUNC("ctx(0x%x) sdio irq enable(%d)\n",
+			   ctx, (enable == MTK_WCN_BOOL_FALSE) ? 0 : 1);
+
+
+}
+EXPORT_SYMBOL(mtk_wcn_hif_sdio_enable_irq);
+
+/*!
+ * \brief
+ *
+ * detailed descriptions
+ *
+ * \param ctx client's context variable
+ *
+ * \retval 0    register successfully
+ * \retval < 0  list error code here
+ */
+INT32 mtk_wcn_hif_sdio_f0_readb(MTK_WCN_HIF_SDIO_CLTCTX ctx, UINT32 offset, PUINT8 pvb)
+{
+#if HIF_SDIO_UPDATE
+	INT32 ret;
+	struct sdio_func *func = NULL;
+#else
+	INT32 ret = -HIF_SDIO_ERR_FAIL;
+	INT32 probe_index = -1;
+	struct sdio_func *func = 0;
+#endif
+
+	HIF_SDIO_DBG_FUNC("start!\n");
+	HIF_SDIO_ASSERT(pvb);
+
+/*4 <1> check if ctx is valid, registered, and probed */
+#if HIF_SDIO_UPDATE
+	ret = -HIF_SDIO_ERR_FAIL;
+	func = hif_sdio_ctx_to_func(ctx);
+	if (!func) {
+		ret = -HIF_SDIO_ERR_FAIL;
+		goto out;
+	}
+#else
+	probe_index = CLTCTX_IDX(ctx);
+	if (unlikely(!CLTCTX_IDX_VALID(probe_index))) {	/* invalid index in CLTCTX */
+		HIF_SDIO_WARN_FUNC("invalid ctx(0x%x)\n", ctx);
+		return -1;
+	}
+	if (probe_index < 0 || probe_index >= CFG_CLIENT_COUNT) {	/* the function has not been probed */
+		HIF_SDIO_WARN_FUNC("can't find client in probed list!\n");
+		ret = -HIF_SDIO_ERR_FAIL;
+		goto out;
+	} else {
+		if (g_hif_sdio_probed_func_list[probe_index].clt_idx < 0) {	/* the client has not been registered */
+			HIF_SDIO_WARN_FUNC("can't find client in registered list!\n");
+			ret = -HIF_SDIO_ERR_FAIL;
+			goto out;
+		}
+	}
+	func = g_hif_sdio_probed_func_list[probe_index].func;
+#endif
+
+/*4 <2>*/
+	sdio_claim_host(func);
+	*pvb = sdio_f0_readb(func, offset, &ret);
+	sdio_release_host(func);
+
+/*4 <3> check result code and return proper error code*/
+
+out:
+	HIF_SDIO_DBG_FUNC("end!\n");
+	return ret;
+}				/* end of mtk_wcn_hif_sdio_f0_readb() */
+
+
+/*!
+ * \brief
+ *
+ * detailed descriptions
+ *
+ * \param ctx client's context variable
+ *
+ * \retval 0register successfully
+ * \retval < 0  list error code here
+ */
+INT32 mtk_wcn_hif_sdio_f0_writeb(MTK_WCN_HIF_SDIO_CLTCTX ctx, UINT32 offset, UINT8 vb)
+{
+#if HIF_SDIO_UPDATE
+	INT32 ret;
+	struct sdio_func *func = NULL;
+#else
+	INT32 ret = -HIF_SDIO_ERR_FAIL;
+	INT32 probe_index = -1;
+	struct sdio_func *func = 0;
+#endif
+
+	HIF_SDIO_DBG_FUNC("start!\n");
+
+/*4 <1> check if ctx is valid, registered, and probed*/
+#if HIF_SDIO_UPDATE
+	ret = -HIF_SDIO_ERR_FAIL;
+	func = hif_sdio_ctx_to_func(ctx);
+	if (!func) {
+		ret = -HIF_SDIO_ERR_FAIL;
+		goto out;
+	}
+#else
+	probe_index = CLTCTX_IDX(ctx);
+	if (unlikely(!CLTCTX_IDX_VALID(probe_index))) {	/* invalid index in CLTCTX */
+		HIF_SDIO_WARN_FUNC("invalid ctx(0x%x)\n", ctx);
+		goto out;
+	}
+	if (probe_index < 0) {	/* the function has not been probed */
+		HIF_SDIO_WARN_FUNC("can't find client in probed list!\n");
+		ret = -HIF_SDIO_ERR_FAIL;
+		goto out;
+	} else {
+		if (g_hif_sdio_probed_func_list[probe_index].clt_idx < 0) {	/* the client has not been registered */
+			HIF_SDIO_WARN_FUNC("can't find client in registered list!\n");
+			ret = -HIF_SDIO_ERR_FAIL;
+			goto out;
+		}
+	}
+	func = g_hif_sdio_probed_func_list[probe_index].func;
+#endif
+
+/*4 <1.1> check if input parameters are valid*/
+
+/*4 <2>*/
+	wmt_tra_sdio_update();
+	sdio_claim_host(func);
+	sdio_f0_writeb(func, vb, offset, &ret);
+	sdio_release_host(func);
+
+/*4 <3> check result code and return proper error code*/
+
+out:
+	HIF_SDIO_DBG_FUNC("end!\n");
+	return ret;
+}				/* end of mtk_wcn_hif_sdio_f0_writeb() */
+
+
+INT32 mtk_wcn_hif_sdio_drv_init(VOID)
+{
+	return hif_sdio_init();
+
+}
+EXPORT_SYMBOL(mtk_wcn_hif_sdio_drv_init);
+
+VOID mtk_wcn_hif_sdio_driver_exit(VOID)
+{
+	return hif_sdio_exit();
+}
+EXPORT_SYMBOL(mtk_wcn_hif_sdio_driver_exit);
diff --git a/vendor/mediatek/kernel_modules/connectivity/common/common_main/platform/wmt_plat_alps.c b/../vendor/mediatek/kernel_modules/connectivity/common/common_main/platform/wmt_plat_alps.c.new
index e69de29..73cafed 100644
--- /dev/null
+++ b/vendor/mediatek/kernel_modules/connectivity/common/common_main/platform/wmt_plat_alps.c
@@ -0,0 +1,1861 @@
+/*
+ * Copyright (C) 2016 MediaTek Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
+ */
+/*! \file
+*    \brief  Declaration of library functions
+*
+*    Any definitions in this file will be shared among GLUE Layer and internal Driver Stack.
+*/
+
+
+
+
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+
+
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG         "[WMT-PLAT]"
+
+#include <linux/version.h>
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+#include <linux/delay.h>
+
+/* ALPS header files */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 19, 0))
+#ifndef CONFIG_RTC_DRV_MT6397
+#include <mtk_rtc.h>
+#else
+#include <linux/mfd/mt6397/rtc_misc.h>
+#endif
+#endif
+
+#ifdef CONFIG_MTK_MT6306_GPIO_SUPPORT
+#include <mtk_6306_gpio.h>
+#endif
+/* ALPS and COMBO header files */
+#include <mtk_wcn_cmb_stub.h>
+/* MTK_WCN_COMBO header files */
+#include "wmt_plat.h"
+#include "wmt_dev.h"
+#include "wmt_lib.h"
+#include "mtk_wcn_cmb_hw.h"
+#include "mtk_wcn_consys_hw.h"
+#include "stp_dbg.h"
+#include "osal.h"
+#include "wmt_gpio.h"
+#include "wmt_detect.h"
+#include <connectivity_build_in_adapter.h>
+
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/irqreturn.h>
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                             D A T A   T Y P E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+#if CFG_WMT_PS_SUPPORT
+static VOID wmt_plat_bgf_eirq_cb(VOID);
+#endif
+static INT32 wmt_plat_ldo_ctrl(ENUM_PIN_STATE state);
+static INT32 wmt_plat_pmu_ctrl(ENUM_PIN_STATE state);
+static INT32 wmt_plat_rtc_ctrl(ENUM_PIN_STATE state);
+static INT32 wmt_plat_rst_ctrl(ENUM_PIN_STATE state);
+static INT32 wmt_plat_bgf_eint_ctrl(ENUM_PIN_STATE state);
+static INT32 wmt_plat_wifi_eint_ctrl(ENUM_PIN_STATE state);
+static INT32 wmt_plat_all_eint_ctrl(ENUM_PIN_STATE state);
+static INT32 wmt_plat_uart_ctrl(ENUM_PIN_STATE state);
+static INT32 wmt_plat_pcm_ctrl(ENUM_PIN_STATE state);
+static INT32 wmt_plat_i2s_ctrl(ENUM_PIN_STATE state);
+static INT32 wmt_plat_sdio_pin_ctrl(ENUM_PIN_STATE state);
+static INT32 wmt_plat_gps_sync_ctrl(ENUM_PIN_STATE state);
+static INT32 wmt_plat_gps_lna_ctrl(ENUM_PIN_STATE state);
+static INT32 wmt_plat_uart_rx_ctrl(ENUM_PIN_STATE state);
+#if CFG_WMT_LTE_COEX_HANDLING
+static INT32 wmt_plat_tdm_req_ctrl(ENUM_PIN_STATE state);
+#endif
+static INT32 wmt_plat_dump_pin_conf(VOID);
+
+
+/*******************************************************************************
+*                            P U B L I C   D A T A
+********************************************************************************
+*/
+
+INT32 gWmtMergeIfSupport;
+UINT32 gCoClockFlag;
+BGF_IRQ_BALANCE g_bgf_irq_lock;
+INT32 wmtPlatLogLvl = WMT_PLAT_LOG_INFO;
+
+/*******************************************************************************
+*                           P R I V A T E   D A T A
+********************************************************************************
+*/
+
+static ENUM_STP_TX_IF_TYPE gCommIfType = STP_MAX_IF_TX;
+static OSAL_SLEEPABLE_LOCK gOsSLock;
+static OSAL_WAKE_LOCK wmt_wake_lock;
+
+irq_cb wmt_plat_bgf_irq_cb;
+device_audio_if_cb wmt_plat_audio_if_cb;
+func_ctrl_cb wmt_plat_func_ctrl_cb;
+thermal_query_ctrl_cb wmt_plat_thermal_query_ctrl_cb;
+trigger_assert_cb wmt_plat_trigger_assert_cb;
+deep_idle_ctrl_cb wmt_plat_deep_idle_ctrl_cb;
+
+static const fp_set_pin gfp_set_pin_table[] = {
+	[PIN_LDO] = wmt_plat_ldo_ctrl,
+	[PIN_PMU] = wmt_plat_pmu_ctrl,
+	[PIN_RTC] = wmt_plat_rtc_ctrl,
+	[PIN_RST] = wmt_plat_rst_ctrl,
+	[PIN_BGF_EINT] = wmt_plat_bgf_eint_ctrl,
+	[PIN_WIFI_EINT] = wmt_plat_wifi_eint_ctrl,
+	[PIN_ALL_EINT] = wmt_plat_all_eint_ctrl,
+	[PIN_UART_GRP] = wmt_plat_uart_ctrl,
+	[PIN_PCM_GRP] = wmt_plat_pcm_ctrl,
+	[PIN_I2S_GRP] = wmt_plat_i2s_ctrl,
+	[PIN_SDIO_GRP] = wmt_plat_sdio_pin_ctrl,
+	[PIN_GPS_SYNC] = wmt_plat_gps_sync_ctrl,
+	[PIN_GPS_LNA] = wmt_plat_gps_lna_ctrl,
+	[PIN_UART_RX] = wmt_plat_uart_rx_ctrl,
+#if CFG_WMT_LTE_COEX_HANDLING
+	[PIN_TDM_REQ] = wmt_plat_tdm_req_ctrl,
+#endif
+};
+
+/*******************************************************************************
+*                              F U N C T I O N S
+********************************************************************************
+*/
+
+/*!
+ * \brief audio control callback function for CMB_STUB on ALPS
+ *
+ * A platform function required for dynamic binding with CMB_STUB on ALPS.
+ *
+ * \param state desired audio interface state to use
+ * \param flag audio interface control options
+ *
+ * \retval 0 operation success
+ * \retval -1 invalid parameters
+ * \retval < 0 error for operation fail
+ */
+INT32 wmt_plat_audio_ctrl(enum CMB_STUB_AIF_X state, enum CMB_STUB_AIF_CTRL ctrl)
+{
+	INT32 iRet = 0;
+	UINT32 mergeIfSupport = 0;
+
+	/* input sanity check */
+	if ((state >= CMB_STUB_AIF_MAX) || (ctrl >= CMB_STUB_AIF_CTRL_MAX))
+		return -1;
+
+	iRet = 0;
+
+	/* set host side first */
+	switch (state) {
+	case CMB_STUB_AIF_0:
+		/* BT_PCM_OFF & FM line in/out */
+		iRet += wmt_plat_gpio_ctrl(PIN_PCM_GRP, PIN_STA_DEINIT);
+		iRet += wmt_plat_gpio_ctrl(PIN_I2S_GRP, PIN_STA_DEINIT);
+		break;
+
+	case CMB_STUB_AIF_1:
+		iRet += wmt_plat_gpio_ctrl(PIN_I2S_GRP, PIN_STA_DEINIT);
+		iRet += wmt_plat_gpio_ctrl(PIN_PCM_GRP, PIN_STA_INIT);
+		break;
+
+	case CMB_STUB_AIF_2:
+		iRet += wmt_plat_gpio_ctrl(PIN_PCM_GRP, PIN_STA_DEINIT);
+		iRet += wmt_plat_gpio_ctrl(PIN_I2S_GRP, PIN_STA_INIT);
+		break;
+
+	case CMB_STUB_AIF_3:
+		iRet += wmt_plat_gpio_ctrl(PIN_PCM_GRP, PIN_STA_INIT);
+		iRet += wmt_plat_gpio_ctrl(PIN_I2S_GRP, PIN_STA_INIT);
+		break;
+
+	default:
+		/* FIXME: move to cust folder? */
+		WMT_ERR_FUNC("invalid state [%d]\n", state);
+		return -1;
+	}
+
+	if (wmt_plat_merge_if_flag_get() != 0) {
+#if (MTK_WCN_CMB_MERGE_INTERFACE_SUPPORT)
+		WMT_DBG_FUNC("[MT6628]<Merge IF> no need to ctrl combo chip side GPIO\n");
+#else
+		mergeIfSupport = 1;
+#endif
+	} else
+		mergeIfSupport = 1;
+
+	if (mergeIfSupport != 0) {
+		if (ctrl == CMB_STUB_AIF_CTRL_EN) {
+			WMT_INFO_FUNC("call chip aif setting\n");
+			/* need to control chip side GPIO */
+			if (wmt_plat_audio_if_cb != NULL)
+				iRet += (*wmt_plat_audio_if_cb)(state, MTK_WCN_BOOL_FALSE);
+			else {
+				WMT_WARN_FUNC("wmt_plat_audio_if_cb is not registered\n");
+				iRet -= 1;
+			}
+
+
+		} else
+			WMT_INFO_FUNC("skip chip aif setting\n");
+	}
+
+	return iRet;
+}
+
+static VOID wmt_plat_func_ctrl(UINT32 type, UINT32 on)
+{
+	if (wmt_plat_func_ctrl_cb)
+		(*wmt_plat_func_ctrl_cb)(on, type);
+}
+
+static long wmt_plat_thermal_ctrl(VOID)
+{
+	long temp = 0;
+
+	if (wmt_plat_thermal_query_ctrl_cb)
+		temp = (*wmt_plat_thermal_query_ctrl_cb)();
+
+	return temp;
+}
+
+static INT32 wmt_plat_assert_ctrl(VOID)
+{
+	INT32 ret = 0;
+
+	mtk_wcn_consys_ipi_timeout_dump();
+
+	if (wmt_plat_trigger_assert_cb)
+		ret = (*wmt_plat_trigger_assert_cb)(WMTDRV_TYPE_WMT, 45);
+
+	return ret;
+}
+
+static INT32 wmt_plat_deep_idle_ctrl(UINT32 dpilde_ctrl)
+{
+	INT32 iRet = -1;
+
+	if (wmt_plat_deep_idle_ctrl_cb)
+		iRet = (*wmt_plat_deep_idle_ctrl_cb)(dpilde_ctrl);
+
+	return iRet;
+}
+
+static VOID wmt_plat_clock_fail_dump(VOID)
+{
+	mtk_wcn_consys_clock_fail_dump();
+}
+
+#if CFG_WMT_PS_SUPPORT
+static VOID wmt_plat_bgf_eirq_cb(VOID)
+{
+/* #error "need to disable EINT here" */
+	/* wmt_lib_ps_irq_cb(); */
+	if (wmt_plat_bgf_irq_cb != NULL)
+		(*(wmt_plat_bgf_irq_cb))();
+	else
+		WMT_PLAT_PR_WARN("WMT-PLAT: wmt_plat_bgf_irq_cb not registered\n");
+}
+#endif
+
+irqreturn_t wmt_plat_bgf_irq_isr(INT32 irq, PVOID arg)
+{
+#if CFG_WMT_PS_SUPPORT
+	mtk_wcn_consys_wakeup_btif_irq_pull_low();
+	wmt_plat_eirq_ctrl(PIN_BGF_EINT, PIN_STA_EINT_DIS);
+	wmt_plat_bgf_eirq_cb();
+#else
+	WMT_PLAT_PR_INFO("skip irq handing because psm is disable");
+#endif
+
+	return IRQ_HANDLED;
+}
+
+VOID wmt_plat_irq_cb_reg(irq_cb bgf_irq_cb)
+{
+	wmt_plat_bgf_irq_cb = bgf_irq_cb;
+}
+
+VOID wmt_plat_aif_cb_reg(device_audio_if_cb aif_ctrl_cb)
+{
+	wmt_plat_audio_if_cb = aif_ctrl_cb;
+}
+
+VOID wmt_plat_func_ctrl_cb_reg(func_ctrl_cb subsys_func_ctrl)
+{
+	wmt_plat_func_ctrl_cb = subsys_func_ctrl;
+}
+
+VOID wmt_plat_thermal_ctrl_cb_reg(thermal_query_ctrl_cb thermal_query_ctrl)
+{
+	wmt_plat_thermal_query_ctrl_cb = thermal_query_ctrl;
+}
+
+VOID wmt_plat_trigger_assert_cb_reg(trigger_assert_cb trigger_assert)
+{
+	wmt_plat_trigger_assert_cb = trigger_assert;
+}
+
+VOID wmt_plat_deep_idle_ctrl_cb_reg(deep_idle_ctrl_cb deep_idle_ctrl)
+{
+	wmt_plat_deep_idle_ctrl_cb = deep_idle_ctrl;
+}
+
+UINT32 wmt_plat_soc_co_clock_flag_get(VOID)
+{
+	return gCoClockFlag;
+}
+
+static UINT32 wmt_plat_soc_co_clock_flag_set(UINT32 flag)
+{
+	gCoClockFlag = flag;
+	return 0;
+}
+
+INT32 wmt_plat_init(P_PWR_SEQ_TIME pPwrSeqTime, UINT32 co_clock_type)
+{
+	struct _CMB_STUB_CB_ stub_cb;
+	INT32 iret = -1;
+
+	if (wmt_detect_get_chip_type() == WMT_CHIP_TYPE_SOC) {
+		iret = mtk_wcn_consys_co_clock_type();
+		if ((co_clock_type == 0) && (iret >= 0))
+			co_clock_type = iret;
+		wmt_plat_soc_co_clock_flag_set(co_clock_type);
+	}
+
+	stub_cb.aif_ctrl_cb = wmt_plat_audio_ctrl;
+	stub_cb.func_ctrl_cb = wmt_plat_func_ctrl;
+	stub_cb.thermal_query_cb = wmt_plat_thermal_ctrl;
+	stub_cb.trigger_assert_cb = wmt_plat_assert_ctrl;
+	stub_cb.deep_idle_ctrl_cb = wmt_plat_deep_idle_ctrl;
+	stub_cb.wmt_do_reset_cb = NULL;
+	stub_cb.clock_fail_dump_cb = wmt_plat_clock_fail_dump;
+	stub_cb.size = sizeof(stub_cb);
+
+	/* register to cmb_stub */
+	iret = mtk_wcn_cmb_stub_reg(&stub_cb);
+
+	/*init wmt function ctrl wakelock if wake lock is supported by host platform */
+	osal_strcpy(wmt_wake_lock.name, "wmtFuncCtrl");
+	wmt_wake_lock.init_flag = 0;
+	osal_wake_lock_init(&wmt_wake_lock);
+	osal_sleepable_lock_init(&gOsSLock);
+
+	/* init hw */
+	if (wmt_detect_get_chip_type() != WMT_CHIP_TYPE_SOC)
+		iret += mtk_wcn_cmb_hw_init(pPwrSeqTime);
+
+	spin_lock_init(&g_bgf_irq_lock.lock);
+
+	mtk_wcn_consys_detect_adie_chipid(co_clock_type);
+
+	WMT_DBG_FUNC("WMT-PLAT: ALPS platform init (%d)\n", iret);
+
+	return 0;
+}
+
+INT32 wmt_plat_deinit(VOID)
+{
+	INT32 iret = 0;
+
+	/* 1. de-init hw */
+	if (wmt_detect_get_chip_type() == WMT_CHIP_TYPE_SOC)
+		iret += mtk_wcn_consys_hw_deinit();
+	else
+		iret = mtk_wcn_cmb_hw_deinit();
+	/* 2. unreg to cmb_stub */
+	iret += mtk_wcn_cmb_stub_unreg();
+	/*3. wmt wakelock deinit */
+	osal_wake_lock_deinit(&wmt_wake_lock);
+	osal_sleepable_lock_deinit(&gOsSLock);
+	WMT_DBG_FUNC("destroy wmt_wake_lock\n");
+	WMT_DBG_FUNC("WMT-PLAT: ALPS platform init (%d)\n", iret);
+
+	return 0;
+}
+
+INT32 wmt_plat_sdio_ctrl(UINT32 sdioPortType, ENUM_FUNC_STATE on)
+{
+	return board_sdio_ctrl(sdioPortType, (on == FUNC_OFF) ? 0 : 1);
+}
+
+INT32 wmt_plat_irq_ctrl(ENUM_FUNC_STATE state)
+{
+	return -1;
+}
+
+static INT32 wmt_plat_dump_pin_conf(VOID)
+{
+	WMT_DBG_FUNC("[WMT-PLAT]=>dump wmt pin configuration start<=\n");
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_LDO_EN_PIN].gpio_num != DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("LDO(GPIO%d)\n",
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_LDO_EN_PIN].gpio_num);
+	} else
+		WMT_DBG_FUNC("LDO(not defined)\n");
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMU_EN_PIN].gpio_num != DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("PMU(GPIO%d)\n",
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMU_EN_PIN].gpio_num);
+	} else
+		WMT_DBG_FUNC("PMU(not defined)\n");
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMUV28_EN_PIN].gpio_num != DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("PMUV28(GPIO%d)\n",
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMUV28_EN_PIN].gpio_num);
+	} else
+		WMT_DBG_FUNC("PMUV28(not defined)\n");
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_RST_PIN].gpio_num != DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("RST(GPIO%d)\n",
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_RST_PIN].gpio_num);
+	} else
+		WMT_DBG_FUNC("RST(not defined)\n");
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_BGF_EINT_PIN].gpio_num != DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("BGF_EINT(GPIO%d)\n",
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_BGF_EINT_PIN].gpio_num);
+	} else
+		WMT_DBG_FUNC("BGF_EINT(not defined)\n");
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_BGF_EINT_PIN].gpio_num != DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("BGF_EINT_NUM(%d)\n",
+				gpio_to_irq(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_BGF_EINT_PIN].gpio_num));
+	} else
+		WMT_DBG_FUNC("BGF_EINT_NUM(not defined)\n");
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_WIFI_EINT_PIN].gpio_num != DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("WIFI_EINT(GPIO%d)\n",
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_WIFI_EINT_PIN].gpio_num);
+	} else
+		WMT_DBG_FUNC("WIFI_EINT(not defined)\n");
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_WIFI_EINT_PIN].gpio_num != DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("WIFI_EINT_NUM(%d)\n",
+				gpio_to_irq(gpio_ctrl_info.gpio_ctrl_state[GPIO_WIFI_EINT_PIN].gpio_num));
+	} else
+		WMT_DBG_FUNC("WIFI_EINT_NUM(not defined)\n");
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_URXD_PIN].gpio_num != DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("UART_RX(GPIO%d)\n",
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_URXD_PIN].gpio_num);
+	} else
+		WMT_DBG_FUNC("UART_RX(not defined)\n");
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_UTXD_PIN].gpio_num != DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("UART_TX(GPIO%d)\n",
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_UTXD_PIN].gpio_num);
+	} else
+		WMT_DBG_FUNC("UART_TX(not defined)\n");
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAICLK_PIN].gpio_num != DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("DAICLK(GPIO%d)\n",
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAICLK_PIN].gpio_num);
+	} else
+		WMT_DBG_FUNC("DAICLK(not defined)\n");
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAIPCMOUT_PIN].gpio_num != DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("PCMOUT(GPIO%d)\n",
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAIPCMOUT_PIN].gpio_num);
+	} else
+		WMT_DBG_FUNC("PCMOUT(not defined)\n");
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAIPCMIN_PIN].gpio_num != DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("PCMIN(GPIO%d)\n",
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAIPCMIN_PIN].gpio_num);
+	} else
+		WMT_DBG_FUNC("PCMIN(not defined)\n");
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAISYNC_PIN].gpio_num != DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("PCMSYNC(GPIO%d)\n",
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAISYNC_PIN].gpio_num);
+	} else
+		WMT_DBG_FUNC("PCMSYNC(not defined)\n");
+#if defined(FM_DIGITAL_INPUT) || defined(FM_DIGITAL_OUTPUT)
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_I2S_CK_PIN].gpio_num != DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("I2S_CK(GPIO%d)\n",
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_I2S_CK_PIN].gpio_num);
+	} else
+		WMT_DBG_FUNC("I2S_CK(not defined)\n");
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_I2S_WS_PIN].gpio_num != DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("I2S_WS(GPIO%d)\n",
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_I2S_WS_PIN].gpio_num);
+	} else
+		WMT_DBG_FUNC("I2S_WS(not defined)\n");
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_I2S_DAT_PIN].gpio_num != DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("I2S_DAT(GPIO%d)\n",
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_I2S_DAT_PIN].gpio_num);
+	} else
+		WMT_DBG_FUNC("I2S_DAT(not defined)\n");
+
+#else				/* FM_ANALOG_INPUT || FM_ANALOG_OUTPUT */
+	WMT_DBG_FUNC("FM digital mode is not set, no need for I2S GPIOs\n");
+#endif
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_GPS_SYNC_PIN].gpio_num != DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("GPS_SYNC(GPIO%d)\n",
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_GPS_SYNC_PIN].gpio_num);
+	} else
+		WMT_DBG_FUNC("GPS_SYNC(not defined)\n");
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_GPS_LNA_PIN].gpio_num != DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("GPS_LNA(GPIO%d)\n",
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_GPS_LNA_PIN].gpio_num);
+	} else
+		WMT_DBG_FUNC("GPS_LNA(not defined)\n");
+
+	WMT_DBG_FUNC("[WMT-PLAT]=>dump wmt pin configuration emds<=\n");
+
+	return 0;
+}
+
+INT32 wmt_plat_pwr_ctrl(ENUM_FUNC_STATE state)
+{
+	INT32 ret = -1;
+
+	switch (state) {
+	case FUNC_ON:
+		/* TODO:[ChangeFeature][George] always output this or by request throuth /proc or sysfs? */
+		if (wmt_detect_get_chip_type() == WMT_CHIP_TYPE_SOC)
+			ret = mtk_wcn_consys_hw_pwr_on(gCoClockFlag);
+		else {
+			wmt_plat_dump_pin_conf();
+			ret = mtk_wcn_cmb_hw_pwr_on();
+		}
+		break;
+
+	case FUNC_OFF:
+		if (wmt_detect_get_chip_type() == WMT_CHIP_TYPE_SOC)
+			ret = mtk_wcn_consys_hw_pwr_off(gCoClockFlag);
+		else
+			ret = mtk_wcn_cmb_hw_pwr_off();
+		break;
+
+	case FUNC_RST:
+		if (wmt_detect_get_chip_type() == WMT_CHIP_TYPE_SOC)
+			ret = mtk_wcn_consys_hw_rst(gCoClockFlag);
+		else
+			ret = mtk_wcn_cmb_hw_rst();
+		break;
+	case FUNC_STAT:
+		if (wmt_detect_get_chip_type() == WMT_CHIP_TYPE_SOC)
+			ret = mtk_wcn_consys_hw_state_show();
+		else
+			ret = mtk_wcn_cmb_hw_state_show();
+		break;
+	default:
+		WMT_WARN_FUNC("WMT-PLAT:Warnning, invalid state(%d) in pwr_ctrl\n", state);
+		break;
+	}
+
+	return ret;
+}
+
+INT32 wmt_plat_ps_ctrl(ENUM_FUNC_STATE state)
+{
+	return -1;
+}
+
+INT32 wmt_plat_eirq_ctrl(ENUM_PIN_ID id, ENUM_PIN_STATE state)
+{
+	INT32 iret;
+	static UINT32 bgf_irq_num = -1;
+	static UINT32 bgf_irq_flag;
+
+	/* TODO: [ChangeFeature][GeorgeKuo]: use another function to handle this, as done in gpio_ctrls */
+
+	if ((state != PIN_STA_INIT) && (state != PIN_STA_DEINIT) && (state != PIN_STA_EINT_EN)
+			&& (state != PIN_STA_EINT_DIS)) {
+		WMT_WARN_FUNC("WMT-PLAT:invalid PIN_STATE(%d) in eirq_ctrl for PIN(%d)\n", state, id);
+		return -1;
+	}
+
+	iret = -2;
+	switch (id) {
+	case PIN_BGF_EINT:
+		if (state == PIN_STA_INIT) {
+			if (wmt_detect_get_chip_type() == WMT_CHIP_TYPE_SOC) {
+#ifdef CONFIG_OF
+				iret = mtk_wcn_consys_read_irq_info_from_dts(&bgf_irq_num, &bgf_irq_flag);
+				if (iret)
+					return iret;
+#else
+				bgf_irq_num = MT_CONN2AP_BTIF_WAKEUP_IRQ_ID;
+				bgf_irq_flag = IRQF_TRIGGER_LOW;
+#endif
+				iret = request_irq(bgf_irq_num, wmt_plat_bgf_irq_isr, bgf_irq_flag,
+						   "BTIF_WAKEUP_IRQ", NULL);
+				if (iret) {
+					WMT_PLAT_PR_ERR("request_irq fail,irq_no(%d),iret(%d)\n",
+							  bgf_irq_num, iret);
+					return iret;
+				} else {
+					iret = enable_irq_wake(bgf_irq_num);
+					if (iret)
+						WMT_PLAT_PR_ERR("enable irq wake fail,irq_no(%d),iret(%d)\n",
+							bgf_irq_num, iret);
+					iret = 0;
+				}
+			} else {
+				struct device_node *node;
+				INT32 ret = -EINVAL;
+
+				node = of_find_compatible_node(NULL, NULL, "mediatek,connectivity-combo");
+				if (node) {
+					/*BGF-eint name maybe wrong*/
+					bgf_irq_num = irq_of_parse_and_map(node, 1);
+					ret = request_irq(bgf_irq_num, wmt_plat_bgf_irq_isr,
+							  IRQF_TRIGGER_LOW, "BGF-eint", NULL);
+					if (ret)
+						WMT_ERR_FUNC("BGF EINT IRQ LINE NOT AVAILABLE!!\n");
+					else
+						WMT_INFO_FUNC("BGF EINT request_irq success!!\n");
+				} else
+					WMT_ERR_FUNC("[%s] can't find BGF eint compatible node\n",
+						     __func__);
+			}
+			g_bgf_irq_lock.counter = 1;
+		} else if (state == PIN_STA_EINT_EN) {
+			spin_lock_irqsave(&g_bgf_irq_lock.lock, g_bgf_irq_lock.flags);
+			if (g_bgf_irq_lock.counter) {
+				WMT_PLAT_PR_DBG("BGF INT has been enabled,counter(%d)\n",
+						  g_bgf_irq_lock.counter);
+			} else {
+				enable_irq(bgf_irq_num);
+				g_bgf_irq_lock.counter++;
+				WMT_DBG_FUNC("WMT-PLAT:BGFInt (en)\n");
+			}
+			spin_unlock_irqrestore(&g_bgf_irq_lock.lock, g_bgf_irq_lock.flags);
+		} else if (state == PIN_STA_EINT_DIS) {
+			spin_lock_irqsave(&g_bgf_irq_lock.lock, g_bgf_irq_lock.flags);
+			if (!g_bgf_irq_lock.counter) {
+				WMT_PLAT_PR_DBG("BGF INT has been disabled,counter(%d)\n",
+						  g_bgf_irq_lock.counter);
+			} else {
+				disable_irq_nosync(bgf_irq_num);
+				g_bgf_irq_lock.counter--;
+				WMT_DBG_FUNC("WMT-PLAT:BGFInt (dis)\n");
+			}
+			spin_unlock_irqrestore(&g_bgf_irq_lock.lock, g_bgf_irq_lock.flags);
+		} else {
+			free_irq(bgf_irq_num, NULL);
+			WMT_DBG_FUNC("WMT-PLAT:BGFInt (free)\n");
+			/* de-init: nothing to do in ALPS, such as un-registration... */
+		}
+
+		iret = 0;
+		break;
+	case PIN_ALL_EINT:
+		if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_ALL_EINT_PIN].gpio_num != DEFAULT_PIN_ID) {
+			if (state == PIN_STA_INIT) {
+				disable_irq_nosync(gpio_to_irq(gpio_ctrl_info.
+							gpio_ctrl_state[GPIO_COMBO_ALL_EINT_PIN].gpio_num));
+				WMT_DBG_FUNC("WMT-PLAT:ALLInt (INIT but not used yet)\n");
+			} else if (state == PIN_STA_EINT_EN) {
+				enable_irq(gpio_to_irq(gpio_ctrl_info.
+							gpio_ctrl_state[GPIO_COMBO_ALL_EINT_PIN].gpio_num));
+				WMT_DBG_FUNC("WMT-PLAT:ALLInt (EN but not used yet)\n");
+			} else if (state == PIN_STA_EINT_DIS) {
+				disable_irq_nosync(gpio_to_irq(gpio_ctrl_info.
+							gpio_ctrl_state[GPIO_COMBO_ALL_EINT_PIN].gpio_num));
+				WMT_DBG_FUNC("WMT-PLAT:ALLInt (DIS but not used yet)\n");
+			} else {
+				disable_irq_nosync(gpio_to_irq(gpio_ctrl_info.
+							gpio_ctrl_state[GPIO_COMBO_ALL_EINT_PIN].gpio_num));
+				WMT_DBG_FUNC("WMT-PLAT:ALLInt (DEINIT but not used yet)\n");
+				/* de-init: nothing to do in ALPS, such as un-registration... */
+			}
+		} else
+			WMT_DBG_FUNC("WMT-PLAT:ALL EINT not defined\n");
+
+		iret = 0;
+		break;
+
+	default:
+		WMT_WARN_FUNC("WMT-PLAT:unsupported EIRQ(PIN_ID:%d) in eirq_ctrl\n", id);
+		iret = -1;
+		break;
+	}
+
+	return iret;
+}
+
+INT32 wmt_plat_gpio_ctrl(ENUM_PIN_ID id, ENUM_PIN_STATE state)
+{
+	INT32 iret = -1;
+
+	if ((id >= 0) && (id < PIN_ID_MAX) && (state < PIN_STA_MAX)) {
+		/* TODO: [FixMe][GeorgeKuo] do sanity check to const function table when init and skip checking here */
+		if (gfp_set_pin_table[id])
+			iret = (*(gfp_set_pin_table[id]))(state);	/* .handler */
+		else {
+			WMT_WARN_FUNC("WMT-PLAT: null fp for gpio_ctrl(%d)\n", id);
+			iret = -2;
+		}
+	}
+
+	return iret;
+}
+
+static INT32 wmt_plat_ldo_ctrl(ENUM_PIN_STATE state)
+{
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_LDO_EN_PIN].gpio_num == DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("WMT-PLAT:LDO is not used\n");
+		return 0;
+	}
+
+	switch (state) {
+	case PIN_STA_INIT:
+		/*set to gpio output low, disable pull */
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+				gpio_ctrl_state[GPIO_COMBO_LDO_EN_PIN].gpio_state[GPIO_PULL_DIS]);
+		gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_LDO_EN_PIN].gpio_num, 0);
+		WMT_DBG_FUNC("WMT-PLAT:LDO init (out 0)\n");
+		break;
+	case PIN_STA_OUT_H:
+		gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_LDO_EN_PIN].gpio_num, 1);
+		WMT_DBG_FUNC("WMT-PLAT:LDO (out 1)\n");
+		break;
+	case PIN_STA_OUT_L:
+		gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_LDO_EN_PIN].gpio_num, 0);
+		WMT_DBG_FUNC("WMT-PLAT:LDO (out 0)\n");
+		break;
+	case PIN_STA_IN_L:
+	case PIN_STA_DEINIT:
+		/*set to gpio input low, pull down enable */
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+				gpio_ctrl_state[GPIO_COMBO_LDO_EN_PIN].gpio_state[GPIO_IN_PULLDOWN]);
+		WMT_DBG_FUNC("WMT-PLAT:LDO deinit (in pd)\n");
+		break;
+	default:
+		WMT_WARN_FUNC("WMT-PLAT:Warnning, invalid state(%d) on LDO\n", state);
+		break;
+	}
+
+	return 0;
+}
+
+static INT32 wmt_plat_pmu_ctrl(ENUM_PIN_STATE state)
+{
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMU_EN_PIN].gpio_num == DEFAULT_PIN_ID) {
+		WMT_ERR_FUNC("WMT-PLAT:PMU not define\n");
+		return -1;
+	}
+
+	switch (state) {
+	case PIN_STA_INIT:
+		/*set to gpio output low, disable pull */
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info,
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMU_EN_PIN].gpio_state[GPIO_PULL_DIS]);
+		gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMU_EN_PIN].gpio_num, 0);
+		WMT_DBG_FUNC("WMT-PLAT:PMU init (out %d)\n",
+				gpio_get_value(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMU_EN_PIN].gpio_num));
+		if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMUV28_EN_PIN].gpio_num != DEFAULT_PIN_ID) {
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+					gpio_ctrl_state[GPIO_COMBO_PMUV28_EN_PIN].gpio_state[GPIO_PULL_DIS]);
+			gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMUV28_EN_PIN].gpio_num,
+					0);
+		}
+		WMT_DBG_FUNC("WMT-PLAT:PMU init (out 0)\n");
+		break;
+
+	case PIN_STA_OUT_H:
+		gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMU_EN_PIN].gpio_num, 1);
+		WMT_DBG_FUNC("WMT-PLAT:PMU (out 1): %d\n",
+				gpio_get_value(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMU_EN_PIN].gpio_num));
+		if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMUV28_EN_PIN].gpio_num != DEFAULT_PIN_ID)
+			gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMUV28_EN_PIN].gpio_num,
+					1);
+		WMT_DBG_FUNC("WMT-PLAT:PMU (out 1)\n");
+		break;
+
+	case PIN_STA_OUT_L:
+		gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMU_EN_PIN].gpio_num, 0);
+		WMT_DBG_FUNC("WMT-PLAT:PMU (out 0): %d\n",
+				gpio_get_value(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMU_EN_PIN].gpio_num));
+		if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMUV28_EN_PIN].gpio_num != DEFAULT_PIN_ID)
+			gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMUV28_EN_PIN].gpio_num,
+					0);
+		WMT_DBG_FUNC("WMT-PLAT:PMU (out 0)\n");
+		break;
+
+	case PIN_STA_IN_L:
+	case PIN_STA_DEINIT:
+		/*set to gpio input low, pull down enable */
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+				gpio_ctrl_state[GPIO_COMBO_PMU_EN_PIN].gpio_state[GPIO_IN_PULLDOWN]);
+		if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMUV28_EN_PIN].gpio_num != DEFAULT_PIN_ID)
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+					gpio_ctrl_state[GPIO_COMBO_PMUV28_EN_PIN].gpio_state[GPIO_IN_PULLDOWN]);
+		WMT_DBG_FUNC("WMT-PLAT:PMU deinit (in pd)\n");
+		break;
+	case PIN_STA_SHOW:
+		WMT_INFO_FUNC("WMT-PLAT:PMU PIN_STA_SHOW start\n");
+		WMT_INFO_FUNC("WMT-PLAT:PMU out(%d)\n",
+				gpio_get_value(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_PMUV28_EN_PIN].gpio_num));
+		WMT_INFO_FUNC("WMT-PLAT:PMU PIN_STA_SHOW end\n");
+		break;
+	default:
+		WMT_WARN_FUNC("WMT-PLAT:Warnning, invalid state(%d) on PMU\n", state);
+		break;
+	}
+
+	return 0;
+}
+
+static INT32 wmt_plat_rtc_ctrl(ENUM_PIN_STATE state)
+{
+	switch (state) {
+	case PIN_STA_INIT:
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0))
+		rtc_gpio_enable_32k(RTC_GPIO_USER_GPS);
+		WMT_DBG_FUNC("WMT-PLAT:RTC init\n");
+#endif
+		break;
+	case PIN_STA_SHOW:
+		WMT_INFO_FUNC("WMT-PLAT:RTC PIN_STA_SHOW start\n");
+		/* WMT_INFO_FUNC("WMT-PLAT:RTC Status(%d)\n", rtc_gpio_32k_status()); */
+		WMT_INFO_FUNC("WMT-PLAT:RTC PIN_STA_SHOW end\n");
+		break;
+	default:
+		WMT_WARN_FUNC("WMT-PLAT:Warnning, invalid state(%d) on RTC\n", state);
+		break;
+	}
+
+	return 0;
+}
+
+static INT32 wmt_plat_rst_ctrl(ENUM_PIN_STATE state)
+{
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_RST_PIN].gpio_num == DEFAULT_PIN_ID) {
+		WMT_ERR_FUNC("WMT-PLAT:RST not define\n");
+		return -1;
+	}
+
+	switch (state) {
+	case PIN_STA_INIT:
+		/*set to gpio output low, disable pull */
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info,
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_RST_PIN].gpio_state[GPIO_PULL_DIS]);
+		gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_RST_PIN].gpio_num, 0);
+		WMT_DBG_FUNC("WMT-PLAT:RST init (out 0)\n");
+		break;
+
+	case PIN_STA_OUT_H:
+		gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_RST_PIN].gpio_num, 1);
+		WMT_DBG_FUNC("WMT-PLAT:RST (out 1): %d\n",
+				gpio_get_value(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_RST_PIN].gpio_num));
+		break;
+
+	case PIN_STA_OUT_L:
+		gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_RST_PIN].gpio_num, 0);
+		WMT_DBG_FUNC("WMT-PLAT:RST (out 0): %d\n",
+			gpio_get_value(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_RST_PIN].gpio_num));
+		break;
+
+	case PIN_STA_IN_L:
+	case PIN_STA_DEINIT:
+		/*set to gpio input low, pull down enable */
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info,
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_RST_PIN].gpio_state[GPIO_IN_PULLDOWN]);
+		WMT_DBG_FUNC("WMT-PLAT:RST deinit (in pd)\n");
+		break;
+	case PIN_STA_SHOW:
+		WMT_INFO_FUNC("WMT-PLAT:RST PIN_STA_SHOW start\n");
+		WMT_INFO_FUNC("WMT-PLAT:RST out(%d)\n",
+				gpio_get_value(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_RST_PIN].gpio_num));
+		WMT_INFO_FUNC("WMT-PLAT:RST PIN_STA_SHOW end\n");
+		break;
+
+	default:
+		WMT_WARN_FUNC("WMT-PLAT:Warnning, invalid state(%d) on RST\n", state);
+		break;
+	}
+
+	return 0;
+}
+
+static INT32 wmt_plat_bgf_eint_ctrl(ENUM_PIN_STATE state)
+{
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_BGF_EINT_PIN].gpio_num == DEFAULT_PIN_ID) {
+		WMT_INFO_FUNC("WMT-PLAT:BGF EINT not defined\n");
+		return 0;
+	}
+
+	switch (state) {
+	case PIN_STA_INIT:
+		/*set to gpio input low, pull down enable */
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+				gpio_ctrl_state[GPIO_COMBO_BGF_EINT_PIN].gpio_state[GPIO_IN_PULLDOWN]);
+		WMT_DBG_FUNC("WMT-PLAT:BGFInt init(in pd)\n");
+		break;
+	case PIN_STA_MUX:
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+				gpio_ctrl_state[GPIO_COMBO_BGF_EINT_PIN].gpio_state[GPIO_IN_PULLUP]);
+		WMT_DBG_FUNC("WMT-PLAT:BGFInt mux (eint)\n");
+		break;
+	case PIN_STA_IN_L:
+	case PIN_STA_DEINIT:
+		/*set to gpio input low, pull down enable */
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+				gpio_ctrl_state[GPIO_COMBO_BGF_EINT_PIN].gpio_state[GPIO_IN_PULLDOWN]);
+		WMT_DBG_FUNC("WMT-PLAT:BGFInt deinit(in pd)\n");
+		break;
+	default:
+		WMT_WARN_FUNC("WMT-PLAT:Warnning, invalid state(%d) on BGF EINT\n", state);
+		break;
+	}
+
+	return 0;
+}
+
+
+static INT32 wmt_plat_wifi_eint_ctrl(ENUM_PIN_STATE state)
+{
+#if 0				/*def GPIO_WIFI_EINT_PIN */
+	switch (state) {
+	case PIN_STA_INIT:
+		mt_set_gpio_pull_enable(GPIO_WIFI_EINT_PIN, GPIO_PULL_DISABLE);
+		mt_set_gpio_dir(GPIO_WIFI_EINT_PIN, GPIO_DIR_OUT);
+		mt_set_gpio_mode(GPIO_WIFI_EINT_PIN, GPIO_MODE_GPIO);
+		mt_set_gpio_out(GPIO_WIFI_EINT_PIN, GPIO_OUT_ONE);
+		break;
+	case PIN_STA_MUX:
+		mt_set_gpio_mode(GPIO_WIFI_EINT_PIN, GPIO_WIFI_EINT_PIN_M_GPIO);
+		mt_set_gpio_pull_enable(GPIO_WIFI_EINT_PIN, GPIO_PULL_ENABLE);
+		mt_set_gpio_pull_select(GPIO_WIFI_EINT_PIN, GPIO_PULL_UP);
+		mt_set_gpio_mode(GPIO_WIFI_EINT_PIN, GPIO_WIFI_EINT_PIN_M_EINT);
+
+		break;
+	case PIN_STA_EINT_EN:
+		mt_eint_unmask(CUST_EINT_WIFI_NUM);
+		break;
+	case PIN_STA_EINT_DIS:
+		mt_eint_mask(CUST_EINT_WIFI_NUM);
+		break;
+	case PIN_STA_IN_L:
+	case PIN_STA_DEINIT:
+		/*set to gpio input low, pull down enable */
+		mt_set_gpio_mode(GPIO_WIFI_EINT_PIN, GPIO_COMBO_BGF_EINT_PIN_M_GPIO);
+		mt_set_gpio_dir(GPIO_WIFI_EINT_PIN, GPIO_DIR_IN);
+		mt_set_gpio_pull_select(GPIO_WIFI_EINT_PIN, GPIO_PULL_DOWN);
+		mt_set_gpio_pull_enable(GPIO_WIFI_EINT_PIN, GPIO_PULL_ENABLE);
+		break;
+	default:
+		WMT_WARN_FUNC("WMT-PLAT:Warnning, invalid state(%d) on WIFI EINT\n", state);
+		break;
+	}
+#else
+	WMT_INFO_FUNC("WMT-PLAT:WIFI EINT is controlled by MSDC driver\n");
+#endif
+	return 0;
+}
+
+
+static INT32 wmt_plat_all_eint_ctrl(ENUM_PIN_STATE state)
+{
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_ALL_EINT_PIN].gpio_num == DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("WMT-PLAT:ALL EINT not defined\n");
+		return 0;
+	}
+
+	switch (state) {
+	case PIN_STA_INIT:
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+				gpio_ctrl_state[GPIO_COMBO_ALL_EINT_PIN].gpio_state[GPIO_IN_PULLDOWN]);
+		WMT_DBG_FUNC("WMT-PLAT:ALLInt init(in pd)\n");
+		break;
+	case PIN_STA_MUX:
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+				gpio_ctrl_state[GPIO_COMBO_ALL_EINT_PIN].gpio_state[GPIO_IN_PULLUP]);
+		break;
+	case PIN_STA_IN_L:
+	case PIN_STA_DEINIT:
+		/*set to gpio input low, pull down enable */
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+				gpio_ctrl_state[GPIO_COMBO_ALL_EINT_PIN].gpio_state[GPIO_IN_PULLDOWN]);
+		break;
+	default:
+		WMT_WARN_FUNC("WMT-PLAT:Warnning, invalid state(%d) on ALL EINT\n", state);
+		break;
+	}
+
+	return 0;
+}
+
+static INT32 wmt_plat_uart_ctrl(ENUM_PIN_STATE state)
+{
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_UTXD_PIN].gpio_num == DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("WMT-PLAT:UART TX not defined\n");
+		return 0;
+	}
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_URXD_PIN].gpio_num == DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("WMT-PLAT:UART RX not defined\n");
+		return 0;
+	}
+
+	switch (state) {
+	case PIN_STA_MUX:
+	case PIN_STA_INIT:
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+				gpio_ctrl_state[GPIO_COMBO_URXD_PIN].gpio_state[GPIO_PULL_DIS]);
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+				gpio_ctrl_state[GPIO_COMBO_UTXD_PIN].gpio_state[GPIO_PULL_DIS]);
+		WMT_DBG_FUNC("WMT-PLAT:UART init (mode_01, uart)\n");
+		break;
+	case PIN_STA_IN_L:
+	case PIN_STA_DEINIT:
+		gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_URXD_PIN].gpio_num, 0);
+		gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_UTXD_PIN].gpio_num, 0);
+		WMT_DBG_FUNC("WMT-PLAT:UART deinit (out 0)\n");
+		break;
+	case PIN_STA_IN_PU:
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+				gpio_ctrl_state[GPIO_COMBO_URXD_PIN].gpio_state[GPIO_IN_PULLUP]);
+		break;
+	default:
+		WMT_WARN_FUNC("WMT-PLAT:Warnning, invalid state(%d) on UART Group\n", state);
+		break;
+	}
+
+	return 0;
+}
+
+static INT32 wmt_plat_pcm_ctrl(ENUM_PIN_STATE state)
+{
+	UINT32 normalPCMFlag = 0;
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAICLK_PIN].gpio_num == DEFAULT_PIN_ID) {
+		WMT_INFO_FUNC("WMT-PLAT:PCM DAICLK not defined\n");
+		return 0;
+	}
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAIPCMOUT_PIN].gpio_num == DEFAULT_PIN_ID) {
+		WMT_INFO_FUNC("WMT-PLAT:PCM DAIPCMOUT not defined\n");
+		return 0;
+	}
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAIPCMIN_PIN].gpio_num == DEFAULT_PIN_ID) {
+		WMT_INFO_FUNC("WMT-PLAT:PCM DAIPCMIN not defined\n");
+		return 0;
+	}
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAISYNC_PIN].gpio_num == DEFAULT_PIN_ID) {
+		WMT_INFO_FUNC("WMT-PLAT:PCM DAISYNC not defined\n");
+		return 0;
+	}
+	/*check if combo chip support merge if or not */
+	if (wmt_plat_merge_if_flag_get() != 0) {
+#if (MTK_WCN_CMB_MERGE_INTERFACE_SUPPORT)
+		/* Hardware support Merge IF function */
+		WMT_DBG_FUNC("WMT-PLAT:<Merge IF>set to Merge PCM function\n");
+		/*merge PCM function define */
+		switch (state) {
+		case PIN_STA_MUX:
+		case PIN_STA_INIT:
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+					gpio_ctrl_state[GPIO_PCM_DAICLK_PIN].gpio_state[GPIO_PULL_DIS]);
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+					gpio_ctrl_state[GPIO_PCM_DAIPCMOUT_PIN].gpio_state[GPIO_PULL_DIS]);
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+					gpio_ctrl_state[GPIO_PCM_DAIPCMIN_PIN].gpio_state[GPIO_PULL_DIS]);
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+					gpio_ctrl_state[GPIO_PCM_DAISYNC_PIN].gpio_state[GPIO_PULL_DIS]);
+			WMT_DBG_FUNC("WMT-PLAT:<Merge IF>PCM init (pcm)\n");
+			break;
+
+		case PIN_STA_IN_L:
+		case PIN_STA_DEINIT:
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info,
+					gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAICLK_PIN].gpio_state[GPIO_PULL_DIS]);
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+					gpio_ctrl_state[GPIO_PCM_DAIPCMOUT_PIN].gpio_state[GPIO_PULL_DIS]);
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+					gpio_ctrl_state[GPIO_PCM_DAIPCMIN_PIN].gpio_state[GPIO_PULL_DIS]);
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+					gpio_ctrl_state[GPIO_PCM_DAISYNC_PIN].gpio_state[GPIO_PULL_DIS]);
+			WMT_DBG_FUNC("WMT-PLAT:<Merge IF>PCM deinit (out 0)\n");
+			break;
+
+		default:
+			WMT_WARN_FUNC
+			    ("WMT-PLAT:<Merge IF>Warnning, invalid state(%d) on PCM Group\n",
+			     state);
+			break;
+		}
+
+#else
+		/* Hardware does not support Merge IF function */
+		normalPCMFlag = 1;
+		WMT_DBG_FUNC("WMT-PLAT:set to normal PCM function\n");
+#endif
+
+	} else {
+		normalPCMFlag = 1;
+	}
+
+	if (normalPCMFlag != 0) {
+		/*normal PCM function define */
+		switch (state) {
+		case PIN_STA_MUX:
+		case PIN_STA_INIT:
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info,
+					gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAICLK_PIN].gpio_state[GPIO_PULL_DIS]);
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+					gpio_ctrl_state[GPIO_PCM_DAIPCMOUT_PIN].gpio_state[GPIO_PULL_DIS]);
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+					gpio_ctrl_state[GPIO_PCM_DAIPCMIN_PIN].gpio_state[GPIO_PULL_DIS]);
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+					gpio_ctrl_state[GPIO_PCM_DAISYNC_PIN].gpio_state[GPIO_PULL_DIS]);
+			WMT_DBG_FUNC("WMT-PLAT:MT6589 PCM init (pcm)\n");
+			break;
+
+		case PIN_STA_IN_L:
+		case PIN_STA_DEINIT:
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info,
+					gpio_ctrl_info.gpio_ctrl_state[GPIO_PCM_DAICLK_PIN].gpio_state[GPIO_PULL_DIS]);
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+					gpio_ctrl_state[GPIO_PCM_DAIPCMOUT_PIN].gpio_state[GPIO_PULL_DIS]);
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+					gpio_ctrl_state[GPIO_PCM_DAIPCMIN_PIN].gpio_state[GPIO_PULL_DIS]);
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+					gpio_ctrl_state[GPIO_PCM_DAISYNC_PIN].gpio_state[GPIO_PULL_DIS]);
+			WMT_DBG_FUNC("WMT-PLAT:MT6589 PCM deinit (out 0)\n");
+			break;
+
+		default:
+			WMT_WARN_FUNC("WMT-PLAT:MT6589 Warnning, invalid state(%d) on PCM Group\n",
+				      state);
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static INT32 wmt_plat_cmb_i2s_ctrl(ENUM_PIN_STATE state)
+{
+	UINT32 normalI2SFlag = 0;
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_I2S_CK_PIN].gpio_num == DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("WMT-PLAT:I2S CK not defined\n");
+		return 0;
+	}
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_I2S_WS_PIN].gpio_num == DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("WMT-PLAT:I2S WS not defined\n");
+		return 0;
+	}
+
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_I2S_DAT_PIN].gpio_num == DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("WMT-PLAT:DAT CK not defined\n");
+		return 0;
+	}
+	/*check if combo chip support merge if or not */
+	if (wmt_plat_merge_if_flag_get() != 0) {
+#if (MTK_WCN_CMB_MERGE_INTERFACE_SUPPORT)
+		/* Hardware support Merge IF function */
+#if defined(FM_DIGITAL_INPUT) || defined(FM_DIGITAL_OUTPUT)
+		if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_I2S_CK_PIN].gpio_num != DEFAULT_PIN_ID) {
+			switch (state) {
+			case PIN_STA_INIT:
+			case PIN_STA_MUX:
+				pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+						gpio_ctrl_state[GPIO_COMBO_I2S_CK_PIN].gpio_state[GPIO_PULL_DIS]);
+				pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+						gpio_ctrl_state[GPIO_COMBO_I2S_WS_PIN].gpio_state[GPIO_PULL_DIS]);
+				pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+						gpio_ctrl_state[GPIO_COMBO_I2S_DAT_PIN].gpio_state[GPIO_PULL_DIS]);
+				pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+						gpio_ctrl_state[GPIO_COMBO_PCM_DAIPMCOUT_PIN].
+							gpio_state[GPIO_PULL_DIS]);
+				WMT_DBG_FUNC("WMT-PLAT:<Merge IF>I2S init (I2S0 system)\n");
+				break;
+			case PIN_STA_IN_L:
+			case PIN_STA_DEINIT:
+				gpio_direction_output(gpio_ctrl_info.
+						gpio_ctrl_state[GPIO_COMBO_I2S_CK_PIN].gpio_num, 0);
+				gpio_direction_output(gpio_ctrl_info.
+						gpio_ctrl_state[GPIO_COMBO_I2S_WS_PIN].gpio_num, 0);
+				gpio_direction_output(gpio_ctrl_info.
+						gpio_ctrl_state[GPIO_COMBO_I2S_DAT_PIN].gpio_num, 0);
+				WMT_DBG_FUNC("WMT-PLAT:<Merge IF>I2S deinit (out 0)\n");
+				break;
+			default:
+				WMT_WARN_FUNC("WMT-PLAT:<Merge IF>Warnning, invalid state(%d) on I2S Group\n",
+						state);
+				break;
+			}
+		} else
+			WMT_ERR_FUNC("[MT662x]<Merge IF>Error:FM digital mode set, no I2S GPIOs defined\n");
+#else
+		WMT_INFO_FUNC("[MT662x]<Merge IF>warnning:FM digital mode is not set\n");
+		WMT_INFO_FUNC("no I2S GPIO settings should be modified by combo driver\n");
+#endif
+#else
+		/* Hardware does support Merge IF function */
+		normalI2SFlag = 1;
+#endif
+	} else
+		normalI2SFlag = 1;
+
+	if (normalI2SFlag != 0) {
+#if defined(FM_DIGITAL_INPUT) || defined(FM_DIGITAL_OUTPUT)
+		if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_I2S_CK_PIN].gpio_num != DEFAULT_PIN_ID) {
+			switch (state) {
+			case PIN_STA_INIT:
+			case PIN_STA_MUX:
+				pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+						gpio_ctrl_state[GPIO_COMBO_I2S_CK_PIN].gpio_state[GPIO_PULL_DIS]);
+				pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+						gpio_ctrl_state[GPIO_COMBO_I2S_WS_PIN].gpio_state[GPIO_PULL_DIS]);
+				pinctrl_select_state(gpio_ctrl_info.pinctrl_info, gpio_ctrl_info.
+						gpio_ctrl_state[GPIO_COMBO_I2S_DAT_PIN].gpio_state[GPIO_PULL_DIS]);
+				WMT_DBG_FUNC("WMT-PLAT:<I2S IF>I2S init (I2S0 system)\n");
+				break;
+			case PIN_STA_IN_L:
+			case PIN_STA_DEINIT:
+				gpio_direction_output(gpio_ctrl_info.
+						gpio_ctrl_state[GPIO_COMBO_I2S_CK_PIN].gpio_num, 0);
+				gpio_direction_output(gpio_ctrl_info.
+						gpio_ctrl_state[GPIO_COMBO_I2S_WS_PIN].gpio_num, 0);
+				gpio_direction_output(gpio_ctrl_info.
+						gpio_ctrl_state[GPIO_COMBO_I2S_DAT_PIN].gpio_num, 0);
+				WMT_DBG_FUNC("WMT-PLAT:<I2S IF>I2S deinit (out 0)\n");
+				break;
+			default:
+				WMT_WARN_FUNC("WMT-PLAT:<I2S IF>Warnning, invalid state(%d) on I2S Group\n",
+					      state);
+				break;
+			}
+		} else
+			WMT_ERR_FUNC("[MT662x]<I2S IF>Error:FM digital mode set, but no I2S GPIOs defined\n");
+#else
+		WMT_INFO_FUNC("[MT662x]<I2S IF>warnning:FM digital mode is not set\n");
+		WMT_INFO_FUNC("no I2S GPIO settings should be modified by combo driver\n");
+#endif
+	}
+
+	return 0;
+}
+
+static INT32 wmt_plat_soc_i2s_ctrl(ENUM_PIN_STATE state)
+{
+	WMT_PLAT_PR_WARN("host i2s pin not defined!!!\n");
+
+	return 0;
+}
+
+static INT32 wmt_plat_i2s_ctrl(ENUM_PIN_STATE state)
+{
+	INT32 ret = -1;
+
+	if (wmt_detect_get_chip_type() == WMT_CHIP_TYPE_SOC)
+		ret = wmt_plat_soc_i2s_ctrl(state);
+	else
+		ret = wmt_plat_cmb_i2s_ctrl(state);
+
+	return ret;
+}
+
+static INT32 wmt_plat_sdio_pin_ctrl(ENUM_PIN_STATE state)
+{
+	return 0;
+}
+
+static INT32 wmt_plat_cmb_gps_sync_ctrl(ENUM_PIN_STATE state)
+{
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_GPS_SYNC_PIN].gpio_num == DEFAULT_PIN_ID) {
+		WMT_INFO_FUNC("WMT-PLAT:GPS SYNC not defined\n");
+		return 0;
+	}
+
+	switch (state) {
+	case PIN_STA_INIT:
+	case PIN_STA_DEINIT:
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info,
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_GPS_SYNC_PIN].gpio_state[GPIO_PULL_DIS]);
+		gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_GPS_SYNC_PIN].gpio_num, 0);
+		break;
+	case PIN_STA_MUX:
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info,
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_GPS_SYNC_PIN].gpio_state[GPIO_PULL_DIS]);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static INT32 wmt_plat_soc_gps_sync_ctrl(ENUM_PIN_STATE state)
+{
+	WMT_PLAT_PR_WARN("host gps sync pin not defined!!!\n");
+
+	return 0;
+}
+
+static INT32 wmt_plat_gps_sync_ctrl(ENUM_PIN_STATE state)
+{
+	INT32 ret = -1;
+
+	if (wmt_detect_get_chip_type() == WMT_CHIP_TYPE_SOC)
+		ret = wmt_plat_soc_gps_sync_ctrl(state);
+	else
+		ret = wmt_plat_cmb_gps_sync_ctrl(state);
+
+	return ret;
+}
+
+static INT32 wmt_plat_soc_gps_lna_ctrl(ENUM_PIN_STATE state)
+{
+#ifdef CONFIG_MTK_MT6306_GPIO_SUPPORT
+	switch (state) {
+	case PIN_STA_INIT:
+	case PIN_STA_DEINIT:
+		KERNEL_mt6306_set_gpio_dir(MT6306_GPIO_01, MT6306_GPIO_DIR_OUT);
+		KERNEL_mt6306_set_gpio_out(MT6306_GPIO_01, MT6306_GPIO_OUT_LOW);
+		WMT_PLAT_PR_DBG("set gps lna to init\n");
+		break;
+	case PIN_STA_OUT_H:
+		KERNEL_mt6306_set_gpio_out(MT6306_GPIO_01, MT6306_GPIO_OUT_HIGH);
+		WMT_PLAT_PR_DBG("set gps lna to oh\n");
+		break;
+	case PIN_STA_OUT_L:
+		KERNEL_mt6306_set_gpio_out(MT6306_GPIO_01, MT6306_GPIO_OUT_LOW);
+		WMT_PLAT_PR_DBG("set gps lna to ol\n");
+		break;
+	default:
+		WMT_PLAT_PR_WARN("%d mode not defined for  gps lna pin !!!\n", state);
+		break;
+	}
+#else
+	struct pinctrl_state *gps_lna_init = NULL;
+	struct pinctrl_state *gps_lna_oh = NULL;
+	struct pinctrl_state *gps_lna_ol = NULL;
+	struct pinctrl *consys_pinctrl = NULL;
+
+	WMT_PLAT_PR_DBG("ENTER++\n");
+	consys_pinctrl = mtk_wcn_consys_get_pinctrl();
+	if (!consys_pinctrl) {
+		WMT_PLAT_PR_ERR("get consys pinctrl fail\n");
+		return 0;
+	}
+
+	gps_lna_init = pinctrl_lookup_state(consys_pinctrl, "gps_lna_state_init");
+	if (IS_ERR(gps_lna_init)) {
+		WMT_PLAT_PR_ERR("Cannot find gps lna pin init state!\n");
+		return 0;
+	}
+
+	gps_lna_oh = pinctrl_lookup_state(consys_pinctrl, "gps_lna_state_oh");
+	if (IS_ERR(gps_lna_oh)) {
+		WMT_PLAT_PR_ERR("Cannot find gps lna pin oh state!\n");
+		return 0;
+	}
+
+	gps_lna_ol = pinctrl_lookup_state(consys_pinctrl, "gps_lna_state_ol");
+	if (IS_ERR(gps_lna_ol)) {
+		WMT_PLAT_PR_ERR("Cannot find gps lna pin ol state!\n");
+		return 0;
+	}
+
+	switch (state) {
+	case PIN_STA_INIT:
+	case PIN_STA_DEINIT:
+		pinctrl_select_state(consys_pinctrl, gps_lna_init);
+		WMT_PLAT_PR_DBG("set gps lna to init\n");
+		break;
+	case PIN_STA_OUT_H:
+		pinctrl_select_state(consys_pinctrl, gps_lna_oh);
+		WMT_PLAT_PR_DBG("set gps lna to oh\n");
+		break;
+	case PIN_STA_OUT_L:
+		pinctrl_select_state(consys_pinctrl, gps_lna_ol);
+		WMT_PLAT_PR_DBG("set gps lna to ol\n");
+		break;
+	default:
+		WMT_PLAT_PR_WARN("%d mode not defined for  gps lna pin !!!\n", state);
+		break;
+	}
+#endif
+
+	return 0;
+}
+
+static INT32 wmt_plat_cmb_gps_lna_ctrl(ENUM_PIN_STATE state)
+{
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_GPS_LNA_PIN].gpio_num != DEFAULT_PIN_ID) {
+		switch (state) {
+		case PIN_STA_INIT:
+		case PIN_STA_DEINIT:
+			pinctrl_select_state(gpio_ctrl_info.pinctrl_info,
+					gpio_ctrl_info.gpio_ctrl_state[GPIO_GPS_LNA_PIN].gpio_state[GPIO_PULL_DIS]);
+			gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_GPS_LNA_PIN].gpio_num, 0);
+			break;
+		case PIN_STA_OUT_H:
+			gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_GPS_LNA_PIN].gpio_num, 1);
+			break;
+		case PIN_STA_OUT_L:
+			gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_GPS_LNA_PIN].gpio_num, 0);
+			break;
+		default:
+			WMT_WARN_FUNC("%d mode not defined for  gps lna pin !!!\n", state);
+			break;
+		}
+	} else {
+#ifdef CONFIG_MTK_MT6306_GPIO_SUPPORT
+		WMT_WARN_FUNC("/******************************************************************/\n");
+		WMT_WARN_FUNC("use MT6306 GPIO7 for  gps lna pin.\n this HARD CODE may hurt other\n");
+		WMT_WARN_FUNC("system module, if GPIO7 of MT6306 is not defined as GPS_LNA function\n");
+		WMT_WARN_FUNC("/******************************************************************/\n");
+
+		switch (state) {
+		case PIN_STA_INIT:
+		case PIN_STA_DEINIT:
+			/* KERNEL_mt6306_set_gpio_dir(GPIO7, GPIO_DIR_OUT); */
+			/* KERNEL_mt6306_set_gpio_out(GPIO7, GPIO_OUT_ZERO); */
+			break;
+		case PIN_STA_OUT_H:
+			/* KERNEL_mt6306_set_gpio_out(GPIO7, GPIO_OUT_ONE); */
+			break;
+		case PIN_STA_OUT_L:
+			/* KERNEL_mt6306_set_gpio_out(GPIO7, GPIO_OUT_ZERO); */
+			break;
+		default:
+			WMT_WARN_FUNC("%d mode not defined for  gps lna pin !!!\n", state);
+			break;
+		}
+#else
+		WMT_WARN_FUNC("host gps lna pin not defined!!!\n");
+		WMT_WARN_FUNC("if you donot use eighter AP or MT6306's pin as GPS_LNA\n");
+		WMT_WARN_FUNC("please customize your own GPS_LNA related code here\n");
+#endif
+	}
+
+	return 0;
+}
+
+static INT32 wmt_plat_gps_lna_ctrl(ENUM_PIN_STATE state)
+{
+	INT32 ret = -1;
+
+	if (wmt_detect_get_chip_type() == WMT_CHIP_TYPE_SOC)
+		ret = wmt_plat_soc_gps_lna_ctrl(state);
+	else
+		ret = wmt_plat_cmb_gps_lna_ctrl(state);
+
+	return ret;
+}
+
+static INT32 wmt_plat_uart_rx_ctrl(ENUM_PIN_STATE state)
+{
+	if (gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_URXD_PIN].gpio_num == DEFAULT_PIN_ID) {
+		WMT_DBG_FUNC("WMT-PLAT:UART RX not defined\n");
+		return 0;
+	}
+
+	switch (state) {
+	case PIN_STA_MUX:
+	case PIN_STA_INIT:
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info,
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_URXD_PIN].gpio_state[GPIO_PULL_DIS]);
+		WMT_DBG_FUNC("WMT-PLAT:UART Rx init\n");
+		break;
+	case PIN_STA_IN_L:
+	case PIN_STA_DEINIT:
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info,
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_URXD_PIN].gpio_state[GPIO_PULL_DIS]);
+		gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_URXD_PIN].gpio_num, 0);
+		WMT_DBG_FUNC("WMT-PLAT:UART Rx deinit (out 0)\n");
+		break;
+	case PIN_STA_IN_NP:
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info,
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_URXD_PIN].gpio_state[GPIO_IN_PULL_DIS]);
+		WMT_DBG_FUNC("WMT-PLAT:UART Rx input pull none\n");
+		break;
+	case PIN_STA_IN_H:
+		pinctrl_select_state(gpio_ctrl_info.pinctrl_info,
+				gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_URXD_PIN].gpio_state[GPIO_IN_PULLUP]);
+		WMT_DBG_FUNC("WMT-PLAT:UART Rx input pull high\n");
+		break;
+	case PIN_STA_OUT_H:
+		gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_URXD_PIN].gpio_num, 1);
+		WMT_DBG_FUNC("WMT-PLAT:UART Rx output high\n");
+		break;
+	case PIN_STA_OUT_L:
+		gpio_direction_output(gpio_ctrl_info.gpio_ctrl_state[GPIO_COMBO_URXD_PIN].gpio_num, 0);
+		WMT_DBG_FUNC("WMT-PLAT:UART Rx deinit (out 0)\n");
+		break;
+	default:
+		WMT_WARN_FUNC("WMT-PLAT:Warnning, invalid state(%d) on UART Rx\n", state);
+		break;
+	}
+
+	return 0;
+}
+
+#if CFG_WMT_LTE_COEX_HANDLING
+static INT32 wmt_plat_tdm_req_ctrl(ENUM_PIN_STATE state)
+{
+	return 0;
+}
+#endif
+
+INT32 wmt_plat_wake_lock_ctrl(ENUM_WL_OP opId)
+{
+	static INT32 counter;
+	INT32 ret = 0;
+
+	ret = osal_lock_sleepable_lock(&gOsSLock);
+	if (ret) {
+		WMT_ERR_FUNC("--->lock gOsSLock failed, ret=%d\n", ret);
+		return ret;
+	}
+
+	if (opId == WL_OP_GET)
+		++counter;
+	else if (opId == WL_OP_PUT)
+		--counter;
+
+	osal_unlock_sleepable_lock(&gOsSLock);
+	if (opId == WL_OP_GET && counter == 1) {
+		osal_wake_lock(&wmt_wake_lock);
+		WMT_DBG_FUNC("WMT-PLAT: after wake_lock(%d), counter(%d)\n",
+				osal_wake_lock_count(&wmt_wake_lock), counter);
+
+	} else if (opId == WL_OP_PUT && counter == 0) {
+		osal_wake_unlock(&wmt_wake_lock);
+		WMT_DBG_FUNC("WMT-PLAT: after wake_unlock(%d), counter(%d)\n",
+				osal_wake_lock_count(&wmt_wake_lock), counter);
+	} else {
+		WMT_WARN_FUNC("WMT-PLAT: wakelock status(%d), counter(%d)\n",
+				osal_wake_lock_count(&wmt_wake_lock), counter);
+	}
+
+	return 0;
+}
+
+
+INT32 wmt_plat_merge_if_flag_ctrl(UINT32 enable)
+{
+	if (enable) {
+#if (MTK_WCN_CMB_MERGE_INTERFACE_SUPPORT)
+		gWmtMergeIfSupport = 1;
+#else
+		gWmtMergeIfSupport = 0;
+		WMT_WARN_FUNC("neither MT6589, MTK_MERGE_INTERFACE_SUPPORT nor MT6628 is not set to 1\n");
+		WMT_WARN_FUNC("so set gWmtMergeIfSupport to %d\n", gWmtMergeIfSupport);
+#endif
+	} else
+		gWmtMergeIfSupport = 0;
+
+	WMT_INFO_FUNC("set gWmtMergeIfSupport to %d\n", gWmtMergeIfSupport);
+
+	return gWmtMergeIfSupport;
+}
+
+INT32 wmt_plat_merge_if_flag_get(VOID)
+{
+	return gWmtMergeIfSupport;
+}
+
+INT32 wmt_plat_set_comm_if_type(ENUM_STP_TX_IF_TYPE type)
+{
+	gCommIfType = type;
+
+	return 0;
+}
+
+ENUM_STP_TX_IF_TYPE wmt_plat_get_comm_if_type(VOID)
+{
+	return gCommIfType;
+}
+
+INT32 wmt_plat_soc_paldo_ctrl(ENUM_PALDO_TYPE ePt, ENUM_PALDO_OP ePo)
+{
+	INT32 iRet = 0;
+
+	switch (ePt) {
+	case BT_PALDO:
+		iRet = mtk_wcn_consys_hw_bt_paldo_ctrl(ePo);
+		break;
+	case WIFI_PALDO:
+		iRet = mtk_wcn_consys_hw_wifi_paldo_ctrl(ePo);
+		break;
+	case FM_PALDO:
+	case GPS_PALDO:
+		iRet = mtk_wcn_consys_hw_vcn28_ctrl(ePo);
+		break;
+	case EFUSE_PALDO:
+		iRet = mtk_wcn_consys_hw_efuse_paldo_ctrl(ePo, wmt_plat_soc_co_clock_flag_get());
+		break;
+	default:
+		WMT_PLAT_PR_WARN("WMT-PLAT:Warnning, invalid type(%d) in palod_ctrl\n", ePt);
+		break;
+	}
+
+	return iRet;
+}
+
+#if CONSYS_WMT_REG_SUSPEND_CB_ENABLE
+UINT32 wmt_plat_soc_osc_en_ctrl(UINT32 en)
+{
+	return mtk_wcn_consys_hw_osc_en_ctrl(en);
+}
+#endif
+
+UINT8 *wmt_plat_get_emi_virt_add(UINT32 offset)
+{
+	return mtk_wcn_consys_emi_virt_addr_get(offset);
+}
+
+P_CONSYS_EMI_ADDR_INFO wmt_plat_get_emi_phy_add(VOID)
+{
+	return mtk_wcn_consys_soc_get_emi_phy_add();
+}
+
+#if CONSYS_ENALBE_SET_JTAG
+UINT32 wmt_plat_jtag_flag_ctrl(UINT32 en)
+{
+	return mtk_wcn_consys_jtag_flag_ctrl(en);
+}
+#endif
+
+#if CFG_WMT_DUMP_INT_STATUS
+VOID wmt_plat_BGF_irq_dump_status(VOID)
+{
+	mt_irq_dump_status(269);/*tag3 wujun rainier is enabled */
+
+	WMT_PLAT_PR_INFO("this function is null in MT6735\n");
+}
+
+MTK_WCN_BOOL wmt_plat_dump_BGF_irq_status(VOID)
+{
+	return MTK_WCN_BOOL_FALSE;/*tag4 wujun rainier is enabled */
+}
+#endif
+
+UINT32 wmt_plat_read_cpupcr(VOID)
+{
+	return mtk_wcn_consys_read_cpupcr();
+}
+EXPORT_SYMBOL(wmt_plat_read_cpupcr);
+
+UINT32 wmt_plat_read_dmaregs(UINT32 type)
+{
+	return 0;
+#if 0
+	switch (type) {
+	case CONNSYS_CLK_GATE_STATUS:
+		return CONSYS_REG_READ(CONNSYS_CLK_GATE_STATUS_REG);
+	case CONSYS_EMI_STATUS:
+		return CONSYS_REG_READ(CONSYS_EMI_STATUS_REG);
+	case SYSRAM1:
+		return CONSYS_REG_READ(SYSRAM1_REG);
+	case SYSRAM2:
+		return CONSYS_REG_READ(SYSRAM2_REG);
+	case SYSRAM3:
+		return CONSYS_REG_READ(SYSRAM3_REG);
+	default:
+		return 0;
+	}
+#endif
+}
+
+INT32 wmt_plat_set_host_dump_state(ENUM_HOST_DUMP_STATE state)
+{
+	PUINT8 p_virtual_addr = NULL;
+
+	p_virtual_addr = wmt_plat_get_emi_virt_add(EXP_APMEM_CTRL_HOST_SYNC_STATE);
+	if (!p_virtual_addr) {
+		WMT_PLAT_PR_ERR("get virtual address fail\n");
+		return -1;
+	}
+
+	CONSYS_REG_WRITE(p_virtual_addr, state);
+
+	return 0;
+}
+
+UINT32 wmt_plat_force_trigger_assert(ENUM_FORCE_TRG_ASSERT_T type)
+{
+	PUINT8 p_virtual_addr = NULL;
+
+	switch (type) {
+	case STP_FORCE_TRG_ASSERT_EMI:
+
+		WMT_PLAT_PR_INFO("[Force Assert] stp_trigger_firmware_assert_via_emi -->\n");
+		p_virtual_addr = wmt_plat_get_emi_virt_add(EXP_APMEM_CTRL_HOST_OUTBAND_ASSERT_W1);
+		if (!p_virtual_addr) {
+			WMT_PLAT_PR_ERR("get virtual address fail\n");
+			return -1;
+		}
+
+		CONSYS_REG_WRITE(p_virtual_addr, EXP_APMEM_HOST_OUTBAND_ASSERT_MAGIC_W1);
+		WMT_PLAT_PR_INFO("[Force Assert] stp_trigger_firmware_assert_via_emi <--\n");
+		break;
+	case STP_FORCE_TRG_ASSERT_DEBUG_PIN:
+		mtk_wcn_force_trigger_assert_debug_pin();
+		break;
+	default:
+		WMT_PLAT_PR_ERR("unknown force trigger assert type\n");
+		break;
+	}
+
+	return 0;
+}
+
+INT32 wmt_plat_update_host_sync_num(VOID)
+{
+	PUINT8 p_virtual_addr = NULL;
+	UINT32 sync_num = 0;
+
+	p_virtual_addr = wmt_plat_get_emi_virt_add(EXP_APMEM_CTRL_HOST_SYNC_NUM);
+	if (!p_virtual_addr) {
+		WMT_PLAT_PR_ERR("get virtual address fail\n");
+		return -1;
+	}
+
+	sync_num = CONSYS_REG_READ(p_virtual_addr);
+	CONSYS_REG_WRITE(p_virtual_addr, sync_num + 1);
+
+	return 0;
+}
+
+INT32 wmt_plat_get_dump_info(UINT32 offset)
+{
+	PUINT8 p_virtual_addr = NULL;
+
+	p_virtual_addr = wmt_plat_get_emi_virt_add(offset);
+	if (!p_virtual_addr) {
+		WMT_PLAT_PR_ERR("get virtual address fail\n");
+		return -1;
+	}
+	WMT_PLAT_PR_DBG("connsys_reg_read (0x%x), (0x%p), (0x%x)\n", CONSYS_REG_READ(p_virtual_addr), p_virtual_addr,
+			   offset);
+	return CONSYS_REG_READ(p_virtual_addr);
+}
+
+INT32 wmt_plat_write_emi_l(UINT32 offset, UINT32 value)
+{
+	PUINT8 p_virtual_addr = NULL;
+
+	p_virtual_addr = wmt_plat_get_emi_virt_add(offset);
+	if (!p_virtual_addr) {
+		WMT_PLAT_PR_ERR("get virtual address fail\n");
+		return -1;
+	}
+
+	CONSYS_REG_WRITE(p_virtual_addr, value);
+	return 0;
+}
+
+UINT32 wmt_plat_get_soc_chipid(VOID)
+{
+	UINT32 chipId = mtk_wcn_consys_soc_chipid();
+
+	return chipId;
+}
+EXPORT_SYMBOL(wmt_plat_get_soc_chipid);
+
+INT32 wmt_plat_get_adie_chipid(VOID)
+{
+	return mtk_wcn_consys_detect_adie_chipid(gCoClockFlag);
+}
+
+INT32 wmt_plat_consys_hw_init(VOID)
+{
+#ifndef MTK_WCN_COMBO_CHIP_SUPPORT
+	return mtk_wcn_consys_hw_init();
+#else
+	return 0;
+#endif
+}
+
+#if CFG_WMT_LTE_COEX_HANDLING
+INT32 wmt_plat_get_tdm_antsel_index(VOID)
+{
+	WMT_PLAT_PR_INFO("not support LTE in this platform\n");
+	return 0;
+}
+#endif
+
+INT32 wmt_plat_set_dbg_mode(UINT32 flag)
+{
+	INT32 ret = -1;
+	PUINT8 vir_addr = NULL;
+
+	vir_addr = mtk_wcn_consys_emi_virt_addr_get(EXP_APMEM_CTRL_CHIP_FW_DBGLOG_MODE);
+	if (!vir_addr) {
+		WMT_PLAT_PR_ERR("get vir address fail\n");
+		return ret;
+	}
+	if (flag) {
+		CONSYS_REG_WRITE(vir_addr, 0x1);
+		ret = 0;
+	} else {
+		CONSYS_REG_WRITE(vir_addr, 0x0);
+		ret = 1;
+	}
+	WMT_PLAT_PR_INFO("fw dbg mode register value(0x%08x)\n", CONSYS_REG_READ(vir_addr));
+
+	return ret;
+}
+
+INT32 wmt_plat_set_dynamic_dumpmem(PUINT32 str_buf)
+{
+	PUINT8 vir_addr = NULL;
+
+	vir_addr = mtk_wcn_consys_emi_virt_addr_get(EXP_APMEM_CTRL_CHIP_DYNAMIC_DUMP);
+	if (!vir_addr) {
+		WMT_PLAT_PR_ERR("get vir address fail\n");
+		return -1;
+	}
+	memcpy(vir_addr, str_buf, DYNAMIC_DUMP_GROUP_NUM*8);
+	WMT_PLAT_PR_INFO("dynamic dump register value(0x%08x)\n", CONSYS_REG_READ(vir_addr));
+
+	return 0;
+}
diff --git a/vendor/mediatek/kernel_modules/connectivity/wlan/./adaptor/Makefile b/vendor/mediatek/kernel_modules/connectivity/wlan/./adaptor/Makefile
new file mode 100644
index 0000000..ca842d4
--- /dev/null
+++ b/vendor/mediatek/kernel_modules/connectivity/wlan/./adaptor/Makefile
@@ -0,0 +1,71 @@
+###############################################################################
+# Necessary Check
+
+ifneq ($(KERNEL_OUT),)
+    ccflags-y += -imacros $(KERNEL_OUT)/include/generated/autoconf.h
+endif
+
+ifndef TOP
+    TOP := $(srctree)/..
+endif
+
+# Force build fail on modpost warning
+KBUILD_MODPOST_FAIL_ON_WARNINGS := y
+
+ccflags-y += \
+    -I$(srctree)/drivers/misc/mediatek/include/mt-plat \
+    -I$(TOP)/vendor/mediatek/kernel_modules/connectivity/common/common_main/include \
+    -I$(TOP)/vendor/mediatek/kernel_modules/connectivity/common/common_main/linux/include
+
+ifeq ($(CONNAC_VER), 2_0)
+ccflags-y += -I$(TOP)/vendor/mediatek/kernel_modules/connectivity/conninfra/include
+ccflags-y += -I$(TOP)/vendor/mediatek/kernel_modules/connectivity/conninfra/debug_utility
+ccflags-y += -I$(TOP)/vendor/mediatek/kernel_modules/connectivity/conninfra/debug_utility/include
+ccflags-y += -I$(TOP)/vendor/mediatek/kernel_modules/connectivity/conninfra/debug_utility/connsyslog
+ccflags-y += -I$(TOP)/vendor/mediatek/kernel_modules/connectivity/conninfra/debug_utility/coredump
+endif
+
+ifneq ($(CONFIG_MTK_CONNSYS_DEDICATED_LOG_PATH),)
+ccflags-y += -DCONFIG_MTK_CONNSYS_DEDICATED_LOG_PATH
+ccflags-y += -I$(TOP)/vendor/mediatek/kernel_modules/connectivity/common/debug_utility
+ccflags-y += -I$(src)/include
+endif
+
+ifeq ($(CONFIG_MTK_CONN_LTE_IDC_SUPPORT),y)
+    ccflags-y += -DWMT_IDC_SUPPORT=1
+else
+    ccflags-y += -DWMT_IDC_SUPPORT=0
+endif
+
+ifeq ($(CONNAC_VER), 2_0)
+ccflags-y += -DCFG_ANDORID_CONNINFRA_SUPPORT=1
+ccflags-y += -DCFG_ANDORID_CONNINFRA_COREDUMP_SUPPORT=1
+else
+ccflags-y += -DCFG_ANDORID_CONNINFRA_SUPPORT=0
+ccflags-y += -DCFG_ANDORID_CONNINFRA_COREDUMP_SUPPORT=0
+endif
+
+ccflags-y += -D MTK_WCN_WMT_STP_EXP_SYMBOL_ABSTRACT
+
+ccflags-y += -D CREATE_NODE_DYNAMIC=1
+
+MODULE_NAME := wmt_chrdev_wifi
+
+ifeq ($(CONFIG_WLAN_DRV_BUILD_IN),y)
+$(warning $(MODULE_NAME) build-in boot.img)
+obj-y += $(MODULE_NAME).o
+else
+$(warning $(MODULE_NAME) is kernel module)
+obj-m += $(MODULE_NAME).o
+endif
+
+# Wi-Fi character device driver
+$(MODULE_NAME)-objs += wmt_cdev_wifi.o
+ifneq ($(CONFIG_MTK_CONNSYS_DEDICATED_LOG_PATH),)
+$(MODULE_NAME)-objs += fw_log_wifi.o
+$(MODULE_NAME)-objs += fw_log_ics.o
+$(MODULE_NAME)-objs += wlan_ring.o
+endif
+ifeq ($(CONNAC_VER), 2_0)
+$(MODULE_NAME)-objs += wifi_pwr_on.o
+endif
diff --git a/vendor/mediatek/kernel_modules/connectivity/wlan/./core/gen4m/Makefile b/vendor/mediatek/kernel_modules/connectivity/wlan/./core/gen4m/Makefile
new file mode 100644
index 0000000..86629a9
--- /dev/null
+++ b/vendor/mediatek/kernel_modules/connectivity/wlan/./core/gen4m/Makefile
@@ -0,0 +1,940 @@
+ccflags-y :=
+ifeq ($(CONFIG_MTK_PLATFORM),)
+CONFIG_MTK_PLATFORM := mt$(WLAN_CHIP_ID)
+endif
+MTK_PLATFORM := $(subst $(quote),,$(CONFIG_MTK_PLATFORM))
+
+# ---------------------------------------------------
+# OS option
+# ---------------------------------------------------
+os=$(CONFIG_MTK_SUPPORT_OS)
+
+ifeq ($(os),)
+os=linux
+endif
+
+ccflags-y += -Wno-unused-value
+ccflags-y += -Wno-unused-result
+ccflags-y += -Wno-format
+ccflags-y += -Wno-parentheses
+
+ifeq ($(os), none)
+ccflags-y += -I/usr/include/
+ccflags-y += -DCFG_VIRTUAL_OS
+ccflags-y += -DCFG_REMIND_IMPLEMENT
+endif
+
+ifndef TOP
+    TOP := $(srctree)/..
+endif
+$(info os option: $(os))
+# ---------------------------------------------------
+# ALPS Setting
+# ---------------------------------------------------
+ifneq ($(KERNEL_OUT),)
+    ccflags-y += -imacros $(KERNEL_OUT)/include/generated/autoconf.h
+endif
+
+ifeq ($(KBUILD_MODPOST_FAIL_ON_WARNINGS),)
+    # Force build fail on modpost warning
+    KBUILD_MODPOST_FAIL_ON_WARNINGS=y
+endif
+
+# ---------------------------------------------------
+# Compile Options
+# ---------------------------------------------------
+WLAN_CHIP_LIST:=-UMT6620 -UMT6628 -UMT5931 -UMT6630 -UMT6632 -UMT7663 -UCONNAC -USOC2_1X1 -USOC2_2X2 -UUT_TEST_MODE -UMT7915 -USOC3_0 -UMT7961 -USOC5_0 -USOC7_0
+# '-D' and '-U' options are processed in the order they are given on the command line.
+# All '-imacros file' and '-include file' options are processed after all '-D' and '-U' options.
+ccflags-y += $(WLAN_CHIP_LIST)
+
+ifeq ($(MTK_COMBO_CHIP),)
+MTK_COMBO_CHIP = MT6632
+endif
+
+$(info $$MTK_PLATFORM is [${MTK_PLATFORM}])
+$(info $$WLAN_CHIP_ID is [${WLAN_CHIP_ID}])
+$(info $$MTK_COMBO_CHIP is [${MTK_COMBO_CHIP}])
+
+ifneq ($(CONFIG_MTK_EMI),)
+ccflags-y += -DCONFIG_WLAN_MTK_EMI=1
+endif
+
+ifneq ($(CONFIG_MEDIATEK_EMI),)
+ccflags-y += -DCONFIG_WLAN_MTK_EMI=1
+endif
+
+ifeq ($(WLAN_CHIP_ID),)
+WLAN_CHIP_ID=$(word 1, $(MTK_COMBO_CHIP))
+endif
+
+ccflags-y += -DCFG_SUPPORT_DEBUG_FS=0
+ccflags-y += -DWLAN_INCLUDE_PROC
+ccflags-y += -DCFG_SUPPORT_AGPS_ASSIST=0
+ccflags-y += -DCFG_SUPPORT_TSF_USING_BOOTTIME=1
+ccflags-y += -DARP_MONITER_ENABLE=1
+ccflags-y += -Werror $(call cc-disable-warning, unused-but-set-variable)
+#ccflags-y:=$(filter-out -U$(WLAN_CHIP_ID),$(ccflags-y))
+#ccflags-y += -DLINUX -D$(WLAN_CHIP_ID)
+#workaround: also needed for none LINUX system
+# because some of common part code is surrounded with this flag
+ccflags-y += -DLINUX
+
+ifneq ($(filter MT6632,$(MTK_COMBO_CHIP)),)
+ccflags-y:=$(filter-out -UMT6632,$(ccflags-y))
+ccflags-y += -DMT6632
+endif
+
+ifneq ($(filter MT7668,$(MTK_COMBO_CHIP)),)
+ccflags-y:=$(filter-out -UMT7668,$(ccflags-y))
+ccflags-y += -DMT7668
+endif
+
+ifneq ($(filter MT7663,$(MTK_COMBO_CHIP)),)
+ccflags-y:=$(filter-out -UMT7663,$(ccflags-y))
+ccflags-y += -DMT7663
+endif
+
+ifneq ($(filter CONNAC,$(MTK_COMBO_CHIP)),)
+ccflags-y:=$(filter-out -UCONNAC,$(ccflags-y))
+ccflags-y += -DCONNAC
+endif
+
+ifneq ($(filter SOC2_1X1,$(MTK_COMBO_CHIP)),)
+ccflags-y:=$(filter-out -USOC2_1X1,$(ccflags-y))
+ccflags-y += -DSOC2_1X1
+ccflags-y += -DCONFIG_MTK_WIFI_VHT80
+endif
+
+ifneq ($(filter SOC2_2X2,$(MTK_COMBO_CHIP)),)
+ccflags-y:=$(filter-out -USOC2_2X2,$(ccflags-y))
+ccflags-y += -DSOC2_2X2
+ccflags-y += -DCONFIG_MTK_WIFI_VHT80
+endif
+
+ifneq ($(findstring MT7915,$(MTK_COMBO_CHIP)),)
+ccflags-y:=$(filter-out -UMT7915,$(ccflags-y))
+ccflags-y += -DMT7915
+CONFIG_MTK_WIFI_CONNAC2X=y
+CONFIG_MTK_WIFI_11AX_SUPPORT=y
+CONFIG_MTK_WIFI_TWT_SUPPORT=y
+CONFIG_MTK_WIFI_TWT_SMART_STA=n
+CONFIG_NUM_OF_WFDMA_RX_RING=5
+CONFIG_NUM_OF_WFDMA_TX_RING=1
+endif
+
+ifneq ($(findstring 3_0,$(MTK_COMBO_CHIP)),)
+ccflags-y:=$(filter-out -USOC3_0,$(ccflags-y))
+ccflags-y += -DSOC3_0
+CONFIG_MTK_WIFI_CONNAC2X=y
+CONFIG_MTK_WIFI_11AX_SUPPORT=y
+CONFIG_MTK_WIFI_TWT_SUPPORT=y
+CONFIG_MTK_WIFI_TWT_SMART_STA=n
+CONFIG_NUM_OF_WFDMA_RX_RING=3
+CONFIG_NUM_OF_WFDMA_TX_RING=0
+CONFIG_MTK_WIFI_CONNINFRA_SUPPORT=y
+CONFIG_MTK_WIFI_CONNAC2X_2x2=y
+CONFIG_MTK_WIFI_DOWNLOAD_DYN_MEMORY_MAP=y
+CFG_WIFI_WORKAROUND_HWITS00012836_WTBL_SEARCH_FAIL=1
+CFG_WIFI_WORKAROUND_HWITS00010371_PMF_CIPHER_MISMATCH=1
+ccflags-y += -DCFG_POWER_ON_DOWNLOAD_EMI_ROM_PATCH=1
+ccflags-y += -DCFG_ROM_PATCH_NO_SEM_CTRL=1
+ccflags-y += -DCONFIG_MTK_WIFI_HE80
+endif
+
+ifneq ($(findstring MT7961,$(MTK_COMBO_CHIP)),)
+ccflags-y:=$(filter-out -UMT7961,$(ccflags-y))
+ccflags-y += -DMT7961
+CONFIG_MTK_WIFI_CONNAC2X=y
+CONFIG_MTK_WIFI_11AX_SUPPORT=y
+CONFIG_MTK_WIFI_TWT_SUPPORT=y
+CONFIG_MTK_WIFI_TWT_SMART_STA=n
+CONFIG_NUM_OF_WFDMA_RX_RING=5
+CONFIG_NUM_OF_WFDMA_TX_RING=1
+endif
+
+ifneq ($(filter 6873, $(WLAN_CHIP_ID)),)
+    ccflags-y += -DCFG_ENABLE_HOST_BUS_TIMEOUT=1
+else
+    ccflags-y += -DCFG_ENABLE_HOST_BUS_TIMEOUT=0
+endif
+
+ifneq ($(filter 6879 6895, $(WLAN_CHIP_ID)),)
+    ccflags-y += -DCFG_SUPPORT_SET_IPV6_NETWORK=1
+else
+    ccflags-y += -DCFG_SUPPORT_SET_IPV6_NETWORK=0
+endif
+
+ifneq ($(filter 6855, $(WLAN_CHIP_ID)),)
+    ccflags-y += -DCFG_SUPPORT_MDDP_AOR=1
+else
+    ccflags-y += -DCFG_SUPPORT_MDDP_AOR=0
+endif
+
+ifneq ($(filter 6879, $(WLAN_CHIP_ID)),)
+    ccflags-y += -DCFG_TRI_TX_RING=1
+else
+    ccflags-y += -DCFG_TRI_TX_RING=0
+endif
+
+ifneq ($(findstring 5_0,$(MTK_COMBO_CHIP)),)
+ccflags-y:=$(filter-out -USOC5_0,$(ccflags-y))
+ccflags-y += -DSOC5_0
+CONFIG_MTK_WIFI_CONNAC2X=y
+CONFIG_MTK_WIFI_11AX_SUPPORT=y
+CONFIG_MTK_WIFI_TWT_SUPPORT=y
+CONFIG_NUM_OF_WFDMA_RX_RING=3
+CONFIG_NUM_OF_WFDMA_TX_RING=0
+CONFIG_MTK_WIFI_CONNINFRA_SUPPORT=y
+CONFIG_MTK_WIFI_CONNAC2X_2x2=y
+CONFIG_MTK_WIFI_DOWNLOAD_DYN_MEMORY_MAP=y
+ccflags-y += -DCFG_POWER_ON_DOWNLOAD_EMI_ROM_PATCH=1
+ccflags-y += -DCFG_ROM_PATCH_NO_SEM_CTRL=1
+ccflags-y += -DCONFIG_MTK_WIFI_HE80
+endif
+
+ifneq ($(findstring 7_0,$(MTK_COMBO_CHIP)),)
+ccflags-y:=$(filter-out -USOC7_0,$(ccflags-y))
+ccflags-y += -DSOC7_0
+CONFIG_MTK_WIFI_CONNAC2X=y
+CONFIG_MTK_WIFI_11AX_SUPPORT=y
+CONFIG_MTK_WIFI_6G_SUPPORT=y
+CONFIG_MTK_WIFI_TWT_SUPPORT=y
+CONFIG_MTK_WIFI_TWT_STA_DIRECT_TEARDOWN=y
+CONFIG_NUM_OF_WFDMA_RX_RING=2
+CONFIG_NUM_OF_WFDMA_TX_RING=0
+CONFIG_MTK_WIFI_CONNINFRA_SUPPORT=y
+CONFIG_MTK_WIFI_CONNAC2X_2x2=y
+CONFIG_MTK_WIFI_DOWNLOAD_DYN_MEMORY_MAP=y
+CONFIG_MTK_WIFI_POWER_THROTTLING=y
+CONFIG_MTK_WIFI_PKT_OFLD_SUPPORT=y
+CONFIG_MTK_WIFI_APF_SUPPORT=y
+CONFIG_MTK_WIFI_NAN=y
+
+ccflags-y += -DCFG_POWER_ON_DOWNLOAD_EMI_ROM_PATCH=1
+ccflags-y += -DCFG_ROM_PATCH_NO_SEM_CTRL=1
+ccflags-y += -DCONFIG_MTK_WIFI_HE160
+ccflags-y += -DCFG_SUPPORT_BW160
+endif
+
+ifeq ($(CONFIG_MTK_WIFI_CONNINFRA_SUPPORT), y)
+ccflags-y += -DCFG_ANDORID_CONNINFRA_SUPPORT=1
+else
+ccflags-y += -DCFG_ANDORID_CONNINFRA_SUPPORT=0
+endif
+
+ifeq ($(CONFIG_MTK_WIFI_CONNAC2X), y)
+    ccflags-y += -DCFG_SUPPORT_CONNAC2X=1
+else
+    ccflags-y += -DCFG_SUPPORT_CONNAC2X=0
+endif
+
+ifeq ($(CONFIG_MTK_WIFI_CONNAC2X_2x2), y)
+    ccflags-y += -DCFG_SUPPORT_CONNAC2X_2x2=1
+else
+    ccflags-y += -DCFG_SUPPORT_CONNAC2X_2x2=0
+endif
+
+ifeq ($(CONFIG_MTK_WIFI_11AX_SUPPORT), y)
+    ccflags-y += -DCFG_SUPPORT_802_11AX=1
+else
+    ccflags-y += -DCFG_SUPPORT_802_11AX=0
+endif
+
+ccflags-y += -DCFG_SUPPORT_802_11BE=0
+
+ifeq ($(CONFIG_MTK_WIFI_11AX_SUPPORT), y)
+    ifeq ($(CONFIG_MTK_WIFI_6G_SUPPORT), y)
+        ccflags-y += -DCFG_SUPPORT_WIFI_6G=1
+    else
+        ccflags-y += -DCFG_SUPPORT_WIFI_6G=0
+    endif
+else
+    ccflags-y += -DCFG_SUPPORT_WIFI_6G=0
+endif
+
+ifeq ($(CONFIG_MTK_WIFI_TWT_SUPPORT), y)
+    ccflags-y += -DCFG_SUPPORT_TWT=1
+    ifeq ($(CONFIG_MTK_WIFI_TWT_SMART_STA), y)
+        ccflags-y += -DCFG_TWT_SMART_STA=1
+    else
+        ccflags-y += -DCFG_TWT_SMART_STA=0
+    endif
+
+    ifeq ($(CONFIG_MTK_WIFI_TWT_STA_DIRECT_TEARDOWN), y)
+        ccflags-y += -DCFG_TWT_STA_DIRECT_TEARDOWN=1
+    else
+        ccflags-y += -DCFG_TWT_STA_DIRECT_TEARDOWN=0
+    endif
+else
+    ccflags-y += -DCFG_SUPPORT_TWT=0
+    ccflags-y += -DCFG_TWT_SMART_STA=0
+endif
+
+ifneq ($(CONFIG_NUM_OF_WFDMA_TX_RING),)
+    ccflags-y += -DCONFIG_NUM_OF_WFDMA_TX_RING=$(CONFIG_NUM_OF_WFDMA_TX_RING)
+endif
+
+ifneq ($(CONFIG_NUM_OF_WFDMA_RX_RING),)
+    ccflags-y += -DCONFIG_NUM_OF_WFDMA_RX_RING=$(CONFIG_NUM_OF_WFDMA_RX_RING)
+endif
+
+ifeq ($(WIFI_ENABLE_GCOV), y)
+    GCOV_PROFILE := y
+endif
+
+ccflags-y += -DCFG_DRIVER_INITIAL_RUNNING_MODE=3
+
+ifneq ($(filter 6765, $(WLAN_CHIP_ID)),)
+    ccflags-y += -DCFG_SUPPORT_DUAL_STA=0
+else ifeq ($(CONFIG_MTK_TC10_FEATURE), y)
+    ccflags-y += -DCFG_SUPPORT_DUAL_STA=0
+else
+    ccflags-y += -DCFG_SUPPORT_DUAL_STA=1
+endif
+
+ifneq ($(filter 6779, $(WLAN_CHIP_ID)),)
+    ccflags-y += -DCFG_FORCE_AP1NSS
+endif
+
+ifeq ($(MTK_ANDROID_WMT), y)
+    ccflags-y += -DCFG_MTK_ANDROID_WMT=1
+    WMT_SUPPORT := y
+else ifneq ($(filter MT6632,$(MTK_COMBO_CHIP)),)
+    ccflags-y += -DCFG_MTK_ANDROID_WMT=1
+    WMT_SUPPORT := y
+else
+    ccflags-y += -DCFG_MTK_ANDROID_WMT=0
+    WMT_SUPPORT := n
+endif
+
+ifeq ($(CONFIG_MTK_WIFI_CONNINFRA_SUPPORT), y)
+    ccflags-y += -DCFG_SUPPORT_CONNINFRA=1
+    ccflags-y += -DCFG_SUPPORT_PRE_ON_PHY_ACTION=1
+    ccflags-y += -I$(TOP)/vendor/mediatek/kernel_modules/connectivity/conninfra/include
+    ccflags-y += -I$(srctree)/drivers/misc/mediatek/connectivity/power_throttling
+    ccflags-y += -DCFG_ANDORID_CONNINFRA_COREDUMP_SUPPORT=1
+    ifneq ($(CONFIG_MTK_CONNSYS_DEDICATED_LOG_PATH),)
+        ccflags-y += -I$(TOP)/vendor/mediatek/kernel_modules/connectivity/conninfra/include
+        ccflags-y += -I$(TOP)/vendor/mediatek/kernel_modules/connectivity/conninfra/platform/include
+        ccflags-y += -I$(TOP)/vendor/mediatek/kernel_modules/connectivity/conninfra/base/include
+        ccflags-y += -I$(TOP)/vendor/mediatek/kernel_modules/connectivity/conninfra/debug_utility
+        ccflags-y += -I$(TOP)/vendor/mediatek/kernel_modules/connectivity/conninfra/debug_utility/include
+        ccflags-y += -I$(TOP)/vendor/mediatek/kernel_modules/connectivity/conninfra/debug_utility/connsyslog
+        ccflags-y += -I$(TOP)/vendor/mediatek/kernel_modules/connectivity/conninfra/debug_utility/coredump
+        ccflags-y += -I$(TOP)/vendor/mediatek/kernel_modules/connectivity/conninfra/debug_utility/coredump/platform/include
+        ccflags-y += -I$(TOP)/vendor/mediatek/kernel_modules/connectivity/conninfra/debug_utility/metlog
+        ccflags-y += -I$(TOP)/vendor/mediatek/kernel_modules/connectivity/wlan/adaptor
+    endif
+else
+    ccflags-y += -DCFG_SUPPORT_CONNINFRA=0
+    ccflags-y += -DCFG_ANDORID_CONNINFRA_COREDUMP_SUPPORT=0
+    ccflags-y += -DCFG_SUPPORT_PRE_ON_PHY_ACTION=0
+    ifeq ($(WMT_SUPPORT), y)
+        ccflags-y += -I$(TOP)/vendor/mediatek/kernel_modules/connectivity/common/common_main/include
+        ccflags-y += -I$(TOP)/vendor/mediatek/kernel_modules/connectivity/common/common_main/linux/include
+        ifeq ($(CONFIG_MTK_CONN_LTE_IDC_SUPPORT),y)
+            ccflags-y += -DWMT_IDC_SUPPORT=1
+        else
+            ccflags-y += -DWMT_IDC_SUPPORT=0
+        endif
+        ccflags-y += -DMTK_WCN_WMT_STP_EXP_SYMBOL_ABSTRACT
+    endif
+endif
+
+ifeq ($(CONFIG_MTK_WIFI_POWER_THROTTLING), y)
+ccflags-y += -DCFG_SUPPORT_POWER_THROTTLING=1
+else
+ccflags-y += -DCFG_SUPPORT_POWER_THROTTLING=0
+endif
+
+ifeq ($(MTK_ANDROID_EMI), y)
+    ccflags-y += -DCFG_MTK_ANDROID_EMI=1
+else
+    ccflags-y += -DCFG_MTK_ANDROID_EMI=0
+endif
+
+ifneq ($(WIFI_IP_SET),)
+    ccflags-y += -DCFG_WIFI_IP_SET=$(WIFI_IP_SET)
+else
+    ccflags-y += -DCFG_WIFI_IP_SET=1
+endif
+
+ifneq ($(filter MTK_WCN_REMOVE_KERNEL_MODULE,$(KBUILD_SUBDIR_CCFLAGS)),)
+    ccflags-y += -DCFG_BUILT_IN_DRIVER=1
+else
+    ccflags-y += -DCFG_BUILT_IN_DRIVER=0
+endif
+
+ifneq ($(findstring UT_TEST_MODE,$(MTK_COMBO_CHIP)),)
+ccflags-y:=$(filter-out -UUT_TEST_MODE,$(ccflags-y))
+ccflags-y += -DUT_TEST_MODE
+endif
+
+CONFIG_MTK_WIFI_MCC_SUPPORT=y
+ifeq ($(CONFIG_MTK_WIFI_MCC_SUPPORT), y)
+    ccflags-y += -DCFG_SUPPORT_CHNL_CONFLICT_REVISE=0
+else
+    ccflags-y += -DCFG_SUPPORT_CHNL_CONFLICT_REVISE=1
+endif
+
+ifeq ($(CONFIG_MTK_AEE_FEATURE), y)
+    ccflags-y += -DCFG_SUPPORT_AEE=1
+else
+    ccflags-y += -DCFG_SUPPORT_AEE=0
+endif
+
+# Disable ASSERT() for user load, enable for others
+ifneq ($(TARGET_BUILD_VARIANT),user)
+    ccflags-y += -DBUILD_QA_DBG=1
+else
+    ccflags-y += -DBUILD_QA_DBG=0
+endif
+
+ifeq ($(CONFIG_MTK_COMBO_WIFI),y)
+    ccflags-y += -DCFG_WPS_DISCONNECT=1
+endif
+
+ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), sdio)
+    ccflags-y += -D_HIF_SDIO=1
+else ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), pcie)
+    ccflags-y += -D_HIF_PCIE=1
+else ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), usb)
+    ccflags-y += -D_HIF_USB=1
+else ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), axi)
+    ccflags-y += -D_HIF_AXI=1
+else ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), ut)
+    # Increase frame size to 2048 because of 'cfg80211_connect_result' exceed stack size
+    ccflags-y += -D_HIF_UT=1 -Wno-unused-function -Wno-unused-variable -Wframe-larger-than=2048
+else ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), none)
+	ccflags-y += -D_HIF_NONE=1
+else
+    $(error Unsuppoted HIF=$(CONFIG_MTK_COMBO_WIFI_HIF)!!)
+endif
+
+ifeq ($(CONFIG_MTK_WIFI_DOWNLOAD_DYN_MEMORY_MAP), y)
+    ccflags-y += -DCFG_DOWNLOAD_DYN_MEMORY_MAP=1
+else
+    ccflags-y += -DCFG_DOWNLOAD_DYN_MEMORY_MAP=0
+endif
+
+ifneq ($(CFG_CFG80211_VERSION),)
+VERSION_STR = $(subst \",,$(subst ., , $(subst -, ,$(subst v,,$(CFG_CFG80211_VERSION)))))
+$(info VERSION_STR=$(VERSION_STR))
+X = $(firstword $(VERSION_STR))
+Y = $(word 2 ,$(VERSION_STR))
+Z = $(word 3 ,$(VERSION_STR))
+VERSION := $(shell echo "$$(( $X * 65536 + $Y * 256 + $Z))" )
+ccflags-y += -DCFG_CFG80211_VERSION=$(VERSION)
+$(info DCFG_CFG80211_VERSION=$(VERSION))
+endif
+
+ccflags-y += -DCFG_SUPPORT_PASSPOINT=1
+ccflags-y += -DCFG_HS20_DEBUG=1
+
+MTK_MET_PROFILING_SUPPORT = yes
+ifeq ($(MTK_MET_PROFILING_SUPPORT), yes)
+    ccflags-y += -DCFG_MET_PACKET_TRACE_SUPPORT=1
+else
+    ccflags-y += -DCFG_MET_PACKET_TRACE_SUPPORT=0
+endif
+
+MTK_MET_TAG_SUPPORT = no
+ifeq ($(MTK_MET_TAG_SUPPORT), yes)
+    ccflags-y += -DMET_USER_EVENT_SUPPORT
+    ccflags-y += -DCFG_MET_TAG_SUPPORT=1
+else
+    ccflags-y += -DCFG_MET_TAG_SUPPORT=0
+endif
+
+MTK_TC3_SUPPORT = no
+ifeq ($(MTK_TC3_SUPPORT), yes)
+    ccflags-y += -DCFG_TC3_FEATURE=1
+    ccflags-y += -DCFG_P2P_CONNECT_ALL_BSS=1
+    ccflags-y += -DCFG_P2P_DEFAULT_CLIENT_COUNT=1
+    ccflags-y += -DCFG_P2P_SCAN_REPORT_ALL_BSS=1
+else
+    ccflags-y += -DCFG_TC3_FEATURE=0
+endif
+
+ifeq ($(CONFIG_MTK_TC10_FEATURE), y)
+    ccflags-y += -DCFG_TC10_FEATURE=1
+else
+    ccflags-y += -DCFG_TC10_FEATURE=0
+endif
+
+ifneq ($(CONFIG_MTK_MD1_SUPPORT), )
+    ccflags-y += -DCONFIG_MTK_MD_SUPPORT=1
+else
+    ccflags-y += -DCONFIG_MTK_MD_SUPPORT=0
+endif
+
+ifeq ($(CONFIG_MTK_TC1_FEATURE), y)
+    ccflags-y += -I$(srctree)/drivers/misc/mediatek/tc1_interface
+    ccflags-y += -DCFG_TC1_FEATURE=1
+else
+    ccflags-y += -DCFG_TC1_FEATURE=0
+endif
+
+ifeq ($(CONFIG_MTK_WIFI_NAN), y)
+ccflags-y += -DCFG_SUPPORT_NAN=1
+else
+ccflags-y += -DCFG_SUPPORT_NAN=0
+endif
+
+MODULE_NAME := wlan_drv_gen4m
+
+ifeq ($(MODULE_NAME),)
+MODULE_NAME := wlan_$(shell echo $(strip $(WLAN_CHIP_ID)) | tr A-Z a-z)_$(CONFIG_MTK_COMBO_WIFI_HIF)
+endif
+
+ccflags-y += -DDBG=0
+ccflags-y += -I$(src)/os -I$(src)/os/$(os)/include
+ccflags-y += -I$(src)/include -I$(src)/include/nic -I$(src)/include/mgmt -I$(src)/include/chips
+ifeq ($(CONFIG_MTK_WIFI_NAN), y)
+ccflags-y += -I$(src)/include/nan -I$(src)/include/nan/wpa_supp
+endif
+ifeq ($(CFG_SUPPORT_WIFI_SYSDVT), 1)
+ccflags-y += -I$(src)/include/dvt
+endif
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/base/power/include/
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/include/mt-plat/
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/performance/include/
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/emi/$(MTK_PLATFORM)
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/emi/submodule
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/pmic/include/
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/power_throttling/
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/connectivity/common
+ccflags-y += -I$(srctree)/drivers/devfreq/
+ccflags-y += -I$(srctree)/net
+ccflags-y += -I$(TOP)/vendor/mediatek/kernel_modules/connectivity/connfem/include/
+
+ifneq ($(CONFIG_MTK_MDDP_SUPPORT),)
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/mddp/include/
+ccflags-y += -DCFG_MTK_MDDP_SUPPORT=1
+else
+ccflags-y += -DCFG_MTK_MDDP_SUPPORT=0
+endif
+
+ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), sdio)
+ccflags-y += -I$(src)/os/$(os)/hif/sdio/include
+else ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), pcie)
+ccflags-y += -I$(src)/os/$(os)/hif/common/include
+ccflags-y += -I$(src)/os/$(os)/hif/pcie/include
+ifneq ($(findstring 3_0,$(MTK_COMBO_CHIP)),)
+ccflags-y += -I$(src)/include/chips/coda/soc3_0
+endif
+else ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), axi)
+ccflags-y += -I$(src)/os/$(os)/hif/common/include
+ccflags-y += -I$(src)/os/$(os)/hif/axi/include
+else ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), usb)
+ccflags-y += -I$(src)/os/$(os)/hif/usb/include
+else ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), ut)
+ccflags-y += -I$(src)/test -I$(src)/test/lib/include -I$(src)/test/testcases -I$(src)/test/lib/hif
+else ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), none)
+ccflags-y += -I$(src)/os/$(os)/hif/none/include
+endif
+
+ifneq ($(PLATFORM_FLAGS), )
+    ccflags-y += $(PLATFORM_FLAGS)
+endif
+
+ifeq ($(CONFIG_MTK_WIFI_ONLY),$(filter $(CONFIG_MTK_WIFI_ONLY),m y))
+obj-$(CONFIG_MTK_WIFI_ONLY) += $(MODULE_NAME).o
+else
+obj-$(CONFIG_MTK_COMBO_WIFI) += $(MODULE_NAME).o
+#obj-y += $(MODULE_NAME).o
+endif
+
+ifeq ($(CONFIG_WLAN_DRV_BUILD_IN),y)
+$(warning $(MODULE_NAME) build-in boot.img)
+obj-y += $(MODULE_NAME).o
+ccflags-y += -DCONFIG_WLAN_DRV_BUILD_IN=1
+else
+$(warning $(MODULE_NAME) is kernel module)
+obj-m += $(MODULE_NAME).o
+ccflags-y += -DCONFIG_WLAN_DRV_BUILD_IN=0
+endif
+
+ifeq ($(CONFIG_MTK_WIFI_PKT_OFLD_SUPPORT), y)
+ccflags-y += -DCFG_SUPPORT_PKT_OFLD=1
+ifeq ($(CONFIG_MTK_WIFI_APF_SUPPORT), y)
+ccflags-y += -DCFG_SUPPORT_APF=1
+else
+ccflags-y += -DCFG_SUPPORT_APF=0
+endif
+else
+ccflags-y += -DCFG_SUPPORT_PKT_OFLD=0
+endif
+
+# ---------------------------------------------------
+# Directory List
+# ---------------------------------------------------
+COMMON_DIR  := common/
+OS_DIR      := os/$(os)/
+HIF_COMMON_DIR := $(OS_DIR)hif/common/
+ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), sdio)
+HIF_DIR	    := os/$(os)/hif/sdio/
+else ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), pcie)
+HIF_DIR     := os/$(os)/hif/pcie/
+else ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), axi)
+HIF_DIR	    := os/$(os)/hif/axi/
+else ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), usb)
+HIF_DIR	    := os/$(os)/hif/usb/
+else ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), ut)
+HIF_DIR	    := test/lib/hif/
+else ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), none)
+HIF_DIR	    := os/$(os)/hif/none/
+endif
+NIC_DIR     := nic/
+MGMT_DIR    := mgmt/
+NAN_DIR     := nan/
+CHIPS       := chips/
+CHIPS_CMM   := $(CHIPS)common/
+
+ifneq ($(WLAN_CHIP_ID),)
+PLAT_DIR    := os/$(os)/plat/mt$(WLAN_CHIP_ID)/
+endif
+SYSDVT_DIR  := dvt/
+
+# ---------------------------------------------------
+# Objects List
+# ---------------------------------------------------
+
+COMMON_OBJS := 	$(COMMON_DIR)dump.o \
+		$(COMMON_DIR)wlan_lib.o \
+		$(COMMON_DIR)wlan_oid.o \
+		$(COMMON_DIR)wlan_bow.o \
+		$(COMMON_DIR)debug.o
+
+NIC_OBJS := 	$(NIC_DIR)nic.o \
+		$(NIC_DIR)nic_tx.o \
+		$(NIC_DIR)nic_txd_v1.o \
+		$(NIC_DIR)nic_rxd_v1.o \
+		$(NIC_DIR)nic_rx.o \
+		$(NIC_DIR)nic_pwr_mgt.o \
+		$(NIC_DIR)nic_rate.o \
+		$(NIC_DIR)cmd_buf.o \
+		$(NIC_DIR)que_mgt.o \
+		$(NIC_DIR)nic_cmd_event.o \
+		$(NIC_DIR)nic_umac.o
+
+ifeq ($(os), none)
+OS_OBJS := 	$(OS_DIR)gl_dependent.o \
+		$(OS_DIR)gl_init.o \
+		$(OS_DIR)gl_kal.o \
+		$(OS_DIR)gl_ate_agent.o \
+		$(OS_DIR)gl_qa_agent.o
+else
+OS_OBJS := 	$(OS_DIR)gl_init.o \
+		$(OS_DIR)gl_kal.o \
+		$(OS_DIR)gl_bow.o \
+		$(OS_DIR)gl_wext.o \
+		$(OS_DIR)gl_wext_priv.o \
+		$(OS_DIR)gl_ate_agent.o \
+		$(OS_DIR)gl_qa_agent.o \
+		$(OS_DIR)gl_hook_api.o \
+		$(OS_DIR)gl_rst.o \
+		$(OS_DIR)gl_cfg80211.o \
+		$(OS_DIR)gl_proc.o \
+		$(OS_DIR)gl_sys.o \
+		$(OS_DIR)gl_vendor.o \
+		$(OS_DIR)platform.o
+endif
+
+MGMT_OBJS := 	$(MGMT_DIR)ais_fsm.o \
+		$(MGMT_DIR)aaa_fsm.o \
+		$(MGMT_DIR)assoc.o \
+		$(MGMT_DIR)auth.o \
+		$(MGMT_DIR)bss.o \
+		$(MGMT_DIR)cnm.o \
+		$(MGMT_DIR)cnm_timer.o \
+		$(MGMT_DIR)cnm_mem.o \
+		$(MGMT_DIR)hem_mbox.o \
+		$(MGMT_DIR)mib.o \
+		$(MGMT_DIR)privacy.o \
+		$(MGMT_DIR)rate.o \
+		$(MGMT_DIR)rlm.o \
+		$(MGMT_DIR)rlm_domain.o \
+		$(MGMT_DIR)reg_rule.o \
+		$(MGMT_DIR)rlm_obss.o \
+		$(MGMT_DIR)rlm_protection.o \
+		$(MGMT_DIR)rrm.o \
+		$(MGMT_DIR)rsn.o \
+		$(MGMT_DIR)saa_fsm.o \
+		$(MGMT_DIR)scan.o \
+		$(MGMT_DIR)scan_fsm.o \
+		$(MGMT_DIR)scan_cache.o \
+		$(MGMT_DIR)swcr.o \
+		$(MGMT_DIR)roaming_fsm.o \
+		$(MGMT_DIR)tkip_mic.o \
+		$(MGMT_DIR)hs20.o \
+		$(MGMT_DIR)tdls.o \
+		$(MGMT_DIR)wnm.o \
+		$(MGMT_DIR)qosmap.o \
+		$(MGMT_DIR)ap_selection.o \
+		$(MGMT_DIR)wmm.o \
+		$(MGMT_DIR)mddp.o \
+		$(MGMT_DIR)thrm.o \
+		$(MGMT_DIR)mscs.o \
+		$(MGMT_DIR)ie_sort.o \
+
+# ---------------------------------------------------
+# Chips Objects List
+# ---------------------------------------------------
+MGMT_OBJS += $(MGMT_DIR)stats.o
+
+
+CHIPS_OBJS += $(CHIPS_CMM)cmm_asic_connac.o
+CHIPS_OBJS +=  $(CHIPS_CMM)dbg_connac.o
+ifeq ($(CONFIG_MTK_WIFI_CONNAC2X), y)
+CHIPS_OBJS +=  $(CHIPS_CMM)dbg_connac2x.o
+endif
+
+ifeq ($(CONFIG_MTK_WIFI_CONNAC2X), y)
+CHIPS_OBJS += $(CHIPS_CMM)cmm_asic_connac2x.o
+CHIPS_OBJS += $(CHIPS_CMM)pre_cal.o
+NIC_OBJS += $(NIC_DIR)nic_ext_cmd_event.o \
+			$(NIC_DIR)nic_txd_v2.o \
+			$(NIC_DIR)nic_rxd_v2.o
+endif
+CHIPS_OBJS += $(CHIPS_CMM)fw_dl.o
+
+ifneq ($(filter MT6632,$(MTK_COMBO_CHIP)),)
+CHIPS_OBJS += $(CHIPS)mt6632/mt6632.o
+endif
+ifneq ($(filter MT7668,$(MTK_COMBO_CHIP)),)
+CHIPS_OBJS += $(CHIPS)mt7668/mt7668.o
+endif
+ifneq ($(filter MT7663,$(MTK_COMBO_CHIP)),)
+CHIPS_OBJS += $(CHIPS)mt7663/mt7663.o
+endif
+ifneq ($(filter CONNAC,$(MTK_COMBO_CHIP)),)
+CHIPS_OBJS += $(CHIPS)connac/connac.o
+endif
+ifneq ($(filter SOC2_1X1,$(MTK_COMBO_CHIP)),)
+CHIPS_OBJS += $(CHIPS)soc2_1x1/soc2_1x1.o
+endif
+ifneq ($(filter SOC2_2X2,$(MTK_COMBO_CHIP)),)
+CHIPS_OBJS += $(CHIPS)soc2_2x2/soc2_2x2.o
+endif
+ifneq ($(findstring MT7915,$(MTK_COMBO_CHIP)),)
+CHIPS_OBJS += $(CHIPS)mt7915/mt7915.o
+CHIPS_OBJS +=  $(CHIPS)mt7915/dbg_mt7915.o
+endif
+ifneq ($(findstring 3_0,$(MTK_COMBO_CHIP)),)
+CHIPS_OBJS += $(CHIPS)soc3_0/soc3_0.o
+CHIPS_OBJS += $(CHIPS)soc3_0/dbg_soc3_0.o
+CHIPS_OBJS += $(CHIPS)soc3_0/hal_dmashdl_soc3_0.o
+endif
+ifneq ($(findstring MT7961,$(MTK_COMBO_CHIP)),)
+CHIPS_OBJS += $(CHIPS)mt7961/mt7961.o
+CHIPS_OBJS += $(CHIPS)mt7961/dbg_mt7961.o
+CHIPS_OBJS += $(CHIPS)mt7961/hal_dmashdl_mt7961.o
+endif
+ifneq ($(findstring 5_0,$(MTK_COMBO_CHIP)),)
+CHIPS_OBJS += $(CHIPS)soc5_0/soc5_0.o
+CHIPS_OBJS += $(CHIPS)soc5_0/dbg_soc5_0.o
+CHIPS_OBJS += $(CHIPS)soc5_0/hal_dmashdl_soc5_0.o
+endif
+ifneq ($(findstring 7_0,$(MTK_COMBO_CHIP)),)
+CHIPS_OBJS += $(CHIPS)soc7_0/soc7_0.o
+CHIPS_OBJS += $(CHIPS)soc7_0/dbg_soc7_0.o
+CHIPS_OBJS += $(CHIPS)soc7_0/hal_dmashdl_soc7_0.o
+endif
+
+# ---------------------------------------------------
+# P2P Objects List
+# ---------------------------------------------------
+
+COMMON_OBJS += $(COMMON_DIR)wlan_p2p.o
+
+NIC_OBJS += $(NIC_DIR)p2p_nic.o
+
+ifneq ($(os), none)
+OS_OBJS += $(OS_DIR)gl_p2p.o \
+           $(OS_DIR)gl_p2p_cfg80211.o \
+           $(OS_DIR)gl_p2p_init.o \
+           $(OS_DIR)gl_p2p_kal.o
+endif
+
+MGMT_OBJS += $(MGMT_DIR)p2p_dev_fsm.o\
+            $(MGMT_DIR)p2p_dev_state.o\
+            $(MGMT_DIR)p2p_role_fsm.o\
+            $(MGMT_DIR)p2p_role_state.o\
+            $(MGMT_DIR)p2p_func.o\
+            $(MGMT_DIR)p2p_scan.o\
+            $(MGMT_DIR)p2p_ie.o\
+            $(MGMT_DIR)p2p_rlm.o\
+            $(MGMT_DIR)p2p_assoc.o\
+            $(MGMT_DIR)p2p_bss.o\
+            $(MGMT_DIR)p2p_rlm_obss.o\
+            $(MGMT_DIR)p2p_fsm.o
+
+MGMT_OBJS += $(MGMT_DIR)wapi.o
+
+# ---------------------------------------------------
+# NAN Objects List
+# ---------------------------------------------------
+ifeq ($(CONFIG_MTK_WIFI_NAN), y)
+OS_OBJS  += $(OS_DIR)gl_nan.o \
+            $(OS_DIR)gl_vendor_nan.o \
+            $(OS_DIR)gl_vendor_ndp.o
+NAN_OBJS := $(NAN_DIR)nan_dev.o \
+            $(NAN_DIR)nanDiscovery.o\
+            $(NAN_DIR)nanScheduler.o\
+            $(NAN_DIR)nanReg.o\
+            $(NAN_DIR)nan_data_engine.o\
+            $(NAN_DIR)nan_data_engine_util.o\
+            $(NAN_DIR)nan_ranging.o\
+            $(NAN_DIR)nan_txm.o
+
+NAN_SEC_OBJS := $(NAN_DIR)nan_sec.o\
+                $(NAN_DIR)wpa_supp/FourWayHandShake.o\
+                $(NAN_DIR)wpa_supp/src/ap/wpa_auth.o\
+                $(NAN_DIR)wpa_supp/src/crypto/sha1.o\
+                $(NAN_DIR)wpa_supp/src/crypto/sha1-internal.o\
+                $(NAN_DIR)wpa_supp/src/crypto/sha1-prf.o\
+                $(NAN_DIR)wpa_supp/src/common/wpa_common.o\
+                $(NAN_DIR)wpa_supp/src/crypto/aes-wrap.o\
+                $(NAN_DIR)wpa_supp/src/crypto/aes-internal.o\
+                $(NAN_DIR)wpa_supp/src/utils/common.o\
+                $(NAN_DIR)wpa_supp/src/rsn_supp/wpa.o\
+                $(NAN_DIR)wpa_supp/src/crypto/aes-unwrap.o\
+                $(NAN_DIR)wpa_supp/src/crypto/aes-internal-enc.o\
+                $(NAN_DIR)wpa_supp/src/crypto/aes-internal-dec.o\
+                $(NAN_DIR)wpa_supp/src/crypto/sha256.o\
+                $(NAN_DIR)wpa_supp/src/crypto/sha256-prf.o\
+                $(NAN_DIR)wpa_supp/src/crypto/sha256-internal.o\
+                $(NAN_DIR)wpa_supp/wpa_supplicant/wpas_glue.o\
+                $(NAN_DIR)wpa_supp/wpa_supplicant/wpa_supplicant.o\
+                $(NAN_DIR)wpa_supp/src/ap/wpa_auth_glue.o\
+                $(NAN_DIR)wpa_supp/src/crypto/pbkdf2-sha256.o\
+                $(NAN_DIR)wpa_supp/src/crypto/sha384-internal.o\
+                $(NAN_DIR)wpa_supp/src/crypto/sha512-internal.o\
+                $(NAN_DIR)wpa_supp/src/crypto/sha384-prf.o\
+                $(NAN_DIR)wpa_supp/src/crypto/sha384.o
+endif
+
+# ---------------------------------------------------
+# HE Objects List
+# ---------------------------------------------------
+
+COMMON_OBJS += $(COMMON_DIR)wlan_he.o
+
+ifeq ($(CONFIG_MTK_WIFI_11AX_SUPPORT), y)
+MGMT_OBJS += $(MGMT_DIR)he_ie.o \
+             $(MGMT_DIR)he_rlm.o
+endif
+
+ifeq ($(CONFIG_MTK_WIFI_11BE_SUPPORT), y)
+MGMT_OBJS += $(MGMT_DIR)eht_rlm.o
+endif
+
+ifeq ($(CONFIG_MTK_WIFI_TWT_SUPPORT), y)
+MGMT_OBJS += $(MGMT_DIR)twt_req_fsm.o \
+             $(MGMT_DIR)twt.o \
+             $(MGMT_DIR)twt_planner.o
+endif
+
+ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), sdio)
+HIF_OBJS :=  $(HIF_DIR)arm.o \
+             $(HIF_DIR)sdio.o \
+             $(HIF_DIR)hal_api.o \
+             $(HIF_DIR)sdio_test_driver_core.o \
+             $(HIF_DIR)sdio_test_driver_ops.o
+else ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), pcie)
+HIF_OBJS :=  $(HIF_COMMON_DIR)hal_pdma.o \
+             $(HIF_COMMON_DIR)kal_pdma.o \
+             $(HIF_COMMON_DIR)dbg_pdma.o \
+             $(HIF_DIR)pcie.o
+else ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), axi)
+HIF_OBJS :=  $(HIF_COMMON_DIR)hal_pdma.o \
+             $(HIF_COMMON_DIR)kal_pdma.o \
+             $(HIF_COMMON_DIR)dbg_pdma.o \
+             $(HIF_COMMON_DIR)sw_wfdma.o \
+             $(HIF_DIR)axi.o
+else ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), usb)
+HIF_OBJS :=  $(HIF_DIR)usb.o \
+             $(HIF_DIR)hal_api.o
+else ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), ut)
+HIF_OBJS :=  $(HIF_DIR)ut.o \
+             $(HIF_DIR)hal_api.o
+else ifeq ($(CONFIG_MTK_COMBO_WIFI_HIF), none)
+HIF_OBJS :=  $(HIF_DIR)none.o
+endif
+# ---------------------------------------------------
+# Platform Objects List
+# ---------------------------------------------------
+ifneq ($(PLAT_DIR),)
+
+PLAT_PRIV_C = $(src)/$(PLAT_DIR)plat_priv.c
+
+# search path (out of kernel tree)
+IS_EXIST_PLAT_PRIV_C := $(wildcard $(PLAT_PRIV_C))
+# search path (build-in kernel tree)
+IS_EXIST_PLAT_PRIV_C += $(wildcard $(srctree)/$(PLAT_PRIV_C))
+
+ifneq ($(strip $(IS_EXIST_PLAT_PRIV_C)),)
+PLAT_OBJS := $(PLAT_DIR)plat_priv.o
+$(MODULE_NAME)-objs  += $(PLAT_OBJS)
+endif
+endif
+
+# ---------------------------------------------------
+# System Dvt Objects List
+# ---------------------------------------------------
+ifeq ($(CFG_SUPPORT_WIFI_SYSDVT), 1)
+SYSDVT_OBJS += $(SYSDVT_DIR)dvt_common.o
+
+ifeq ($(CFG_SUPPORT_DMASHDL_SYSDVT), 1)
+SYSDVT_OBJS += $(SYSDVT_DIR)dvt_dmashdl.o
+endif
+endif
+
+# ---------------------------------------------------
+# Service git List
+# ---------------------------------------------------
+SERVICE_DIR  := wlan_service/
+MTK_WLAN_SERVICE=yes
+
+ifneq ($(findstring wlan_service,$(MTK_WLAN_SERVICE_PATH)),)
+MTK_WLAN_SERVICE=yes
+SERVICE_DIR  := $(MTK_WLAN_SERVICE_PATH)
+$(info SERVICE_DIR is [{$(MTK_WLAN_SERVICE_PATH)}])
+endif
+
+ifeq ($(MTK_WLAN_SERVICE), yes)
+ccflags-y += -DCONFIG_WLAN_SERVICE=1
+ccflags-y += -DCONFIG_TEST_ENGINE_OFFLOAD=1
+ccflags-y += -I$(src)/$(SERVICE_DIR)include
+ccflags-y += -I$(src)/$(SERVICE_DIR)service/include
+ccflags-y += -I$(src)/$(SERVICE_DIR)glue/osal/include
+ccflags-y += -I$(src)/$(SERVICE_DIR)glue/hal/include
+$(info $$CCFLAG is [{$(ccflags-y)}])
+SERVICE_OBJS := $(SERVICE_DIR)agent/agent.o \
+                $(SERVICE_DIR)service/service_test.o \
+                $(SERVICE_DIR)service/test_engine.o \
+                $(SERVICE_DIR)glue/osal/gen4m/sys_adaption_gen4m.o \
+                $(SERVICE_DIR)glue/osal/gen4m/net_adaption_gen4m.o \
+                $(SERVICE_DIR)glue/hal/gen4m/operation_gen4m.o
+$(MODULE_NAME)-objs  += $(SERVICE_OBJS)
+$(info $$MTK_WLAN_SERVICE is [{$(SERVICE_OBJS)}])
+else
+ccflags-y += -DCONFIG_WLAN_SERVICE=0
+ccflags-y += -DCONFIG_TEST_ENGINE_OFFLOAD=0
+endif
+
+$(MODULE_NAME)-objs  += $(COMMON_OBJS)
+$(MODULE_NAME)-objs  += $(NIC_OBJS)
+$(MODULE_NAME)-objs  += $(OS_OBJS)
+$(MODULE_NAME)-objs  += $(HIF_OBJS)
+$(MODULE_NAME)-objs  += $(MGMT_OBJS)
+$(MODULE_NAME)-objs  += $(CHIPS_OBJS)
+$(MODULE_NAME)-objs  += $(SYSDVT_OBJS)
+$(MODULE_NAME)-objs  += $(NAN_OBJS)
+$(MODULE_NAME)-objs  += $(NAN_SEC_OBJS)
+
+ifneq ($(findstring UT_TEST_MODE,$(MTK_COMBO_CHIP)),)
+include $(src)/test/ut.make
+endif
diff --git a/vendor/mediatek/kernel_modules/connectivity/wlan/./core/gen4m/nic/que_mgt.c b/vendor/mediatek/kernel_modules/connectivity/wlan/./core/gen4m/nic/que_mgt.c
new file mode 100644
index 0000000..94d31fe
--- /dev/null
+++ b/vendor/mediatek/kernel_modules/connectivity/wlan/./core/gen4m/nic/que_mgt.c
@@ -0,0 +1,8944 @@
+/******************************************************************************
+ *
+ * This file is provided under a dual license.  When you use or
+ * distribute this software, you may choose to be licensed under
+ * version 2 of the GNU General Public License ("GPLv2 License")
+ * or BSD License.
+ *
+ * GPLv2 License
+ *
+ * Copyright(C) 2016 MediaTek Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(C) 2016 MediaTek Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+/*! \file   "que_mgt.c"
+ *    \brief  TX/RX queues management
+ *
+ *    The main tasks of queue management include TC-based HIF TX flow control,
+ *    adaptive TC quota adjustment, HIF TX grant scheduling, Power-Save
+ *    forwarding control, RX packet reordering, and RX BA agreement management.
+ */
+
+
+/*******************************************************************************
+ *                         C O M P I L E R   F L A G S
+ *******************************************************************************
+ */
+
+/*******************************************************************************
+ *                    E X T E R N A L   R E F E R E N C E S
+ *******************************************************************************
+ */
+#include "precomp.h"
+#include "queue.h"
+#include "mddp.h"
+/*******************************************************************************
+ *                              C O N S T A N T S
+ *******************************************************************************
+ */
+
+/*******************************************************************************
+ *                             D A T A   T Y P E S
+ *******************************************************************************
+ */
+
+/*******************************************************************************
+ *                            P U B L I C   D A T A
+ *******************************************************************************
+ */
+OS_SYSTIME g_arMissTimeout[CFG_STA_REC_NUM][CFG_RX_MAX_BA_TID_NUM];
+
+const uint8_t aucTid2ACI[TX_DESC_TID_NUM] = {
+	WMM_AC_BE_INDEX,	/* TID0 */
+	WMM_AC_BK_INDEX,	/* TID1 */
+	WMM_AC_BK_INDEX,	/* TID2 */
+	WMM_AC_BE_INDEX,	/* TID3 */
+	WMM_AC_VI_INDEX,	/* TID4 */
+	WMM_AC_VI_INDEX,	/* TID5 */
+	WMM_AC_VO_INDEX,	/* TID6 */
+	WMM_AC_VO_INDEX		/* TID7 */
+};
+
+const uint8_t aucACI2TxQIdx[WMM_AC_INDEX_NUM] = {
+	TX_QUEUE_INDEX_AC1,	/* WMM_AC_BE_INDEX */
+	TX_QUEUE_INDEX_AC0,	/* WMM_AC_BK_INDEX */
+	TX_QUEUE_INDEX_AC2,	/* WMM_AC_VI_INDEX */
+	TX_QUEUE_INDEX_AC3	/* WMM_AC_VO_INDEX */
+};
+
+const uint8_t *apucACI2Str[WMM_AC_INDEX_NUM] = {
+	"BE", "BK", "VI", "VO"
+};
+
+const uint8_t arNetwork2TcResource[MAX_BSSID_NUM + 1][NET_TC_NUM] = {
+	/* HW Queue Set 1 */
+	/* AC_BE, AC_BK, AC_VI, AC_VO, MGMT, BMC */
+	/* AIS */
+	{TC1_INDEX, TC0_INDEX, TC2_INDEX, TC3_INDEX, TC4_INDEX, BMC_TC_INDEX},
+	/* P2P/BoW */
+	{TC1_INDEX, TC0_INDEX, TC2_INDEX, TC3_INDEX, TC4_INDEX, BMC_TC_INDEX},
+	/* P2P/BoW */
+	{TC1_INDEX, TC0_INDEX, TC2_INDEX, TC3_INDEX, TC4_INDEX, BMC_TC_INDEX},
+	/* P2P/BoW */
+	{TC1_INDEX, TC0_INDEX, TC2_INDEX, TC3_INDEX, TC4_INDEX, BMC_TC_INDEX},
+	/* P2P_DEV */
+	{TC1_INDEX, TC0_INDEX, TC2_INDEX, TC3_INDEX, TC4_INDEX, BMC_TC_INDEX},
+};
+
+const uint8_t aucWmmAC2TcResourceSet1[WMM_AC_INDEX_NUM] = {
+	TC1_INDEX,
+	TC0_INDEX,
+	TC2_INDEX,
+	TC3_INDEX
+};
+
+#if NIC_TX_ENABLE_SECOND_HW_QUEUE
+const uint8_t aucWmmAC2TcResourceSet2[WMM_AC_INDEX_NUM] = {
+	TC7_INDEX,
+	TC6_INDEX,
+	TC8_INDEX,
+	TC9_INDEX
+};
+#endif
+/*******************************************************************************
+ *                           P R I V A T E   D A T A
+ *******************************************************************************
+ */
+#if ARP_MONITER_ENABLE
+static uint16_t arpMoniter;
+static uint8_t apIp[4];
+static uint8_t gatewayIp[4];
+static uint32_t last_rx_packets, latest_rx_packets;
+#endif
+/*******************************************************************************
+ *                                 M A C R O S
+ *******************************************************************************
+ */
+#ifdef CFG_SUPPORT_LINK_QUALITY_MONITOR
+#define LINK_QUALITY_COUNT_DUP(prAdapter, prSwRfb) \
+do { \
+	struct BSS_INFO *prBssInfo = NULL; \
+	prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, \
+		AIS_DEFAULT_INDEX); \
+	if (prBssInfo && prBssInfo->prStaRecOfAP) \
+		if (prBssInfo->prStaRecOfAP->ucWlanIndex == \
+		    prSwRfb->ucWlanIdx) \
+			prAdapter->rLinkQualityInfo.u4RxDupCount++; \
+} while (0)
+#else
+#define LINK_QUALITY_COUNT_DUP
+#endif /* CFG_SUPPORT_LINK_QUALITY_MONITOR */
+
+#if CFG_RX_REORDERING_ENABLED
+#define qmHandleRxPackets_AOSP_1 \
+do { \
+	DBGLOG(RX, TEMP, "qmHandleRxPackets_AOSP_1 %p\n", prCurrSwRfb); \
+	/* ToDo[6630]: duplicate removal */ \
+	if (!fgIsBMC && nicRxIsDuplicateFrame(prCurrSwRfb) == TRUE) { \
+		DBGLOG(RX, TEMP, "Duplicated packet is detected\n"); \
+		RX_INC_CNT(&prAdapter->rRxCtrl, RX_DUPICATE_DROP_COUNT); \
+		LINK_QUALITY_COUNT_DUP(prAdapter, prCurrSwRfb); \
+		prCurrSwRfb->eDst = RX_PKT_DESTINATION_NULL; \
+	} \
+	/* ToDo[6630]: defragmentation */ \
+	if (prCurrSwRfb->fgFragFrame) { \
+		prCurrSwRfb = nicRxDefragMPDU(prAdapter, \
+			prCurrSwRfb, prReturnedQue); \
+		if (prCurrSwRfb) { \
+			prRxStatus = prCurrSwRfb->prRxStatus; \
+			DBGLOG(RX, TEMP, \
+				"defragmentation RxStatus=%p\n", prRxStatus); \
+		} \
+	} \
+	if (prCurrSwRfb) { \
+		fgMicErr = FALSE; \
+		if (prCurrSwRfb->ucSecMode == \
+			CIPHER_SUITE_TKIP_WO_MIC) { \
+			if (prCurrSwRfb->prStaRec) { \
+				uint8_t ucBssIndex; \
+				struct BSS_INFO *prBssInfo = NULL; \
+				uint8_t *pucMicKey = NULL; \
+				ucBssIndex = \
+					prCurrSwRfb->prStaRec->ucBssIndex; \
+				ASSERT(ucBssIndex < prAdapter->ucHwBssIdNum); \
+				prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, \
+					ucBssIndex); \
+				ASSERT(prBssInfo); \
+				if (prBssInfo->eCurrentOPMode == \
+					OP_MODE_INFRASTRUCTURE) \
+					pucMicKey = \
+					&(aisGetAisSpecBssInfo(prAdapter, \
+					ucBssIndex)->aucRxMicKey[0]); \
+				else { \
+					ASSERT(FALSE); \
+				} \
+				/* SW TKIP MIC verify */ \
+				if (pucMicKey == NULL) { \
+					DBGLOG(RX, ERROR, \
+						"No TKIP Mic Key\n"); \
+					fgMicErr = TRUE; \
+				} \
+				else if (tkipMicDecapsulateInRxHdrTransMode( \
+					prCurrSwRfb, pucMicKey) == FALSE) { \
+					fgMicErr = TRUE; \
+				} \
+			} \
+			if (fgMicErr) { \
+				/* bypass tkip frag */ \
+				if (!prCurrSwRfb->fgFragFrame) { \
+					log_dbg(RX, ERROR, \
+					"Mark NULL for TKIP Mic Error\n"); \
+					RX_INC_CNT(&prAdapter->rRxCtrl, \
+					RX_MIC_ERROR_DROP_COUNT); \
+					prCurrSwRfb->eDst = \
+						RX_PKT_DESTINATION_NULL; \
+				} \
+			} \
+		} \
+		QUEUE_INSERT_TAIL(prReturnedQue, \
+			(struct QUE_ENTRY *)prCurrSwRfb); \
+	} \
+} while (0)
+#endif
+
+#define RX_DIRECT_REORDER_LOCK(pad, dbg) \
+do { \
+	struct GLUE_INFO *_glue = pad->prGlueInfo; \
+	if (!HAL_IS_RX_DIRECT(pad) || !_glue) \
+		break; \
+	if (dbg) \
+		DBGLOG(QM, EVENT, "RX_DIRECT_REORDER_LOCK %d\n", __LINE__); \
+	spin_lock_bh(&_glue->rSpinLock[SPIN_LOCK_RX_DIRECT_REORDER]);\
+} while (0)
+
+#define RX_DIRECT_REORDER_UNLOCK(pad, dbg) \
+do { \
+	struct GLUE_INFO *_glue = pad->prGlueInfo; \
+	if (!HAL_IS_RX_DIRECT(pad) || !_glue) \
+		break; \
+	if (dbg) \
+		DBGLOG(QM, EVENT, "RX_DIRECT_REORDER_UNLOCK %u\n", __LINE__); \
+	spin_unlock_bh(&_glue->rSpinLock[SPIN_LOCK_RX_DIRECT_REORDER]); \
+} while (0)
+
+/*******************************************************************************
+ *                   F U N C T I O N   D E C L A R A T I O N S
+ *******************************************************************************
+ */
+
+/*******************************************************************************
+ *                              F U N C T I O N S
+ *******************************************************************************
+ */
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Init Queue Management for TX
+ *
+ * \param[in] (none)
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void qmInit(IN struct ADAPTER *prAdapter,
+	IN u_int8_t isTxResrouceControlEn)
+{
+	uint32_t u4Idx;
+#if QM_ADAPTIVE_TC_RESOURCE_CTRL
+	uint32_t u4TotalMinReservedTcResource = 0;
+	uint32_t u4TotalTcResource = 0;
+	uint32_t u4TotalGurantedTcResource = 0;
+#endif
+
+	struct QUE_MGT *prQM = &prAdapter->rQM;
+
+	/* DbgPrint("QM: Enter qmInit()\n"); */
+
+	/* 4 <2> Initialize other TX queues (queues not in STA_RECs) */
+	for (u4Idx = 0; u4Idx < NUM_OF_PER_TYPE_TX_QUEUES; u4Idx++)
+		QUEUE_INITIALIZE(&(prQM->arTxQueue[u4Idx]));
+
+	/* 4 <3> Initialize the RX BA table and RX queues */
+	/* Initialize the RX Reordering Parameters and Queues */
+	for (u4Idx = 0; u4Idx < CFG_NUM_OF_RX_BA_AGREEMENTS; u4Idx++) {
+		prQM->arRxBaTable[u4Idx].fgIsValid = FALSE;
+		QUEUE_INITIALIZE(&(prQM->arRxBaTable[u4Idx].rReOrderQue));
+		prQM->arRxBaTable[u4Idx].u2WinStart = 0xFFFF;
+		prQM->arRxBaTable[u4Idx].u2WinEnd = 0xFFFF;
+		prQM->arRxBaTable[u4Idx].u2BarSSN = 0;
+		prQM->arRxBaTable[u4Idx].u2LastRcvdSN = 0;
+
+		prQM->arRxBaTable[u4Idx].fgIsWaitingForPktWithSsn = FALSE;
+		prQM->arRxBaTable[u4Idx].fgHasBubble = FALSE;
+#if CFG_SUPPORT_RX_AMSDU
+		/* RX reorder for one MSDU in AMSDU issue */
+		prQM->arRxBaTable[u4Idx].u8LastAmsduSubIdx =
+			RX_PAYLOAD_FORMAT_MSDU;
+		prQM->arRxBaTable[u4Idx].fgAmsduNeedLastFrame = FALSE;
+		prQM->arRxBaTable[u4Idx].fgIsAmsduDuplicated = FALSE;
+#endif
+		cnmTimerInitTimer(prAdapter,
+			&(prQM->arRxBaTable[u4Idx].rReorderBubbleTimer),
+			(PFN_MGMT_TIMEOUT_FUNC) qmHandleReorderBubbleTimeout,
+			(unsigned long) (&prQM->arRxBaTable[u4Idx]));
+
+	}
+	prQM->ucRxBaCount = 0;
+
+	kalMemSet(&g_arMissTimeout, 0, sizeof(g_arMissTimeout));
+
+	prQM->fgIsTxResrouceControlEn = isTxResrouceControlEn;
+
+#if QM_ADAPTIVE_TC_RESOURCE_CTRL
+	/* 4 <4> Initialize TC resource control variables */
+	for (u4Idx = 0; u4Idx < TC_NUM; u4Idx++)
+		prQM->au4AverageQueLen[u4Idx] = 0;
+
+	ASSERT(prQM->u4TimeToAdjustTcResource
+	       && prQM->u4TimeToUpdateQueLen);
+
+	for (u4Idx = 0; u4Idx < TC_NUM; u4Idx++) {
+		prQM->au4CurrentTcResource[u4Idx] =
+			prAdapter->rTxCtrl.rTc.au4MaxNumOfBuffer[u4Idx];
+
+		if (u4Idx != TC4_INDEX) {
+			u4TotalTcResource += prQM->au4CurrentTcResource[u4Idx];
+			u4TotalGurantedTcResource +=
+				prQM->au4GuaranteedTcResource[u4Idx];
+			u4TotalMinReservedTcResource +=
+				prQM->au4MinReservedTcResource[u4Idx];
+		}
+	}
+
+	/* Sanity Check */
+	if (u4TotalMinReservedTcResource > u4TotalTcResource)
+		kalMemZero(prQM->au4MinReservedTcResource,
+			   sizeof(prQM->au4MinReservedTcResource));
+
+	if (u4TotalGurantedTcResource > u4TotalTcResource)
+		kalMemZero(prQM->au4GuaranteedTcResource,
+			   sizeof(prQM->au4GuaranteedTcResource));
+
+	u4TotalGurantedTcResource = 0;
+
+	/* Initialize Residual TC resource */
+	for (u4Idx = 0; u4Idx < TC_NUM; u4Idx++) {
+		if (prQM->au4GuaranteedTcResource[u4Idx] <
+		    prQM->au4MinReservedTcResource[u4Idx])
+			prQM->au4GuaranteedTcResource[u4Idx] =
+				prQM->au4MinReservedTcResource[u4Idx];
+
+		if (u4Idx != TC4_INDEX)
+			u4TotalGurantedTcResource +=
+				prQM->au4GuaranteedTcResource[u4Idx];
+	}
+
+	prQM->u4ResidualTcResource = u4TotalTcResource -
+				     u4TotalGurantedTcResource;
+
+	prQM->fgTcResourcePostAnnealing = FALSE;
+	prQM->fgForceReassign = FALSE;
+#if QM_FAST_TC_RESOURCE_CTRL
+	prQM->fgTcResourceFastReaction = FALSE;
+#endif
+#endif
+
+#if QM_TEST_MODE
+	prQM->u4PktCount = 0;
+
+#if QM_TEST_FAIR_FORWARDING
+
+	prQM->u4CurrentStaRecIndexToEnqueue = 0;
+	{
+		uint8_t aucMacAddr[MAC_ADDR_LEN];
+		struct STA_RECORD *prStaRec;
+
+		/* Irrelevant in case this STA is an AIS AP
+		 * (see qmDetermineStaRecIndex())
+		 */
+		aucMacAddr[0] = 0x11;
+		aucMacAddr[1] = 0x22;
+		aucMacAddr[2] = 0xAA;
+		aucMacAddr[3] = 0xBB;
+		aucMacAddr[4] = 0xCC;
+		aucMacAddr[5] = 0xDD;
+
+		prStaRec = &prAdapter->arStaRec[1];
+		ASSERT(prStaRec);
+
+		prStaRec->fgIsValid = TRUE;
+		prStaRec->fgIsQoS = TRUE;
+		prStaRec->fgIsInPS = FALSE;
+		prStaRec->ucNetTypeIndex = NETWORK_TYPE_AIS_INDEX;
+		COPY_MAC_ADDR((prStaRec)->aucMacAddr, aucMacAddr);
+
+	}
+
+#endif
+
+#endif
+
+#if QM_FORWARDING_FAIRNESS
+	for (u4Idx = 0; u4Idx < NUM_OF_PER_STA_TX_QUEUES; u4Idx++) {
+		prQM->au4ResourceUsedCount[u4Idx] = 0;
+		prQM->au4HeadStaRecIndex[u4Idx] = 0;
+	}
+
+	prQM->u4HeadBssInfoIndex = 0;
+	prQM->u4GlobalResourceUsedCount = 0;
+#endif
+
+	prQM->u4TxAllowedStaCount = 0;
+
+	prQM->rLastTxPktDumpTime = (OS_SYSTIME) kalGetTimeTick();
+
+}
+
+#if QM_TEST_MODE
+void qmTestCases(IN struct ADAPTER *prAdapter)
+{
+	struct QUE_MGT *prQM = &prAdapter->rQM;
+
+	DbgPrint("QM: ** TEST MODE **\n");
+
+	if (QM_TEST_STA_REC_DETERMINATION) {
+		if (prAdapter->arStaRec[0].fgIsValid) {
+			prAdapter->arStaRec[0].fgIsValid = FALSE;
+			DbgPrint("QM: (Test) Deactivate STA_REC[0]\n");
+		} else {
+			prAdapter->arStaRec[0].fgIsValid = TRUE;
+			DbgPrint("QM: (Test) Activate STA_REC[0]\n");
+		}
+	}
+
+	if (QM_TEST_STA_REC_DEACTIVATION) {
+		/* Note that QM_STA_REC_HARD_CODING
+		 * shall be set to 1 for this test
+		 */
+
+		if (prAdapter->arStaRec[0].fgIsValid) {
+
+			DbgPrint("QM: (Test) Deactivate STA_REC[0]\n");
+			qmDeactivateStaRec(prAdapter, &prAdapter->arStaRec[0]);
+		} else {
+
+			uint8_t aucMacAddr[MAC_ADDR_LEN];
+
+			/* Irrelevant in case this STA is an AIS AP
+			 * (see qmDetermineStaRecIndex())
+			 */
+			aucMacAddr[0] = 0x11;
+			aucMacAddr[1] = 0x22;
+			aucMacAddr[2] = 0xAA;
+			aucMacAddr[3] = 0xBB;
+			aucMacAddr[4] = 0xCC;
+			aucMacAddr[5] = 0xDD;
+
+			DbgPrint("QM: (Test) Activate STA_REC[0]\n");
+			qmActivateStaRec(prAdapter,	/* Adapter pointer */
+				0,	/* STA_REC index from FW */
+				TRUE,	/* fgIsQoS */
+				NETWORK_TYPE_AIS_INDEX, /* Network type */
+				TRUE,	/* fgIsAp */
+				aucMacAddr	/* MAC address */
+			);
+		}
+	}
+
+	if (QM_TEST_FAIR_FORWARDING) {
+		if (prAdapter->arStaRec[1].fgIsValid) {
+			prQM->u4CurrentStaRecIndexToEnqueue++;
+			prQM->u4CurrentStaRecIndexToEnqueue %= 2;
+			DbgPrint("QM: (Test) Switch to STA_REC[%ld]\n",
+				 prQM->u4CurrentStaRecIndexToEnqueue);
+		}
+	}
+
+}
+#endif
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Update a STA_REC
+ *
+ * \param[in] prAdapter  Pointer to the Adapter instance
+ * \param[in] prStaRec The pointer of the STA_REC
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void qmUpdateStaRec(IN struct ADAPTER *prAdapter,
+	IN struct STA_RECORD *prStaRec)
+{
+	struct BSS_INFO *prBssInfo;
+	u_int8_t fgIsTxAllowed = FALSE;
+
+	if (!prStaRec)
+		return;
+
+	prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, prStaRec->ucBssIndex);
+
+	ASSERT(prBssInfo);
+
+	/* 4 <1> Ensure STA is valid */
+	if (prStaRec->fgIsValid) {
+		/* 4 <2.1> STA/BSS is protected */
+		if (secIsProtectedBss(prAdapter, prBssInfo)) {
+			if (prStaRec->fgIsTxKeyReady ||
+				secIsWepBss(prAdapter, prBssInfo))
+				fgIsTxAllowed = TRUE;
+			else
+				fgIsTxAllowed = FALSE;
+		}
+		/* 4 <2.2> OPEN security */
+		else
+			fgIsTxAllowed = TRUE;
+	}
+	/* 4 <x> Update StaRec */
+	qmSetStaRecTxAllowed(prAdapter, prStaRec, fgIsTxAllowed);
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Activate a STA_REC
+ *
+ * \param[in] prAdapter  Pointer to the Adapter instance
+ * \param[in] prStaRec The pointer of the STA_REC
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void qmActivateStaRec(IN struct ADAPTER *prAdapter,
+		      IN struct STA_RECORD *prStaRec)
+{
+	/* 4 <1> Deactivate first */
+	if (!prStaRec)
+		return;
+
+	if (prStaRec->fgIsValid) {	/* The STA_REC has been activated */
+		DBGLOG(QM, WARN,
+			"QM: (WARNING) Activating a STA_REC which has been activated\n");
+		DBGLOG(QM, WARN,
+			"QM: (WARNING) Deactivating a STA_REC before re-activating\n");
+		/* To flush TX/RX queues and del RX BA agreements */
+		qmDeactivateStaRec(prAdapter, prStaRec);
+	}
+	/* 4 <2> Activate the STA_REC */
+	/* Reset buffer count  */
+	prStaRec->ucFreeQuota = 0;
+	prStaRec->ucFreeQuotaForDelivery = 0;
+	prStaRec->ucFreeQuotaForNonDelivery = 0;
+
+	/* Init the STA_REC */
+	prStaRec->fgIsValid = TRUE;
+	prStaRec->fgIsInPS = FALSE;
+
+	/* Default setting of TX/RX AMPDU */
+	prStaRec->fgTxAmpduEn = IS_FEATURE_ENABLED(
+		prAdapter->rWifiVar.ucAmpduTx);
+	prStaRec->fgRxAmpduEn = IS_FEATURE_ENABLED(
+		prAdapter->rWifiVar.ucAmpduRx);
+
+	nicTxGenerateDescTemplate(prAdapter, prStaRec);
+
+	qmUpdateStaRec(prAdapter, prStaRec);
+
+	/* Done in qmInit() or qmDeactivateStaRec() */
+#if 0
+	/* At the beginning, no RX BA agreements have been established */
+	for (i = 0; i < CFG_RX_MAX_BA_TID_NUM; i++)
+		(prStaRec->aprRxReorderParamRefTbl)[i] = NULL;
+#endif
+
+#if CFG_MTK_MDDP_SUPPORT
+	if (mddpIsSupportMcifWifi())
+		mddpNotifyDrvTxd(prAdapter, prStaRec, TRUE);
+#endif
+
+	LINK_INITIALIZE(&prStaRec->rMscsMonitorList);
+	LINK_INITIALIZE(&prStaRec->rMscsTcpMonitorList);
+
+	DBGLOG(QM, INFO, "QM: +STA[%d]\n", prStaRec->ucIndex);
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Deactivate a STA_REC
+ *
+ * \param[in] prAdapter  Pointer to the Adapter instance
+ * \param[in] u4StaRecIdx The index of the STA_REC
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void qmDeactivateStaRec(IN struct ADAPTER *prAdapter,
+	IN struct STA_RECORD *prStaRec)
+{
+	uint32_t i;
+
+	if (!prStaRec)
+		return;
+
+#if CFG_SUPPORT_FRAG_AGG_ATTACK_DETECTION
+	/* clear fragment cache when reconnect, reassoc, disconnect */
+	nicRxClearFrag(prAdapter, prStaRec);
+#endif /* CFG_SUPPORT_FRAG_AGG_ATTACK_DETECTION */
+
+	/* 4 <1> Flush TX queues */
+	if (HAL_IS_TX_DIRECT(prAdapter)) {
+		nicTxDirectClearStaPsQ(prAdapter, prStaRec->ucIndex);
+	} else {
+		struct MSDU_INFO *prFlushedTxPacketList = NULL;
+
+		prFlushedTxPacketList = qmFlushStaTxQueues(prAdapter,
+			prStaRec->ucIndex);
+
+		if (prFlushedTxPacketList)
+			wlanProcessQueuedMsduInfo(prAdapter,
+				prFlushedTxPacketList);
+	}
+
+	/* 4 <2> Flush RX queues and delete RX BA agreements */
+	for (i = 0; i < CFG_RX_MAX_BA_TID_NUM; i++) {
+		/* Delete the RX BA entry with TID = i */
+		qmDelRxBaEntry(prAdapter, prStaRec->ucIndex, (uint8_t) i,
+			FALSE);
+	}
+
+	/* 4 <3> Deactivate the STA_REC */
+	prStaRec->fgIsValid = FALSE;
+	prStaRec->fgIsInPS = FALSE;
+	prStaRec->fgIsTxKeyReady = FALSE;
+	prStaRec->fgIsMscsSupported = FALSE;
+
+	/* Reset buffer count  */
+	prStaRec->ucFreeQuota = 0;
+	prStaRec->ucFreeQuotaForDelivery = 0;
+	prStaRec->ucFreeQuotaForNonDelivery = 0;
+
+	nicTxFreeDescTemplate(prAdapter, prStaRec);
+
+	qmUpdateStaRec(prAdapter, prStaRec);
+
+#if CFG_MTK_MDDP_SUPPORT
+	if (mddpIsSupportMcifWifi())
+		mddpNotifyDrvTxd(prAdapter, prStaRec, FALSE);
+#endif
+	mscsDeactivate(prAdapter, prStaRec);
+
+	DBGLOG(QM, INFO, "QM: -STA[%u]\n", prStaRec->ucIndex);
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Deactivate a STA_REC
+ *
+ * \param[in] prAdapter  Pointer to the Adapter instance
+ * \param[in] ucBssIndex The index of the BSS
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void qmFreeAllByBssIdx(IN struct ADAPTER *prAdapter, IN uint8_t ucBssIndex)
+{
+
+	struct QUE_MGT *prQM;
+	struct QUE *prQue;
+	struct QUE rNeedToFreeQue;
+	struct QUE rTempQue;
+	struct QUE *prNeedToFreeQue;
+	struct QUE *prTempQue;
+	struct MSDU_INFO *prMsduInfo;
+
+	prQM = &prAdapter->rQM;
+	prQue = &prQM->arTxQueue[TX_QUEUE_INDEX_BMCAST];
+
+	QUEUE_INITIALIZE(&rNeedToFreeQue);
+	QUEUE_INITIALIZE(&rTempQue);
+
+	prNeedToFreeQue = &rNeedToFreeQue;
+	prTempQue = &rTempQue;
+
+	QUEUE_MOVE_ALL(prTempQue, prQue);
+
+	QUEUE_REMOVE_HEAD(prTempQue, prMsduInfo,
+		struct MSDU_INFO *);
+	while (prMsduInfo) {
+
+		if (prMsduInfo->ucBssIndex == ucBssIndex) {
+			/* QUEUE_INSERT_TAIL */
+			QUEUE_INSERT_TAIL(prNeedToFreeQue,
+				(struct QUE_ENTRY *) prMsduInfo);
+		} else {
+			/* QUEUE_INSERT_TAIL */
+			QUEUE_INSERT_TAIL(prQue,
+				(struct QUE_ENTRY *) prMsduInfo);
+		}
+
+		QUEUE_REMOVE_HEAD(prTempQue, prMsduInfo,
+			struct MSDU_INFO *);
+	}
+	if (QUEUE_IS_NOT_EMPTY(prNeedToFreeQue))
+		wlanProcessQueuedMsduInfo(prAdapter,
+			(struct MSDU_INFO *)
+			QUEUE_GET_HEAD(prNeedToFreeQue));
+
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Flush all TX queues
+ *
+ * \param[in] (none)
+ *
+ * \return The flushed packets (in a list of MSDU_INFOs)
+ */
+/*----------------------------------------------------------------------------*/
+struct MSDU_INFO *qmFlushTxQueues(IN struct ADAPTER *prAdapter)
+{
+	uint8_t ucStaArrayIdx;
+	uint8_t ucQueArrayIdx;
+
+	struct QUE_MGT *prQM = &prAdapter->rQM;
+
+	struct QUE rTempQue;
+	struct QUE *prTempQue = &rTempQue;
+	struct QUE *prQue;
+
+	DBGLOG(QM, TRACE, "QM: Enter qmFlushTxQueues()\n");
+
+	QUEUE_INITIALIZE(prTempQue);
+
+	/* Concatenate all MSDU_INFOs in per-STA queues */
+	for (ucStaArrayIdx = 0; ucStaArrayIdx < CFG_STA_REC_NUM;
+		ucStaArrayIdx++) {
+		for (ucQueArrayIdx = 0;
+			ucQueArrayIdx < NUM_OF_PER_STA_TX_QUEUES;
+			ucQueArrayIdx++) {
+			prQue = &(prAdapter->arStaRec[ucStaArrayIdx].
+			arPendingTxQueue[ucQueArrayIdx]);
+			QUEUE_CONCATENATE_QUEUES(prTempQue, prQue);
+			prQue = &(prAdapter->arStaRec[ucStaArrayIdx].
+			arTxQueue[ucQueArrayIdx]);
+			QUEUE_CONCATENATE_QUEUES(prTempQue, prQue);
+		}
+	}
+
+	/* Flush per-Type queues */
+	for (ucQueArrayIdx = 0;
+		ucQueArrayIdx < NUM_OF_PER_TYPE_TX_QUEUES;
+		ucQueArrayIdx++) {
+		prQue = &(prQM->arTxQueue[ucQueArrayIdx]);
+		QUEUE_CONCATENATE_QUEUES(prTempQue, prQue);
+	}
+
+	return (struct MSDU_INFO *)QUEUE_GET_HEAD(prTempQue);
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Flush TX packets for a particular STA
+ *
+ * \param[in] u4StaRecIdx STA_REC index
+ *
+ * \return The flushed packets (in a list of MSDU_INFOs)
+ */
+/*----------------------------------------------------------------------------*/
+struct MSDU_INFO *qmFlushStaTxQueues(IN struct ADAPTER *prAdapter,
+	IN uint32_t u4StaRecIdx)
+{
+	uint8_t ucQueArrayIdx;
+	struct STA_RECORD *prStaRec;
+	struct QUE *prQue;
+	struct QUE rTempQue;
+	struct QUE *prTempQue = &rTempQue;
+
+	DBGLOG(QM, TRACE, "QM: Enter qmFlushStaTxQueues(%u)\n", u4StaRecIdx);
+
+	ASSERT(u4StaRecIdx < CFG_STA_REC_NUM);
+
+	prStaRec = &prAdapter->arStaRec[u4StaRecIdx];
+	ASSERT(prStaRec);
+
+	QUEUE_INITIALIZE(prTempQue);
+
+	/* Concatenate all MSDU_INFOs in TX queues of this STA_REC */
+	for (ucQueArrayIdx = 0;
+		ucQueArrayIdx < NUM_OF_PER_STA_TX_QUEUES; ucQueArrayIdx++) {
+		prQue = &(prStaRec->arPendingTxQueue[ucQueArrayIdx]);
+		QUEUE_CONCATENATE_QUEUES(prTempQue, prQue);
+		prQue = &(prStaRec->arTxQueue[ucQueArrayIdx]);
+		QUEUE_CONCATENATE_QUEUES(prTempQue, prQue);
+	}
+
+	return (struct MSDU_INFO *)QUEUE_GET_HEAD(prTempQue);
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Flush RX packets
+ *
+ * \param[in] (none)
+ *
+ * \return The flushed packets (in a list of SW_RFBs)
+ */
+/*----------------------------------------------------------------------------*/
+struct SW_RFB *qmFlushRxQueues(IN struct ADAPTER *prAdapter)
+{
+	uint32_t i;
+	struct SW_RFB *prSwRfbListHead;
+	struct SW_RFB *prSwRfbListTail;
+	struct QUE_MGT *prQM = &prAdapter->rQM;
+
+	prSwRfbListHead = prSwRfbListTail = NULL;
+
+	DBGLOG(QM, TRACE, "QM: Enter qmFlushRxQueues()\n");
+
+	RX_DIRECT_REORDER_LOCK(prAdapter, 0);
+	for (i = 0; i < CFG_NUM_OF_RX_BA_AGREEMENTS; i++) {
+		if (QUEUE_IS_NOT_EMPTY(&
+			(prQM->arRxBaTable[i].rReOrderQue))) {
+			if (!prSwRfbListHead) {
+
+				/* The first MSDU_INFO is found */
+				prSwRfbListHead = (struct SW_RFB *)
+					QUEUE_GET_HEAD(
+						&(prQM->arRxBaTable[i].
+						rReOrderQue));
+				prSwRfbListTail = (struct SW_RFB *)
+					QUEUE_GET_TAIL(
+						&(prQM->arRxBaTable[i].
+						rReOrderQue));
+			} else {
+				/* Concatenate the MSDU_INFO list with
+				 * the existing list
+				 */
+				QM_TX_SET_NEXT_MSDU_INFO(prSwRfbListTail,
+					QUEUE_GET_HEAD(
+						&(prQM->arRxBaTable[i].
+						rReOrderQue)));
+
+				prSwRfbListTail = (struct SW_RFB *)
+					QUEUE_GET_TAIL(
+						&(prQM->arRxBaTable[i].
+						rReOrderQue));
+			}
+
+			QUEUE_INITIALIZE(&(prQM->arRxBaTable[i].rReOrderQue));
+			if (QM_RX_GET_NEXT_SW_RFB(prSwRfbListTail)) {
+				DBGLOG(QM, ERROR,
+					"QM: non-null tail->next at arRxBaTable[%u]\n",
+					i);
+			}
+		} else {
+			continue;
+		}
+	}
+	RX_DIRECT_REORDER_UNLOCK(prAdapter, 0);
+
+	if (prSwRfbListTail) {
+		/* Terminate the MSDU_INFO list with a NULL pointer */
+		QM_TX_SET_NEXT_SW_RFB(prSwRfbListTail, NULL);
+	}
+	return prSwRfbListHead;
+
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Flush RX packets with respect to a particular STA
+ *
+ * \param[in] u4StaRecIdx STA_REC index
+ * \param[in] u4Tid TID
+ *
+ * \return The flushed packets (in a list of SW_RFBs)
+ */
+/*----------------------------------------------------------------------------*/
+struct SW_RFB *qmFlushStaRxQueue(IN struct ADAPTER *prAdapter,
+	IN uint32_t u4StaRecIdx, IN uint32_t u4Tid)
+{
+	/* UINT_32 i; */
+	struct SW_RFB *prSwRfbListHead;
+	struct SW_RFB *prSwRfbListTail;
+	struct RX_BA_ENTRY *prReorderQueParm;
+	struct STA_RECORD *prStaRec;
+
+	DBGLOG(QM, TRACE, "QM: Enter qmFlushStaRxQueues(%u)\n", u4StaRecIdx);
+
+	prSwRfbListHead = prSwRfbListTail = NULL;
+
+	prStaRec = &prAdapter->arStaRec[u4StaRecIdx];
+	ASSERT(prStaRec);
+
+	/* No matter whether this is an activated STA_REC, do flush */
+#if 0
+	if (!prStaRec->fgIsValid)
+		return NULL;
+#endif
+
+	/* Obtain the RX BA Entry pointer */
+	prReorderQueParm = ((prStaRec->aprRxReorderParamRefTbl)[u4Tid]);
+
+	/* Note: For each queued packet,
+	 * prCurrSwRfb->eDst equals RX_PKT_DESTINATION_HOST
+	 */
+	if (prReorderQueParm) {
+		RX_DIRECT_REORDER_LOCK(prAdapter, 0);
+		if (QUEUE_IS_NOT_EMPTY(&(prReorderQueParm->rReOrderQue))) {
+
+			prSwRfbListHead = (struct SW_RFB *)
+				QUEUE_GET_HEAD(
+					&(prReorderQueParm->rReOrderQue));
+			prSwRfbListTail = (struct SW_RFB *)
+				QUEUE_GET_TAIL(
+					&(prReorderQueParm->rReOrderQue));
+
+			QUEUE_INITIALIZE(&(prReorderQueParm->rReOrderQue));
+		}
+		RX_DIRECT_REORDER_UNLOCK(prAdapter, 0);
+	}
+
+	if (prSwRfbListTail) {
+		if (QM_RX_GET_NEXT_SW_RFB(prSwRfbListTail)) {
+			DBGLOG(QM, ERROR,
+				"QM: non-empty tail->next at STA %u TID %u\n",
+				u4StaRecIdx, u4Tid);
+		}
+
+		/* Terminate the MSDU_INFO list with a NULL pointer */
+		QM_TX_SET_NEXT_SW_RFB(prSwRfbListTail, NULL);
+	}
+	return prSwRfbListHead;
+}
+
+struct QUE *qmDetermineStaTxQueue(IN struct ADAPTER *prAdapter,
+				  IN struct MSDU_INFO *prMsduInfo,
+				  IN uint8_t ucActiveTs, OUT uint8_t *pucTC)
+{
+	struct QUE *prTxQue = NULL;
+	struct STA_RECORD *prStaRec;
+	enum ENUM_WMM_ACI eAci = WMM_AC_BE_INDEX;
+	u_int8_t fgCheckACMAgain;
+	uint8_t ucTC, ucQueIdx = TX_QUEUE_INDEX_AC0;
+	struct BSS_INFO *prBssInfo;
+	/* BEtoBK, na, VItoBE, VOtoVI */
+	uint8_t aucNextUP[WMM_AC_INDEX_NUM] = {1, 1, 0, 4};
+
+	prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter,
+		prMsduInfo->ucBssIndex);
+	prStaRec = QM_GET_STA_REC_PTR_FROM_INDEX(prAdapter,
+		prMsduInfo->ucStaRecIndex);
+	if (prStaRec == NULL)
+		return prTxQue;
+
+	if (!prStaRec) {
+		DBGLOG(QM, ERROR, "prStaRec is null.\n");
+		return NULL;
+	}
+	if (prMsduInfo->ucUserPriority < 8) {
+		QM_DBG_CNT_INC(&prAdapter->rQM,
+			prMsduInfo->ucUserPriority + 15);
+	}
+
+	eAci = WMM_AC_BE_INDEX;
+	do {
+		fgCheckACMAgain = FALSE;
+		if (prStaRec->fgIsQoS) {
+			if (prMsduInfo->ucUserPriority < TX_DESC_TID_NUM) {
+				eAci = aucTid2ACI[prMsduInfo->ucUserPriority];
+				ucQueIdx = aucACI2TxQIdx[eAci];
+				ucTC =
+					arNetwork2TcResource[
+					prMsduInfo->ucBssIndex][eAci];
+			} else {
+				ucQueIdx = TX_QUEUE_INDEX_AC1;
+				ucTC = TC1_INDEX;
+				eAci = WMM_AC_BE_INDEX;
+				DBGLOG(QM, WARN,
+					"Packet TID is not in [0~7]\n");
+				ASSERT(0);
+			}
+			if ((prBssInfo->arACQueParms[eAci].ucIsACMSet) &&
+			    !(ucActiveTs & BIT(eAci)) &&
+			    (eAci != WMM_AC_BK_INDEX)) {
+				DBGLOG(WMM, TRACE,
+					"ucUserPriority: %d, aucNextUP[eAci]: %d",
+					prMsduInfo->ucUserPriority,
+					aucNextUP[eAci]);
+				prMsduInfo->ucUserPriority = aucNextUP[eAci];
+				fgCheckACMAgain = TRUE;
+			}
+		} else {
+			ucQueIdx = TX_QUEUE_INDEX_NON_QOS;
+			ucTC = arNetwork2TcResource[prMsduInfo->ucBssIndex][
+				NET_TC_WMM_AC_BE_INDEX];
+		}
+
+		if (prAdapter->rWifiVar.ucTcRestrict < TC_NUM) {
+			ucTC = prAdapter->rWifiVar.ucTcRestrict;
+			ucQueIdx = ucTC;
+		}
+
+	} while (fgCheckACMAgain);
+
+	if (ucQueIdx >= NUM_OF_PER_STA_TX_QUEUES) {
+		DBGLOG(QM, ERROR,
+			"ucQueIdx = %u, needs 0~3 to avoid out-of-bounds.\n",
+			ucQueIdx);
+		return NULL;
+	}
+	if (prStaRec->fgIsTxAllowed) {
+		/* non protected BSS or protected BSS with key set */
+		prTxQue = prStaRec->aprTargetQueue[ucQueIdx];
+	} else if (secIsProtectedBss(prAdapter, prBssInfo) &&
+		prMsduInfo->fgIs802_1x &&
+		prMsduInfo->fgIs802_1x_NonProtected &&
+		!prAdapter->fgIsPostponeTxEAPOLM3) {
+		/* protected BSS without key set */
+		/* Tx pairwise EAPOL 1x packet (non-protected frame) */
+		prTxQue = &prStaRec->arTxQueue[ucQueIdx];
+	} else {
+		/* protected BSS without key set */
+		/* Enqueue protected frame into pending queue */
+		prTxQue = prStaRec->aprTargetQueue[ucQueIdx];
+	}
+
+	*pucTC = ucTC;
+	/*
+	 * Record how many packages enqueue this STA
+	 * to TX during statistic intervals
+	 */
+	prStaRec->u4EnqueueCounter++;
+
+	return prTxQue;
+}
+
+void qmSetTxPacketDescTemplate(IN struct ADAPTER *prAdapter,
+	IN struct MSDU_INFO *prMsduInfo)
+{
+	struct STA_RECORD *prStaRec = QM_GET_STA_REC_PTR_FROM_INDEX(
+		prAdapter, prMsduInfo->ucStaRecIndex);
+
+	/* Check the Tx descriptor template is valid */
+	if (prStaRec &&
+		prStaRec->aprTxDescTemplate[prMsduInfo->ucUserPriority]) {
+		prMsduInfo->fgIsTXDTemplateValid = TRUE;
+	} else {
+		if (prStaRec) {
+			DBGLOG(QM, TRACE,
+				"Cannot get TXD template for STA[%u] QoS[%u] MSDU UP[%u]\n",
+				prStaRec->ucIndex, prStaRec->fgIsQoS,
+				prMsduInfo->ucUserPriority);
+		}
+		prMsduInfo->fgIsTXDTemplateValid = FALSE;
+	}
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief : To StaRec, function to stop TX
+ *
+ * \param[in] :
+ *
+ * \return none
+ */
+/*----------------------------------------------------------------------------*/
+void qmSetStaRecTxAllowed(IN struct ADAPTER *prAdapter,
+	IN struct STA_RECORD *prStaRec, IN u_int8_t fgIsTxAllowed)
+{
+	uint8_t ucIdx;
+	struct QUE *prSrcQ, *prDstQ;
+
+	DBGLOG(QM, INFO, "Set Sta[%u] TxAllowed from [%u] to [%u] %s TxQ\n",
+		prStaRec->ucIndex,
+		prStaRec->fgIsTxAllowed,
+		fgIsTxAllowed,
+		fgIsTxAllowed ? "normal" : "pending");
+
+	/* Update Tx queue when allowed state change*/
+	if (prStaRec->fgIsTxAllowed != fgIsTxAllowed) {
+		for (ucIdx = 0; ucIdx < NUM_OF_PER_STA_TX_QUEUES; ucIdx++) {
+			if (fgIsTxAllowed) {
+				prSrcQ = &prStaRec->arPendingTxQueue[ucIdx];
+				prDstQ = &prStaRec->arTxQueue[ucIdx];
+			} else {
+				prSrcQ = &prStaRec->arTxQueue[ucIdx];
+				prDstQ = &prStaRec->arPendingTxQueue[ucIdx];
+			}
+
+			QUEUE_CONCATENATE_QUEUES_HEAD(prDstQ, prSrcQ);
+			prStaRec->aprTargetQueue[ucIdx] = prDstQ;
+		}
+
+		if (fgIsTxAllowed)
+			prAdapter->rQM.u4TxAllowedStaCount++;
+		else
+			prAdapter->rQM.u4TxAllowedStaCount--;
+	}
+	prStaRec->fgIsTxAllowed = fgIsTxAllowed;
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Enqueue TX packets
+ *
+ * \param[in] prMsduInfoListHead Pointer to the list of TX packets
+ *
+ * \return The freed packets, which are not enqueued
+ */
+/*----------------------------------------------------------------------------*/
+struct MSDU_INFO *qmEnqueueTxPackets(IN struct ADAPTER *prAdapter,
+	IN struct MSDU_INFO *prMsduInfoListHead)
+{
+	struct MSDU_INFO *prMsduInfoReleaseList;
+	struct MSDU_INFO *prCurrentMsduInfo;
+	struct MSDU_INFO *prNextMsduInfo;
+
+	struct QUE *prTxQue;
+	struct QUE rNotEnqueuedQue;
+	struct STA_RECORD *prStaRec;
+	uint8_t ucTC;
+	struct TX_CTRL *prTxCtrl = &prAdapter->rTxCtrl;
+	struct QUE_MGT *prQM = &prAdapter->rQM;
+	struct BSS_INFO *prBssInfo;
+	u_int8_t fgDropPacket;
+	uint8_t ucActivedTspec = 0;
+
+	DBGLOG(QM, LOUD, "Enter qmEnqueueTxPackets\n");
+
+	ASSERT(prMsduInfoListHead);
+
+	prMsduInfoReleaseList = NULL;
+	prCurrentMsduInfo = NULL;
+	QUEUE_INITIALIZE(&rNotEnqueuedQue);
+	prNextMsduInfo = prMsduInfoListHead;
+
+	do {
+		prCurrentMsduInfo = prNextMsduInfo;
+		prNextMsduInfo = QM_TX_GET_NEXT_MSDU_INFO(
+			prCurrentMsduInfo);
+		ucTC = TC1_INDEX;
+
+		/* 4 <0> Sanity check of BSS_INFO */
+		prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter,
+			prCurrentMsduInfo->ucBssIndex);
+
+		if (!prBssInfo) {
+			/* No BSS_INFO */
+			fgDropPacket = TRUE;
+		} else if (IS_BSS_ACTIVE(prBssInfo)) {
+			/* BSS active */
+			fgDropPacket = FALSE;
+		} else {
+			/* BSS inactive */
+			fgDropPacket = TRUE;
+		}
+
+		if (!fgDropPacket) {
+			/* 4 <1> Lookup the STA_REC index */
+			/* The ucStaRecIndex will be set in this function */
+			qmDetermineStaRecIndex(prAdapter, prCurrentMsduInfo);
+
+			/*get per-AC Tx packets */
+			wlanUpdateTxStatistics(prAdapter, prCurrentMsduInfo,
+				FALSE);
+
+			DBGLOG(QM, LOUD, "Enqueue MSDU by StaRec[%u]!\n",
+			       prCurrentMsduInfo->ucStaRecIndex);
+
+			switch (prCurrentMsduInfo->ucStaRecIndex) {
+			case STA_REC_INDEX_BMCAST:
+				prTxQue =
+					&prQM->arTxQueue[TX_QUEUE_INDEX_BMCAST];
+				ucTC =
+					arNetwork2TcResource[prCurrentMsduInfo->
+					ucBssIndex][NET_TC_BMC_INDEX];
+
+				/* Always set BMC packet retry limit
+				 * to unlimited
+				 */
+				if (!(prCurrentMsduInfo->u4Option &
+				      MSDU_OPT_MANUAL_RETRY_LIMIT))
+					nicTxSetPktRetryLimit(prCurrentMsduInfo,
+						TX_DESC_TX_COUNT_NO_LIMIT);
+
+				QM_DBG_CNT_INC(prQM, QM_DBG_CNT_23);
+				break;
+
+			case STA_REC_INDEX_NOT_FOUND:
+				/* Drop packet if no STA_REC is found */
+				DBGLOG(QM, INFO,
+					"Drop the Packet for no STA_REC\n");
+
+				prTxQue = &rNotEnqueuedQue;
+
+				TX_INC_CNT(&prAdapter->rTxCtrl,
+					TX_INACTIVE_STA_DROP);
+				QM_DBG_CNT_INC(prQM, QM_DBG_CNT_24);
+				break;
+
+			default:
+				ucActivedTspec = wmmHasActiveTspec(
+					aisGetWMMInfo(prAdapter,
+					prCurrentMsduInfo->ucBssIndex));
+
+				prTxQue = qmDetermineStaTxQueue(
+					prAdapter, prCurrentMsduInfo,
+					ucActivedTspec, &ucTC);
+				if (!prTxQue) {
+					DBGLOG(QM, INFO,
+						"Drop the Packet for TxQue is NULL\n");
+					prTxQue = &rNotEnqueuedQue;
+					TX_INC_CNT(&prAdapter->rTxCtrl,
+						TX_INACTIVE_STA_DROP);
+					QM_DBG_CNT_INC(prQM, QM_DBG_CNT_24);
+				}
+#if ARP_MONITER_ENABLE
+				prStaRec =
+					QM_GET_STA_REC_PTR_FROM_INDEX(prAdapter,
+						prCurrentMsduInfo->
+						ucStaRecIndex);
+				if (prStaRec && IS_STA_IN_AIS(prStaRec) &&
+					prCurrentMsduInfo->eSrc == TX_PACKET_OS)
+					qmDetectArpNoResponse(prAdapter,
+						prCurrentMsduInfo);
+#endif
+				break;	/*default */
+			}	/* switch (prCurrentMsduInfo->ucStaRecIndex) */
+
+			if (prCurrentMsduInfo->eSrc == TX_PACKET_FORWARDING) {
+				DBGLOG(QM, TRACE,
+					"Forward Pkt to STA[%u] BSS[%u]\n",
+					prCurrentMsduInfo->ucStaRecIndex,
+					prCurrentMsduInfo->ucBssIndex);
+
+				if (prTxQue->u4NumElem >=
+					prQM->u4MaxForwardBufferCount) {
+					DBGLOG(QM, INFO,
+					       "Drop the Packet for full Tx queue (forwarding) Bss %u\n",
+					       prCurrentMsduInfo->ucBssIndex);
+					prTxQue = &rNotEnqueuedQue;
+					TX_INC_CNT(&prAdapter->rTxCtrl,
+						TX_FORWARD_OVERFLOW_DROP);
+				}
+			}
+
+		} else {
+			DBGLOG(QM, INFO,
+				"Drop the Packet for inactive Bss %u\n",
+				prCurrentMsduInfo->ucBssIndex);
+			QM_DBG_CNT_INC(prQM, QM_DBG_CNT_31);
+			prTxQue = &rNotEnqueuedQue;
+			TX_INC_CNT(&prAdapter->rTxCtrl, TX_INACTIVE_BSS_DROP);
+		}
+
+		/* 4 <3> Fill the MSDU_INFO for constructing HIF TX header */
+		/* Note that the BSS Index and STA_REC index are determined in
+		 *  qmDetermineStaRecIndex(prCurrentMsduInfo).
+		 */
+		prCurrentMsduInfo->ucTC = ucTC;
+
+		/* Check the Tx descriptor template is valid */
+		qmSetTxPacketDescTemplate(prAdapter, prCurrentMsduInfo);
+
+		/* Set Tx rate */
+		switch (prAdapter->rWifiVar.ucDataTxRateMode) {
+		case DATA_RATE_MODE_BSS_LOWEST:
+			nicTxSetPktLowestFixedRate(prAdapter,
+				prCurrentMsduInfo);
+			break;
+
+		case DATA_RATE_MODE_MANUAL:
+			prCurrentMsduInfo->u4FixedRateOption =
+				prAdapter->rWifiVar.u4DataTxRateCode;
+
+			prCurrentMsduInfo->ucRateMode =
+				MSDU_RATE_MODE_MANUAL_DESC;
+			break;
+
+		case DATA_RATE_MODE_AUTO:
+		default:
+			if (prCurrentMsduInfo->ucRateMode ==
+			    MSDU_RATE_MODE_LOWEST_RATE)
+				nicTxSetPktLowestFixedRate(prAdapter,
+					prCurrentMsduInfo);
+			break;
+		}
+
+		/* 4 <4> Enqueue the packet */
+		QUEUE_INSERT_TAIL(prTxQue,
+			(struct QUE_ENTRY *) prCurrentMsduInfo);
+		wlanFillTimestamp(prAdapter, prCurrentMsduInfo->prPacket,
+				  PHASE_ENQ_QM);
+		/*
+		 * Record how many packages enqueue
+		 * to TX during statistic intervals
+		 */
+		if (prTxQue != &rNotEnqueuedQue) {
+			prQM->u4EnqueueCounter++;
+			/* how many page count this frame wanted */
+			prQM->au4QmTcWantedPageCounter[ucTC] +=
+				prCurrentMsduInfo->u4PageCount;
+		}
+#if QM_TC_RESOURCE_EMPTY_COUNTER
+		if (prCurrentMsduInfo->u4PageCount >
+			prTxCtrl->rTc.au4FreePageCount[ucTC])
+			prQM->au4QmTcResourceEmptyCounter[
+			prCurrentMsduInfo->ucBssIndex][ucTC]++;
+#endif
+
+#if QM_FAST_TC_RESOURCE_CTRL && QM_ADAPTIVE_TC_RESOURCE_CTRL
+		if (prTxQue != &rNotEnqueuedQue) {
+			/* Check and trigger fast TC resource
+			 * adjustment for queued packets
+			 */
+			qmCheckForFastTcResourceCtrl(prAdapter, ucTC);
+		}
+#endif
+
+#if QM_TEST_MODE
+		if (++prQM->u4PktCount == QM_TEST_TRIGGER_TX_COUNT) {
+			prQM->u4PktCount = 0;
+			qmTestCases(prAdapter);
+		}
+#endif
+	} while (prNextMsduInfo);
+
+	if (QUEUE_IS_NOT_EMPTY(&rNotEnqueuedQue)) {
+		QM_TX_SET_NEXT_MSDU_INFO((struct MSDU_INFO *)
+			QUEUE_GET_TAIL(&rNotEnqueuedQue), NULL);
+		prMsduInfoReleaseList = (struct MSDU_INFO *) QUEUE_GET_HEAD(
+			&rNotEnqueuedQue);
+	}
+#if QM_ADAPTIVE_TC_RESOURCE_CTRL
+	/* 4 <x> Update TC resource control related variables */
+	/* Keep track of the queue length */
+	qmDoAdaptiveTcResourceCtrl(prAdapter);
+#endif
+
+	return prMsduInfoReleaseList;
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Determine the STA_REC index for a packet
+ *
+ * \param[in] prMsduInfo Pointer to the packet
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void qmDetermineStaRecIndex(IN struct ADAPTER *prAdapter,
+	IN struct MSDU_INFO *prMsduInfo)
+{
+	struct STA_RECORD *prTempStaRec;
+	struct BSS_INFO *prBssInfo;
+
+	prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, prMsduInfo->ucBssIndex);
+	prTempStaRec = NULL;
+
+	ASSERT(prMsduInfo);
+
+	DBGLOG(QM, LOUD,
+		"Msdu BSS Idx[%u] OpMode[%u] StaRecOfApExist[%u]\n",
+		prMsduInfo->ucBssIndex, prBssInfo->eCurrentOPMode,
+		prBssInfo->prStaRecOfAP ? TRUE : FALSE);
+
+	switch (prBssInfo->eCurrentOPMode) {
+	case OP_MODE_IBSS:
+	case OP_MODE_ACCESS_POINT:
+	case OP_MODE_NAN:
+		/* 4 <1> DA = BMCAST */
+		if (IS_BMCAST_MAC_ADDR(prMsduInfo->aucEthDestAddr)) {
+			prMsduInfo->ucStaRecIndex = STA_REC_INDEX_BMCAST;
+			DBGLOG(QM, LOUD, "TX with DA = BMCAST\n");
+			return;
+		}
+		break;
+
+	/* Infra Client/GC */
+	case OP_MODE_INFRASTRUCTURE:
+	case OP_MODE_BOW:
+		if (prBssInfo->prStaRecOfAP) {
+#if CFG_SUPPORT_TDLS
+
+			prTempStaRec =
+				cnmGetTdlsPeerByAddress(prAdapter,
+					prBssInfo->ucBssIndex,
+					prMsduInfo->aucEthDestAddr);
+			if (IS_DLS_STA(prTempStaRec)
+			    && prTempStaRec->ucStaState == STA_STATE_3) {
+				if (g_arTdlsLink[prTempStaRec->ucTdlsIndex]) {
+					prMsduInfo->ucStaRecIndex =
+						prTempStaRec->ucIndex;
+					return;
+				}
+			}
+#endif
+			/* 4 <2> Check if an AP STA is present */
+			prTempStaRec = prBssInfo->prStaRecOfAP;
+
+			DBGLOG(QM, LOUD,
+				"StaOfAp Idx[%u] WIDX[%u] Valid[%u] TxAllowed[%u] InUse[%u] Type[%u]\n",
+				prTempStaRec->ucIndex,
+				prTempStaRec->ucWlanIndex,
+				prTempStaRec->fgIsValid,
+				prTempStaRec->fgIsTxAllowed,
+				prTempStaRec->fgIsInUse,
+				prTempStaRec->eStaType);
+
+			if (prTempStaRec->fgIsInUse) {
+				prMsduInfo->ucStaRecIndex =
+					prTempStaRec->ucIndex;
+				DBGLOG(QM, LOUD, "TX with AP_STA[%u]\n",
+					prTempStaRec->ucIndex);
+				return;
+			}
+		}
+		break;
+
+	case OP_MODE_P2P_DEVICE:
+		break;
+
+	default:
+		break;
+	}
+
+	/* 4 <3> Not BMCAST, No AP --> Compare DA
+	 * (i.e., to see whether this is a unicast frame to a client)
+	 */
+	prTempStaRec = cnmGetStaRecByAddress(prAdapter,
+			prMsduInfo->ucBssIndex,
+			prMsduInfo->aucEthDestAddr);
+	if (prTempStaRec) {
+		prMsduInfo->ucStaRecIndex = prTempStaRec->ucIndex;
+		DBGLOG(QM, LOUD, "TX with STA[%u]\n",
+			prTempStaRec->ucIndex);
+		return;
+	}
+
+	/* 4 <4> No STA found, Not BMCAST --> Indicate NOT_FOUND to FW */
+	prMsduInfo->ucStaRecIndex = STA_REC_INDEX_NOT_FOUND;
+	DBGLOG(QM, LOUD, "QM: TX with STA_REC_INDEX_NOT_FOUND\n");
+
+#if (QM_TEST_MODE && QM_TEST_FAIR_FORWARDING)
+	prMsduInfo->ucStaRecIndex =
+		(uint8_t)	prQM->u4CurrentStaRecIndexToEnqueue;
+#endif
+}
+
+struct STA_RECORD *qmDetermineStaToBeDequeued(
+	IN struct ADAPTER *prAdapter,
+	IN uint32_t u4StartStaRecIndex)
+{
+
+	return NULL;
+}
+
+struct QUE *qmDequeueStaTxPackets(IN struct ADAPTER *prAdapter)
+{
+
+	return NULL;
+}
+#if CFG_SUPPORT_NAN
+void
+qmUpdateFreeNANQouta(IN struct ADAPTER *prAdapter,
+		     struct EVENT_UPDATE_NAN_TX_STATUS *prTxStatus) {
+	struct EVENT_UPDATE_NAN_TX_STATUS *prUpdateTxStatus;
+	uint8_t ucStaIndex = 0;
+	struct STA_RECORD *prStaRec; /* The current focused STA */
+
+	prUpdateTxStatus = prTxStatus;
+
+	prStaRec = &prAdapter->arStaRec[ucStaIndex];
+
+	kalSetEvent(prAdapter->prGlueInfo);
+}
+#endif
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Dequeue TX packets from a STA_REC for a particular TC
+ *
+ * \param[out] prQue The queue to put the dequeued packets
+ * \param[in] ucTC The TC index (TC0_INDEX to TC5_INDEX)
+ * \param[in] ucMaxNum The maximum amount of dequeued packets
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+uint32_t
+qmDequeueTxPacketsFromPerStaQueues(IN struct ADAPTER *prAdapter,
+	OUT struct QUE *prQue, IN uint8_t ucTC,
+	IN uint32_t u4CurrentQuota,
+	IN uint32_t *prPleCurrentQuota,
+	IN uint32_t u4TotalQuota)
+{
+	uint32_t ucLoop;		/* Loop for */
+
+	uint32_t u4CurStaIndex = 0;
+	uint32_t u4CurStaUsedResource = 0;
+
+	/* The current focused STA */
+	struct STA_RECORD *prStaRec;
+	/* The Bss for current focused STA */
+	struct BSS_INFO	*prBssInfo;
+	/* The current TX queue to dequeue */
+	struct QUE *prCurrQueue;
+	/* The dequeued packet */
+	struct MSDU_INFO *prDequeuedPkt;
+
+	/* To remember the total forwarded packets for a STA */
+	uint32_t u4CurStaForwardFrameCount;
+	/* The maximum number of packets a STA can forward */
+	uint32_t u4MaxForwardFrameCountLimit;
+	uint32_t u4AvaliableResource;	/* The TX resource amount */
+	uint32_t u4MaxResourceLimit;
+
+	u_int8_t fgEndThisRound;
+	struct QUE_MGT *prQM = &prAdapter->rQM;
+
+	uint8_t *pucPsStaFreeQuota;
+#if CFG_SUPPORT_NAN
+#if CFG_SUPPORT_NAN_ADVANCE_DATA_CONTROL
+	unsigned char fgIsNanStaRec;
+#endif
+#endif
+#if CFG_SUPPORT_SOFT_ACM
+	uint8_t ucAc;
+	u_int8_t fgAcmFlowCtrl = FALSE;
+	static const uint8_t aucTc2Ac[] = {ACI_BK, ACI_BE, ACI_VI, ACI_VO};
+#endif
+
+	/* Sanity Check */
+	if (!u4CurrentQuota) {
+		DBGLOG(TX, LOUD,
+			"(Fairness) Skip TC = %u u4CurrentQuota = %u\n", ucTC,
+			u4CurrentQuota);
+		prQM->au4DequeueNoTcResourceCounter[ucTC]++;
+		return u4CurrentQuota;
+	}
+	/* Check PLE resource */
+	if (!(*prPleCurrentQuota))
+		return u4CurrentQuota;
+	/* 4 <1> Assign init value */
+	u4AvaliableResource = u4CurrentQuota;
+	u4MaxResourceLimit = u4TotalQuota;
+
+#if QM_FORWARDING_FAIRNESS
+	u4CurStaIndex = prQM->au4HeadStaRecIndex[ucTC];
+	u4CurStaUsedResource = prQM->au4ResourceUsedCount[ucTC];
+#endif
+
+	fgEndThisRound = FALSE;
+	ucLoop = 0;
+	u4CurStaForwardFrameCount = 0;
+
+	DBGLOG(QM, TEMP,
+		"(Fairness) TC[%u] Init Head STA[%u] Resource[%u]\n",
+		ucTC, u4CurStaIndex, u4AvaliableResource);
+
+	/* 4 <2> Traverse STA array from Head STA */
+	/* From STA[x] to STA[x+1] to STA[x+2] to ... to STA[x] */
+	while (ucLoop < CFG_STA_REC_NUM) {
+		prStaRec = &prAdapter->arStaRec[u4CurStaIndex];
+		prCurrQueue = &prStaRec->arTxQueue[ucTC];
+
+		/* 4 <2.1> Find a Tx allowed STA */
+		/* Only Data frame will be queued in */
+		/* if (prStaRec->fgIsTxAllowed) { */
+		if (QUEUE_IS_NOT_EMPTY(prCurrQueue)) {
+			prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter,
+				prStaRec->ucBssIndex);
+
+			/* prCurrQueue = &prStaRec->aprTxQueue[ucTC]; */
+			prDequeuedPkt = NULL;
+			pucPsStaFreeQuota = NULL;
+			/* Set default forward count limit to unlimited */
+			u4MaxForwardFrameCountLimit =
+				QM_STA_FORWARD_COUNT_UNLIMITED;
+
+			/* 4 <2.2> Update forward frame/page count
+			 * limit for this STA
+			 */
+			/* AP mode: STA in PS buffer handling */
+			if (prStaRec->fgIsInPS) {
+				if (prStaRec->fgIsQoS &&
+					prStaRec->fgIsUapsdSupported &&
+					(prStaRec->ucBmpTriggerAC &
+						BIT(ucTC))) {
+					u4MaxForwardFrameCountLimit =
+						prStaRec->
+						ucFreeQuotaForDelivery;
+					pucPsStaFreeQuota =
+						&prStaRec->
+						ucFreeQuotaForDelivery;
+				} else {
+					u4MaxForwardFrameCountLimit =
+						prStaRec->
+						ucFreeQuotaForNonDelivery;
+					pucPsStaFreeQuota =
+						&prStaRec->
+						ucFreeQuotaForNonDelivery;
+				}
+			}
+
+#if CFG_SUPPORT_NAN
+#if CFG_SUPPORT_NAN_ADVANCE_DATA_CONTROL
+			fgIsNanStaRec = FALSE;
+			if (prBssInfo->eNetworkType == NETWORK_TYPE_NAN) {
+				fgIsNanStaRec = TRUE;
+				DBGLOG(NAN, TEMP, "NAN STA:%d, TC:%d\n",
+				       prStaRec->ucIndex, ucTC);
+			}
+#endif
+#endif
+
+			/* fgIsInPS */
+			/* Absent BSS handling */
+			if (prBssInfo->fgIsNetAbsent) {
+				if (u4MaxForwardFrameCountLimit >
+					prBssInfo->ucBssFreeQuota)
+					u4MaxForwardFrameCountLimit =
+						prBssInfo->ucBssFreeQuota;
+			}
+#if CFG_SUPPORT_DBDC
+			if (prAdapter->rWifiVar.fgDbDcModeEn)
+				u4MaxResourceLimit =
+					gmGetDequeueQuota(prAdapter,
+						prStaRec, prBssInfo,
+						u4TotalQuota);
+#endif
+#if CFG_SUPPORT_SOFT_ACM
+			if (ucTC <= TC3_INDEX &&
+			    prStaRec->afgAcmRequired[aucTc2Ac[ucTC]]) {
+				ucAc = aucTc2Ac[ucTC];
+				DBGLOG(QM, TRACE, "AC %d Pending Pkts %u\n",
+				       ucAc, prCurrQueue->u4NumElem);
+				/* Quick check remain medium time and pending
+				** packets
+				*/
+				if (QUEUE_IS_EMPTY(prCurrQueue) ||
+				    !wmmAcmCanDequeue(prAdapter, ucAc, 0,
+				    prBssInfo->ucBssIndex))
+					goto skip_dequeue;
+				fgAcmFlowCtrl = TRUE;
+			} else
+				fgAcmFlowCtrl = FALSE;
+#endif
+			/* 4 <2.3> Dequeue packet */
+			/* Three cases to break: (1) No resource
+			 * (2) No packets (3) Fairness
+			 */
+			while (!QUEUE_IS_EMPTY(prCurrQueue)) {
+				prDequeuedPkt = (struct MSDU_INFO *)
+					QUEUE_GET_HEAD(prCurrQueue);
+
+				if ((u4CurStaForwardFrameCount >=
+				     u4MaxForwardFrameCountLimit) ||
+				    (u4CurStaUsedResource >=
+				    u4MaxResourceLimit)) {
+					/* Exceeds Limit */
+					prQM->
+					au4DequeueNoTcResourceCounter[ucTC]++;
+					break;
+				} else if (prDequeuedPkt->u4PageCount >
+					   u4AvaliableResource) {
+					/* Available Resource is not enough */
+					prQM->
+					au4DequeueNoTcResourceCounter[ucTC]++;
+					if (!(prAdapter->rWifiVar.
+						ucAlwaysResetUsedRes & BIT(0)))
+						fgEndThisRound = TRUE;
+					break;
+				} else if ((*prPleCurrentQuota) <
+					   NIX_TX_PLE_PAGE_CNT_PER_FRAME) {
+					if (!(prAdapter->rWifiVar.
+						ucAlwaysResetUsedRes & BIT(0)))
+						fgEndThisRound = TRUE;
+					break;
+				} else if (!prStaRec->fgIsValid) {
+					/* In roaming, if the sta_rec doesn't
+					 * active by event 0x0C, it can't
+					 * dequeue data.
+					 */
+					DBGLOG_LIMITED(QM, WARN,
+						"sta_rec is not valid\n");
+					break;
+				}
+
+#if CFG_SUPPORT_NAN
+#if CFG_SUPPORT_NAN_ADVANCE_DATA_CONTROL
+				if (fgIsNanStaRec == TRUE) {
+					OS_SYSTIME rCurrentTime;
+					unsigned char fgExpired;
+
+					rCurrentTime = kalGetTimeTick();
+					fgExpired = CHECK_FOR_EXPIRATION(
+						rCurrentTime,
+						prStaRec->rNanExpiredSendTime);
+
+					/* avoid to flood the kernel log,
+					 * only the 1st expiry event logged
+					 */
+					if (fgExpired &&
+					    !prStaRec->fgNanSendTimeExpired)
+						DBGLOG(NAN, TEMP,
+						       "[NAN Pkt Tx Expired] Sta:%u, Exp:%u, Now:%u\n",
+						       prStaRec->ucIndex,
+						       prStaRec->
+							rNanExpiredSendTime,
+						       rCurrentTime);
+
+					if (fgExpired) {
+						prStaRec->fgNanSendTimeExpired =
+							TRUE;
+						break;
+					}
+
+					prStaRec->fgNanSendTimeExpired = FALSE;
+				}
+#endif
+#endif
+
+#if CFG_SUPPORT_SOFT_ACM
+				if (fgAcmFlowCtrl) {
+					uint32_t u4PktTxTime = 0;
+
+					u4PktTxTime = wmmCalculatePktUsedTime(
+						prBssInfo, prStaRec,
+						prDequeuedPkt->u2FrameLength -
+							ETH_HLEN);
+					if (!wmmAcmCanDequeue(prAdapter, ucAc,
+						u4PktTxTime,
+						prBssInfo->ucBssIndex))
+						break;
+				}
+#endif
+				/* Available to be Tx */
+
+				QUEUE_REMOVE_HEAD(prCurrQueue, prDequeuedPkt,
+						  struct MSDU_INFO *);
+
+				if (!QUEUE_IS_EMPTY(prCurrQueue)) {
+					/* XXX: check all queues for STA */
+					prDequeuedPkt->ucPsForwardingType =
+						PS_FORWARDING_MORE_DATA_ENABLED;
+				}
+
+				if (unlikely(prStaRec->ucBssIndex !=
+					prDequeuedPkt->ucBssIndex)) {
+					DBGLOG(QM, INFO,
+						"BssIdx mismatch [%d,%d]",
+						prStaRec->ucBssIndex,
+						prDequeuedPkt->ucBssIndex);
+				}
+
+				/* to record WMM Set */
+				prDequeuedPkt->ucWmmQueSet =
+					prBssInfo->ucWmmQueSet;
+				QUEUE_INSERT_TAIL(prQue,
+					(struct QUE_ENTRY *)
+					prDequeuedPkt);
+				prStaRec->u4DeqeueuCounter++;
+				prQM->u4DequeueCounter++;
+
+				u4AvaliableResource -=
+					prDequeuedPkt->u4PageCount;
+				u4CurStaUsedResource +=
+					prDequeuedPkt->u4PageCount;
+				u4CurStaForwardFrameCount++;
+				(*prPleCurrentQuota) -=
+					NIX_TX_PLE_PAGE_CNT_PER_FRAME;
+			}
+#if CFG_SUPPORT_SOFT_ACM
+skip_dequeue:
+#endif
+			/* AP mode: Update STA in PS Free quota */
+			if (prStaRec->fgIsInPS && pucPsStaFreeQuota) {
+				if ((*pucPsStaFreeQuota) >=
+					u4CurStaForwardFrameCount)
+					(*pucPsStaFreeQuota) -=
+						u4CurStaForwardFrameCount;
+				else
+					(*pucPsStaFreeQuota) = 0;
+			}
+
+			if (prBssInfo->fgIsNetAbsent) {
+				if (prBssInfo->ucBssFreeQuota >=
+					u4CurStaForwardFrameCount)
+					prBssInfo->ucBssFreeQuota -=
+						u4CurStaForwardFrameCount;
+				else
+					prBssInfo->ucBssFreeQuota = 0;
+			}
+		}
+
+		if (fgEndThisRound) {
+			/* End this round */
+			break;
+		}
+
+		/* Prepare for next STA */
+		ucLoop++;
+		u4CurStaIndex++;
+		u4CurStaIndex %= CFG_STA_REC_NUM;
+		u4CurStaUsedResource = 0;
+		u4CurStaForwardFrameCount = 0;
+	}
+
+	/* 4 <3> Store Head Sta information to QM */
+	/* No need to count used resource if thers is only one STA */
+	if ((prQM->u4TxAllowedStaCount == 1) ||
+		(prAdapter->rWifiVar.ucAlwaysResetUsedRes & BIT(1)))
+		u4CurStaUsedResource = 0;
+
+#if QM_FORWARDING_FAIRNESS
+	prQM->au4HeadStaRecIndex[ucTC] = u4CurStaIndex;
+	prQM->au4ResourceUsedCount[ucTC] = u4CurStaUsedResource;
+#endif
+
+	DBGLOG(QM, TEMP,
+		"(Fairness) TC[%u] Scheduled Head STA[%u] Left Resource[%u]\n",
+		ucTC, u4CurStaIndex, u4AvaliableResource);
+
+	return u4AvaliableResource;
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Dequeue TX packets from a per-Type-based Queue for a particular TC
+ *
+ * \param[out] prQue The queue to put the dequeued packets
+ * \param[in] ucTC The TC index(Shall always be BMC_TC_INDEX)
+ * \param[in] ucMaxNum The maximum amount of available resource
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void
+qmDequeueTxPacketsFromPerTypeQueues(IN struct ADAPTER *prAdapter,
+	OUT struct QUE *prQue, IN uint8_t ucTC,
+	IN uint32_t u4CurrentQuota,
+	IN uint32_t *prPleCurrentQuota,
+	IN uint32_t u4TotalQuota)
+{
+	uint32_t u4AvaliableResource, u4LeftResource;
+	uint32_t u4MaxResourceLimit;
+	uint32_t u4TotalUsedResource = 0;
+	struct QUE_MGT *prQM;
+	PFN_DEQUEUE_FUNCTION pfnDeQFunc[2];
+	u_int8_t fgChangeDeQFunc = TRUE;
+	u_int8_t fgGlobalQueFirst = TRUE;
+
+	DBGLOG(QM, TEMP, "Enter %s (TC = %d, quota = %u)\n",
+		__func__, ucTC, u4CurrentQuota);
+
+	/* Broadcast/Multicast data packets */
+	if (u4CurrentQuota == 0)
+		return;
+	/* Check PLE resource */
+	if (!(*prPleCurrentQuota))
+		return;
+
+	prQM = &prAdapter->rQM;
+
+	u4AvaliableResource = u4CurrentQuota;
+	u4MaxResourceLimit = u4TotalQuota;
+#if QM_FORWARDING_FAIRNESS
+	u4TotalUsedResource = prQM->u4GlobalResourceUsedCount;
+	fgGlobalQueFirst = prQM->fgGlobalQFirst;
+#endif
+
+	/* Dequeue function selection */
+	if (fgGlobalQueFirst) {
+		pfnDeQFunc[0] = qmDequeueTxPacketsFromGlobalQueue;
+		pfnDeQFunc[1] = qmDequeueTxPacketsFromPerStaQueues;
+	} else {
+		pfnDeQFunc[0] = qmDequeueTxPacketsFromPerStaQueues;
+		pfnDeQFunc[1] = qmDequeueTxPacketsFromGlobalQueue;
+	}
+
+	/* 1st dequeue function */
+	u4LeftResource = pfnDeQFunc[0](prAdapter, prQue, ucTC,
+		u4AvaliableResource,
+		prPleCurrentQuota,
+		(u4MaxResourceLimit - u4TotalUsedResource));
+
+	/* dequeue function comsumes no resource, change */
+	if ((u4LeftResource >= u4AvaliableResource) &&
+		(u4AvaliableResource >=
+		prAdapter->rTxCtrl.u4MaxPageCntPerFrame)) {
+		fgChangeDeQFunc = TRUE;
+	} else {
+		u4TotalUsedResource +=
+			(u4AvaliableResource - u4LeftResource);
+		/* Used resource exceeds limit, change */
+		if (u4TotalUsedResource >= u4MaxResourceLimit)
+			fgChangeDeQFunc = TRUE;
+	}
+
+	if (fgChangeDeQFunc) {
+		fgGlobalQueFirst = !fgGlobalQueFirst;
+		u4TotalUsedResource = 0;
+	}
+
+	/* 2nd dequeue function */
+	u4LeftResource = pfnDeQFunc[1](prAdapter, prQue, ucTC,
+		u4LeftResource, prPleCurrentQuota, u4MaxResourceLimit);
+
+#if QM_FORWARDING_FAIRNESS
+	prQM->fgGlobalQFirst = fgGlobalQueFirst;
+	prQM->u4GlobalResourceUsedCount = u4TotalUsedResource;
+#endif
+
+}				/* qmDequeueTxPacketsFromPerTypeQueues */
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Dequeue TX packets from a QM global Queue for a particular TC
+ *
+ * \param[out] prQue The queue to put the dequeued packets
+ * \param[in] ucTC The TC index(Shall always be BMC_TC_INDEX)
+ * \param[in] ucMaxNum The maximum amount of available resource
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+uint32_t
+qmDequeueTxPacketsFromGlobalQueue(IN struct ADAPTER *prAdapter,
+	OUT struct QUE *prQue,
+	IN uint8_t ucTC, IN uint32_t u4CurrentQuota,
+	IN uint32_t *prPleCurrentQuota,
+	IN uint32_t u4TotalQuota)
+{
+	struct BSS_INFO *prBssInfo;
+	struct QUE *prCurrQueue;
+	uint32_t u4AvaliableResource;
+	struct MSDU_INFO *prDequeuedPkt;
+	struct MSDU_INFO *prBurstEndPkt;
+	struct QUE rMergeQue;
+	struct QUE *prMergeQue;
+	struct QUE_MGT *prQM;
+
+	DBGLOG(QM, TEMP, "Enter %s (TC = %d, quota = %u)\n",
+		__func__, ucTC, u4CurrentQuota);
+
+	/* Broadcast/Multicast data packets */
+	if (u4CurrentQuota == 0)
+		return u4CurrentQuota;
+	/* Check PLE resource */
+	if (!(*prPleCurrentQuota))
+		return u4CurrentQuota;
+
+	prQM = &prAdapter->rQM;
+
+	/* 4 <1> Determine the queue */
+	prCurrQueue = &prQM->arTxQueue[TX_QUEUE_INDEX_BMCAST];
+	u4AvaliableResource = u4CurrentQuota;
+	prDequeuedPkt = NULL;
+	prBurstEndPkt = NULL;
+
+	QUEUE_INITIALIZE(&rMergeQue);
+	prMergeQue = &rMergeQue;
+
+	/* 4 <2> Dequeue packets */
+	while (!QUEUE_IS_EMPTY(prCurrQueue)) {
+		prDequeuedPkt = (struct MSDU_INFO *) QUEUE_GET_HEAD(
+					prCurrQueue);
+		if (prDequeuedPkt->u4PageCount > u4AvaliableResource)
+			break;
+		if ((*prPleCurrentQuota) < NIX_TX_PLE_PAGE_CNT_PER_FRAME)
+			break;
+
+		QUEUE_REMOVE_HEAD(prCurrQueue, prDequeuedPkt,
+			struct MSDU_INFO *);
+
+		prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter,
+			prDequeuedPkt->ucBssIndex);
+
+		if (IS_BSS_ACTIVE(prBssInfo)) {
+			if (!prBssInfo->fgIsNetAbsent) {
+				/* to record WMM Set */
+				prDequeuedPkt->ucWmmQueSet =
+					prBssInfo->ucWmmQueSet;
+				QUEUE_INSERT_TAIL(prQue,
+					(struct QUE_ENTRY *)
+					prDequeuedPkt);
+				prBurstEndPkt = prDequeuedPkt;
+				prQM->u4DequeueCounter++;
+				u4AvaliableResource -=
+					prDequeuedPkt->u4PageCount;
+				(*prPleCurrentQuota) -=
+					NIX_TX_PLE_PAGE_CNT_PER_FRAME;
+				QM_DBG_CNT_INC(prQM, QM_DBG_CNT_26);
+			} else {
+				QUEUE_INSERT_TAIL(prMergeQue,
+					(struct QUE_ENTRY *)
+					prDequeuedPkt);
+			}
+		} else {
+			QM_TX_SET_NEXT_MSDU_INFO(prDequeuedPkt, NULL);
+			wlanProcessQueuedMsduInfo(prAdapter, prDequeuedPkt);
+		}
+	}
+
+	if (QUEUE_IS_NOT_EMPTY(prMergeQue)) {
+		QUEUE_CONCATENATE_QUEUES(prMergeQue, prCurrQueue);
+		QUEUE_MOVE_ALL(prCurrQueue, prMergeQue);
+		QM_TX_SET_NEXT_MSDU_INFO((struct MSDU_INFO *)
+			QUEUE_GET_TAIL(prCurrQueue), NULL);
+	}
+
+	return u4AvaliableResource;
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Dequeue TX packets to send to HIF TX
+ *
+ * \param[in] prTcqStatus Info about the maximum amount of dequeued packets
+ *
+ * \return The list of dequeued TX packets
+ */
+/*----------------------------------------------------------------------------*/
+struct MSDU_INFO *qmDequeueTxPackets(IN struct ADAPTER *prAdapter,
+	IN struct TX_TCQ_STATUS *prTcqStatus)
+{
+	int32_t i;
+	struct MSDU_INFO *prReturnedPacketListHead;
+	struct QUE rReturnedQue;
+	uint32_t u4MaxQuotaLimit;
+	uint32_t u4AvailableResourcePLE;
+
+	DBGLOG(QM, TEMP, "Enter qmDequeueTxPackets\n");
+
+	QUEUE_INITIALIZE(&rReturnedQue);
+
+	prReturnedPacketListHead = NULL;
+
+	/* TC0 to TC3: AC0~AC3 (commands packets are not handled by QM) */
+	for (i = TC3_INDEX; i >= TC0_INDEX; i--) {
+		DBGLOG(QM, TEMP, "Dequeue packets from Per-STA queue[%u]\n", i);
+
+		/* If only one STA is Tx allowed,
+		 * no need to restrict Max quota
+		 */
+		if (prAdapter->rWifiVar.u4MaxTxDeQLimit)
+			u4MaxQuotaLimit = prAdapter->rWifiVar.u4MaxTxDeQLimit;
+		else if (prAdapter->rQM.u4TxAllowedStaCount == 1)
+			u4MaxQuotaLimit = QM_STA_FORWARD_COUNT_UNLIMITED;
+		else
+			u4MaxQuotaLimit =
+				(uint32_t) prTcqStatus->au4MaxNumOfPage[i];
+
+		u4AvailableResourcePLE = nicTxResourceGetPleFreeCount(
+			prAdapter, i);
+
+		if (i == BMC_TC_INDEX)
+			qmDequeueTxPacketsFromPerTypeQueues(prAdapter,
+				&rReturnedQue, (uint8_t)i,
+				prTcqStatus->au4FreePageCount[i],
+				&u4AvailableResourcePLE,
+				u4MaxQuotaLimit);
+		else
+			qmDequeueTxPacketsFromPerStaQueues(prAdapter,
+				&rReturnedQue,
+				(uint8_t)i,
+				prTcqStatus->au4FreePageCount[i],
+				&u4AvailableResourcePLE,
+				u4MaxQuotaLimit);
+
+		/* The aggregate number of dequeued packets */
+		DBGLOG(QM, TEMP, "DQA)[%u](%u)\n", i,
+			rReturnedQue.u4NumElem);
+	}
+
+	if (QUEUE_IS_NOT_EMPTY(&rReturnedQue)) {
+		prReturnedPacketListHead = (struct MSDU_INFO *)
+			QUEUE_GET_HEAD(&rReturnedQue);
+		QM_TX_SET_NEXT_MSDU_INFO((struct MSDU_INFO *)
+			QUEUE_GET_TAIL(&rReturnedQue), NULL);
+	}
+
+	return prReturnedPacketListHead;
+}
+
+#if CFG_SUPPORT_MULTITHREAD
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Dequeue TX packets to send to HIF TX
+ *
+ * \param[in] prTcqStatus Info about the maximum amount of dequeued packets
+ *
+ * \return The list of dequeued TX packets
+ */
+/*----------------------------------------------------------------------------*/
+struct MSDU_INFO *qmDequeueTxPacketsMthread(
+	IN struct ADAPTER *prAdapter,
+	IN struct TX_TCQ_STATUS *prTcqStatus)
+{
+
+	/* INT_32 i; */
+	struct MSDU_INFO *prReturnedPacketListHead;
+	/* QUE_T rReturnedQue; */
+	/* UINT_32 u4MaxQuotaLimit; */
+	struct MSDU_INFO *prMsduInfo, *prNextMsduInfo;
+
+	KAL_SPIN_LOCK_DECLARATION();
+
+#if QM_ADAPTIVE_TC_RESOURCE_CTRL
+	if (prAdapter->rQM.fgForceReassign)
+		qmDoAdaptiveTcResourceCtrl(prAdapter);
+#endif
+
+	KAL_ACQUIRE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_RESOURCE);
+
+	prReturnedPacketListHead = qmDequeueTxPackets(prAdapter,
+		prTcqStatus);
+
+	/* require the resource first to prevent from unsync */
+	prMsduInfo = prReturnedPacketListHead;
+	while (prMsduInfo) {
+		prNextMsduInfo = (struct MSDU_INFO *) QUEUE_GET_NEXT_ENTRY((
+			struct QUE_ENTRY *) prMsduInfo);
+		nicTxAcquireResource(prAdapter, prMsduInfo->ucTC,
+			nicTxGetPageCount(prAdapter, prMsduInfo->u2FrameLength,
+				FALSE), FALSE);
+		prMsduInfo = prNextMsduInfo;
+	}
+
+	if (prReturnedPacketListHead)
+		wlanTxProfilingTagMsdu(prAdapter, prReturnedPacketListHead,
+			TX_PROF_TAG_DRV_DEQUE);
+
+	KAL_RELEASE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_RESOURCE);
+
+	return prReturnedPacketListHead;
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Adjust the TC quotas according to traffic demands
+ *
+ * \param[out] prTcqAdjust The resulting adjustment
+ * \param[in] prTcqStatus Info about the current TC quotas and counters
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+u_int8_t
+qmAdjustTcQuotasMthread(IN struct ADAPTER *prAdapter,
+	OUT struct TX_TCQ_ADJUST *prTcqAdjust,
+	IN struct TX_TCQ_STATUS *prTcqStatus)
+{
+#if QM_ADAPTIVE_TC_RESOURCE_CTRL
+	uint32_t i;
+	struct QUE_MGT *prQM = &prAdapter->rQM;
+
+	KAL_SPIN_LOCK_DECLARATION();
+
+	/* Must initialize */
+	for (i = 0; i < QM_ACTIVE_TC_NUM; i++)
+		prTcqAdjust->ai4Variation[i] = 0;
+
+	/* 4 <1> If TC resource is not just adjusted, exit directly */
+	if (!prQM->fgTcResourcePostAnnealing)
+		return FALSE;
+
+	/* 4 <2> Adjust TcqStatus according to
+	 * the updated prQM->au4CurrentTcResource
+	 */
+	else {
+		int32_t i4TotalExtraQuota = 0;
+		int32_t ai4ExtraQuota[QM_ACTIVE_TC_NUM];
+		u_int8_t fgResourceRedistributed = TRUE;
+
+		/* Must initialize */
+		for (i = 0; i < TC_NUM; i++)
+			prTcqAdjust->ai4Variation[i] = 0;
+
+		KAL_ACQUIRE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_RESOURCE);
+
+		/* Obtain the free-to-distribute resource */
+		for (i = 0; i < QM_ACTIVE_TC_NUM; i++) {
+			ai4ExtraQuota[i] =
+				(int32_t) prTcqStatus->au4MaxNumOfBuffer[i] -
+				(int32_t) prQM->au4CurrentTcResource[i];
+
+			if (ai4ExtraQuota[i] > 0) {
+				/* The resource shall be reallocated
+				 * to other TCs
+				 */
+				if (ai4ExtraQuota[i] >
+					prTcqStatus->au4FreeBufferCount[
+					i]) {
+					ai4ExtraQuota[i] =
+						prTcqStatus->
+						au4FreeBufferCount[i];
+					fgResourceRedistributed = FALSE;
+				}
+
+				i4TotalExtraQuota += ai4ExtraQuota[i];
+				prTcqAdjust->ai4Variation[i] =
+					(-ai4ExtraQuota[i]);
+			}
+		}
+
+		/* Distribute quotas to TCs which need extra resource
+		 * according to prQM->au4CurrentTcResource
+		 */
+		for (i = 0; i < QM_ACTIVE_TC_NUM; i++) {
+			if (ai4ExtraQuota[i] < 0) {
+				if ((-ai4ExtraQuota[i]) > i4TotalExtraQuota) {
+					ai4ExtraQuota[i] = (-i4TotalExtraQuota);
+					fgResourceRedistributed = FALSE;
+				}
+
+				i4TotalExtraQuota += ai4ExtraQuota[i];
+				prTcqAdjust->ai4Variation[i] =
+					(-ai4ExtraQuota[i]);
+			}
+		}
+
+		/* In case some TC is waiting for TX Done,
+		 * continue to adjust TC quotas upon TX Done
+		 */
+		prQM->fgTcResourcePostAnnealing = (!fgResourceRedistributed);
+
+		for (i = 0; i < TC_NUM; i++) {
+			prTcqStatus->au4FreePageCount[i] +=
+				(prTcqAdjust->ai4Variation[i] *
+				prAdapter->rTxCtrl.u4MaxPageCntPerFrame);
+			prTcqStatus->au4MaxNumOfPage[i] +=
+				(prTcqAdjust->ai4Variation[i] *
+				prAdapter->rTxCtrl.u4MaxPageCntPerFrame);
+
+			prTcqStatus->au4FreeBufferCount[i] +=
+				prTcqAdjust->ai4Variation[i];
+			prTcqStatus->au4MaxNumOfBuffer[i] +=
+				prTcqAdjust->ai4Variation[i];
+		}
+
+
+		/* PLE */
+		qmAdjustTcQuotaPle(prAdapter, prTcqAdjust, prTcqStatus);
+
+
+#if QM_FAST_TC_RESOURCE_CTRL
+		prQM->fgTcResourceFastReaction = FALSE;
+#endif
+		KAL_RELEASE_SPIN_LOCK(prAdapter, SPIN_LOCK_TX_RESOURCE);
+	}
+
+	return TRUE;
+#else
+	return FALSE;
+#endif
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Adjust the TC PLE quotas according to traffic demands
+ *
+ * \param[out] prTcqAdjust The resulting adjustment
+ * \param[in] prTcqStatus Info about the current TC quotas and counters
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void qmAdjustTcQuotaPle(IN struct ADAPTER *prAdapter,
+	OUT struct TX_TCQ_ADJUST *prTcqAdjust,
+	IN struct TX_TCQ_STATUS *prTcqStatus)
+{
+	uint8_t i;
+	int32_t i4pages;
+	struct TX_CTRL *prTxCtrl;
+	struct TX_TCQ_STATUS *prTc;
+	int32_t i4TotalExtraQuota = 0;
+
+	ASSERT(prAdapter);
+
+	prTxCtrl = &prAdapter->rTxCtrl;
+	prTc = &prTxCtrl->rTc;
+
+	/* no PLE resource control */
+	if (!prTc->fgNeedPleCtrl)
+		return;
+
+	/* collect free PLE resource */
+	for (i = TC0_INDEX; i < TC_NUM; i++) {
+
+		if (!nicTxResourceIsPleCtrlNeeded(prAdapter, i))
+			continue;
+
+		/* adjust ple resource */
+		i4pages = prTcqAdjust->ai4Variation[i] *
+				NIX_TX_PLE_PAGE_CNT_PER_FRAME;
+
+		if (i4pages < 0) {
+			/* donate resource to other TC */
+			if (prTcqStatus->au4FreePageCount_PLE[i] < (-i4pages)) {
+				/* not enough to give */
+				i4pages =
+					-(prTcqStatus->au4FreePageCount_PLE[i]);
+			}
+			i4TotalExtraQuota += -i4pages;
+
+			prTcqStatus->au4FreePageCount_PLE[i] += i4pages;
+			prTcqStatus->au4MaxNumOfPage_PLE[i] += i4pages;
+
+			prTcqStatus->au4FreeBufferCount_PLE[i] +=
+				(i4pages / NIX_TX_PLE_PAGE_CNT_PER_FRAME);
+			prTcqStatus->au4MaxNumOfBuffer_PLE[i] +=
+				(i4pages / NIX_TX_PLE_PAGE_CNT_PER_FRAME);
+		}
+	}
+
+	/* distribute PLE resource */
+	for (i = TC0_INDEX; i < TC_NUM; i++) {
+		if (!nicTxResourceIsPleCtrlNeeded(prAdapter, i))
+			continue;
+
+		/* adjust ple resource */
+		i4pages = prTcqAdjust->ai4Variation[i] *
+				NIX_TX_PLE_PAGE_CNT_PER_FRAME;
+
+		if (i4pages > 0) {
+			if (i4TotalExtraQuota >= i4pages) {
+				i4TotalExtraQuota -= i4pages;
+			} else {
+				i4pages = i4TotalExtraQuota;
+				i4TotalExtraQuota = 0;
+			}
+			prTcqStatus->au4FreePageCount_PLE[i] += i4pages;
+			prTcqStatus->au4MaxNumOfPage_PLE[i] += i4pages;
+
+			prTcqStatus->au4FreeBufferCount_PLE[i] =
+				(prTcqStatus->au4FreePageCount_PLE[i] /
+					NIX_TX_PLE_PAGE_CNT_PER_FRAME);
+			prTcqStatus->au4MaxNumOfBuffer_PLE[i] =
+				(prTcqStatus->au4MaxNumOfBuffer_PLE[i] /
+					NIX_TX_PLE_PAGE_CNT_PER_FRAME);
+		}
+	}
+
+	/* distribute remaining PLE resource */
+	while (i4TotalExtraQuota != 0) {
+		DBGLOG(QM, INFO,
+				"distribute remaining PLE resource[%u]\n",
+				i4TotalExtraQuota);
+		for (i = TC0_INDEX; i < TC_NUM; i++) {
+			if (!nicTxResourceIsPleCtrlNeeded(prAdapter, i))
+				continue;
+
+			if (i4TotalExtraQuota >=
+				NIX_TX_PLE_PAGE_CNT_PER_FRAME) {
+				prTcqStatus->au4FreePageCount_PLE[i] +=
+					NIX_TX_PLE_PAGE_CNT_PER_FRAME;
+				prTcqStatus->au4MaxNumOfPage_PLE[i] +=
+					NIX_TX_PLE_PAGE_CNT_PER_FRAME;
+
+				prTcqStatus->au4FreeBufferCount_PLE[i] += 1;
+				prTcqStatus->au4MaxNumOfBuffer_PLE[i] += 1;
+
+				i4TotalExtraQuota -=
+					NIX_TX_PLE_PAGE_CNT_PER_FRAME;
+			} else {
+				/* remaining PLE pages are
+				 * not enough for a package
+				 */
+				prTcqStatus->au4FreePageCount_PLE[i] +=
+					i4TotalExtraQuota;
+				prTcqStatus->au4MaxNumOfPage_PLE[i] +=
+					i4TotalExtraQuota;
+
+				prTcqStatus->au4FreeBufferCount_PLE[i] =
+					(prTcqStatus->au4FreePageCount_PLE[i] /
+						NIX_TX_PLE_PAGE_CNT_PER_FRAME);
+				prTcqStatus->au4MaxNumOfBuffer_PLE[i] =
+					(prTcqStatus->au4MaxNumOfPage_PLE[i] /
+						NIX_TX_PLE_PAGE_CNT_PER_FRAME);
+
+				i4TotalExtraQuota = 0;
+			}
+		}
+	}
+
+}
+
+#endif
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Adjust the TC quotas according to traffic demands
+ *
+ * \param[out] prTcqAdjust The resulting adjustment
+ * \param[in] prTcqStatus Info about the current TC quotas and counters
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+u_int8_t qmAdjustTcQuotas(IN struct ADAPTER *prAdapter,
+	OUT struct TX_TCQ_ADJUST *prTcqAdjust,
+	IN struct TX_TCQ_STATUS *prTcqStatus)
+{
+#if QM_ADAPTIVE_TC_RESOURCE_CTRL
+	uint32_t i;
+	struct QUE_MGT *prQM = &prAdapter->rQM;
+
+	/* Must initialize */
+	for (i = 0; i < QM_ACTIVE_TC_NUM; i++)
+		prTcqAdjust->ai4Variation[i] = 0;
+
+	/* 4 <1> If TC resource is not just adjusted, exit directly */
+	if (!prQM->fgTcResourcePostAnnealing)
+		return FALSE;
+	/* 4 <2> Adjust TcqStatus according to
+	 * the updated prQM->au4CurrentTcResource
+	 */
+	else {
+		int32_t i4TotalExtraQuota = 0;
+		int32_t ai4ExtraQuota[QM_ACTIVE_TC_NUM];
+		u_int8_t fgResourceRedistributed = TRUE;
+
+		/* Obtain the free-to-distribute resource */
+		for (i = 0; i < QM_ACTIVE_TC_NUM; i++) {
+			ai4ExtraQuota[i] =
+				(int32_t) prTcqStatus->au4MaxNumOfBuffer[i] -
+				(int32_t) prQM->au4CurrentTcResource[i];
+
+			if (ai4ExtraQuota[i] > 0) {
+				/* The resource shall be
+				 * reallocated to other TCs
+				 */
+				if (ai4ExtraQuota[i] >
+					prTcqStatus->au4FreeBufferCount[i]) {
+					ai4ExtraQuota[i] =
+						prTcqStatus->
+						au4FreeBufferCount[i];
+					fgResourceRedistributed = FALSE;
+				}
+
+				i4TotalExtraQuota += ai4ExtraQuota[i];
+				prTcqAdjust->ai4Variation[i] =
+					(-ai4ExtraQuota[i]);
+			}
+		}
+
+		/* Distribute quotas to TCs which need extra resource
+		 * according to prQM->au4CurrentTcResource
+		 */
+		for (i = 0; i < QM_ACTIVE_TC_NUM; i++) {
+			if (ai4ExtraQuota[i] < 0) {
+				if ((-ai4ExtraQuota[i]) > i4TotalExtraQuota) {
+					ai4ExtraQuota[i] = (-i4TotalExtraQuota);
+					fgResourceRedistributed = FALSE;
+				}
+
+				i4TotalExtraQuota += ai4ExtraQuota[i];
+				prTcqAdjust->ai4Variation[i] =
+					(-ai4ExtraQuota[i]);
+			}
+		}
+
+		/* In case some TC is waiting for TX Done,
+		 * continue to adjust TC quotas upon TX Done
+		 */
+		prQM->fgTcResourcePostAnnealing = (!fgResourceRedistributed);
+
+#if QM_FAST_TC_RESOURCE_CTRL
+		prQM->fgTcResourceFastReaction = FALSE;
+#endif
+
+#if QM_PRINT_TC_RESOURCE_CTRL
+		DBGLOG(QM, LOUD,
+			"QM: Curr Quota [0]=%u [1]=%u [2]=%u [3]=%u [4]=%u [5]=%u\n",
+			prTcqStatus->au4FreeBufferCount[0],
+			prTcqStatus->au4FreeBufferCount[1],
+			prTcqStatus->au4FreeBufferCount[2],
+			prTcqStatus->au4FreeBufferCount[3],
+			prTcqStatus->au4FreeBufferCount[4],
+			prTcqStatus->au4FreeBufferCount[5]);
+#endif
+	}
+
+	return TRUE;
+#else
+	return FALSE;
+#endif
+}
+
+#if QM_ADAPTIVE_TC_RESOURCE_CTRL
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Update the average TX queue length for the TC resource control
+ *        mechanism
+ *
+ * \param (none)
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void qmUpdateAverageTxQueLen(IN struct ADAPTER *prAdapter)
+{
+	int32_t u4CurrQueLen, u4Tc, u4StaRecIdx;
+	struct STA_RECORD *prStaRec;
+	struct QUE_MGT *prQM = &prAdapter->rQM;
+	struct BSS_INFO *prBssInfo;
+
+	/* 4 <1> Update the queue lengths for TC0 to TC3 (skip TC4) and TC5 */
+	for (u4Tc = 0; u4Tc < QM_ACTIVE_TC_NUM; u4Tc++) {
+		u4CurrQueLen = 0;
+
+		/* Calculate per-STA queue length */
+		if (u4Tc < NUM_OF_PER_STA_TX_QUEUES) {
+			for (u4StaRecIdx = 0; u4StaRecIdx < CFG_STA_REC_NUM;
+			     u4StaRecIdx++) {
+				prStaRec = cnmGetStaRecByIndex(prAdapter,
+					u4StaRecIdx);
+				if (prStaRec) {
+					prBssInfo = GET_BSS_INFO_BY_INDEX(
+						prAdapter,
+						prStaRec->ucBssIndex);
+
+					/* If the STA is activated,
+					 * get the queue length
+					 */
+					if ((prStaRec->fgIsValid) &&
+						(!prBssInfo->fgIsNetAbsent))
+						u4CurrQueLen +=
+							(prStaRec->
+							arTxQueue[u4Tc].
+							u4NumElem);
+				}
+			}
+		}
+
+		if (u4Tc == BMC_TC_INDEX) {
+			/* Update the queue length for (BMCAST) */
+			u4CurrQueLen += prQM->arTxQueue[
+			TX_QUEUE_INDEX_BMCAST].u4NumElem;
+		}
+
+		if (prQM->au4AverageQueLen[u4Tc] == 0) {
+			prQM->au4AverageQueLen[u4Tc] = (u4CurrQueLen <<
+				prQM->u4QueLenMovingAverage);
+		} else {
+			prQM->au4AverageQueLen[u4Tc] -=
+				(prQM->au4AverageQueLen[u4Tc] >>
+				 prQM->u4QueLenMovingAverage);
+			prQM->au4AverageQueLen[u4Tc] += (u4CurrQueLen);
+		}
+	}
+#if 0
+	/* Update the queue length for TC5 (BMCAST) */
+	u4CurrQueLen =
+		prQM->arTxQueue[TX_QUEUE_INDEX_BMCAST].u4NumElem;
+
+	if (prQM->au4AverageQueLen[TC5_INDEX] == 0) {
+		prQM->au4AverageQueLen[TC5_INDEX] = (u4CurrQueLen <<
+			QM_QUE_LEN_MOVING_AVE_FACTOR);
+	} else {
+		prQM->au4AverageQueLen[TC5_INDEX] -=
+			(prQM->au4AverageQueLen[TC5_INDEX] >>
+			QM_QUE_LEN_MOVING_AVE_FACTOR);
+		prQM->au4AverageQueLen[TC5_INDEX] += (u4CurrQueLen);
+	}
+#endif
+}
+
+void qmAllocateResidualTcResource(IN struct ADAPTER *prAdapter,
+	IN int32_t *ai4TcResDemand,
+	IN uint32_t *pu4ResidualResource,
+	IN uint32_t *pu4ShareCount)
+{
+	struct QUE_MGT *prQM = &prAdapter->rQM;
+	uint32_t u4Share = 0;
+	uint32_t u4TcIdx;
+	uint8_t ucIdx;
+	uint32_t au4AdjTc[] = { TC3_INDEX, TC2_INDEX, TC1_INDEX, TC0_INDEX };
+	uint32_t u4AdjTcSize = (sizeof(au4AdjTc) / sizeof(uint32_t));
+	uint32_t u4ResidualResource = *pu4ResidualResource;
+	uint32_t u4ShareCount = *pu4ShareCount;
+
+	/* If there is no resource left, exit directly */
+	if (u4ResidualResource == 0)
+		return;
+
+	/* This shall not happen */
+	if (u4ShareCount == 0) {
+		prQM->au4CurrentTcResource[TC1_INDEX] += u4ResidualResource;
+		DBGLOG(QM, ERROR, "QM: (Error) u4ShareCount = 0\n");
+		return;
+	}
+
+	/* Share the residual resource evenly */
+	u4Share = (u4ResidualResource / u4ShareCount);
+	if (u4Share) {
+		for (u4TcIdx = 0; u4TcIdx < QM_ACTIVE_TC_NUM; u4TcIdx++) {
+			/* Skip TC4 (not adjustable) */
+			if (u4TcIdx == TC4_INDEX)
+				continue;
+
+			if (ai4TcResDemand[u4TcIdx] > 0) {
+				if (ai4TcResDemand[u4TcIdx] > u4Share) {
+					prQM->au4CurrentTcResource[u4TcIdx] +=
+						u4Share;
+					u4ResidualResource -= u4Share;
+					ai4TcResDemand[u4TcIdx] -= u4Share;
+				} else {
+					prQM->au4CurrentTcResource[u4TcIdx] +=
+						ai4TcResDemand[u4TcIdx];
+					u4ResidualResource -=
+						ai4TcResDemand[u4TcIdx];
+					ai4TcResDemand[u4TcIdx] = 0;
+				}
+			}
+		}
+	}
+
+	/* By priority, allocate the left resource
+	 * that is not divisible by u4Share
+	 */
+	ucIdx = 0;
+	while (u4ResidualResource) {
+		u4TcIdx = au4AdjTc[ucIdx];
+
+		if (ai4TcResDemand[u4TcIdx]) {
+			prQM->au4CurrentTcResource[u4TcIdx]++;
+			u4ResidualResource--;
+			ai4TcResDemand[u4TcIdx]--;
+
+			if (ai4TcResDemand[u4TcIdx] == 0)
+				u4ShareCount--;
+		}
+
+		if (u4ShareCount <= 0)
+			break;
+
+		ucIdx++;
+		ucIdx %= u4AdjTcSize;
+	}
+
+	/* Allocate the left resource */
+	prQM->au4CurrentTcResource[TC3_INDEX] += u4ResidualResource;
+
+	*pu4ResidualResource = u4ResidualResource;
+	*pu4ShareCount = u4ShareCount;
+
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Assign TX resource for each TC according to TX queue length and
+ *        current assignment
+ *
+ * \param (none)
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void qmReassignTcResource(IN struct ADAPTER *prAdapter)
+{
+	int32_t i4TotalResourceDemand = 0;
+	uint32_t u4ResidualResource = 0;
+	uint32_t u4TcIdx;
+	int32_t ai4TcResDemand[QM_ACTIVE_TC_NUM];
+	uint32_t u4ShareCount = 0;
+	uint32_t u4Share = 0;
+	struct QUE_MGT *prQM = &prAdapter->rQM;
+	uint32_t u4ActiveTcCount = 0;
+	uint32_t u4LastActiveTcIdx = TC3_INDEX;
+
+	/* Note: After the new assignment is obtained,
+	 * set prQM->fgTcResourcePostAnnealing to TRUE to
+	 * start the TC-quota adjusting procedure,
+	 * which will be invoked upon every TX Done
+	 */
+
+	/* 4 <1> Determine the demands */
+	/* Determine the amount of extra resource
+	 * to fulfill all of the demands
+	 */
+	for (u4TcIdx = 0; u4TcIdx < QM_ACTIVE_TC_NUM; u4TcIdx++) {
+		/* Skip TC4, which is not adjustable */
+		if (u4TcIdx == TC4_INDEX)
+			continue;
+
+		/* Define: extra_demand = que_length +
+		 * min_reserved_quota - current_quota
+		 */
+		ai4TcResDemand[u4TcIdx] = ((int32_t)(QM_GET_TX_QUEUE_LEN(
+			prAdapter, u4TcIdx) +
+			prQM->au4MinReservedTcResource[u4TcIdx]) -
+			(int32_t)prQM->au4CurrentTcResource[u4TcIdx]);
+
+		/* If there are queued packets, allocate extra resource
+		 * for the TC (for TCP consideration)
+		 */
+		if (QM_GET_TX_QUEUE_LEN(prAdapter, u4TcIdx)) {
+			ai4TcResDemand[u4TcIdx] +=
+				prQM->u4ExtraReservedTcResource;
+			u4ActiveTcCount++;
+		}
+
+		i4TotalResourceDemand += ai4TcResDemand[u4TcIdx];
+	}
+
+	/* 4 <2> Case 1: Demand <= Total Resource */
+	if (i4TotalResourceDemand <= 0) {
+
+		/* 4 <2.1> Calculate the residual resource evenly */
+		/* excluding TC4 */
+		if (u4ActiveTcCount == 0)
+			u4ShareCount = (QM_ACTIVE_TC_NUM - 1);
+		else
+			u4ShareCount = u4ActiveTcCount;
+
+		u4ResidualResource = (uint32_t) (-i4TotalResourceDemand);
+		u4Share = (u4ResidualResource / u4ShareCount);
+
+		/* 4 <2.2> Satisfy every TC and share
+		 * the residual resource evenly
+		 */
+		for (u4TcIdx = 0; u4TcIdx < QM_ACTIVE_TC_NUM; u4TcIdx++) {
+			/* Skip TC4 (not adjustable) */
+			if (u4TcIdx == TC4_INDEX)
+				continue;
+
+			prQM->au4CurrentTcResource[u4TcIdx] +=
+				ai4TcResDemand[u4TcIdx];
+
+			/* Every TC is fully satisfied */
+			ai4TcResDemand[u4TcIdx] = 0;
+
+			/* The left resource will be allocated */
+			if (QM_GET_TX_QUEUE_LEN(prAdapter, u4TcIdx) ||
+				(u4ActiveTcCount == 0)) {
+				prQM->au4CurrentTcResource[u4TcIdx] += u4Share;
+				u4ResidualResource -= u4Share;
+				u4LastActiveTcIdx = u4TcIdx;
+			}
+		}
+
+		/* 4 <2.3> Allocate the left resource to last active TC */
+		prQM->au4CurrentTcResource[u4LastActiveTcIdx] +=
+			(u4ResidualResource);
+
+	}
+	/* 4 <3> Case 2: Demand > Total Resource --> Guarantee
+	 * a minimum amount of resource for each TC
+	 */
+	else {
+		u4ShareCount = 0;
+		u4ResidualResource = prQM->u4ResidualTcResource;
+
+		/* 4 <3.1> Allocated resouce amount  = minimum
+		 * of (guaranteed, total demand)
+		 */
+		for (u4TcIdx = 0; u4TcIdx < QM_ACTIVE_TC_NUM; u4TcIdx++) {
+			/* Skip TC4 (not adjustable) */
+			if (u4TcIdx == TC4_INDEX)
+				continue;
+
+			/* The demand can be fulfilled with
+			 * the guaranteed resource amount
+			 */
+			if ((prQM->au4CurrentTcResource[u4TcIdx] +
+			     ai4TcResDemand[u4TcIdx]) <=
+			    prQM->au4GuaranteedTcResource[u4TcIdx]) {
+
+				prQM->au4CurrentTcResource[u4TcIdx] +=
+					ai4TcResDemand[u4TcIdx];
+				u4ResidualResource +=
+					(prQM->au4GuaranteedTcResource[u4TcIdx]
+					- prQM->au4CurrentTcResource[u4TcIdx]);
+				ai4TcResDemand[u4TcIdx] = 0;
+			}
+
+			/* The demand can not be fulfilled with
+			 * the guaranteed resource amount
+			 */
+			else {
+				ai4TcResDemand[u4TcIdx] -=
+					(prQM->au4GuaranteedTcResource[u4TcIdx]
+					- prQM->au4CurrentTcResource[u4TcIdx]);
+
+				prQM->au4CurrentTcResource[u4TcIdx] =
+					prQM->au4GuaranteedTcResource[u4TcIdx];
+				u4ShareCount++;
+			}
+		}
+
+		/* 4 <3.2> Allocate the residual resource */
+		qmAllocateResidualTcResource(prAdapter, ai4TcResDemand,
+			&u4ResidualResource, &u4ShareCount);
+	}
+
+	prQM->fgTcResourcePostAnnealing = TRUE;
+
+#if QM_PRINT_TC_RESOURCE_CTRL
+	/* Debug print */
+	DBGLOG(QM, INFO,
+		"QM: TC Rsc adjust to [%03u:%03u:%03u:%03u:%03u:%03u]\n",
+		prQM->au4CurrentTcResource[0],
+		prQM->au4CurrentTcResource[1],
+		prQM->au4CurrentTcResource[2],
+		prQM->au4CurrentTcResource[3],
+		prQM->au4CurrentTcResource[4],
+		prQM->au4CurrentTcResource[5]);
+#endif
+
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Adjust TX resource for each TC according to TX queue length and
+ *        current assignment
+ *
+ * \param (none)
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void qmDoAdaptiveTcResourceCtrl(IN struct ADAPTER	*prAdapter)
+{
+	struct QUE_MGT *prQM = &prAdapter->rQM;
+
+	if (prQM->fgForceReassign) {
+		prQM->u4TimeToUpdateQueLen = 1;
+		prQM->u4TimeToAdjustTcResource = 1;
+		prQM->fgTcResourceFastReaction = TRUE;
+
+		prQM->fgForceReassign = FALSE;
+	}
+
+	/* 4 <0> Check to update queue length or not */
+	if (--prQM->u4TimeToUpdateQueLen)
+		return;
+	/* 4 <1> Update TC queue length */
+	prQM->u4TimeToUpdateQueLen = QM_INIT_TIME_TO_UPDATE_QUE_LEN;
+	qmUpdateAverageTxQueLen(prAdapter);
+
+	/* 4 <2> Adjust TC resource assignment */
+	/* Check whether it is time to adjust the TC resource assignment */
+	if (--prQM->u4TimeToAdjustTcResource == 0) {
+		/* The last assignment has not been completely applied */
+		if (prQM->fgTcResourcePostAnnealing) {
+			/* Upon the next qmUpdateAverageTxQueLen function call,
+			 * do this check again
+			 */
+			prQM->u4TimeToAdjustTcResource = 1;
+		}
+
+		/* The last assignment has been applied */
+		else {
+			prQM->u4TimeToAdjustTcResource =
+				QM_INIT_TIME_TO_ADJUST_TC_RSC;
+			qmReassignTcResource(prAdapter);
+#if QM_FAST_TC_RESOURCE_CTRL
+			if (prQM->fgTcResourceFastReaction) {
+				prQM->fgTcResourceFastReaction = FALSE;
+				nicTxAdjustTcq(prAdapter);
+			}
+#endif
+		}
+	}
+
+	/* Debug */
+#if QM_PRINT_TC_RESOURCE_CTRL
+	do {
+		uint32_t u4Tc;
+
+		for (u4Tc = 0; u4Tc < QM_ACTIVE_TC_NUM; u4Tc++) {
+			if (QM_GET_TX_QUEUE_LEN(prAdapter, u4Tc) >= 100) {
+				log_dbg(QM, LOUD, "QM: QueLen [%ld %ld %ld %ld %ld %ld]\n",
+					QM_GET_TX_QUEUE_LEN(prAdapter, 0),
+					QM_GET_TX_QUEUE_LEN(prAdapter, 1),
+					QM_GET_TX_QUEUE_LEN(prAdapter, 2),
+					QM_GET_TX_QUEUE_LEN(prAdapter, 3),
+					QM_GET_TX_QUEUE_LEN(prAdapter, 4),
+					QM_GET_TX_QUEUE_LEN(prAdapter, 5));
+				break;
+			}
+		}
+	} while (FALSE);
+#endif
+
+}
+
+#if QM_FAST_TC_RESOURCE_CTRL
+void qmCheckForFastTcResourceCtrl(IN struct ADAPTER *prAdapter,
+	IN uint8_t ucTc)
+{
+	struct QUE_MGT *prQM = &prAdapter->rQM;
+	u_int8_t fgTrigger = FALSE;
+
+	if (!prAdapter->rTxCtrl.rTc.au4FreeBufferCount[ucTc]
+	|| ((prAdapter->rTxCtrl.rTc.fgNeedPleCtrl) &&
+	(!prAdapter->rTxCtrl.rTc.au4FreeBufferCount_PLE[ucTc]))) {
+		if (!prQM->au4CurrentTcResource[ucTc] ||
+			nicTxGetAdjustableResourceCnt(prAdapter))
+			fgTrigger = TRUE;
+	}
+
+	/* Trigger TC resource adjustment
+	 * if there is a requirement coming for a empty TC
+	 */
+	if (fgTrigger) {
+		prQM->fgForceReassign = TRUE;
+
+		DBGLOG(QM, LOUD,
+			"Trigger TC Resource adjustment for TC[%u]\n", ucTc);
+	}
+}
+#endif
+
+#endif
+
+uint32_t gmGetDequeueQuota(
+	IN struct ADAPTER *prAdapter,
+	IN struct STA_RECORD *prStaRec,
+	IN struct BSS_INFO *prBssInfo,
+	IN uint32_t			u4TotalQuota
+)
+{
+	uint32_t	u4Weight = 100;
+	uint32_t	u4Quota;
+
+	struct QUE_MGT *prQM = &prAdapter->rQM;
+
+	/* Only apply to SDIO, PCIE/AXI use HW DMA */
+	if ((prAdapter->rWifiVar.uDeQuePercentEnable == FALSE) ||
+		(prQM->fgIsTxResrouceControlEn == FALSE))
+		return u4TotalQuota;
+
+	if (prStaRec->ucDesiredPhyTypeSet & PHY_TYPE_BIT_VHT) {
+		if (prBssInfo->ucVhtChannelWidth >
+			VHT_OP_CHANNEL_WIDTH_20_40) {
+			/* BW80 NSS1 rate: MCS9 433 Mbps */
+			u4Weight = prAdapter->rWifiVar.u4DeQuePercentVHT80Nss1;
+		} else if (prBssInfo->eBssSCO != CHNL_EXT_SCN) {
+			/* BW40 NSS1 Max rate: 200 Mbps */
+			u4Weight = prAdapter->rWifiVar.u4DeQuePercentVHT40Nss1;
+		} else {
+			/* BW20 NSS1 Max rate: 72.2Mbps (MCS8 86.7Mbps) */
+			u4Weight = prAdapter->rWifiVar.u4DeQuePercentVHT20Nss1;
+		}
+	} else if (prStaRec->ucDesiredPhyTypeSet & PHY_TYPE_BIT_HT) {
+		if (prBssInfo->ucHtOpInfo1 & HT_OP_INFO1_STA_CHNL_WIDTH) {
+			/* BW40 NSS1 Max rate: 150 Mbps (MCS9 200Mbps)*/
+			u4Weight = prAdapter->rWifiVar.u4DeQuePercentHT40Nss1;
+		} else {
+			/* BW20 NSS1 Max rate: 72.2Mbps (MCS8 86.7Mbps)*/
+			u4Weight = prAdapter->rWifiVar.u4DeQuePercentHT20Nss1;
+		}
+	}
+#if (CFG_SUPPORT_802_11AX == 1)
+	else if (fgEfuseCtrlAxOn == 1) {
+		if (prStaRec->ucDesiredPhyTypeSet & PHY_TYPE_BIT_HE)
+		;/* TBD */
+	}
+#endif
+#if (CFG_SUPPORT_802_11BE == 1)
+	else if (prStaRec->ucDesiredPhyTypeSet & PHY_TYPE_BIT_EHT)
+		;/* TBD */
+#endif
+
+	u4Quota = u4TotalQuota * u4Weight / 100;
+
+	if (u4Quota > u4TotalQuota || u4Quota <= 0)
+		return u4TotalQuota;
+
+	return u4Quota;
+}
+
+/*----------------------------------------------------------------------------*/
+/* RX-Related Queue Management                                                */
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Init Queue Management for RX
+ *
+ * \param[in] (none)
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void qmInitRxQueues(IN struct ADAPTER *prAdapter)
+{
+	/* DbgPrint("QM: Enter qmInitRxQueues()\n"); */
+	/* TODO */
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Handle RX packets (buffer reordering)
+ *
+ * \param[in] prSwRfbListHead The list of RX packets
+ *
+ * \return The list of packets which are not buffered for reordering
+ */
+/*----------------------------------------------------------------------------*/
+struct SW_RFB *qmHandleRxPackets(IN struct ADAPTER *prAdapter,
+	IN struct SW_RFB *prSwRfbListHead)
+{
+
+#if CFG_RX_REORDERING_ENABLED
+	struct SW_RFB *prCurrSwRfb;
+	struct SW_RFB *prNextSwRfb;
+	void *prRxStatus;
+	struct QUE rReturnedQue;
+	struct QUE *prReturnedQue;
+	uint8_t *pucEthDestAddr;
+	u_int8_t fgIsBMC, fgIsHTran;
+	u_int8_t fgMicErr;
+#if CFG_SUPPORT_REPLAY_DETECTION
+	u_int8_t ucBssIndexRly = 0;
+	struct BSS_INFO *prBssInfoRly = NULL;
+#endif
+
+	DEBUGFUNC("qmHandleRxPackets");
+
+	ASSERT(prSwRfbListHead);
+
+	prReturnedQue = &rReturnedQue;
+
+	QUEUE_INITIALIZE(prReturnedQue);
+	prNextSwRfb = prSwRfbListHead;
+
+	do {
+		prCurrSwRfb = prNextSwRfb;
+		prNextSwRfb = QM_RX_GET_NEXT_SW_RFB(prCurrSwRfb);
+
+		prRxStatus = prCurrSwRfb->prRxStatus;
+		if (prCurrSwRfb->u2RxByteCount > CFG_RX_MAX_PKT_SIZE) {
+			prCurrSwRfb->eDst = RX_PKT_DESTINATION_NULL;
+			QUEUE_INSERT_TAIL(prReturnedQue,
+				(struct QUE_ENTRY *) prCurrSwRfb);
+			DBGLOG(QM, ERROR,
+				"Drop packet when packet length is larger than CFG_RX_MAX_PKT_SIZE. Packet length=%d\n",
+				prCurrSwRfb->u2RxByteCount);
+			continue;
+		}
+		/* TODO: (Tehuang) Check if relaying */
+		prCurrSwRfb->eDst = RX_PKT_DESTINATION_HOST;
+
+		/* Decide the Destination */
+#if CFG_RX_PKTS_DUMP
+		if (prAdapter->rRxCtrl.u4RxPktsDumpTypeMask & BIT(
+			    HIF_RX_PKT_TYPE_DATA)) {
+			log_dbg(SW4, INFO,
+				"QM RX DATA: net _u sta idx %u wlan idx %u",
+				prCurrSwRfb->ucStaRecIdx,
+				prCurrSwRfb->ucWlanIdx);
+			log_dbg(SW4, INFO,
+				" ssn _u tid %u ptype %u 11 %u\n",
+				prCurrSwRfb->ucTid,
+				prCurrSwRfb->ucPacketType,
+				prCurrSwRfb->fgReorderBuffer);
+
+			DBGLOG_MEM8(SW4, TRACE,
+				(uint8_t *) prCurrSwRfb->pvHeader,
+				prCurrSwRfb->u2PacketLen);
+		}
+#endif
+
+		fgIsBMC = (prCurrSwRfb->fgIsBC | prCurrSwRfb->fgIsMC);
+		fgIsHTran = FALSE;
+		if (prCurrSwRfb->fgHdrTran) {
+			/* (!HIF_RX_HDR_GET_80211_FLAG(prHifRxHdr)){ */
+
+			uint8_t ucBssIndex;
+			struct BSS_INFO *prBssInfo;
+			uint8_t aucTaAddr[MAC_ADDR_LEN];
+
+			fgIsHTran = TRUE;
+			pucEthDestAddr = prCurrSwRfb->pvHeader;
+			if (prCurrSwRfb->prRxStatusGroup4 == NULL) {
+				DBGLOG(QM, ERROR,
+					"H/W did Header Trans but prRxStatusGroup4 is NULL !!!\n");
+				DBGLOG_MEM8(QM, ERROR, prCurrSwRfb->pucRecvBuff,
+					prCurrSwRfb->u2RxByteCount);
+				prCurrSwRfb->eDst = RX_PKT_DESTINATION_NULL;
+				QUEUE_INSERT_TAIL(prReturnedQue,
+					(struct QUE_ENTRY *)
+					prCurrSwRfb);
+				DBGLOG(RX, WARN,
+				       "rxStatusGroup4 for data packet is NULL, drop this packet, and dump RXD and Packet\n");
+				DBGLOG_MEM8(RX, WARN, (uint8_t *) prRxStatus,
+					sizeof(*prRxStatus));
+				if (prCurrSwRfb->pvHeader)
+					DBGLOG_MEM8(RX, WARN,
+						prCurrSwRfb->pvHeader,
+						prCurrSwRfb->u2PacketLen >
+						 32 ? 32 :
+						prCurrSwRfb->u2PacketLen);
+#if 0
+				glSetRstReason(RST_GROUP4_NULL);
+				GL_RESET_TRIGGER(prAdapter,
+					RST_FLAG_DO_CORE_DUMP);
+#endif
+				continue;
+			}
+
+			if (prCurrSwRfb->prStaRec == NULL) {
+				/* Workaround WTBL Issue */
+				HAL_RX_STATUS_GET_TA(
+					prCurrSwRfb->prRxStatusGroup4,
+					aucTaAddr);
+				prCurrSwRfb->ucStaRecIdx =
+					secLookupStaRecIndexFromTA(
+					prAdapter, aucTaAddr);
+				if (prCurrSwRfb->ucStaRecIdx <
+					CFG_STA_REC_NUM) {
+					prCurrSwRfb->prStaRec =
+						cnmGetStaRecByIndex(prAdapter,
+							prCurrSwRfb->
+							ucStaRecIdx);
+#define __STR_FMT__ \
+	"Re-search the staRec = %d, mac = " MACSTR ", byteCnt= %d\n"
+					log_dbg(QM, TRACE,
+						__STR_FMT__,
+						prCurrSwRfb->ucStaRecIdx,
+						MAC2STR(aucTaAddr),
+						prCurrSwRfb->u2RxByteCount);
+#undef __STR_FMT__
+				}
+
+				if (prCurrSwRfb->prStaRec == NULL) {
+					DBGLOG(RX, TEMP,
+						"Mark NULL the Packet for no STA_REC, wlanIdx=%d\n",
+						prCurrSwRfb->ucWlanIdx);
+					RX_INC_CNT(&prAdapter->rRxCtrl,
+						RX_NO_STA_DROP_COUNT);
+					prCurrSwRfb->eDst =
+						RX_PKT_DESTINATION_NULL;
+					QUEUE_INSERT_TAIL(prReturnedQue,
+						(struct QUE_ENTRY *)
+						prCurrSwRfb);
+					continue;
+				}
+
+				prCurrSwRfb->ucWlanIdx =
+					prCurrSwRfb->prStaRec->ucWlanIndex;
+				GLUE_SET_PKT_BSS_IDX(prCurrSwRfb->pvPacket,
+					secGetBssIdxByWlanIdx(prAdapter,
+						prCurrSwRfb->ucWlanIdx));
+			}
+
+			ucBssIndex = prCurrSwRfb->prStaRec->ucBssIndex;
+			prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter,
+				ucBssIndex);
+
+			if (!IS_BSS_ACTIVE(prBssInfo)) {
+				log_dbg(RX, TEMP, "Mark NULL the Packet for inactive Bss %u\n",
+					ucBssIndex);
+				RX_INC_CNT(&prAdapter->rRxCtrl,
+					RX_INACTIVE_BSS_DROP_COUNT);
+				prCurrSwRfb->eDst =
+					RX_PKT_DESTINATION_NULL;
+				QUEUE_INSERT_TAIL(prReturnedQue,
+					(struct QUE_ENTRY *)
+					prCurrSwRfb);
+				continue;
+			}
+
+			if (prBssInfo->eCurrentOPMode ==
+				OP_MODE_ACCESS_POINT) {
+				if (IS_BMCAST_MAC_ADDR(
+					pucEthDestAddr)) {
+					prCurrSwRfb->eDst =
+				RX_PKT_DESTINATION_HOST_WITH_FORWARD;
+				} else if (
+					secLookupStaRecIndexFromTA(
+					prAdapter,
+					pucEthDestAddr)
+					!=
+					STA_REC_INDEX_NOT_FOUND) {
+
+					prCurrSwRfb->eDst =
+					RX_PKT_DESTINATION_FORWARD;
+				}
+			}
+#if CFG_SUPPORT_PASSPOINT
+			else if (hs20IsFrameFilterEnabled(prAdapter,
+				prBssInfo) &&
+				hs20IsUnsecuredFrame(prAdapter,
+				prBssInfo,
+				prCurrSwRfb)) {
+				DBGLOG(QM, WARN,
+					"Mark NULL the Packet for Dropped Packet %u\n",
+					ucBssIndex);
+				RX_INC_CNT(&prAdapter->rRxCtrl,
+					RX_HS20_DROP_COUNT);
+				prCurrSwRfb->eDst =
+					RX_PKT_DESTINATION_NULL;
+				QUEUE_INSERT_TAIL(prReturnedQue,
+					(struct QUE_ENTRY *)
+					prCurrSwRfb);
+				continue;
+			}
+#endif /* CFG_SUPPORT_PASSPOINT */
+		} else {
+			uint16_t u2FrameCtrl = 0;
+			struct WLAN_MAC_HEADER *prWlanHeader = NULL;
+			struct BSS_INFO *prAisBssInfo = NULL;
+
+			prAisBssInfo = aisGetAisBssInfo(prAdapter,
+				secGetBssIdxByWlanIdx(
+					prAdapter,
+					prCurrSwRfb->ucWlanIdx));
+			prWlanHeader = (struct WLAN_MAC_HEADER *)
+				prCurrSwRfb->pvHeader;
+			u2FrameCtrl = prWlanHeader->u2FrameCtrl;
+			prCurrSwRfb->u2SequenceControl =
+				prWlanHeader->u2SeqCtrl;
+#if (CFG_SUPPORT_NAN == 1)
+			if (prCurrSwRfb->prStaRec == NULL)
+				prCurrSwRfb->prStaRec = nanGetStaRecByNDI(
+					prAdapter, prWlanHeader->aucAddr2);
+
+			if (prCurrSwRfb->prStaRec != NULL && fgIsBMC) {
+				struct BSS_INFO *prBssInfo;
+
+				prBssInfo = prAdapter->aprBssInfo[
+					prCurrSwRfb->prStaRec->ucBssIndex];
+				if (prBssInfo->eNetworkType ==
+					NETWORK_TYPE_NAN) {
+					uint16_t u2MACLen = 0;
+
+					DBGLOG(QM, INFO,
+						   "NAN special case for BMC packet\n");
+					if (RXM_IS_QOS_DATA_FRAME(u2FrameCtrl))
+						u2MACLen = sizeof(
+							struct
+							WLAN_MAC_HEADER_QOS);
+					else
+						u2MACLen =
+							sizeof(struct
+							WLAN_MAC_HEADER);
+					u2MACLen +=
+						ETH_LLC_LEN + ETH_SNAP_OUI_LEN;
+					u2MACLen -=
+						ETHER_TYPE_LEN_OFFSET;
+					prCurrSwRfb->pvHeader += u2MACLen;
+					kalMemCopy(prCurrSwRfb->pvHeader,
+					   prWlanHeader->aucAddr1,
+					   MAC_ADDR_LEN);
+					kalMemCopy(prCurrSwRfb->pvHeader +
+					   MAC_ADDR_LEN,
+					   prWlanHeader->aucAddr2,
+					   MAC_ADDR_LEN);
+					prCurrSwRfb->u2PacketLen -= u2MACLen;
+					/* record StaRec related info */
+					prCurrSwRfb->ucStaRecIdx =
+						prCurrSwRfb->prStaRec->ucIndex;
+					prCurrSwRfb->ucWlanIdx =
+						prCurrSwRfb->
+						prStaRec->ucWlanIndex;
+					GLUE_SET_PKT_BSS_IDX(
+						prCurrSwRfb->pvPacket,
+						secGetBssIdxByWlanIdx(
+							prAdapter,
+							prCurrSwRfb->
+							ucWlanIdx));
+				}
+			}
+#endif
+
+			if (prCurrSwRfb->prStaRec == NULL &&
+				RXM_IS_DATA_FRAME(u2FrameCtrl) &&
+				(prAisBssInfo) &&
+				(prAisBssInfo->eConnectionState ==
+				MEDIA_STATE_CONNECTED)) {
+				/* rx header translation */
+				log_dbg(QM, WARN, "RXD Trans: FrameCtrl=0x%02x GVLD=0x%x, StaRecIdx=%d, WlanIdx=%d PktLen=%d\n",
+					u2FrameCtrl, prCurrSwRfb->ucGroupVLD,
+					prCurrSwRfb->ucStaRecIdx,
+					prCurrSwRfb->ucWlanIdx,
+					prCurrSwRfb->u2PacketLen);
+				DBGLOG_MEM8(QM, LOUD,
+						(uint8_t *)
+						prCurrSwRfb->pvHeader,
+						(prCurrSwRfb->
+						u2PacketLen > 32) ? 32 :
+						prCurrSwRfb->
+						u2PacketLen);
+				if (prAisBssInfo
+				    && prAisBssInfo->prStaRecOfAP)
+				if (EQUAL_MAC_ADDR(
+							prWlanHeader->
+							aucAddr1,
+							prAisBssInfo->
+							aucOwnMacAddr)
+				    && EQUAL_MAC_ADDR(
+							prWlanHeader->
+							aucAddr2,
+							prAisBssInfo->
+							aucBSSID)) {
+					uint16_t u2MACLen = 0;
+					/* QoS data, VHT */
+					if (RXM_IS_QOS_DATA_FRAME(
+						u2FrameCtrl))
+						u2MACLen = sizeof(
+						struct WLAN_MAC_HEADER_QOS);
+					else
+						u2MACLen = sizeof(
+							struct
+							WLAN_MAC_HEADER);
+					u2MACLen +=
+						ETH_LLC_LEN +
+						ETH_SNAP_OUI_LEN;
+					u2MACLen -=
+						ETHER_TYPE_LEN_OFFSET;
+					prCurrSwRfb->pvHeader +=
+						u2MACLen;
+					kalMemCopy(
+						prCurrSwRfb->pvHeader,
+						prWlanHeader->aucAddr1,
+						MAC_ADDR_LEN);
+					kalMemCopy(
+						prCurrSwRfb->pvHeader +
+						MAC_ADDR_LEN,
+						prWlanHeader->aucAddr2,
+						MAC_ADDR_LEN);
+					prCurrSwRfb->u2PacketLen -=
+						u2MACLen;
+
+					/* record StaRec related info */
+					prCurrSwRfb->prStaRec =
+						prAisBssInfo->
+						prStaRecOfAP;
+					prCurrSwRfb->ucStaRecIdx =
+						prCurrSwRfb->prStaRec->
+						ucIndex;
+					prCurrSwRfb->ucWlanIdx =
+						prCurrSwRfb->prStaRec->
+						ucWlanIndex;
+					GLUE_SET_PKT_BSS_IDX(
+						prCurrSwRfb->pvPacket,
+						secGetBssIdxByWlanIdx(
+							prAdapter,
+							prCurrSwRfb->
+							ucWlanIdx));
+					DBGLOG_MEM8(QM, WARN,
+						(uint8_t *)
+						prCurrSwRfb->pvHeader,
+						(prCurrSwRfb->
+						u2PacketLen > 64) ? 64 :
+						prCurrSwRfb->
+						u2PacketLen);
+				}
+			}
+		}
+
+#if CFG_SUPPORT_FRAG_AGG_ATTACK_DETECTION
+		if (prCurrSwRfb->fgDataFrame && prCurrSwRfb->prStaRec &&
+			qmAmsduAttackDetection(prAdapter, prCurrSwRfb)) {
+			prCurrSwRfb->eDst = RX_PKT_DESTINATION_NULL;
+			QUEUE_INSERT_TAIL(prReturnedQue,
+				(struct QUE_ENTRY *) prCurrSwRfb);
+			DBGLOG(QM, INFO, "drop AMSDU attack packet\n");
+			continue;
+		}
+
+		if (prCurrSwRfb->fgDataFrame && prCurrSwRfb->prStaRec &&
+			qmDetectRxInvalidEAPOL(prAdapter, prCurrSwRfb)) {
+			prCurrSwRfb->eDst = RX_PKT_DESTINATION_NULL;
+			QUEUE_INSERT_TAIL(prReturnedQue,
+				(struct QUE_ENTRY *) prCurrSwRfb);
+			DBGLOG(QM, INFO,
+				"drop EAPOL packet not in sec mode\n");
+			continue;
+		}
+#endif /* CFG_SUPPORT_FRAG_AGG_ATTACK_DETECTION */
+
+#if CFG_SUPPORT_WAPI
+		if (prCurrSwRfb->u2PacketLen > ETHER_HEADER_LEN) {
+			uint8_t *pc = (uint8_t *) prCurrSwRfb->pvHeader;
+			uint16_t u2Etype = 0;
+
+			u2Etype = (pc[ETHER_TYPE_LEN_OFFSET] << 8) |
+				  (pc[ETHER_TYPE_LEN_OFFSET + 1]);
+			/* for wapi integrity test. WPI_1x packet should be
+			 * always in non-encrypted mode. if we received any
+			 * WPI(0x88b4) packet that is encrypted, drop here.
+			 */
+			if (u2Etype == ETH_WPI_1X &&
+			    prCurrSwRfb->ucSecMode != 0 &&
+			    prCurrSwRfb->fgIsCipherMS == 0) {
+				DBGLOG(QM, INFO,
+					"drop wpi packet with sec mode\n");
+				prCurrSwRfb->eDst = RX_PKT_DESTINATION_NULL;
+				QUEUE_INSERT_TAIL(prReturnedQue,
+					(struct QUE_ENTRY *) prCurrSwRfb);
+				continue;
+			}
+		}
+#endif
+
+		/* Todo:: Move the data class error check here */
+
+#if CFG_SUPPORT_REPLAY_DETECTION
+		if (prCurrSwRfb->prStaRec) {
+			ucBssIndexRly = prCurrSwRfb->prStaRec->ucBssIndex;
+			prBssInfoRly = GET_BSS_INFO_BY_INDEX(prAdapter,
+				ucBssIndexRly);
+			if (prBssInfoRly && !IS_BSS_ACTIVE(prBssInfoRly)) {
+				DBGLOG(QM, INFO,
+					"Mark NULL the Packet for inactive Bss %u\n",
+					ucBssIndexRly);
+				prCurrSwRfb->eDst = RX_PKT_DESTINATION_NULL;
+				QUEUE_INSERT_TAIL(prReturnedQue,
+					(struct QUE_ENTRY *) prCurrSwRfb);
+				continue;
+			}
+		}
+		if (fgIsBMC && prBssInfoRly && IS_BSS_AIS(prBssInfoRly) &&
+			qmHandleRxReplay(prAdapter, prCurrSwRfb)) {
+			prCurrSwRfb->eDst = RX_PKT_DESTINATION_NULL;
+			QUEUE_INSERT_TAIL(prReturnedQue,
+				(struct QUE_ENTRY *) prCurrSwRfb);
+			DBGLOG(RX, TEMP, "BMC replay\n");
+			continue;
+		}
+#endif
+
+		if (prCurrSwRfb->fgReorderBuffer && !fgIsBMC && fgIsHTran) {
+			/* If this packet should dropped or indicated to the
+			 * host immediately, it should be enqueued into the
+			 * rReturnedQue with specific flags. If this packet
+			 * should be buffered for reordering, it should be
+			 * enqueued into the reordering queue in the STA_REC
+			 * rather than into the rReturnedQue.
+			 */
+			if (prCurrSwRfb->ucTid >= CFG_RX_MAX_BA_TID_NUM) {
+				log_dbg(QM, ERROR,
+					"TID from RXD = %d, out of range !!!\n",
+					prCurrSwRfb->ucTid);
+				DBGLOG_MEM8(QM, ERROR,
+					prCurrSwRfb->pucRecvBuff,
+					prCurrSwRfb->u2RxByteCount);
+				QUEUE_INSERT_TAIL(prReturnedQue,
+					(struct QUE_ENTRY *) prCurrSwRfb);
+			} else
+				qmProcessPktWithReordering(prAdapter,
+					prCurrSwRfb, prReturnedQue);
+
+		} else if (prCurrSwRfb->fgDataFrame) {
+			/* Check Class Error */
+			if (prCurrSwRfb->prStaRec &&
+				(secCheckClassError(prAdapter, prCurrSwRfb,
+				prCurrSwRfb->prStaRec) == TRUE)) {
+				struct RX_BA_ENTRY *prReorderQueParm = NULL;
+
+				if ((prCurrSwRfb->ucTid < CFG_RX_MAX_BA_TID_NUM)
+					&& !fgIsBMC && fgIsHTran &&
+					(HAL_RX_STATUS_GET_FRAME_CTL_FIELD(
+					prCurrSwRfb->prRxStatusGroup4) &
+					MASK_FRAME_TYPE) != MAC_FRAME_DATA) {
+					prReorderQueParm =
+						((prCurrSwRfb->prStaRec->
+						aprRxReorderParamRefTbl)[
+						prCurrSwRfb->ucTid]);
+				}
+
+				if (prReorderQueParm &&
+					prReorderQueParm->fgIsValid) {
+					/* Only QoS Data frame with BA aggrement
+					 * shall enter reordering buffer
+					 */
+					qmProcessPktWithReordering(prAdapter,
+						prCurrSwRfb,
+						prReturnedQue);
+				} else
+					qmHandleRxPackets_AOSP_1;
+			} else {
+				DBGLOG(RX, TEMP,
+					"Mark NULL the Packet for class error\n");
+				RX_INC_CNT(&prAdapter->rRxCtrl,
+					RX_CLASS_ERR_DROP_COUNT);
+				prCurrSwRfb->eDst = RX_PKT_DESTINATION_NULL;
+				QUEUE_INSERT_TAIL(prReturnedQue,
+					(struct QUE_ENTRY *) prCurrSwRfb);
+			}
+		} else {
+			struct WLAN_MAC_HEADER *prWlanMacHeader;
+
+			ASSERT(prCurrSwRfb->pvHeader);
+
+			prWlanMacHeader = (struct WLAN_MAC_HEADER *)
+				prCurrSwRfb->pvHeader;
+			prCurrSwRfb->eDst = RX_PKT_DESTINATION_NULL;
+
+			switch (prWlanMacHeader->u2FrameCtrl &
+				MASK_FRAME_TYPE) {
+			/* BAR frame */
+			case MAC_FRAME_BLOCK_ACK_REQ:
+				qmProcessBarFrame(prAdapter,
+					prCurrSwRfb, prReturnedQue);
+				RX_INC_CNT(&prAdapter->rRxCtrl,
+					RX_BAR_DROP_COUNT);
+				break;
+			default:
+				DBGLOG(RX, TEMP,
+					"Mark NULL the Packet for non-interesting type\n");
+				RX_INC_CNT(&prAdapter->rRxCtrl,
+					RX_NO_INTEREST_DROP_COUNT);
+				QUEUE_INSERT_TAIL(prReturnedQue,
+					(struct QUE_ENTRY *) prCurrSwRfb);
+				break;
+			}
+		}
+
+	} while (prNextSwRfb);
+
+	/* The returned list of SW_RFBs must end with a NULL pointer */
+	if (QUEUE_IS_NOT_EMPTY(prReturnedQue))
+		QM_TX_SET_NEXT_MSDU_INFO((struct SW_RFB *) QUEUE_GET_TAIL(
+			prReturnedQue), NULL);
+
+	return (struct SW_RFB *) QUEUE_GET_HEAD(prReturnedQue);
+
+#else
+
+	/* DbgPrint("QM: Enter qmHandleRxPackets()\n"); */
+	return prSwRfbListHead;
+
+#endif
+
+}
+
+#if CFG_SUPPORT_FRAG_AGG_ATTACK_DETECTION
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief qmDetectRxInvalidEAPOL() is used for fake EAPOL checking.
+ *
+ * \param[in] prSwRfb        The RFB which is being processed.
+ *
+ * \return TRUE when we need to drop it
+ */
+/*----------------------------------------------------------------------------*/
+u_int8_t qmDetectRxInvalidEAPOL(IN struct ADAPTER *prAdapter,
+	IN struct SW_RFB *prSwRfb)
+{
+	uint8_t *pucPkt = NULL;
+	uint8_t ucBssIndex;
+	struct BSS_INFO *prBssInfo;
+	uint16_t u2EtherType = 0;
+	u_int8_t fgDrop = FALSE;
+	uint16_t u2SeqCtrl, u2FrameCtrl;
+	uint8_t ucFragNo;
+
+	DEBUGFUNC("qmDetectRxInvalidEAPOL");
+
+	ASSERT(prSwRfb);
+	ASSERT(prSwRfb->prStaRec);
+
+	/* return FALSE if no Header Translation*/
+	if (prSwRfb->fgHdrTran == FALSE)
+		return FALSE;
+
+	if (prSwRfb->u2PacketLen <= ETHER_HEADER_LEN)
+		return FALSE;
+
+	pucPkt = prSwRfb->pvHeader;
+	if (!pucPkt)
+		return FALSE;
+
+	ucBssIndex = prSwRfb->prStaRec->ucBssIndex;
+	prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, ucBssIndex);
+
+	/* return FALSE if OP_MODE is not SAP */
+	if (!IS_BSS_ACTIVE(prBssInfo)
+		|| prBssInfo->eCurrentOPMode != OP_MODE_ACCESS_POINT)
+		return FALSE;
+
+	/* return FALSE for this frame is a mid/last fragment*/
+	u2FrameCtrl = HAL_RX_STATUS_GET_FRAME_CTL_FIELD(
+			prSwRfb->prRxStatusGroup4);
+	u2SeqCtrl = HAL_RX_STATUS_GET_SEQFrag_NUM(prSwRfb->prRxStatusGroup4);
+	ucFragNo = (uint8_t) (u2SeqCtrl & MASK_SC_FRAG_NUM);
+	if (prSwRfb->fgFragFrame && ucFragNo != 0)
+		return FALSE;
+
+	u2EtherType = (pucPkt[ETH_TYPE_LEN_OFFSET] << 8)
+			| (pucPkt[ETH_TYPE_LEN_OFFSET + 1]);
+
+	/* return FALSE if EtherType is not EAPOL */
+	if (u2EtherType != ETH_P_1X)
+		return FALSE;
+
+	if ((prSwRfb->eDst
+			== RX_PKT_DESTINATION_HOST_WITH_FORWARD
+		    || prSwRfb->eDst == RX_PKT_DESTINATION_FORWARD)) {
+		/* fgIsTxKeyReady is set by nicEventAddPkeyDone */
+		if (prSwRfb->prStaRec->fgIsTxKeyReady != TRUE)
+			fgDrop = TRUE;
+	}
+
+	DBGLOG(QM, TRACE,
+		"QM: eDst:%d TxKeyReady:%d fgDrop:%d",
+		prSwRfb->eDst, prSwRfb->prStaRec->fgIsTxKeyReady,
+		fgDrop);
+
+	return fgDrop;
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief AMSDU Attack Detection
+ *
+ * \param[in] prSwRfb The RX packet to process
+ *
+ * \return TRUE when we find an amsdu attack
+ */
+/*----------------------------------------------------------------------------*/
+u_int8_t qmAmsduAttackDetection(IN struct ADAPTER *prAdapter,
+	IN struct SW_RFB *prSwRfb)
+{
+	u_int8_t fgDrop = FALSE;
+	uint8_t aucTaAddr[MAC_ADDR_LEN];
+	uint8_t *pucTaAddr = NULL, *pucRaAddr = NULL;
+	uint8_t *pucSaAddr = NULL, *pucDaAddr = NULL;
+	uint8_t *pucAmsduAddr = NULL, *pucCmpAddr = NULL;
+	uint8_t ucBssIndex = 0;
+	struct BSS_INFO *prBssInfo = NULL;
+	struct STA_RECORD *prStaRec = NULL;
+	uint16_t u2FrameCtrl, u2SSN;
+	struct WLAN_MAC_HEADER *prWlanHeader = NULL;
+	uint8_t ucTid;
+	uint8_t *pucPaylod = NULL;
+
+	DEBUGFUNC("qmAmsduAttackDetection");
+
+	ASSERT(prSwRfb);
+
+	prStaRec = prSwRfb->prStaRec;
+	ASSERT(prStaRec);
+
+	/* 802.11 header TA */
+	if (prSwRfb->fgHdrTran) {
+		u2SSN = HAL_RX_STATUS_GET_SEQFrag_NUM(
+			prSwRfb->prRxStatusGroup4) >> RX_STATUS_SEQ_NUM_OFFSET;
+		u2FrameCtrl = HAL_RX_STATUS_GET_FRAME_CTL_FIELD(
+				prSwRfb->prRxStatusGroup4);
+		HAL_RX_STATUS_GET_TA(prSwRfb->prRxStatusGroup4, aucTaAddr);
+		pucTaAddr = &aucTaAddr[0];
+		pucPaylod = prSwRfb->pvHeader;
+	} else {
+		prWlanHeader = (struct WLAN_MAC_HEADER *) prSwRfb->pvHeader;
+		u2SSN = prWlanHeader->u2SeqCtrl >> MASK_SC_SEQ_NUM_OFFSET;
+		u2FrameCtrl = prWlanHeader->u2FrameCtrl;
+		pucTaAddr = prWlanHeader->aucAddr2;
+		pucPaylod = prSwRfb->pvHeader + prSwRfb->u2HeaderLen;
+	}
+
+	/* 802.11 header RA */
+	ucBssIndex = prSwRfb->prStaRec->ucBssIndex;
+	prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, ucBssIndex);
+	pucRaAddr = &prBssInfo->aucOwnMacAddr[0];
+
+	/* DA and SA */
+	pucDaAddr = pucPaylod;
+	pucSaAddr = pucPaylod + MAC_ADDR_LEN;
+
+	if (RXM_IS_QOS_DATA_FRAME(u2FrameCtrl)) {
+		ucTid = prSwRfb->ucTid;
+	} else {
+		/* for non-qos data, use TID_NUM as tid */
+		ucTid = TID_NUM;
+	}
+
+	if (prSwRfb->ucPayloadFormat == RX_PAYLOAD_FORMAT_MSDU) {
+		return FALSE;
+	} else if (prSwRfb->ucPayloadFormat
+			== RX_PAYLOAD_FORMAT_FIRST_SUB_AMSDU) {
+		if (RXM_IS_FROM_DS(u2FrameCtrl)) {
+			/*
+			 * FromDS frames:
+			 * A-MSDU DA must match 802.11 header RA
+			 */
+			pucCmpAddr = pucDaAddr;
+			pucAmsduAddr = pucRaAddr;
+		} else if (RXM_IS_TO_DS(u2FrameCtrl)) {
+			/*
+			 * ToDS frames:
+			 * A-MSDU SA must match 802.11 header TA
+			 */
+			pucCmpAddr = pucSaAddr;
+			pucAmsduAddr = pucTaAddr;
+		}
+
+		/* mark to drop amsdu with same SeqNo */
+		if (prSwRfb->fgIsFirstSubAMSDULLCMS) {
+			fgDrop = TRUE;
+			DBGLOG(QM, INFO,
+				"QM: AMSDU Attack LLC Mismatch.");
+		} else {
+			if (prSwRfb->fgHdrTran) {
+				if (prSwRfb->u2PacketLen <= ETH_HLEN)
+					fgDrop = TRUE;
+			} else {
+				if (prSwRfb->u2PacketLen
+					<= prSwRfb->u2HeaderLen + ETH_HLEN)
+					fgDrop = TRUE;
+			}
+
+			if (fgDrop == TRUE)
+				DBGLOG(QM, INFO,
+					"QM: AMSDU Attack Unexpected HLen.");
+		}
+
+		if (fgDrop == FALSE &&
+			pucCmpAddr != NULL && pucAmsduAddr != NULL) {
+			if (UNEQUAL_MAC_ADDR(pucCmpAddr, pucAmsduAddr))
+				fgDrop = TRUE;
+
+#define __STR_FMT__ \
+	"QM: FromDS:%d ToDS:%d TID:%u SN:%u PF:%u" \
+	" TA:" MACSTR " RA:" MACSTR " DA:" MACSTR " SA:" MACSTR " Drop:%d"
+			/*DBGLOG(QM, INFO,
+				__STR_FMT__,
+				RXM_IS_FROM_DS(u2FrameCtrl),
+				RXM_IS_TO_DS(u2FrameCtrl),
+				ucTid, prSwRfb->u2SSN,
+				prSwRfb->ucPayloadFormat,
+				MAC2STR(pucTaAddr), MAC2STR(pucRaAddr),
+				MAC2STR(pucDaAddr), MAC2STR(pucSaAddr),
+				fgDrop
+				);*/
+#undef __STR_FMT__
+		}
+
+		prStaRec->afgIsAmsduInvalid[ucTid] = fgDrop;
+		prStaRec->au2AmsduInvalidSN[ucTid] = u2SSN;
+	} else {
+		/* drop it if find an asmdu attack in station record */
+		if (prStaRec->afgIsAmsduInvalid[ucTid] == TRUE
+			&& prStaRec->au2AmsduInvalidSN[ucTid] == u2SSN) {
+			fgDrop = TRUE;
+			DBGLOG(QM, INFO,
+				"QM: AMSDU Attack TID:%u SN:%u PF:%u",
+				ucTid, prSwRfb->u2SSN,
+				prSwRfb->ucPayloadFormat);
+		}
+
+		/* reset flag when find last subframe */
+		if (prSwRfb->ucPayloadFormat
+			== RX_PAYLOAD_FORMAT_LAST_SUB_AMSDU) {
+			prStaRec->afgIsAmsduInvalid[ucTid] = FALSE;
+			prStaRec->au2AmsduInvalidSN[ucTid] = 0XFFFF;
+		}
+	}
+
+	return fgDrop;
+}
+#endif /* CFG_SUPPORT_FRAG_AGG_ATTACK_DETECTION */
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Reorder the received packet
+ *
+ * \param[in] prSwRfb The RX packet to process
+ * \param[out] prReturnedQue The queue for indicating packets
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void qmProcessPktWithReordering(IN struct ADAPTER *prAdapter,
+	IN struct SW_RFB *prSwRfb,
+	OUT struct QUE *prReturnedQue)
+{
+
+	struct STA_RECORD *prStaRec;
+	struct RX_BA_ENTRY *prReorderQueParm;
+
+#if CFG_SUPPORT_RX_AMSDU
+	uint8_t u8AmsduSubframeIdx;
+	uint32_t u4SeqNo;
+#endif
+	DEBUGFUNC("qmProcessPktWithReordering");
+
+	ASSERT(prSwRfb);
+	ASSERT(prReturnedQue);
+
+	/* We should have STA_REC here */
+	prStaRec = prSwRfb->prStaRec;
+	ASSERT(prStaRec);
+	ASSERT(prSwRfb->ucTid < CFG_RX_MAX_BA_TID_NUM);
+
+	if (prSwRfb->ucTid >= CFG_RX_MAX_BA_TID_NUM) {
+		DBGLOG(QM, WARN, "TID from RXD = %d, out of range!!\n",
+			prSwRfb->ucTid);
+		DBGLOG_MEM8(QM, ERROR, prSwRfb->pucRecvBuff,
+			prSwRfb->u2RxByteCount);
+		prSwRfb->eDst = RX_PKT_DESTINATION_NULL;
+		QUEUE_INSERT_TAIL(prReturnedQue,
+			(struct QUE_ENTRY *) prSwRfb);
+		return;
+	}
+
+	/* Check whether the BA agreement exists */
+	prReorderQueParm = ((
+		prStaRec->aprRxReorderParamRefTbl)[prSwRfb->ucTid]);
+	if (!prReorderQueParm || !(prReorderQueParm->fgIsValid)) {
+		DBGLOG(RX, TEMP,
+			"Reordering but no BA agreement for STA[%d] TID[%d]\n",
+			prStaRec->ucIndex, prSwRfb->ucTid);
+		QUEUE_INSERT_TAIL(prReturnedQue,
+			(struct QUE_ENTRY *) prSwRfb);
+		return;
+	}
+
+	RX_INC_CNT(&prAdapter->rRxCtrl,
+		RX_DATA_REORDER_TOTAL_COUNT);
+
+	prSwRfb->u2SSN = HAL_RX_STATUS_GET_SEQFrag_NUM(
+		prSwRfb->prRxStatusGroup4) >> RX_STATUS_SEQ_NUM_OFFSET;
+
+#if CFG_SUPPORT_RX_AMSDU
+	/* RX reorder for one MSDU in AMSDU issue */
+	/* QUEUE_INITIALIZE(&prSwRfb->rAmsduQue); */
+
+	u8AmsduSubframeIdx = prSwRfb->ucPayloadFormat;
+
+	/* prMpduSwRfb = prReorderQueParm->prMpduSwRfb; */
+	u4SeqNo = (uint32_t)prSwRfb->u2SSN;
+
+	switch (u8AmsduSubframeIdx) {
+	case RX_PAYLOAD_FORMAT_FIRST_SUB_AMSDU:
+		if (prReorderQueParm->fgAmsduNeedLastFrame) {
+			RX_INC_CNT(&prAdapter->rRxCtrl,
+				RX_DATA_AMSDU_MISS_COUNT);
+			prReorderQueParm->fgAmsduNeedLastFrame = FALSE;
+		}
+		RX_INC_CNT(&prAdapter->rRxCtrl,
+			   RX_DATA_MSDU_IN_AMSDU_COUNT);
+		RX_INC_CNT(&prAdapter->rRxCtrl, RX_DATA_AMSDU_COUNT);
+		break;
+
+	case RX_PAYLOAD_FORMAT_MIDDLE_SUB_AMSDU:
+		prReorderQueParm->fgAmsduNeedLastFrame = TRUE;
+		RX_INC_CNT(&prAdapter->rRxCtrl,
+			   RX_DATA_MSDU_IN_AMSDU_COUNT);
+		if (prReorderQueParm->u4SeqNo != u4SeqNo) {
+			RX_INC_CNT(&prAdapter->rRxCtrl,
+				RX_DATA_AMSDU_MISS_COUNT);
+			RX_INC_CNT(&prAdapter->rRxCtrl,
+				RX_DATA_AMSDU_COUNT);
+		}
+		break;
+	case RX_PAYLOAD_FORMAT_LAST_SUB_AMSDU:
+		prReorderQueParm->fgAmsduNeedLastFrame = FALSE;
+		RX_INC_CNT(&prAdapter->rRxCtrl,
+			   RX_DATA_MSDU_IN_AMSDU_COUNT);
+		if (prReorderQueParm->u4SeqNo != u4SeqNo) {
+			RX_INC_CNT(&prAdapter->rRxCtrl,
+				RX_DATA_AMSDU_MISS_COUNT);
+			RX_INC_CNT(&prAdapter->rRxCtrl,
+				RX_DATA_AMSDU_COUNT);
+		}
+		break;
+
+	case RX_PAYLOAD_FORMAT_MSDU:
+		if (prReorderQueParm->fgAmsduNeedLastFrame) {
+			RX_INC_CNT(&prAdapter->rRxCtrl,
+				RX_DATA_AMSDU_MISS_COUNT);
+			prReorderQueParm->fgAmsduNeedLastFrame = FALSE;
+		}
+		break;
+	default:
+		break;
+	}
+
+	prReorderQueParm->u4SeqNo = u4SeqNo;
+#endif
+
+	RX_DIRECT_REORDER_LOCK(prAdapter, 0);
+	/* Insert reorder packet */
+	qmInsertReorderPkt(prAdapter, prSwRfb, prReorderQueParm,
+		prReturnedQue);
+	RX_DIRECT_REORDER_UNLOCK(prAdapter, 0);
+}
+
+void qmProcessBarFrame(IN struct ADAPTER *prAdapter,
+	IN struct SW_RFB *prSwRfb, OUT struct QUE *prReturnedQue)
+{
+	struct CTRL_BAR_FRAME *prBarCtrlFrame;
+
+	ASSERT(prSwRfb);
+	ASSERT(prReturnedQue);
+	ASSERT(prSwRfb->pvHeader);
+
+	prBarCtrlFrame = (struct CTRL_BAR_FRAME *) prSwRfb->pvHeader;
+
+	prSwRfb->ucTid =
+		(*((uint16_t *) ((uint8_t *) prBarCtrlFrame +
+		CTRL_BAR_BAR_CONTROL_OFFSET))) >>
+		BAR_CONTROL_TID_INFO_OFFSET;
+	prSwRfb->u2SSN =
+		(*((uint16_t *) ((uint8_t *) prBarCtrlFrame +
+		CTRL_BAR_BAR_INFORMATION_OFFSET))) >>
+		OFFSET_BAR_SSC_SN;
+
+	prSwRfb->eDst = RX_PKT_DESTINATION_NULL;
+	QUEUE_INSERT_TAIL(prReturnedQue, (struct QUE_ENTRY *) prSwRfb);
+
+	/* Incorrect STA_REC index */
+	prSwRfb->ucStaRecIdx = secLookupStaRecIndexFromTA(prAdapter,
+		prBarCtrlFrame->aucSrcAddr);
+	if (prSwRfb->ucStaRecIdx >= CFG_STA_REC_NUM) {
+		DBGLOG(QM, WARN,
+			"QM: (Warning) BAR for a NULL STA_REC, ucStaRecIdx = %d\n",
+			prSwRfb->ucStaRecIdx);
+		/* ASSERT(0); */
+		return;
+	}
+
+	qmHandleRxReorderWinShift(prAdapter, prSwRfb->ucStaRecIdx,
+		prSwRfb->ucTid, prSwRfb->u2SSN, prReturnedQue);
+}
+
+/**
+ * To avoid printing every fall behind drop msdu overwhelming the output buffer,
+ * log only start and end SN by checking whether there is gap between current
+ * dropping SN and the last dropped SN.
+ */
+static void qmLogDropFallBehind(IN struct ADAPTER *prAdapter,
+		IN struct RX_BA_ENTRY *prReorderQueParm,
+		uint8_t ucTid, uint32_t u4BarSSN,
+		uint32_t u4SeqNo, uint32_t u4WinStart, uint32_t u4WinEnd)
+{
+	uint16_t u2LastDrop = prReorderQueParm->u2LastFallBehindDropSN;
+	uint16_t u2DropGap = (u4SeqNo - u2LastDrop) & MAX_SEQ_NO;
+	uint64_t u8Count;
+
+	prReorderQueParm->u2LastFallBehindDropSN = u4SeqNo;
+
+	if (u2DropGap <= 1)
+		return;
+
+	u8Count = RX_GET_CNT(&prAdapter->rRxCtrl, RX_REORDER_BEHIND_DROP_COUNT);
+	if (IS_BAR_SSN_VALID(prReorderQueParm->u2BarSSN))
+		DBGLOG(RX, INFO,
+		       "QM:(D)[%u](~%u)(%u~){%u,%u} BAR SSN:%u/%u total:%lu",
+		       ucTid, u2LastDrop, u4SeqNo, u4WinStart, u4WinEnd, 1,
+		       u4BarSSN, u8Count);
+	else
+		DBGLOG(RX, TRACE,
+		       "QM:(D)[%u](~%u)(%u~){%u,%u} BAR SSN:%u/%u total:%lu",
+		       ucTid, u2LastDrop, u4SeqNo, u4WinStart, u4WinEnd, 0,
+		       u4BarSSN, u8Count);
+}
+
+void qmInsertReorderPkt(IN struct ADAPTER *prAdapter,
+	IN struct SW_RFB *prSwRfb,
+	IN struct RX_BA_ENTRY *prReorderQueParm,
+	OUT struct QUE *prReturnedQue)
+{
+	uint32_t u4SeqNo;
+	uint32_t u4WinStart;
+	uint32_t u4WinEnd;
+	uint32_t u4BarSSN;
+
+	/* Start to reorder packets */
+	u4SeqNo = (uint32_t) (prSwRfb->u2SSN);
+	u4WinStart = (uint32_t) (prReorderQueParm->u2WinStart);
+	u4WinEnd = (uint32_t) (prReorderQueParm->u2WinEnd);
+	u4BarSSN = (uint32_t) (prReorderQueParm->u2BarSSN) & MAX_SEQ_NO;
+
+	/* Debug */
+	DBGLOG(RX, TEMP, "QM:ipid=%d(R)[%u](%u){%u,%u}\n",
+		GLUE_GET_PKT_IP_ID(prSwRfb->pvPacket), prSwRfb->ucTid,
+		u4SeqNo, u4WinStart, u4WinEnd);
+
+	if (prReorderQueParm->fgNoDrop) {
+		if (!qmCompareSnIsLessThan(u4SeqNo,
+			prReorderQueParm->u2WinStart)) {
+			/* Fall behind SSN pkts started to Fall within
+			 * StartWin
+			 */
+			prReorderQueParm->u4SNOverlapCount++;
+			if (prReorderQueParm->u4SNOverlapCount > 10) {
+				/*  Set threshold as 10 to make sure
+				 *  the SSN is really falling within StartWin
+				 */
+				prReorderQueParm->u4SNOverlapCount = 0;
+				prReorderQueParm->fgNoDrop = FALSE;
+				DBGLOG(QM, INFO, "NO drop = FALSE, [%d][%d]\n",
+					u4SeqNo, prReorderQueParm->u2WinStart);
+			}
+		}
+	}
+	/* Case 1: Fall within */
+	if			/* 0 - start - sn - end - 4095 */
+	(((u4WinStart <= u4SeqNo) && (u4SeqNo <= u4WinEnd))
+	    /* 0 - end - start - sn - 4095 */
+	    || ((u4WinEnd < u4WinStart) && (u4WinStart <= u4SeqNo))
+	    /* 0 - sn - end - start - 4095 */
+	    || ((u4SeqNo <= u4WinEnd) && (u4WinEnd < u4WinStart))) {
+		DBGLOG(RX, TEMP, "RxPkt=%p seq=%d fall within\n",
+			prSwRfb, u4SeqNo);
+
+#if CFG_SUPPORT_RX_OOR_BAR
+		if (IS_BAR_SSN_VALID(prReorderQueParm->u2BarSSN) &&
+		    (u4SeqNo == u4BarSSN || SEQ_SMALLER(u4BarSSN, u4SeqNo))) {
+			prReorderQueParm->u2BarSSN = 0;
+			prReorderQueParm->u2LastRcvdSN = 0;
+			DBGLOG(RX, INFO,
+				"Clear BAR SSN, SN %d >= u4BarSSN %d received\n",
+				u4SeqNo, u4BarSSN);
+		}
+		prReorderQueParm->u2LastRcvdSN = u4SeqNo;
+#endif /* CFG_SUPPORT_RX_OOR_BAR */
+
+		qmInsertFallWithinReorderPkt(prAdapter, prSwRfb,
+					     prReorderQueParm, prReturnedQue);
+
+#if QM_RX_WIN_SSN_AUTO_ADVANCING
+		if (prReorderQueParm->fgIsWaitingForPktWithSsn) {
+			/* Let the first received packet
+			 * pass the reorder check
+			 */
+			DBGLOG(RX, TEMP, "QM:(A)[%d](%u){%u,%u}\n",
+				prSwRfb->ucTid, u4SeqNo, u4WinStart, u4WinEnd);
+
+			prReorderQueParm->u2WinStart = (uint16_t) u4SeqNo;
+			prReorderQueParm->u2WinEnd =
+				((prReorderQueParm->u2WinStart) +
+				 (prReorderQueParm->u2WinSize) - 1) %
+				 MAX_SEQ_NO_COUNT;
+			prReorderQueParm->fgIsWaitingForPktWithSsn = FALSE;
+#if CFG_SUPPORT_RX_AMSDU
+			/* RX reorder for one MSDU in AMSDU issue */
+			prReorderQueParm->u8LastAmsduSubIdx =
+				RX_PAYLOAD_FORMAT_MSDU;
+#endif
+		}
+#endif
+
+		qmPopOutDueToFallWithin(prAdapter, prReorderQueParm,
+			prReturnedQue);
+	}
+	/* Case 2: Fall ahead */
+	else if
+	/* 0 - start - end - sn - (start+2048) - 4095 */
+	(((u4WinStart < u4WinEnd) && (u4WinEnd < u4SeqNo) &&
+		(u4SeqNo < (u4WinStart + HALF_SEQ_NO_COUNT)))
+		/* 0 - sn - (start+2048) - start - end - 4095 */
+	  || ((u4SeqNo < u4WinStart) && (u4WinStart < u4WinEnd) &&
+			((u4SeqNo + MAX_SEQ_NO_COUNT) <
+			(u4WinStart + HALF_SEQ_NO_COUNT)))
+			/* 0 - end - sn - (start+2048) - start - 4095 */
+			|| ((u4WinEnd < u4SeqNo) && (u4SeqNo < u4WinStart) &&
+			((u4SeqNo + MAX_SEQ_NO_COUNT) < (u4WinStart +
+			HALF_SEQ_NO_COUNT)))) {
+
+		uint16_t u2Delta, u2BeforeWinEnd;
+		uint32_t u4BeforeCount, u4MissingCount;
+
+		DBGLOG(RX, TEMP, "RxPkt=%p seq=%d fall ahead\n",
+			prSwRfb, u4SeqNo);
+
+#if QM_RX_WIN_SSN_AUTO_ADVANCING
+		if (prReorderQueParm->fgIsWaitingForPktWithSsn)
+			prReorderQueParm->fgIsWaitingForPktWithSsn = FALSE;
+#endif
+
+		qmInsertFallAheadReorderPkt(prAdapter, prSwRfb,
+			prReorderQueParm, prReturnedQue);
+
+		u2BeforeWinEnd = prReorderQueParm->u2WinEnd;
+
+		/* Advance the window after inserting a new tail */
+		prReorderQueParm->u2WinEnd = (uint16_t) u4SeqNo;
+		prReorderQueParm->u2WinStart =
+			(((prReorderQueParm->u2WinEnd) + MAX_SEQ_NO_COUNT -
+			prReorderQueParm->u2WinSize + 1) %
+			MAX_SEQ_NO_COUNT);
+#if CFG_SUPPORT_RX_AMSDU
+		/* RX reorder for one MSDU in AMSDU issue */
+		prReorderQueParm->u8LastAmsduSubIdx =
+			RX_PAYLOAD_FORMAT_MSDU;
+#endif
+		u4BeforeCount = prReorderQueParm->rReOrderQue.u4NumElem;
+		qmPopOutDueToFallAhead(prAdapter, prReorderQueParm,
+			prReturnedQue);
+
+		if (prReorderQueParm->u2WinEnd >= u2BeforeWinEnd)
+			u2Delta = prReorderQueParm->u2WinEnd - u2BeforeWinEnd;
+		else
+			u2Delta = MAX_SEQ_NO_COUNT - (u2BeforeWinEnd -
+				prReorderQueParm->u2WinEnd);
+
+		u4MissingCount = u2Delta - (u4BeforeCount -
+			prReorderQueParm->rReOrderQue.u4NumElem);
+
+		RX_ADD_CNT(&prAdapter->rRxCtrl, RX_DATA_REORDER_MISS_COUNT,
+			u4MissingCount);
+		/* If the SSN jump over 1024,
+		  *  we consider it as an abnormal jump and
+		  *  temporally reserve the fall behind packets until
+		  *  the pkt SSN is really falling within StartWin
+		  */
+		if (u2Delta > QUARTER_SEQ_NO_COUNT) {
+			prReorderQueParm->fgNoDrop = TRUE;
+			prReorderQueParm->u4SNOverlapCount = 0;
+			DBGLOG_LIMITED(QM, INFO,
+				"QM: SSN jump over 1024:[%d]\n", u2Delta);
+		}
+		DBGLOG(RX, TEMP, "QM: Miss Count:[%lu]\n",
+			RX_GET_CNT(&prAdapter->rRxCtrl,
+			RX_DATA_REORDER_MISS_COUNT));
+	}
+	/* Case 3: Fall behind */
+	else {
+#if CFG_SUPPORT_RX_OOR_BAR
+		if (IS_BAR_SSN_VALID(prReorderQueParm->u2BarSSN) &&
+		    SEQ_SMALLER(u4SeqNo, u4BarSSN) &&
+		    (u4SeqNo == prReorderQueParm->u2LastRcvdSN || /* AMSDU */
+		     SEQ_SMALLER(prReorderQueParm->u2LastRcvdSN, u4SeqNo))) {
+			qmPopOutReorderPkt(prAdapter, prSwRfb,
+				prReturnedQue, RX_DATA_REORDER_BEHIND_COUNT);
+			DBGLOG(RX, TRACE,
+				"QM: Data after BAR:[%d](%d){%d,%d} total:%lu",
+				prSwRfb->ucTid, u4SeqNo, u4WinStart, u4WinEnd,
+				RX_GET_CNT(&prAdapter->rRxCtrl,
+				RX_DATA_REORDER_BEHIND_COUNT));
+			return;
+		}
+#endif /* CFG_SUPPORT_RX_OOR_BAR */
+
+#if CFG_SUPPORT_LOWLATENCY_MODE || CFG_SUPPORT_OSHARE
+		if (qmIsNoDropPacket(prAdapter, prSwRfb) ||
+			prReorderQueParm->fgNoDrop) {
+			qmPopOutReorderPkt(prAdapter, prSwRfb,
+				prReturnedQue, RX_DATA_REORDER_BEHIND_COUNT);
+			DBGLOG(RX, TEMP,
+				"QM: No drop packet:[%d](%d){%d,%d} total:%lu\n",
+				prSwRfb->ucTid, u4SeqNo, u4WinStart, u4WinEnd,
+				RX_GET_CNT(&prAdapter->rRxCtrl,
+					RX_DATA_REORDER_BEHIND_COUNT));
+			return;
+		}
+#endif /* CFG_SUPPORT_LOWLATENCY_MODE */
+
+#if QM_RX_WIN_SSN_AUTO_ADVANCING && QM_RX_INIT_FALL_BEHIND_PASS
+		if (prReorderQueParm->fgIsWaitingForPktWithSsn) {
+			qmPopOutReorderPkt(prAdapter, prSwRfb, prReturnedQue,
+				RX_DATA_REORDER_BEHIND_COUNT);
+			DBGLOG(RX, TEMP, "QM:(P)[%u](%u){%u,%u} total:%lu\n",
+				prSwRfb->ucTid, u4SeqNo, u4WinStart, u4WinEnd,
+				RX_GET_CNT(&prAdapter->rRxCtrl,
+					RX_DATA_REORDER_BEHIND_COUNT));
+			return;
+		}
+#endif
+
+		/* An erroneous packet */
+		prSwRfb->eDst = RX_PKT_DESTINATION_NULL;
+		qmPopOutReorderPkt(prAdapter, prSwRfb, prReturnedQue,
+			RX_REORDER_BEHIND_DROP_COUNT);
+
+		qmLogDropFallBehind(prAdapter, prReorderQueParm,
+		       prSwRfb->ucTid, u4BarSSN, u4SeqNo, u4WinStart, u4WinEnd);
+		return;
+	}
+}
+
+void qmInsertFallWithinReorderPkt(IN struct ADAPTER *prAdapter,
+	IN struct SW_RFB *prSwRfb,
+	IN struct RX_BA_ENTRY *prReorderQueParm,
+	OUT struct QUE *prReturnedQue)
+{
+	struct SW_RFB *prExaminedQueuedSwRfb;
+	struct QUE *prReorderQue;
+	uint8_t u8AmsduSubframeIdx; /* RX reorder for one MSDU in AMSDU issue */
+
+	ASSERT(prSwRfb);
+	ASSERT(prReorderQueParm);
+	ASSERT(prReturnedQue);
+
+	prReorderQue = &(prReorderQueParm->rReOrderQue);
+	prExaminedQueuedSwRfb = (struct SW_RFB *) QUEUE_GET_HEAD(
+		prReorderQue);
+
+	u8AmsduSubframeIdx = prSwRfb->ucPayloadFormat;
+
+	/* There are no packets queued in the Reorder Queue */
+	if (prExaminedQueuedSwRfb == NULL) {
+		((struct QUE_ENTRY *) prSwRfb)->prPrev = NULL;
+		((struct QUE_ENTRY *) prSwRfb)->prNext = NULL;
+		prReorderQue->prHead = (struct QUE_ENTRY *) prSwRfb;
+		prReorderQue->prTail = (struct QUE_ENTRY *) prSwRfb;
+		prReorderQue->u4NumElem++;
+	}
+
+	/* Determine the insert position */
+	else {
+		do {
+			/* Case 1: Terminate. A duplicate packet */
+			if ((prExaminedQueuedSwRfb->u2SSN) ==
+				(prSwRfb->u2SSN)) {
+#if CFG_SUPPORT_RX_AMSDU
+				/* RX reorder for one MSDU in AMSDU issue */
+				/* if middle or last and first is not
+				 * duplicated, not a duplicat packet
+				 */
+				if (!prReorderQueParm->fgIsAmsduDuplicated &&
+					(u8AmsduSubframeIdx ==
+					RX_PAYLOAD_FORMAT_MIDDLE_SUB_AMSDU ||
+					u8AmsduSubframeIdx ==
+					RX_PAYLOAD_FORMAT_LAST_SUB_AMSDU)) {
+
+					prExaminedQueuedSwRfb =
+						(struct SW_RFB *)((
+						(struct QUE_ENTRY *)
+						prExaminedQueuedSwRfb)->prNext);
+					while (prExaminedQueuedSwRfb &&
+						((prExaminedQueuedSwRfb->
+						u2SSN) == (prSwRfb->u2SSN)))
+						prExaminedQueuedSwRfb =
+							(struct SW_RFB *)((
+							(struct QUE_ENTRY *)
+							prExaminedQueuedSwRfb)->
+							prNext);
+
+					break;
+				}
+				/* if first is duplicated,
+				 * drop subsequent middle and last frames
+				 */
+				if (u8AmsduSubframeIdx ==
+					RX_PAYLOAD_FORMAT_FIRST_SUB_AMSDU)
+					prReorderQueParm->fgIsAmsduDuplicated =
+						TRUE;
+#endif
+				prSwRfb->eDst = RX_PKT_DESTINATION_NULL;
+				qmPopOutReorderPkt(prAdapter,
+					prSwRfb, prReturnedQue,
+					RX_DUPICATE_DROP_COUNT);
+				DBGLOG(RX, TEMP,
+					"seq=%d dup drop total:%lu\n",
+					prSwRfb->u2SSN,
+					RX_GET_CNT(&prAdapter->rRxCtrl,
+						RX_DUPICATE_DROP_COUNT));
+				LINK_QUALITY_COUNT_DUP(prAdapter, prSwRfb);
+				return;
+			}
+
+			/* Case 2: Terminate. The insert point is found */
+			else if (qmCompareSnIsLessThan((prSwRfb->u2SSN),
+				(prExaminedQueuedSwRfb->u2SSN)))
+				break;
+
+			/* Case 3: Insert point not found.
+			 * Check the next SW_RFB in the Reorder Queue
+			 */
+			else
+				prExaminedQueuedSwRfb =
+					(struct SW_RFB *) (((struct QUE_ENTRY *)
+						prExaminedQueuedSwRfb)->prNext);
+		} while (prExaminedQueuedSwRfb);
+#if CFG_SUPPORT_RX_AMSDU
+		prReorderQueParm->fgIsAmsduDuplicated = FALSE;
+#endif
+		/* Update the Reorder Queue Parameters according to
+		 * the found insert position
+		 */
+		if (prExaminedQueuedSwRfb == NULL) {
+			/* The received packet shall be placed at the tail */
+			((struct QUE_ENTRY *) prSwRfb)->prPrev =
+				prReorderQue->prTail;
+			((struct QUE_ENTRY *) prSwRfb)->prNext = NULL;
+			(prReorderQue->prTail)->prNext =
+				(struct QUE_ENTRY *) (prSwRfb);
+			prReorderQue->prTail = (struct QUE_ENTRY *) (prSwRfb);
+		} else {
+			((struct QUE_ENTRY *) prSwRfb)->prPrev =
+				((struct QUE_ENTRY *)
+				prExaminedQueuedSwRfb)->prPrev;
+			((struct QUE_ENTRY *) prSwRfb)->prNext =
+				(struct QUE_ENTRY *) prExaminedQueuedSwRfb;
+			if (((struct QUE_ENTRY *) prExaminedQueuedSwRfb) ==
+			    (prReorderQue->prHead)) {
+				/* The received packet will become the head */
+				prReorderQue->prHead =
+					(struct QUE_ENTRY *) prSwRfb;
+			} else {
+				(((struct QUE_ENTRY *)
+				prExaminedQueuedSwRfb)->prPrev)->prNext =
+					(struct QUE_ENTRY *) prSwRfb;
+			}
+			((struct QUE_ENTRY *) prExaminedQueuedSwRfb)->prPrev =
+				(struct QUE_ENTRY *) prSwRfb;
+		}
+
+		prReorderQue->u4NumElem++;
+	}
+
+}
+
+void qmInsertFallAheadReorderPkt(IN struct ADAPTER *prAdapter,
+	IN struct SW_RFB *prSwRfb,
+	IN struct RX_BA_ENTRY *prReorderQueParm,
+	OUT struct QUE *prReturnedQue)
+{
+	struct QUE *prReorderQue;
+
+	ASSERT(prSwRfb);
+	ASSERT(prReorderQueParm);
+	ASSERT(prReturnedQue);
+#if CFG_SUPPORT_RX_AMSDU
+	/* RX reorder for one MSDU in AMSDU issue */
+	prReorderQueParm->fgIsAmsduDuplicated = FALSE;
+#endif
+	prReorderQue = &(prReorderQueParm->rReOrderQue);
+	/* There are no packets queued in the Reorder Queue */
+	if (QUEUE_IS_EMPTY(prReorderQue)) {
+		((struct QUE_ENTRY *) prSwRfb)->prPrev = NULL;
+		((struct QUE_ENTRY *) prSwRfb)->prNext = NULL;
+		prReorderQue->prHead = (struct QUE_ENTRY *) prSwRfb;
+	} else {
+		((struct QUE_ENTRY *) prSwRfb)->prPrev =
+			prReorderQue->prTail;
+		((struct QUE_ENTRY *) prSwRfb)->prNext = NULL;
+		(prReorderQue->prTail)->prNext = (struct QUE_ENTRY *) (
+			prSwRfb);
+	}
+	prReorderQue->prTail = (struct QUE_ENTRY *) prSwRfb;
+	prReorderQue->u4NumElem++;
+}
+
+void qmPopOutReorderPkt(IN struct ADAPTER *prAdapter,
+	IN struct SW_RFB *prSwRfb, OUT struct QUE *prReturnedQue,
+	IN enum ENUM_RX_STATISTIC_COUNTER eRxCounter)
+{
+	uint32_t u4PktCnt = 0;
+	/* RX reorder for one MSDU in AMSDU issue */
+#if 0
+	struct SW_RFB *prAmsduSwRfb;
+#endif
+
+	u4PktCnt++;
+	QUEUE_INSERT_TAIL(prReturnedQue,
+		(struct QUE_ENTRY *)prSwRfb);
+
+#if 0
+	u4PktCnt += prSwRfb->rAmsduQue.u4NumElem;
+	QUEUE_REMOVE_HEAD(&prSwRfb->rAmsduQue, prAmsduSwRfb,
+		struct SW_RFB *);
+	while (prAmsduSwRfb) {
+		/* Update MSDU destination of AMSDU */
+		prAmsduSwRfb->eDst = prSwRfb->eDst;
+		QUEUE_INSERT_TAIL(prReturnedQue,
+			(struct QUE_ENTRY *)prAmsduSwRfb);
+		QUEUE_REMOVE_HEAD(&prSwRfb->rAmsduQue, prAmsduSwRfb,
+			struct SW_RFB *);
+	}
+#endif
+	RX_ADD_CNT(&prAdapter->rRxCtrl, eRxCounter, u4PktCnt);
+}
+
+void qmPopOutDueToFallWithin(IN struct ADAPTER *prAdapter,
+	IN struct RX_BA_ENTRY *prReorderQueParm,
+	OUT struct QUE *prReturnedQue)
+{
+	struct SW_RFB *prReorderedSwRfb;
+	struct QUE *prReorderQue;
+	u_int8_t fgDequeuHead, fgMissing;
+	OS_SYSTIME rCurrentTime, *prMissTimeout;
+	/* RX reorder for one MSDU in AMSDU issue */
+	uint8_t fgIsAmsduSubframe;
+
+	prReorderQue = &(prReorderQueParm->rReOrderQue);
+
+	fgMissing = FALSE;
+	rCurrentTime = 0;
+	prMissTimeout =
+		&g_arMissTimeout[prReorderQueParm->ucStaRecIdx][
+		prReorderQueParm->ucTid];
+	if (*prMissTimeout) {
+		fgMissing = TRUE;
+		GET_CURRENT_SYSTIME(&rCurrentTime);
+	}
+
+	/* Check whether any packet can be indicated to the higher layer */
+	while (TRUE) {
+		if (QUEUE_IS_EMPTY(prReorderQue))
+			break;
+
+		/* Always examine the head packet */
+		prReorderedSwRfb = (struct SW_RFB *) QUEUE_GET_HEAD(
+			prReorderQue);
+		fgDequeuHead = FALSE;
+
+		/* RX reorder for one MSDU in AMSDU issue */
+		fgIsAmsduSubframe = prReorderedSwRfb->ucPayloadFormat;
+#if CFG_SUPPORT_RX_AMSDU
+		/* If SN + 1 come and last frame is first or middle,
+		 * update winstart
+		 */
+		if ((qmCompareSnIsLessThan((prReorderQueParm->u2WinStart),
+			(prReorderedSwRfb->u2SSN)))
+			&& (prReorderQueParm->u4SeqNo !=
+			prReorderQueParm->u2WinStart)) {
+			if (prReorderQueParm->u8LastAmsduSubIdx ==
+				RX_PAYLOAD_FORMAT_FIRST_SUB_AMSDU
+				|| prReorderQueParm->u8LastAmsduSubIdx ==
+				RX_PAYLOAD_FORMAT_MIDDLE_SUB_AMSDU) {
+
+				prReorderQueParm->u2WinStart =
+					(((prReorderQueParm->u2WinStart) + 1) %
+					MAX_SEQ_NO_COUNT);
+				prReorderQueParm->u8LastAmsduSubIdx =
+					RX_PAYLOAD_FORMAT_MSDU;
+			}
+		}
+#endif
+		/* SN == WinStart, so the head packet
+		 * shall be indicated (advance the window)
+		 */
+		if ((prReorderedSwRfb->u2SSN) ==
+			(prReorderQueParm->u2WinStart)) {
+
+			fgDequeuHead = TRUE;
+			/* RX reorder for one MSDU in AMSDU issue */
+			/* if last frame, winstart++.
+			 * Otherwise, keep winstart
+			 */
+			if (fgIsAmsduSubframe ==
+				RX_PAYLOAD_FORMAT_LAST_SUB_AMSDU
+				|| fgIsAmsduSubframe == RX_PAYLOAD_FORMAT_MSDU)
+				prReorderQueParm->u2WinStart =
+				(((prReorderedSwRfb->u2SSN) + 1) %
+				MAX_SEQ_NO_COUNT);
+#if CFG_SUPPORT_RX_AMSDU
+			prReorderQueParm->u8LastAmsduSubIdx = fgIsAmsduSubframe;
+#endif
+		}
+		/* SN > WinStart, break to update WinEnd */
+		else {
+			/* Start bubble timer */
+			if (!prReorderQueParm->fgHasBubble) {
+				cnmTimerStartTimer(prAdapter,
+				&(prReorderQueParm->rReorderBubbleTimer),
+					prAdapter->u4QmRxBaMissTimeout);
+				prReorderQueParm->fgHasBubble = TRUE;
+				prReorderQueParm->u2FirstBubbleSn =
+					prReorderQueParm->u2WinStart;
+
+				DBGLOG(RX, TEMP,
+					"QM:(Bub Timer) STA[%u] TID[%u] BubSN[%u] Win{%d, %d}\n",
+					prReorderQueParm->ucStaRecIdx,
+					prReorderedSwRfb->ucTid,
+					prReorderQueParm->u2FirstBubbleSn,
+					prReorderQueParm->u2WinStart,
+					prReorderQueParm->u2WinEnd);
+			}
+
+			if (fgMissing &&
+				CHECK_FOR_TIMEOUT(rCurrentTime, *prMissTimeout,
+				MSEC_TO_SYSTIME(
+				prAdapter->u4QmRxBaMissTimeout
+				))) {
+
+				DBGLOG(RX, TEMP,
+					"QM:RX BA Timout Next Tid %d SSN %d\n",
+					prReorderQueParm->ucTid,
+					prReorderedSwRfb->u2SSN);
+				fgDequeuHead = TRUE;
+				prReorderQueParm->u2WinStart =
+					(((prReorderedSwRfb->u2SSN) + 1) %
+					MAX_SEQ_NO_COUNT);
+#if CFG_SUPPORT_RX_AMSDU
+				/* RX reorder for one MSDU in AMSDU issue */
+				prReorderQueParm->u8LastAmsduSubIdx =
+					RX_PAYLOAD_FORMAT_MSDU;
+#endif
+				fgMissing = FALSE;
+			} else
+				break;
+		}
+
+		/* Dequeue the head packet */
+		if (fgDequeuHead) {
+			if (((struct QUE_ENTRY *) prReorderedSwRfb)->prNext ==
+				NULL) {
+				prReorderQue->prHead = NULL;
+				prReorderQue->prTail = NULL;
+			} else {
+				prReorderQue->prHead =
+					((struct QUE_ENTRY *)
+					prReorderedSwRfb)->prNext;
+				(((struct QUE_ENTRY *)
+					prReorderedSwRfb)->prNext)->prPrev =
+					NULL;
+			}
+			prReorderQue->u4NumElem--;
+			qmPopOutReorderPkt(prAdapter, prReorderedSwRfb,
+				prReturnedQue, RX_DATA_REORDER_WITHIN_COUNT);
+			DBGLOG(RX, TEMP, "QM: [%d] %d (%d) within total:%lu\n",
+				prReorderQueParm->ucTid,
+				prReorderedSwRfb->u2PacketLen,
+				prReorderedSwRfb->u2SSN,
+				RX_GET_CNT(&prAdapter->rRxCtrl,
+					RX_DATA_REORDER_WITHIN_COUNT));
+		}
+	}
+
+	if (QUEUE_IS_EMPTY(prReorderQue))
+		*prMissTimeout = 0;
+	else {
+		if (fgMissing == FALSE)
+			GET_CURRENT_SYSTIME(prMissTimeout);
+	}
+
+	/* After WinStart has been determined, update the WinEnd */
+	prReorderQueParm->u2WinEnd =
+		(((prReorderQueParm->u2WinStart) +
+		(prReorderQueParm->u2WinSize) - 1) % MAX_SEQ_NO_COUNT);
+
+}
+
+void qmPopOutDueToFallAhead(IN struct ADAPTER *prAdapter,
+	IN struct RX_BA_ENTRY *prReorderQueParm,
+	OUT struct QUE *prReturnedQue)
+{
+	struct SW_RFB *prReorderedSwRfb;
+	struct QUE *prReorderQue;
+	u_int8_t fgDequeuHead;
+	uint8_t fgIsAmsduSubframe;/* RX reorder for one MSDU in AMSDU issue */
+
+	prReorderQue = &(prReorderQueParm->rReOrderQue);
+
+	/* Check whether any packet can be indicated to the higher layer */
+	while (TRUE) {
+		if (QUEUE_IS_EMPTY(prReorderQue))
+			break;
+
+		/* Always examine the head packet */
+		prReorderedSwRfb =
+			(struct SW_RFB *) QUEUE_GET_HEAD(prReorderQue);
+		fgDequeuHead = FALSE;
+
+		/* RX reorder for one MSDU in AMSDU issue */
+		fgIsAmsduSubframe = prReorderedSwRfb->ucPayloadFormat;
+#if CFG_SUPPORT_RX_AMSDU
+		/* If SN + 1 come and last frame is first or middle,
+		 * update winstart
+		 */
+		if ((qmCompareSnIsLessThan((prReorderQueParm->u2WinStart),
+			(prReorderedSwRfb->u2SSN)))
+			&& (prReorderQueParm->u4SeqNo !=
+			prReorderQueParm->u2WinStart)) {
+			if (prReorderQueParm->u8LastAmsduSubIdx ==
+				RX_PAYLOAD_FORMAT_FIRST_SUB_AMSDU
+				|| prReorderQueParm->u8LastAmsduSubIdx ==
+				RX_PAYLOAD_FORMAT_MIDDLE_SUB_AMSDU) {
+
+				prReorderQueParm->u2WinStart =
+					(((prReorderQueParm->u2WinStart) + 1) %
+					MAX_SEQ_NO_COUNT);
+				prReorderQueParm->u8LastAmsduSubIdx =
+					RX_PAYLOAD_FORMAT_MSDU;
+			}
+		}
+#endif
+		/* SN == WinStart, so the head packet shall be
+		 * indicated (advance the window)
+		 */
+		if ((prReorderedSwRfb->u2SSN) ==
+			(prReorderQueParm->u2WinStart)) {
+
+			fgDequeuHead = TRUE;
+			/* RX reorder for one MSDU in AMSDU issue */
+			/* if last frame, winstart++.
+			 * Otherwise, keep winstart
+			 */
+			if (fgIsAmsduSubframe ==
+				RX_PAYLOAD_FORMAT_LAST_SUB_AMSDU ||
+				fgIsAmsduSubframe == RX_PAYLOAD_FORMAT_MSDU)
+				prReorderQueParm->u2WinStart =
+				(((prReorderedSwRfb->u2SSN) + 1) %
+				MAX_SEQ_NO_COUNT);
+#if CFG_SUPPORT_RX_AMSDU
+			prReorderQueParm->u8LastAmsduSubIdx = fgIsAmsduSubframe;
+#endif
+		}
+
+		/* SN < WinStart, so the head packet shall be
+		 * indicated (do not advance the window)
+		 */
+		else if (qmCompareSnIsLessThan((uint32_t)(
+			prReorderedSwRfb->u2SSN),
+			(uint32_t)(prReorderQueParm->u2WinStart)))
+			fgDequeuHead = TRUE;
+
+		/* SN > WinStart, break to update WinEnd */
+		else {
+			/* Start bubble timer */
+			if (!prReorderQueParm->fgHasBubble) {
+				cnmTimerStartTimer(prAdapter,
+					&(prReorderQueParm->
+					rReorderBubbleTimer),
+					prAdapter->u4QmRxBaMissTimeout);
+				prReorderQueParm->fgHasBubble = TRUE;
+				prReorderQueParm->u2FirstBubbleSn =
+					prReorderQueParm->u2WinStart;
+
+				DBGLOG(RX, TEMP,
+					"QM:(Bub Timer) STA[%u] TID[%u] BubSN[%u] Win{%d, %d}\n",
+					prReorderQueParm->ucStaRecIdx,
+					prReorderedSwRfb->ucTid,
+					prReorderQueParm->u2FirstBubbleSn,
+					prReorderQueParm->u2WinStart,
+					prReorderQueParm->u2WinEnd);
+			}
+			break;
+		}
+
+		/* Dequeue the head packet */
+		if (fgDequeuHead) {
+			if (((struct QUE_ENTRY *) prReorderedSwRfb)->prNext ==
+				NULL) {
+				prReorderQue->prHead = NULL;
+				prReorderQue->prTail = NULL;
+			} else {
+				prReorderQue->prHead = ((struct QUE_ENTRY *)
+				prReorderedSwRfb)->prNext;
+				(((struct QUE_ENTRY *) prReorderedSwRfb)->
+				prNext)->prPrev = NULL;
+			}
+			prReorderQue->u4NumElem--;
+			qmPopOutReorderPkt(prAdapter, prReorderedSwRfb,
+				prReturnedQue, RX_DATA_REORDER_AHEAD_COUNT);
+			DBGLOG(RX, TEMP, "QM: [%u] %u (%u) ahead total:%lu\n",
+				prReorderQueParm->ucTid,
+				prReorderedSwRfb->u2PacketLen,
+				prReorderedSwRfb->u2SSN,
+				RX_GET_CNT(&prAdapter->rRxCtrl,
+					RX_DATA_REORDER_WITHIN_COUNT));
+		}
+	}
+
+	/* After WinStart has been determined, update the WinEnd */
+	prReorderQueParm->u2WinEnd =
+		(((prReorderQueParm->u2WinStart) +
+		(prReorderQueParm->u2WinSize) - 1) % MAX_SEQ_NO_COUNT);
+
+}
+
+void qmHandleReorderBubbleTimeout(IN struct ADAPTER *prAdapter,
+	IN unsigned long ulParamPtr)
+{
+	struct RX_BA_ENTRY *prReorderQueParm =
+		(struct RX_BA_ENTRY *) ulParamPtr;
+
+	ASSERT(prAdapter);
+
+	if (!prReorderQueParm->fgIsValid) {
+		DBGLOG(QM, TRACE,
+			"QM:(Bub Check Cancel) STA[%u] TID[%u], No Rx BA entry\n",
+			prReorderQueParm->ucStaRecIdx, prReorderQueParm->ucTid);
+		return;
+	}
+
+	if (!prReorderQueParm->fgHasBubble) {
+		DBGLOG(QM, TRACE,
+			"QM:(Bub Check Cancel) STA[%u] TID[%u], Bubble has been filled\n",
+			prReorderQueParm->ucStaRecIdx, prReorderQueParm->ucTid);
+		return;
+	}
+
+	DBGLOG(QM, TRACE,
+		"QM:(Bub Timeout) STA[%u] TID[%u] BubSN[%u]\n",
+		prReorderQueParm->ucStaRecIdx, prReorderQueParm->ucTid,
+		prReorderQueParm->u2FirstBubbleSn);
+
+	qmHandleEventCheckReorderBubble(prAdapter, prReorderQueParm);
+}
+
+void qmHandleEventCheckReorderBubble(IN struct ADAPTER *prAdapter,
+				     struct RX_BA_ENTRY *prReorderQueParm)
+{
+	struct QUE *prReorderQue;
+	struct QUE rReturnedQue;
+	struct QUE *prReturnedQue = &rReturnedQue;
+	struct SW_RFB *prReorderedSwRfb, *prSwRfb;
+	OS_SYSTIME *prMissTimeout;
+
+	QUEUE_INITIALIZE(prReturnedQue);
+
+	/* Sanity Check */
+	if (!prReorderQueParm) {
+		DBGLOG(QM, TRACE, "QM:(Bub Check Cancel) No Rx BA entry\n");
+		return;
+	}
+
+	if (!prReorderQueParm->fgIsValid) {
+		DBGLOG(QM, TRACE,
+			"QM:(Bub Check Cancel) STA[%u] TID[%u], No Rx BA entry\n",
+			prReorderQueParm->ucStaRecIdx, prReorderQueParm->ucTid);
+		return;
+	}
+
+	if (!prReorderQueParm->fgHasBubble) {
+		DBGLOG(QM, TRACE,
+			"QM:(Bub Check Cancel) STA[%u] TID[%u], Bubble has been filled\n",
+			prReorderQueParm->ucStaRecIdx, prReorderQueParm->ucTid);
+		return;
+	}
+
+	prReorderQue = &(prReorderQueParm->rReOrderQue);
+
+	RX_DIRECT_REORDER_LOCK(prAdapter, 0);
+
+	if (QUEUE_IS_EMPTY(prReorderQue)) {
+		prReorderQueParm->fgHasBubble = FALSE;
+
+		DBGLOG(QM, TRACE,
+			"QM:(Bub Check Cancel) STA[%u] TID[%u], Bubble has been filled\n",
+			prReorderQueParm->ucStaRecIdx, prReorderQueParm->ucTid);
+
+		RX_DIRECT_REORDER_UNLOCK(prAdapter, 0);
+		return;
+	}
+
+	DBGLOG(QM, TRACE,
+		"QM:(Bub Check Event Got) STA[%u] TID[%u]\n",
+		prReorderQueParm->ucStaRecIdx, prReorderQueParm->ucTid);
+
+	/* Expected bubble timeout => pop out packets before win_end */
+	if (prReorderQueParm->u2FirstBubbleSn ==
+		prReorderQueParm->u2WinStart) {
+
+		prReorderedSwRfb = (struct SW_RFB *) QUEUE_GET_TAIL(
+			prReorderQue);
+
+		prReorderQueParm->u2WinStart = prReorderedSwRfb->u2SSN + 1;
+		if (prReorderQueParm->u2WinStart >= MAX_SEQ_NO_COUNT)
+			prReorderQueParm->u2WinStart %= MAX_SEQ_NO_COUNT;
+		prReorderQueParm->u2WinEnd =
+			((prReorderQueParm->u2WinStart) +
+			(prReorderQueParm->u2WinSize) - 1) % MAX_SEQ_NO_COUNT;
+#if CFG_SUPPORT_RX_AMSDU
+		prReorderQueParm->u8LastAmsduSubIdx =
+			RX_PAYLOAD_FORMAT_MSDU;
+#endif
+		qmPopOutDueToFallAhead(prAdapter, prReorderQueParm,
+			prReturnedQue);
+
+		DBGLOG(QM, TRACE,
+			"QM:(Bub Flush) STA[%u] TID[%u] BubSN[%u] Win{%u, %u}\n",
+			prReorderQueParm->ucStaRecIdx,
+			prReorderQueParm->ucTid,
+			prReorderQueParm->u2FirstBubbleSn,
+			prReorderQueParm->u2WinStart,
+			prReorderQueParm->u2WinEnd);
+
+		prReorderQueParm->fgHasBubble = FALSE;
+		RX_DIRECT_REORDER_UNLOCK(prAdapter, 0);
+
+		/* process prReturnedQue after unlock prReturnedQue */
+		if (QUEUE_IS_NOT_EMPTY(prReturnedQue)) {
+			QM_TX_SET_NEXT_MSDU_INFO(
+				(struct SW_RFB *) QUEUE_GET_TAIL(
+				prReturnedQue), NULL);
+
+			prSwRfb = (struct SW_RFB *)
+				QUEUE_GET_HEAD(prReturnedQue);
+			while (prSwRfb) {
+				DBGLOG(QM, TRACE,
+					"QM:(Bub Flush) STA[%u] TID[%u] Pop Out SN[%u]\n",
+				  prReorderQueParm->ucStaRecIdx,
+				  prReorderQueParm->ucTid,
+				  prSwRfb->u2SSN);
+
+				prSwRfb = (struct SW_RFB *)
+					QUEUE_GET_NEXT_ENTRY(
+					(struct QUE_ENTRY *) prSwRfb);
+			}
+
+			wlanProcessQueuedSwRfb(prAdapter,
+				(struct SW_RFB *)
+				QUEUE_GET_HEAD(prReturnedQue));
+		} else {
+			DBGLOG(QM, TRACE,
+				"QM:(Bub Flush) STA[%u] TID[%u] Pop Out 0 packet\n",
+				prReorderQueParm->ucStaRecIdx,
+				prReorderQueParm->ucTid);
+		}
+	}
+	/* First bubble has been filled but others exist */
+	else {
+		prReorderQueParm->u2FirstBubbleSn =
+			prReorderQueParm->u2WinStart;
+
+		DBGLOG(QM, TRACE,
+			"QM:(Bub Timer) STA[%u] TID[%u] BubSN[%u] Win{%u, %u}\n",
+			prReorderQueParm->ucStaRecIdx,
+			prReorderQueParm->ucTid,
+			prReorderQueParm->u2FirstBubbleSn,
+			prReorderQueParm->u2WinStart,
+			prReorderQueParm->u2WinEnd);
+		RX_DIRECT_REORDER_UNLOCK(prAdapter, 0);
+
+		cnmTimerStartTimer(prAdapter,
+			&(prReorderQueParm->rReorderBubbleTimer),
+			prAdapter->u4QmRxBaMissTimeout);
+	}
+
+	prMissTimeout = &g_arMissTimeout[
+		prReorderQueParm->ucStaRecIdx][prReorderQueParm->ucTid];
+	if (QUEUE_IS_EMPTY(prReorderQue)) {
+		DBGLOG(QM, TRACE,
+			"QM:(Bub Check) Reset prMissTimeout to zero\n");
+		*prMissTimeout = 0;
+	} else {
+		DBGLOG(QM, TRACE,
+			"QM:(Bub Check) Reset prMissTimeout to current time\n");
+		GET_CURRENT_SYSTIME(prMissTimeout);
+	}
+}
+
+u_int8_t qmCompareSnIsLessThan(IN uint32_t u4SnLess, IN uint32_t u4SnGreater)
+{
+	/* 0 <--->  SnLess   <--(gap>2048)--> SnGreater : SnLess > SnGreater */
+	if ((u4SnLess + HALF_SEQ_NO_COUNT) <= u4SnGreater)
+		return FALSE;
+
+	/* 0 <---> SnGreater <--(gap>2048)--> SnLess    : SnLess < SnGreater */
+	else if ((u4SnGreater + HALF_SEQ_NO_COUNT) < u4SnLess)
+		return TRUE;
+
+	/* 0 <---> SnGreater <--(gap<2048)--> SnLess    : SnLess > SnGreater */
+	/* 0 <--->  SnLess   <--(gap<2048)--> SnGreater : SnLess < SnGreater */
+	else
+		return u4SnLess < u4SnGreater;
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Handle Mailbox RX messages
+ *
+ * \param[in] prMailboxRxMsg The received Mailbox message from the FW
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void qmHandleMailboxRxMessage(IN struct MAILBOX_MSG prMailboxRxMsg)
+{
+	/* DbgPrint("QM: Enter qmHandleMailboxRxMessage()\n"); */
+	/* TODO */
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Handle ADD TX BA Event from the FW
+ *
+ * \param[in] prAdapter Adapter pointer
+ * \param[in] prEvent The event packet from the FW
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void qmHandleEventTxAddBa(IN struct ADAPTER *prAdapter,
+	IN struct WIFI_EVENT *prEvent)
+{
+	struct mt66xx_chip_info *prChipInfo;
+	struct EVENT_TX_ADDBA *prEventTxAddBa;
+	struct STA_RECORD *prStaRec;
+	uint8_t ucStaRecIdx;
+	uint8_t ucTid;
+
+	ASSERT(prAdapter);
+	prChipInfo = prAdapter->chip_info;
+
+	DBGLOG(QM, INFO, "QM:Event +TxBa\n");
+
+	if (!prChipInfo->is_support_hw_amsdu &&
+	    prChipInfo->ucMaxSwAmsduNum <= 1) {
+		DBGLOG(QM, INFO, "QM:Event +TxBa but chip is not support\n");
+		return;
+	}
+
+	prEventTxAddBa = (struct EVENT_TX_ADDBA *) (prEvent->aucBuffer);
+	ucStaRecIdx = prEventTxAddBa->ucStaRecIdx;
+	prStaRec = QM_GET_STA_REC_PTR_FROM_INDEX(prAdapter, ucStaRecIdx);
+	if (!prStaRec) {
+		/* Invalid STA_REC index, discard the event packet */
+		/* ASSERT(0); */
+		DBGLOG(QM, INFO,
+		       "QM: (Warning) TX ADDBA Event for a NULL STA_REC\n");
+		return;
+	}
+
+	for (ucTid = 0; ucTid < TX_DESC_TID_NUM; ucTid++) {
+		uint8_t ucStaEn = prStaRec->ucAmsduEnBitmap & BIT(ucTid);
+		uint8_t ucEvtEn = prEventTxAddBa->ucAmsduEnBitmap & BIT(ucTid);
+
+		if (prChipInfo->is_support_hw_amsdu && ucStaEn != ucEvtEn)
+			nicTxSetHwAmsduDescTemplate(prAdapter, prStaRec, ucTid,
+						    ucEvtEn >> ucTid);
+	}
+
+	prStaRec->ucAmsduEnBitmap = prEventTxAddBa->ucAmsduEnBitmap;
+	prStaRec->ucMaxMpduCount = prEventTxAddBa->ucMaxMpduCount;
+	prStaRec->u4MaxMpduLen = prEventTxAddBa->u4MaxMpduLen;
+	prStaRec->u4MinMpduLen = prEventTxAddBa->u4MinMpduLen;
+
+#if CFG_MTK_MDDP_SUPPORT
+	if (mddpIsSupportMcifWifi())
+		mddpNotifyDrvTxd(prAdapter, prStaRec, TRUE);
+#endif
+
+	DBGLOG(QM, INFO,
+	       "QM:Event +TxBa bitmap[0x%x] count[%u] MaxLen[%u] MinLen[%u]\n",
+	       prStaRec->ucAmsduEnBitmap, prStaRec->ucMaxMpduCount,
+	       prStaRec->u4MaxMpduLen, prStaRec->u4MinMpduLen);
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Handle ADD RX BA Event from the FW
+ *
+ * \param[in] prAdapter Adapter pointer
+ * \param[in] prEvent The event packet from the FW
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void qmHandleEventRxAddBa(IN struct ADAPTER *prAdapter,
+	IN struct WIFI_EVENT *prEvent)
+{
+	struct EVENT_RX_ADDBA *prEventRxAddBa;
+	struct STA_RECORD *prStaRec;
+	uint32_t u4Tid;
+	uint32_t u4WinSize;
+
+	DBGLOG(QM, INFO, "QM:Event +RxBa\n");
+
+	prEventRxAddBa = (struct EVENT_RX_ADDBA *) (
+				 prEvent->aucBuffer);
+	prStaRec = QM_GET_STA_REC_PTR_FROM_INDEX(prAdapter,
+			prEventRxAddBa->ucStaRecIdx);
+
+	if (!prStaRec) {
+		/* Invalid STA_REC index, discard the event packet */
+		/* ASSERT(0); */
+		DBGLOG(QM, INFO,
+			"QM: (Warning) RX ADDBA Event for a NULL STA_REC\n");
+		return;
+	}
+#if 0
+	if (!(prStaRec->fgIsValid)) {
+		/* TODO: (Tehuang) Handle the Host-FW synchronization issue */
+		DBGLOG(QM, WARN,
+			"QM: (Warning) RX ADDBA Event for an invalid STA_REC\n");
+		/* ASSERT(0); */
+		/* return; */
+	}
+#endif
+
+	u4Tid = (((prEventRxAddBa->u2BAParameterSet) &
+		BA_PARAM_SET_TID_MASK) >>
+		BA_PARAM_SET_TID_MASK_OFFSET);
+
+	u4WinSize = (((prEventRxAddBa->u2BAParameterSet) &
+		BA_PARAM_SET_BUFFER_SIZE_MASK) >>
+		BA_PARAM_SET_BUFFER_SIZE_MASK_OFFSET);
+
+	if (!qmAddRxBaEntry(prAdapter,
+		prStaRec->ucIndex,
+		(uint8_t) u4Tid,
+		(prEventRxAddBa->u2BAStartSeqCtrl >>
+		OFFSET_BAR_SSC_SN),
+		(uint16_t) u4WinSize)) {
+
+		/* FW shall ensure the availabiilty of
+		 * the free-to-use BA entry
+		 */
+		DBGLOG(QM, ERROR, "QM: (Error) qmAddRxBaEntry() failure\n");
+	}
+
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Handle DEL RX BA Event from the FW
+ *
+ * \param[in] prAdapter Adapter pointer
+ * \param[in] prEvent The event packet from the FW
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void qmHandleEventRxDelBa(IN struct ADAPTER *prAdapter,
+	IN struct WIFI_EVENT *prEvent)
+{
+	struct EVENT_RX_DELBA *prEventRxDelBa;
+	struct STA_RECORD *prStaRec;
+
+	/* DbgPrint("QM:Event -RxBa\n"); */
+
+	prEventRxDelBa = (struct EVENT_RX_DELBA *) (
+		prEvent->aucBuffer);
+	prStaRec = QM_GET_STA_REC_PTR_FROM_INDEX(prAdapter,
+		prEventRxDelBa->ucStaRecIdx);
+
+	if (!prStaRec)
+		/* Invalid STA_REC index, discard the event packet */
+		/* ASSERT(0); */
+		return;
+#if 0
+	if (!(prStaRec->fgIsValid))
+		/* TODO: (Tehuang) Handle the Host-FW synchronization issue */
+		/* ASSERT(0); */
+		return;
+#endif
+
+	qmDelRxBaEntry(prAdapter, prStaRec->ucIndex,
+		prEventRxDelBa->ucTid, TRUE);
+
+}
+
+struct RX_BA_ENTRY *qmLookupRxBaEntry(IN struct ADAPTER *prAdapter,
+	uint8_t ucStaRecIdx, uint8_t ucTid)
+{
+	int i;
+	struct QUE_MGT *prQM = &prAdapter->rQM;
+
+	/* DbgPrint("QM: Enter qmLookupRxBaEntry()\n"); */
+
+	for (i = 0; i < CFG_NUM_OF_RX_BA_AGREEMENTS; i++) {
+		if (prQM->arRxBaTable[i].fgIsValid) {
+			if ((prQM->arRxBaTable[i].ucStaRecIdx == ucStaRecIdx)
+				&& (prQM->arRxBaTable[i].ucTid == ucTid))
+				return &prQM->arRxBaTable[i];
+		}
+	}
+	return NULL;
+}
+
+u_int8_t qmAddRxBaEntry(IN struct ADAPTER *prAdapter,
+	IN uint8_t ucStaRecIdx, IN uint8_t ucTid,
+	IN uint16_t u2WinStart, IN uint16_t u2WinSize)
+{
+	int i;
+	struct RX_BA_ENTRY *prRxBaEntry = NULL;
+	struct STA_RECORD *prStaRec;
+	struct QUE_MGT *prQM = &prAdapter->rQM;
+
+	ASSERT(ucStaRecIdx < CFG_STA_REC_NUM);
+
+	if (ucStaRecIdx >= CFG_STA_REC_NUM || ucTid >= CFG_RX_MAX_BA_TID_NUM) {
+		/* Invalid STA_REC index, discard the event packet */
+		DBGLOG(QM, WARN,
+			"QM: (WARNING) RX ADDBA Event for a invalid ucStaRecIdx = %d, ucTID=%d\n",
+			ucStaRecIdx, ucTid);
+		return FALSE;
+	}
+
+	prStaRec = &prAdapter->arStaRec[ucStaRecIdx];
+	ASSERT(prStaRec);
+
+	/* 4 <1> Delete before adding */
+	/* Remove the BA entry for the same (STA, TID) tuple if it exists */
+	/* prQM->ucRxBaCount-- */
+	if (qmLookupRxBaEntry(prAdapter, ucStaRecIdx, ucTid))
+		qmDelRxBaEntry(prAdapter, ucStaRecIdx, ucTid, TRUE);
+	/* 4 <2> Add a new BA entry */
+	/* No available entry to store the BA agreement info. Retrun FALSE. */
+	if (prQM->ucRxBaCount >= CFG_NUM_OF_RX_BA_AGREEMENTS) {
+		DBGLOG(QM, ERROR,
+			"QM: **failure** (limited resource, ucRxBaCount=%d)\n",
+			prQM->ucRxBaCount);
+		return FALSE;
+	}
+	/* Find the free-to-use BA entry */
+	for (i = 0; i < CFG_NUM_OF_RX_BA_AGREEMENTS; i++) {
+		if (!prQM->arRxBaTable[i].fgIsValid) {
+			prRxBaEntry = &(prQM->arRxBaTable[i]);
+			prQM->ucRxBaCount++;
+			DBGLOG(QM, LOUD,
+				"QM: ucRxBaCount=%d\n", prQM->ucRxBaCount);
+			break;
+		}
+	}
+
+	/* If a free-to-use entry is found,
+	 * configure it and associate it with the STA_REC
+	 */
+	u2WinSize += CFG_RX_BA_INC_SIZE;
+	if (prRxBaEntry) {
+		prRxBaEntry->ucStaRecIdx = ucStaRecIdx;
+		prRxBaEntry->ucTid = ucTid;
+		prRxBaEntry->u2WinStart = u2WinStart;
+		prRxBaEntry->u2WinSize = u2WinSize;
+		prRxBaEntry->u2WinEnd = ((u2WinStart + u2WinSize - 1) %
+			MAX_SEQ_NO_COUNT);
+#if CFG_SUPPORT_RX_AMSDU
+		/* RX reorder for one MSDU in AMSDU issue */
+		prRxBaEntry->u8LastAmsduSubIdx = RX_PAYLOAD_FORMAT_MSDU;
+		prRxBaEntry->fgAmsduNeedLastFrame = FALSE;
+		prRxBaEntry->fgIsAmsduDuplicated = FALSE;
+#endif
+		prRxBaEntry->fgIsValid = TRUE;
+		prRxBaEntry->fgIsWaitingForPktWithSsn = TRUE;
+		prRxBaEntry->fgHasBubble = FALSE;
+
+		g_arMissTimeout[ucStaRecIdx][ucTid] = 0;
+
+		DBGLOG(QM, INFO,
+			"QM: +RxBA(STA=%u TID=%u WinStart=%u WinEnd=%u WinSize=%u)\n",
+			ucStaRecIdx, ucTid, prRxBaEntry->u2WinStart,
+			prRxBaEntry->u2WinEnd,
+			prRxBaEntry->u2WinSize);
+
+		/* Update the BA entry reference table for per-packet lookup */
+		prStaRec->aprRxReorderParamRefTbl[ucTid] = prRxBaEntry;
+	} else {
+		/* This shall not happen because
+		 * FW should keep track of the usage of RX BA entries
+		 */
+		DBGLOG(QM, ERROR, "QM: **AddBA Error** (ucRxBaCount=%d)\n",
+			prQM->ucRxBaCount);
+		return FALSE;
+	}
+
+
+	return TRUE;
+}
+
+void qmDelRxBaEntry(IN struct ADAPTER *prAdapter,
+	IN uint8_t ucStaRecIdx, IN uint8_t ucTid,
+	IN u_int8_t fgFlushToHost)
+{
+	struct RX_BA_ENTRY *prRxBaEntry = NULL;
+	struct STA_RECORD *prStaRec;
+	struct SW_RFB *prFlushedPacketList = NULL;
+	struct QUE_MGT *prQM = &prAdapter->rQM;
+
+	ASSERT(ucStaRecIdx < CFG_STA_REC_NUM);
+
+	prStaRec = &prAdapter->arStaRec[ucStaRecIdx];
+	ASSERT(prStaRec);
+
+#if 0
+	if (!(prStaRec->fgIsValid)) {
+		DbgPrint("QM: (WARNING) Invalid STA when deleting an RX BA\n");
+		return;
+	}
+#endif
+
+	/* Remove the BA entry for the same (STA, TID) tuple if it exists */
+	if (ucTid < CFG_RX_MAX_BA_TID_NUM) {
+		prRxBaEntry = prStaRec->aprRxReorderParamRefTbl[ucTid];
+	}
+
+	if (prRxBaEntry) {
+
+		prFlushedPacketList = qmFlushStaRxQueue(prAdapter,
+			ucStaRecIdx, ucTid);
+
+		if (prFlushedPacketList) {
+
+			if (fgFlushToHost) {
+				wlanProcessQueuedSwRfb(prAdapter,
+					prFlushedPacketList);
+			} else {
+
+				struct SW_RFB *prSwRfb;
+				struct SW_RFB *prNextSwRfb;
+
+				prSwRfb = prFlushedPacketList;
+
+				do {
+					prNextSwRfb = (struct SW_RFB *)
+						QUEUE_GET_NEXT_ENTRY(
+						(struct QUE_ENTRY *) prSwRfb);
+					nicRxReturnRFB(prAdapter, prSwRfb);
+					prSwRfb = prNextSwRfb;
+				} while (prSwRfb);
+
+			}
+
+		}
+
+		if (prRxBaEntry->fgHasBubble) {
+			DBGLOG(QM, TRACE,
+				"QM:(Bub Check Cancel) STA[%u] TID[%u], DELBA\n",
+			  prRxBaEntry->ucStaRecIdx, prRxBaEntry->ucTid);
+
+			cnmTimerStopTimer(prAdapter,
+				&prRxBaEntry->rReorderBubbleTimer);
+			prRxBaEntry->fgHasBubble = FALSE;
+		}
+#if ((QM_TEST_MODE == 0) && (QM_TEST_STA_REC_DEACTIVATION == 0))
+		/* Update RX BA entry state.
+		 * Note that RX queue flush is not done here
+		 */
+		prRxBaEntry->fgIsValid = FALSE;
+		prQM->ucRxBaCount--;
+
+		/* Debug */
+#if 0
+		DbgPrint("QM: ucRxBaCount=%d\n", prQM->ucRxBaCount);
+#endif
+
+		/* Update STA RX BA table */
+		prStaRec->aprRxReorderParamRefTbl[ucTid] = NULL;
+#endif
+
+		DBGLOG(QM, INFO, "QM: -RxBA(STA=%d,TID=%d)\n",
+			ucStaRecIdx, ucTid);
+
+	}
+
+	/* Debug */
+#if CFG_HIF_RX_STARVATION_WARNING
+	{
+		struct RX_CTRL *prRxCtrl;
+
+		prRxCtrl = &prAdapter->rRxCtrl;
+		DBGLOG(QM, TRACE,
+			"QM: (RX DEBUG) Enqueued: %d / Dequeued: %d\n",
+			prRxCtrl->u4QueuedCnt, prRxCtrl->u4DequeuedCnt);
+	}
+#endif
+}
+
+u_int8_t qmIsIndependentPkt(IN struct SW_RFB *prSwRfb)
+{
+	struct sk_buff *skb = NULL;
+
+	if (prSwRfb->u2PacketLen <= ETHER_HEADER_LEN)
+		return FALSE;
+
+	skb = (struct sk_buff *)(prSwRfb->pvPacket);
+	if (!skb)
+		return FALSE;
+
+	if (GLUE_GET_INDEPENDENT_PKT(skb))
+		return TRUE;
+
+	return FALSE;
+}
+
+void mqmParseAssocReqWmmIe(IN struct ADAPTER *prAdapter,
+	IN uint8_t *pucIE, IN struct STA_RECORD *prStaRec)
+{
+	struct IE_WMM_INFO *prIeWmmInfo;
+	uint8_t ucQosInfo;
+	uint8_t ucQosInfoAC;
+	uint8_t ucBmpAC;
+	uint8_t aucWfaOui[] = VENDOR_OUI_WFA;
+
+	if ((WMM_IE_OUI_TYPE(pucIE) == VENDOR_OUI_TYPE_WMM)
+		&& (!kalMemCmp(WMM_IE_OUI(pucIE), aucWfaOui, 3))) {
+
+		switch (WMM_IE_OUI_SUBTYPE(pucIE)) {
+		case VENDOR_OUI_SUBTYPE_WMM_INFO:
+			if (IE_LEN(pucIE) != 7)
+				break;	/* WMM Info IE with a wrong length */
+
+			prStaRec->fgIsQoS = TRUE;
+			prStaRec->fgIsWmmSupported = TRUE;
+
+			prIeWmmInfo = (struct IE_WMM_INFO *) pucIE;
+			ucQosInfo = prIeWmmInfo->ucQosInfo;
+			ucQosInfoAC = ucQosInfo & BITS(0, 3);
+
+			if (IS_FEATURE_ENABLED(prAdapter->rWifiVar.ucUapsd))
+				prStaRec->fgIsUapsdSupported =
+					(ucQosInfoAC) ? TRUE : FALSE;
+			else
+				prStaRec->fgIsUapsdSupported = FALSE;
+
+			ucBmpAC = 0;
+
+			if (ucQosInfoAC & WMM_QOS_INFO_VO_UAPSD)
+				ucBmpAC |= BIT(ACI_VO);
+
+			if (ucQosInfoAC & WMM_QOS_INFO_VI_UAPSD)
+				ucBmpAC |= BIT(ACI_VI);
+
+			if (ucQosInfoAC & WMM_QOS_INFO_BE_UAPSD)
+				ucBmpAC |= BIT(ACI_BE);
+
+			if (ucQosInfoAC & WMM_QOS_INFO_BK_UAPSD)
+				ucBmpAC |= BIT(ACI_BK);
+			prStaRec->ucBmpTriggerAC = prStaRec->ucBmpDeliveryAC =
+				ucBmpAC;
+			prStaRec->ucUapsdSp = (ucQosInfo &
+				WMM_QOS_INFO_MAX_SP_LEN_MASK) >> 5;
+			break;
+
+		default:
+			/* Other WMM QoS IEs. Ignore any */
+			break;
+		}
+	}
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief To process WMM related IEs in ASSOC_RSP
+ *
+ * \param[in] prAdapter Adapter pointer
+ * \param[in] prSwRfb            The received frame
+ * \param[in] pucIE              The pointer to the first IE in the frame
+ * \param[in] u2IELength         The total length of IEs in the frame
+ *
+ * \return none
+ */
+/*----------------------------------------------------------------------------*/
+void mqmProcessAssocReq(IN struct ADAPTER *prAdapter,
+	IN struct SW_RFB *prSwRfb, IN uint8_t *pucIE,
+	IN uint16_t u2IELength)
+{
+	struct STA_RECORD *prStaRec;
+	uint16_t u2Offset;
+	uint8_t *pucIEStart;
+	uint32_t u4Flags;
+
+	DEBUGFUNC("mqmProcessAssocReq");
+
+	ASSERT(prSwRfb);
+	ASSERT(pucIE);
+
+	prStaRec = cnmGetStaRecByIndex(prAdapter, prSwRfb->ucStaRecIdx);
+	ASSERT(prStaRec);
+
+	if (prStaRec == NULL)
+		return;
+
+	prStaRec->fgIsQoS = FALSE;
+	prStaRec->fgIsWmmSupported = prStaRec->fgIsUapsdSupported = FALSE;
+
+	pucIEStart = pucIE;
+
+	/* If the device does not support QoS or if
+	 * WMM is not supported by the peer, exit.
+	 */
+	if (IS_FEATURE_DISABLED(prAdapter->rWifiVar.ucQoS))
+		return;
+
+	/* Determine whether QoS is enabled with the association */
+	else {
+		prStaRec->u4Flags = 0;
+		IE_FOR_EACH(pucIE, u2IELength, u2Offset) {
+			switch (IE_ID(pucIE)) {
+			case ELEM_ID_VENDOR:
+				mqmParseAssocReqWmmIe(prAdapter,
+					pucIE, prStaRec);
+
+#if CFG_SUPPORT_MTK_SYNERGY
+				if (rlmParseCheckMTKOuiIE(prAdapter,
+					pucIE, &u4Flags))
+					prStaRec->u4Flags = u4Flags;
+#endif
+
+				break;
+
+			case ELEM_ID_HT_CAP:
+				/* Some client won't put the WMM IE
+				 * if client is 802.11n
+				 */
+				if (IE_LEN(pucIE) ==
+					(sizeof(struct IE_HT_CAP) - 2))
+					prStaRec->fgIsQoS = TRUE;
+				break;
+			default:
+				break;
+			}
+		}
+
+		DBGLOG(QM, TRACE,
+			"MQM: Assoc_Req Parsing (QoS Enabled=%d)\n",
+			prStaRec->fgIsQoS);
+
+	}
+}
+
+void mqmParseAssocRspWmmIe(IN uint8_t *pucIE,
+	IN struct STA_RECORD *prStaRec)
+{
+	uint8_t aucWfaOui[] = VENDOR_OUI_WFA;
+
+	if ((WMM_IE_OUI_TYPE(pucIE) == VENDOR_OUI_TYPE_WMM)
+		&& (!kalMemCmp(WMM_IE_OUI(pucIE), aucWfaOui, 3))) {
+		struct IE_WMM_PARAM *prWmmParam = (struct IE_WMM_PARAM *) pucIE;
+		enum ENUM_ACI eAci;
+
+		switch (WMM_IE_OUI_SUBTYPE(pucIE)) {
+		case VENDOR_OUI_SUBTYPE_WMM_PARAM:
+			if (IE_LEN(pucIE) != 24)
+				break;	/* WMM Info IE with a wrong length */
+			prStaRec->fgIsQoS = TRUE;
+			prStaRec->fgIsWmmSupported = TRUE;
+			prStaRec->fgIsUapsdSupported =
+				!!(prWmmParam->ucQosInfo & WMM_QOS_INFO_UAPSD);
+			for (eAci = ACI_BE; eAci < ACI_NUM; eAci++)
+				prStaRec->afgAcmRequired[eAci] = !!(
+					prWmmParam->arAcParam[eAci].ucAciAifsn &
+					WMM_ACIAIFSN_ACM);
+			DBGLOG(WMM, INFO,
+			       "WMM: " MACSTR "ACM BK=%d BE=%d VI=%d VO=%d\n",
+			       MAC2STR(prStaRec->aucMacAddr),
+			       prStaRec->afgAcmRequired[ACI_BK],
+			       prStaRec->afgAcmRequired[ACI_BE],
+			       prStaRec->afgAcmRequired[ACI_VI],
+			       prStaRec->afgAcmRequired[ACI_VO]);
+			break;
+
+		case VENDOR_OUI_SUBTYPE_WMM_INFO:
+			if (IE_LEN(pucIE) != 7)
+				break;	/* WMM Info IE with a wrong length */
+			prStaRec->fgIsQoS = TRUE;
+			break;
+
+		default:
+			/* Other WMM QoS IEs. Ignore any */
+			break;
+		}
+	}
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief To process WMM related IEs in ASSOC_RSP
+ *
+ * \param[in] prAdapter Adapter pointer
+ * \param[in] prSwRfb            The received frame
+ * \param[in] pucIE              The pointer to the first IE in the frame
+ * \param[in] u2IELength         The total length of IEs in the frame
+ *
+ * \return none
+ */
+/*----------------------------------------------------------------------------*/
+void mqmProcessAssocRsp(IN struct ADAPTER *prAdapter,
+	IN struct SW_RFB *prSwRfb, IN uint8_t *pucIE,
+	IN uint16_t u2IELength)
+{
+	struct STA_RECORD *prStaRec;
+	uint16_t u2Offset;
+	uint8_t *pucIEStart;
+	uint32_t u4Flags;
+
+	DEBUGFUNC("mqmProcessAssocRsp");
+
+	ASSERT(prSwRfb);
+	ASSERT(pucIE);
+
+	prStaRec = cnmGetStaRecByIndex(prAdapter,
+		prSwRfb->ucStaRecIdx);
+	ASSERT(prStaRec);
+
+	if (prStaRec == NULL)
+		return;
+
+	prStaRec->fgIsQoS = FALSE;
+
+	pucIEStart = pucIE;
+
+	DBGLOG(QM, TRACE,
+		"QM: (fgIsWmmSupported=%d, fgSupportQoS=%d)\n",
+		prStaRec->fgIsWmmSupported, prAdapter->rWifiVar.ucQoS);
+
+	/* If the device does not support QoS
+	 * or if WMM is not supported by the peer, exit.
+	 */
+	if (IS_FEATURE_DISABLED(prAdapter->rWifiVar.ucQoS))
+		return;
+
+	/* Determine whether QoS is enabled with the association */
+	else {
+		prStaRec->u4Flags = 0;
+		IE_FOR_EACH(pucIE, u2IELength, u2Offset) {
+			switch (IE_ID(pucIE)) {
+			case ELEM_ID_VENDOR:
+				/* Process WMM related IE */
+				mqmParseAssocRspWmmIe(pucIE, prStaRec);
+
+#if CFG_SUPPORT_MTK_SYNERGY
+				if (rlmParseCheckMTKOuiIE(prAdapter,
+					pucIE, &u4Flags))
+					prStaRec->u4Flags = u4Flags;
+#endif
+
+				break;
+
+			case ELEM_ID_HT_CAP:
+				/* Some AP won't put the WMM IE
+				 * if client is 802.11n
+				 */
+				if (IE_LEN(pucIE) ==
+					(sizeof(struct IE_HT_CAP) - 2))
+					prStaRec->fgIsQoS = TRUE;
+				break;
+#if DSCP_SUPPORT
+			case ELEM_ID_QOS_MAP_SET:
+				DBGLOG(QM, WARN,
+					"QM: received assoc resp qosmapset ie\n");
+				qosParseQosMapSet(prAdapter, prStaRec, pucIE);
+				break;
+#endif
+			default:
+				break;
+			}
+		}
+		/* Parse AC parameters and write to HW CRs */
+		if ((prStaRec->fgIsQoS)
+			&& (prStaRec->eStaType == STA_TYPE_LEGACY_AP)) {
+			mqmParseEdcaParameters(prAdapter, prSwRfb, pucIEStart,
+				u2IELength, TRUE);
+#if (CFG_SUPPORT_802_11AX == 1)
+			if (fgEfuseCtrlAxOn == 1) {
+				mqmParseMUEdcaParams(prAdapter, prSwRfb,
+				pucIEStart, u2IELength, TRUE);
+			}
+#endif
+#if (CFG_SUPPORT_802_11BE == 1)
+			/*TODO */
+#endif
+
+#if ARP_MONITER_ENABLE
+			qmResetArpDetect();
+#endif
+		}
+		DBGLOG(QM, TRACE,
+			"MQM: Assoc_Rsp Parsing (QoS Enabled=%d)\n",
+			prStaRec->fgIsQoS);
+		if (prStaRec->fgIsWmmSupported)
+			nicQmUpdateWmmParms(prAdapter, prStaRec->ucBssIndex);
+#if (CFG_SUPPORT_802_11AX == 1)
+		if (fgEfuseCtrlAxOn == 1) {
+		if (prStaRec->fgIsMuEdcaSupported ||
+			prAdapter->fgMuEdcaOverride) {
+			nicQmUpdateMUEdcaParams(prAdapter,
+				prStaRec->ucBssIndex);
+		}
+		}
+#endif
+#if (CFG_SUPPORT_802_11BE == 1)
+		/*TODO */
+#endif
+	}
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief
+ *
+ * \param[in]
+ *
+ * \return none
+ */
+/*----------------------------------------------------------------------------*/
+void mqmProcessBcn(IN struct ADAPTER *prAdapter,
+	IN struct SW_RFB *prSwRfb, IN uint8_t *pucIE,
+	IN uint16_t u2IELength)
+{
+	struct BSS_INFO *prBssInfo;
+	u_int8_t fgNewParameter;
+#if (CFG_SUPPORT_802_11AX == 1)
+	u_int8_t fgNewMUEdca = FALSE;
+#endif
+	uint8_t i;
+
+	ASSERT(prAdapter);
+	ASSERT(prSwRfb);
+	ASSERT(pucIE);
+
+	DBGLOG(QM, TRACE, "Enter %s\n", __func__);
+
+	fgNewParameter = FALSE;
+
+	for (i = 0; i < prAdapter->ucHwBssIdNum; i++) {
+		prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, i);
+
+		if (IS_BSS_ACTIVE(prBssInfo)) {
+			if (prBssInfo->eCurrentOPMode ==
+				OP_MODE_INFRASTRUCTURE &&
+			    prBssInfo->eConnectionState ==
+			    MEDIA_STATE_CONNECTED) {
+				/* P2P client or AIS infra STA */
+				if (EQUAL_MAC_ADDR(prBssInfo->aucBSSID,
+					((struct WLAN_MAC_MGMT_HEADER *)
+					(prSwRfb->pvHeader))->aucBSSID)) {
+
+					fgNewParameter =
+						mqmParseEdcaParameters(
+							prAdapter,
+							prSwRfb, pucIE,
+							u2IELength, FALSE);
+#if (CFG_SUPPORT_802_11AX == 1)
+				if (fgEfuseCtrlAxOn == 1) {
+				fgNewMUEdca = mqmParseMUEdcaParams(
+						prAdapter, prSwRfb, pucIE,
+						u2IELength, FALSE);
+					}
+#endif
+#if (CFG_SUPPORT_802_11BE == 1)
+				/*TODO */
+#endif
+
+				}
+			}
+
+			/* Appy new parameters if necessary */
+			if (fgNewParameter) {
+				nicQmUpdateWmmParms(prAdapter,
+					prBssInfo->ucBssIndex);
+				fgNewParameter = FALSE;
+			}
+#if (CFG_SUPPORT_802_11AX == 1)
+			if (fgEfuseCtrlAxOn == 1) {
+				if (fgNewMUEdca) {
+					nicQmUpdateMUEdcaParams(prAdapter,
+						prBssInfo->ucBssIndex);
+					fgNewMUEdca = FALSE;
+				}
+			}
+#endif
+#if (CFG_SUPPORT_802_11BE == 1)
+			/*TODO */
+#endif
+		}
+	}		/* end of IS_BSS_ACTIVE() */
+}
+
+
+u_int8_t mqmUpdateEdcaParameters(IN struct BSS_INFO	*prBssInfo,
+	IN uint8_t *pucIE, IN u_int8_t fgForceOverride)
+{
+	struct AC_QUE_PARMS *prAcQueParams;
+	struct IE_WMM_PARAM *prIeWmmParam;
+	enum ENUM_WMM_ACI eAci;
+	u_int8_t fgNewParameter = FALSE;
+
+	do {
+		if (IE_LEN(pucIE) != 24)
+			break;	/* WMM Param IE with a wrong length */
+
+		prIeWmmParam = (struct IE_WMM_PARAM *) pucIE;
+
+		/* Check the Parameter Set Count to determine
+		 * whether EDCA parameters have been changed
+		 */
+		if (!fgForceOverride) {
+			if (mqmCompareEdcaParameters(prIeWmmParam, prBssInfo)) {
+				fgNewParameter = FALSE;
+				break;
+			}
+		}
+
+		fgNewParameter = TRUE;
+		/* Update Parameter Set Count */
+		prBssInfo->ucWmmParamSetCount = (prIeWmmParam->ucQosInfo &
+			WMM_QOS_INFO_PARAM_SET_CNT);
+		/* Update EDCA parameters */
+		for (eAci = 0; eAci < WMM_AC_INDEX_NUM; eAci++) {
+			prAcQueParams = &prBssInfo->arACQueParms[eAci];
+			mqmFillAcQueParam(prIeWmmParam, eAci, prAcQueParams);
+			log_dbg(QM, INFO, "BSS[%u]: eAci[%d] ACM[%d] Aifsn[%d] CWmin/max[%d/%d] TxopLimit[%d] NewParameter[%d]\n",
+				prBssInfo->ucBssIndex, eAci,
+				prAcQueParams->ucIsACMSet,
+				prAcQueParams->u2Aifsn, prAcQueParams->u2CWmin,
+				prAcQueParams->u2CWmax,
+				prAcQueParams->u2TxopLimit, fgNewParameter);
+		}
+	} while (FALSE);
+
+	return fgNewParameter;
+}
+
+#if (CFG_SUPPORT_802_11AX == 1)
+uint8_t mqmCompareMUEdcaParameters(
+	struct _IE_MU_EDCA_PARAM_T *prIeMUEdcaParam,
+	struct BSS_INFO *prBssInfo)
+{
+	struct _CMD_MU_EDCA_PARAMS_T *prBSSMUEdca;
+	struct _MU_AC_PARAM_RECORD_T *prMUAcParamInIE;
+	enum ENUM_WMM_ACI eAci;
+
+	/* Check Set Count */
+	if (prBssInfo->ucMUEdcaUpdateCnt !=
+		(prIeMUEdcaParam->ucMUQosInfo & WMM_QOS_INFO_PARAM_SET_CNT))
+		return FALSE;
+
+	for (eAci = 0; eAci < WMM_AC_INDEX_NUM; eAci++) {
+		prBSSMUEdca = &prBssInfo->arMUEdcaParams[eAci];
+		prMUAcParamInIE = &prIeMUEdcaParam->arMUAcParam[eAci];
+
+		/* ACM */
+		if (prBSSMUEdca->ucIsACMSet != ((prMUAcParamInIE->ucAciAifsn &
+			WMM_ACIAIFSN_ACM) ? TRUE : FALSE))
+			return FALSE;
+
+		/* AIFSN */
+		if (prBSSMUEdca->ucAifsn != (prMUAcParamInIE->ucAciAifsn &
+			WMM_ACIAIFSN_AIFSN))
+			return FALSE;
+
+		/* CW Max */
+		if (prBSSMUEdca->ucECWmax !=
+			((prMUAcParamInIE->ucEcw & WMM_ECW_WMAX_MASK)
+				>> WMM_ECW_WMAX_OFFSET))
+			return FALSE;
+
+		/* CW Min */
+		if (prBSSMUEdca->ucECWmin !=
+			(prMUAcParamInIE->ucEcw & WMM_ECW_WMIN_MASK))
+			return FALSE;
+
+		/* MU EDCA timer */
+		if (prBSSMUEdca->ucMUEdcaTimer !=
+			prMUAcParamInIE->ucMUEdcaTimer)
+			return FALSE;
+	}
+
+	return TRUE;
+}
+
+uint8_t mqmUpdateMUEdcaParams(struct BSS_INFO *prBssInfo,
+	uint8_t *pucIE, uint8_t fgForceOverride)
+{
+	struct _CMD_MU_EDCA_PARAMS_T *prBSSMUEdca;
+	struct _IE_MU_EDCA_PARAM_T *prIeMUEdcaParam;
+	struct _MU_AC_PARAM_RECORD_T *prMUAcParamInIE;
+	enum ENUM_WMM_ACI eAci;
+	uint8_t fgNewParameter = FALSE;
+
+	do {
+		if (IE_LEN(pucIE) != 14)
+			break;	/* MU EDCA Param IE with a wrong length */
+
+		prIeMUEdcaParam = (struct _IE_MU_EDCA_PARAM_T *) pucIE;
+
+		/*
+		 * Check the Parameter Set Count to determine whether
+		 * MU EDCA parameters have been changed
+		 */
+		if (!fgForceOverride) {
+			if (mqmCompareMUEdcaParameters(prIeMUEdcaParam,
+				prBssInfo)) {
+				fgNewParameter = FALSE;
+				break;
+			}
+		}
+
+		fgNewParameter = TRUE;
+		/* Update Parameter Set Count */
+		prBssInfo->ucMUEdcaUpdateCnt = (prIeMUEdcaParam->ucMUQosInfo &
+			WMM_QOS_INFO_PARAM_SET_CNT);
+		/* Update MU EDCA parameters to BSS structure */
+		for (eAci = 0; eAci < WMM_AC_INDEX_NUM; eAci++) {
+			prMUAcParamInIE = &(prIeMUEdcaParam->arMUAcParam[eAci]);
+			prBSSMUEdca = &prBssInfo->arMUEdcaParams[eAci];
+
+			prBSSMUEdca->ucECWmin = prMUAcParamInIE->ucEcw &
+							WMM_ECW_WMIN_MASK;
+			prBSSMUEdca->ucECWmax = (prMUAcParamInIE->ucEcw &
+							WMM_ECW_WMAX_MASK)
+							>> WMM_ECW_WMAX_OFFSET;
+			prBSSMUEdca->ucAifsn = (prMUAcParamInIE->ucAciAifsn &
+				WMM_ACIAIFSN_AIFSN);
+			prBSSMUEdca->ucIsACMSet = (prMUAcParamInIE->ucAciAifsn &
+				WMM_ACIAIFSN_ACM) ? TRUE : FALSE;
+			prBSSMUEdca->ucMUEdcaTimer =
+				prMUAcParamInIE->ucMUEdcaTimer;
+
+			DBGLOG(QM, INFO,
+				"BSS[%u]: eAci[%d] ACM[%d] Aifsn[%d],",
+				prBssInfo->ucBssIndex, eAci,
+				prBSSMUEdca->ucIsACMSet, prBSSMUEdca->ucAifsn);
+			DBGLOG(QM, INFO,
+				"ECWmin/max[%d/%d] NewParameter[%d]\n",
+				prBSSMUEdca->ucECWmin, prBSSMUEdca->ucECWmax,
+				fgNewParameter);
+
+		}
+	} while (FALSE);
+
+	return fgNewParameter;
+}
+
+uint8_t
+mqmParseMUEdcaParams(
+	struct ADAPTER *prAdapter,
+	struct SW_RFB *prSwRfb,
+	uint8_t *pucIE,
+	uint16_t u2IELength,
+	uint8_t fgForceOverride)
+{
+	struct STA_RECORD *prStaRec;
+	uint16_t u2Offset;
+	struct BSS_INFO *prBssInfo;
+	uint8_t fgNewParameter = FALSE;
+
+	DEBUGFUNC("mqmParseMUEdcaParams");
+
+	if (!prSwRfb)
+		return FALSE;
+
+	if (!pucIE)
+		return FALSE;
+
+	prStaRec = cnmGetStaRecByIndex(prAdapter, prSwRfb->ucStaRecIdx);
+	if (prStaRec == NULL)
+		return FALSE;
+
+	DBGLOG(QM, TRACE, "QM: (fgIsQoS=%d)\n", prStaRec->fgIsQoS);
+
+	if (IS_FEATURE_DISABLED(prAdapter->rWifiVar.ucQoS) ||
+		(!prStaRec->fgIsQoS))
+		return FALSE;
+
+	prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, prStaRec->ucBssIndex);
+
+	/* Goal: Obtain the MU EDCA parameters */
+	IE_FOR_EACH(pucIE, u2IELength, u2Offset) {
+		switch (IE_ID(pucIE)) {
+		case ELEM_ID_RESERVED:
+			if (IE_ID_EXT(pucIE) == ELEM_EXT_ID_MU_EDCA_PARAM) {
+				prStaRec->fgIsMuEdcaSupported = TRUE;
+				fgNewParameter = mqmUpdateMUEdcaParams(
+					prBssInfo, pucIE, fgForceOverride);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	return fgNewParameter;
+}
+#endif
+
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief To parse WMM Parameter IE (in BCN or Assoc_Rsp)
+ *
+ * \param[in] prAdapter          Adapter pointer
+ * \param[in] prSwRfb            The received frame
+ * \param[in] pucIE              The pointer to the first IE in the frame
+ * \param[in] u2IELength         The total length of IEs in the frame
+ * \param[in] fgForceOverride    TRUE: If EDCA parameters are found, always set
+ *                               to HW CRs.
+ *
+ * \return none
+ */
+/*----------------------------------------------------------------------------*/
+u_int8_t
+mqmParseEdcaParameters(IN struct ADAPTER *prAdapter,
+	IN struct SW_RFB *prSwRfb, IN uint8_t *pucIE,
+	IN uint16_t u2IELength, IN u_int8_t fgForceOverride)
+{
+	struct STA_RECORD *prStaRec;
+	uint16_t u2Offset;
+	uint8_t aucWfaOui[] = VENDOR_OUI_WFA;
+	struct BSS_INFO *prBssInfo;
+	u_int8_t fgNewParameter = FALSE;
+
+	DEBUGFUNC("mqmParseEdcaParameters");
+
+	if (!prSwRfb)
+		return FALSE;
+
+	if (!pucIE)
+		return FALSE;
+
+	prStaRec = cnmGetStaRecByIndex(prAdapter,
+		prSwRfb->ucStaRecIdx);
+	/* ASSERT(prStaRec); */
+
+	if (prStaRec == NULL)
+		return FALSE;
+
+	DBGLOG(QM, TRACE, "QM: (fgIsWmmSupported=%d, fgIsQoS=%d)\n",
+		prStaRec->fgIsWmmSupported, prStaRec->fgIsQoS);
+
+	if (IS_FEATURE_DISABLED(prAdapter->rWifiVar.ucQoS)
+	    || (!prStaRec->fgIsWmmSupported)
+	    || (!prStaRec->fgIsQoS))
+		return FALSE;
+
+	prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter,
+		prStaRec->ucBssIndex);
+
+	/* Goal: Obtain the EDCA parameters */
+	IE_FOR_EACH(pucIE, u2IELength, u2Offset) {
+		switch (IE_ID(pucIE)) {
+		case ELEM_ID_WMM:
+			if (!((WMM_IE_OUI_TYPE(pucIE) == VENDOR_OUI_TYPE_WMM) &&
+			      (!kalMemCmp(WMM_IE_OUI(pucIE), aucWfaOui, 3))))
+				break;
+
+			switch (WMM_IE_OUI_SUBTYPE(pucIE)) {
+			case VENDOR_OUI_SUBTYPE_WMM_PARAM:
+				fgNewParameter =
+					mqmUpdateEdcaParameters(prBssInfo,
+					pucIE, fgForceOverride);
+				break;
+
+			default:
+				/* Other WMM QoS IEs. Ignore */
+				break;
+			}
+
+			/* else: VENDOR_OUI_TYPE_WPA, VENDOR_OUI_TYPE_WPS, ...
+			 * (not cared)
+			 */
+			break;
+		default:
+			break;
+		}
+	}
+
+	return fgNewParameter;
+}
+
+u_int8_t mqmCompareEdcaParameters(IN struct IE_WMM_PARAM *prIeWmmParam,
+	IN struct BSS_INFO *prBssInfo)
+{
+	struct AC_QUE_PARMS *prAcQueParams;
+	struct WMM_AC_PARAM *prWmmAcParams;
+	enum ENUM_WMM_ACI eAci;
+
+	/* return FALSE; */
+
+	/* Check Set Count */
+	if (prBssInfo->ucWmmParamSetCount !=
+	(prIeWmmParam->ucQosInfo & WMM_QOS_INFO_PARAM_SET_CNT))
+		return FALSE;
+
+	for (eAci = 0; eAci < WMM_AC_INDEX_NUM; eAci++) {
+		prAcQueParams = &prBssInfo->arACQueParms[eAci];
+		prWmmAcParams = &prIeWmmParam->arAcParam[eAci];
+
+		/* ACM */
+		if (prAcQueParams->ucIsACMSet != ((prWmmAcParams->ucAciAifsn &
+			WMM_ACIAIFSN_ACM) ? TRUE : FALSE))
+			return FALSE;
+
+		/* AIFSN */
+		if (prAcQueParams->u2Aifsn != (prWmmAcParams->ucAciAifsn &
+			WMM_ACIAIFSN_AIFSN))
+			return FALSE;
+
+		/* CW Max */
+		if (prAcQueParams->u2CWmax !=
+			(BIT((prWmmAcParams->ucEcw & WMM_ECW_WMAX_MASK) >>
+			WMM_ECW_WMAX_OFFSET) - 1))
+			return FALSE;
+
+		/* CW Min */
+		if (prAcQueParams->u2CWmin != (BIT(prWmmAcParams->ucEcw &
+			WMM_ECW_WMIN_MASK) - 1))
+			return FALSE;
+
+		if (prAcQueParams->u2TxopLimit !=
+			prWmmAcParams->u2TxopLimit)
+			return FALSE;
+	}
+
+	return TRUE;
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief This function is used for parsing EDCA parameters specified in the
+ *        WMM Parameter IE
+ *
+ * \param[in] prAdapter           Adapter pointer
+ * \param[in] prIeWmmParam        The pointer to the WMM Parameter IE
+ * \param[in] u4AcOffset          The offset specifying the AC queue for parsing
+ * \param[in] prHwAcParams        The parameter structure used to configure the
+ *                                HW CRs
+ *
+ * \return none
+ */
+/*----------------------------------------------------------------------------*/
+void mqmFillAcQueParam(IN struct IE_WMM_PARAM *prIeWmmParam,
+	IN uint32_t u4AcOffset,
+	OUT struct AC_QUE_PARMS *prAcQueParams)
+{
+	struct WMM_AC_PARAM *prAcParam =
+		&prIeWmmParam->arAcParam[u4AcOffset];
+
+	prAcQueParams->ucIsACMSet = (prAcParam->ucAciAifsn &
+		WMM_ACIAIFSN_ACM) ? TRUE : FALSE;
+
+	prAcQueParams->u2Aifsn = (prAcParam->ucAciAifsn &
+		WMM_ACIAIFSN_AIFSN);
+
+	prAcQueParams->u2CWmax = BIT((prAcParam->ucEcw &
+		WMM_ECW_WMAX_MASK) >> WMM_ECW_WMAX_OFFSET) - 1;
+
+	prAcQueParams->u2CWmin = BIT(prAcParam->ucEcw &
+		WMM_ECW_WMIN_MASK) - 1;
+
+	WLAN_GET_FIELD_16(&prAcParam->u2TxopLimit,
+		&prAcQueParams->u2TxopLimit);
+
+	prAcQueParams->ucGuradTime =
+		TXM_DEFAULT_FLUSH_QUEUE_GUARD_TIME;
+
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief To parse WMM/11n related IEs in scan results (only for AP peers)
+ *
+ * \param[in] prAdapter       Adapter pointer
+ * \param[in]  prScanResult   The scan result which shall be parsed to
+ *                            obtain needed info
+ * \param[out] prStaRec       The obtained info is stored in the STA_REC
+ *
+ * \return none
+ */
+/*----------------------------------------------------------------------------*/
+void mqmProcessScanResult(IN struct ADAPTER *prAdapter,
+	IN struct BSS_DESC *prScanResult,
+	OUT struct STA_RECORD *prStaRec)
+{
+	uint8_t *pucIE;
+	uint16_t u2IELength;
+	uint16_t u2Offset;
+	uint8_t aucWfaOui[] = VENDOR_OUI_WFA;
+	u_int8_t fgIsHtVht;
+
+	DEBUGFUNC("mqmProcessScanResult");
+
+	ASSERT(prScanResult);
+	ASSERT(prStaRec);
+
+	/* Reset the flag before parsing */
+	prStaRec->fgIsWmmSupported = FALSE;
+	prStaRec->fgIsUapsdSupported = FALSE;
+	prStaRec->fgIsQoS = FALSE;
+	prStaRec->fgIsMscsSupported = FALSE;
+#if (CFG_SUPPORT_802_11AX == 1)
+	prStaRec->fgIsMuEdcaSupported = FALSE;
+#endif
+
+	fgIsHtVht = FALSE;
+
+	if (IS_FEATURE_DISABLED(prAdapter->rWifiVar.ucQoS))
+		return;
+
+	u2IELength = prScanResult->u2IELength;
+	pucIE = prScanResult->aucIEBuf;
+
+	/* <1> Determine whether the peer supports WMM/QoS and UAPSDU */
+	IE_FOR_EACH(pucIE, u2IELength, u2Offset) {
+		switch (IE_ID(pucIE)) {
+
+		case ELEM_ID_EXTENDED_CAP:
+#if CFG_SUPPORT_TDLS
+			TdlsBssExtCapParse(prStaRec, pucIE);
+#endif /* CFG_SUPPORT_TDLS */
+#if CFG_SUPPORT_802_11V_BSS_TRANSITION_MGT
+			prStaRec->fgSupportBTM =
+				!!((*(uint32_t *)(pucIE + 2)) &
+			BIT(ELEM_EXT_CAP_BSS_TRANSITION_BIT));
+#endif
+			prStaRec->fgIsMscsSupported = wlanCheckExtCapBit(
+				prStaRec, pucIE, ELEM_EXT_CAP_MSCS_BIT);
+			if (IS_FEATURE_DISABLED(
+				prAdapter->rWifiVar.ucCheckBeacon))
+				prStaRec->fgIsMscsSupported = TRUE;
+			break;
+		case ELEM_ID_WMM:
+			if ((WMM_IE_OUI_TYPE(pucIE) == VENDOR_OUI_TYPE_WMM) &&
+			    (!kalMemCmp(WMM_IE_OUI(pucIE), aucWfaOui, 3))) {
+				struct IE_WMM_PARAM *prWmmParam =
+					(struct IE_WMM_PARAM *)pucIE;
+				enum ENUM_ACI eAci;
+
+				switch (WMM_IE_OUI_SUBTYPE(pucIE)) {
+				case VENDOR_OUI_SUBTYPE_WMM_PARAM:
+					/* WMM Param IE with a wrong length */
+					if (IE_LEN(pucIE) != 24)
+						break;
+					prStaRec->fgIsWmmSupported = TRUE;
+					prStaRec->fgIsUapsdSupported =
+						!!(prWmmParam->ucQosInfo &
+						   WMM_QOS_INFO_UAPSD);
+					for (eAci = ACI_BE; eAci < ACI_NUM;
+					     eAci++)
+						prStaRec->afgAcmRequired
+							[eAci] = !!(
+							prWmmParam
+								->arAcParam
+									[eAci]
+								.ucAciAifsn &
+							WMM_ACIAIFSN_ACM);
+					DBGLOG(WMM, INFO,
+					       "WMM: " MACSTR
+					       "ACM BK=%d BE=%d VI=%d VO=%d\n",
+					       MAC2STR(prStaRec->aucMacAddr),
+					       prStaRec->afgAcmRequired[ACI_BK],
+					       prStaRec->afgAcmRequired[ACI_BE],
+					       prStaRec->afgAcmRequired[ACI_VI],
+					       prStaRec->afgAcmRequired
+						       [ACI_VO]);
+					break;
+
+				case VENDOR_OUI_SUBTYPE_WMM_INFO:
+					/* WMM Info IE with a wrong length */
+					if (IE_LEN(pucIE) != 7)
+						break;
+					prStaRec->fgIsWmmSupported = TRUE;
+					prStaRec->fgIsUapsdSupported =
+						((((
+							(struct IE_WMM_INFO *)
+							pucIE)->ucQosInfo)
+							& WMM_QOS_INFO_UAPSD)
+							? TRUE : FALSE);
+					break;
+
+				default:
+					/* A WMM QoS IE that doesn't matter.
+					 * Ignore it.
+					 */
+					break;
+				}
+			}
+			break;
+
+		default:
+			/* A WMM IE that doesn't matter. Ignore it. */
+			break;
+		}
+	}
+
+	/* <1> Determine QoS */
+	if (prStaRec->ucDesiredPhyTypeSet & (PHY_TYPE_SET_802_11N |
+		PHY_TYPE_SET_802_11AC))
+		fgIsHtVht = TRUE;
+
+	if (fgIsHtVht || prStaRec->fgIsWmmSupported)
+		prStaRec->fgIsQoS = TRUE;
+
+#if (CFG_SUPPORT_802_11AX == 1)
+	if (fgEfuseCtrlAxOn == 1) {
+		if (prStaRec->ucDesiredPhyTypeSet & PHY_TYPE_SET_802_11AX)
+			prStaRec->fgIsQoS = TRUE;
+	}
+#endif
+
+#if (CFG_SUPPORT_802_11BE == 1)
+	if (prStaRec->ucDesiredPhyTypeSet & PHY_TYPE_SET_802_11BE)
+		prStaRec->fgIsQoS = TRUE;
+#endif
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * @brief Generate the WMM Info IE by Param
+ *
+ * \param[in] prAdapter  Adapter pointer
+ * @param prMsduInfo The TX MMPDU
+ *
+ * @return (none)
+ */
+/*----------------------------------------------------------------------------*/
+uint32_t
+mqmFillWmmInfoIE(uint8_t *pucOutBuf,
+	u_int8_t fgSupportUAPSD, uint8_t ucBmpDeliveryAC,
+	uint8_t ucBmpTriggerAC, uint8_t ucUapsdSp)
+{
+	struct IE_WMM_INFO *prIeWmmInfo;
+	uint32_t ucUapsd[] = {
+		WMM_QOS_INFO_BE_UAPSD,
+		WMM_QOS_INFO_BK_UAPSD,
+		WMM_QOS_INFO_VI_UAPSD,
+		WMM_QOS_INFO_VO_UAPSD
+	};
+	uint8_t aucWfaOui[] = VENDOR_OUI_WFA;
+
+	ASSERT(pucOutBuf);
+
+	prIeWmmInfo = (struct IE_WMM_INFO *) pucOutBuf;
+
+	prIeWmmInfo->ucId = ELEM_ID_WMM;
+	prIeWmmInfo->ucLength = ELEM_MAX_LEN_WMM_INFO;
+
+	/* WMM-2.2.1 WMM Information Element Field Values */
+	prIeWmmInfo->aucOui[0] = aucWfaOui[0];
+	prIeWmmInfo->aucOui[1] = aucWfaOui[1];
+	prIeWmmInfo->aucOui[2] = aucWfaOui[2];
+	prIeWmmInfo->ucOuiType = VENDOR_OUI_TYPE_WMM;
+	prIeWmmInfo->ucOuiSubtype = VENDOR_OUI_SUBTYPE_WMM_INFO;
+
+	prIeWmmInfo->ucVersion = VERSION_WMM;
+	prIeWmmInfo->ucQosInfo = 0;
+
+	/* UAPSD initial queue configurations (delivery and trigger enabled) */
+	if (fgSupportUAPSD) {
+		uint8_t ucQosInfo = 0;
+		uint8_t i;
+
+		/* Static U-APSD setting */
+		for (i = ACI_BE; i <= ACI_VO; i++) {
+			if (ucBmpDeliveryAC & ucBmpTriggerAC & BIT(i))
+				ucQosInfo |= (uint8_t) ucUapsd[i];
+		}
+
+		if (ucBmpDeliveryAC & ucBmpTriggerAC) {
+			switch (ucUapsdSp) {
+			case WMM_MAX_SP_LENGTH_ALL:
+				ucQosInfo |= WMM_QOS_INFO_MAX_SP_ALL;
+				break;
+
+			case WMM_MAX_SP_LENGTH_2:
+				ucQosInfo |= WMM_QOS_INFO_MAX_SP_2;
+				break;
+
+			case WMM_MAX_SP_LENGTH_4:
+				ucQosInfo |= WMM_QOS_INFO_MAX_SP_4;
+				break;
+
+			case WMM_MAX_SP_LENGTH_6:
+				ucQosInfo |= WMM_QOS_INFO_MAX_SP_6;
+				break;
+
+			default:
+				DBGLOG(QM, INFO, "MQM: Incorrect SP length\n");
+				ucQosInfo |= WMM_QOS_INFO_MAX_SP_2;
+				break;
+			}
+		}
+		prIeWmmInfo->ucQosInfo = ucQosInfo;
+
+	}
+
+	/* Increment the total IE length
+	 * for the Element ID and Length fields.
+	 */
+	return IE_SIZE(prIeWmmInfo);
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * @brief Generate the WMM Info IE
+ *
+ * \param[in] prAdapter  Adapter pointer
+ * @param prMsduInfo The TX MMPDU
+ *
+ * @return (none)
+ */
+/*----------------------------------------------------------------------------*/
+uint32_t
+mqmGenerateWmmInfoIEByStaRec(struct ADAPTER *prAdapter,
+	struct BSS_INFO *prBssInfo, struct STA_RECORD *prStaRec,
+	uint8_t *pucOutBuf)
+{
+	struct PM_PROFILE_SETUP_INFO *prPmProfSetupInfo;
+	u_int8_t fgSupportUapsd;
+
+	ASSERT(pucOutBuf);
+
+	/* In case QoS is not turned off, exit directly */
+	if (IS_FEATURE_DISABLED(prAdapter->rWifiVar.ucQoS))
+		return 0;
+
+	if (prStaRec == NULL)
+		return 0;
+
+	if (!prStaRec->fgIsQoS)
+		return 0;
+
+	prPmProfSetupInfo = &prBssInfo->rPmProfSetupInfo;
+
+	fgSupportUapsd = (IS_FEATURE_ENABLED(
+		prAdapter->rWifiVar.ucUapsd) &&
+		prStaRec->fgIsUapsdSupported);
+
+	return mqmFillWmmInfoIE(pucOutBuf,
+		fgSupportUapsd,
+		prPmProfSetupInfo->ucBmpDeliveryAC,
+		prPmProfSetupInfo->ucBmpTriggerAC,
+		prPmProfSetupInfo->ucUapsdSp);
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * @brief Generate the WMM Info IE
+ *
+ * \param[in] prAdapter  Adapter pointer
+ * @param prMsduInfo The TX MMPDU
+ *
+ * @return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void mqmGenerateWmmInfoIE(IN struct ADAPTER *prAdapter,
+	IN struct MSDU_INFO *prMsduInfo)
+{
+	struct BSS_INFO *prBssInfo;
+	struct STA_RECORD *prStaRec;
+	uint32_t u4Length;
+
+	DEBUGFUNC("mqmGenerateWmmInfoIE");
+
+	ASSERT(prMsduInfo);
+
+	prStaRec = cnmGetStaRecByIndex(prAdapter,
+		prMsduInfo->ucStaRecIndex);
+	ASSERT(prStaRec);
+
+	if (prStaRec == NULL)
+		return;
+
+	prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter,
+		prStaRec->ucBssIndex);
+
+	u4Length = mqmGenerateWmmInfoIEByStaRec(prAdapter,
+		prBssInfo, prStaRec,
+		((uint8_t *) prMsduInfo->prPacket +
+		prMsduInfo->u2FrameLength));
+
+	prMsduInfo->u2FrameLength += u4Length;
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * @brief Generate the WMM Param IE
+ *
+ * \param[in] prAdapter  Adapter pointer
+ * @param prMsduInfo The TX MMPDU
+ *
+ * @return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void mqmGenerateWmmParamIE(IN struct ADAPTER *prAdapter,
+	IN struct MSDU_INFO *prMsduInfo)
+{
+	struct IE_WMM_PARAM *prIeWmmParam;
+
+	uint8_t aucWfaOui[] = VENDOR_OUI_WFA;
+
+	uint8_t aucACI[] = {
+		WMM_ACI_AC_BE,
+		WMM_ACI_AC_BK,
+		WMM_ACI_AC_VI,
+		WMM_ACI_AC_VO
+	};
+
+	struct BSS_INFO *prBssInfo;
+	struct STA_RECORD *prStaRec;
+	enum ENUM_WMM_ACI eAci;
+	struct WMM_AC_PARAM *prAcParam;
+
+	DEBUGFUNC("mqmGenerateWmmParamIE");
+	DBGLOG(QM, LOUD, "\n");
+
+	ASSERT(prMsduInfo);
+
+	/* In case QoS is not turned off, exit directly */
+	if (IS_FEATURE_DISABLED(prAdapter->rWifiVar.ucQoS))
+		return;
+
+	prStaRec = cnmGetStaRecByIndex(prAdapter,
+		prMsduInfo->ucStaRecIndex);
+
+	if (prStaRec) {
+		if (!prStaRec->fgIsQoS)
+			return;
+	}
+
+	prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter,
+		prMsduInfo->ucBssIndex);
+
+	if (!prBssInfo->fgIsQBSS)
+		return;
+
+	prIeWmmParam = (struct IE_WMM_PARAM *)
+		((uint8_t *) prMsduInfo->prPacket +
+		prMsduInfo->u2FrameLength);
+
+	prIeWmmParam->ucId = ELEM_ID_WMM;
+	prIeWmmParam->ucLength = ELEM_MAX_LEN_WMM_PARAM;
+
+	/* WMM-2.2.1 WMM Information Element Field Values */
+	prIeWmmParam->aucOui[0] = aucWfaOui[0];
+	prIeWmmParam->aucOui[1] = aucWfaOui[1];
+	prIeWmmParam->aucOui[2] = aucWfaOui[2];
+	prIeWmmParam->ucOuiType = VENDOR_OUI_TYPE_WMM;
+	prIeWmmParam->ucOuiSubtype = VENDOR_OUI_SUBTYPE_WMM_PARAM;
+
+	prIeWmmParam->ucVersion = VERSION_WMM;
+	prIeWmmParam->ucQosInfo = (prBssInfo->ucWmmParamSetCount &
+		WMM_QOS_INFO_PARAM_SET_CNT);
+
+	/* UAPSD initial queue configurations (delivery and trigger enabled) */
+	if (IS_FEATURE_ENABLED(prAdapter->rWifiVar.ucUapsd))
+		prIeWmmParam->ucQosInfo |= WMM_QOS_INFO_UAPSD;
+
+	/* EDCA parameter */
+
+	for (eAci = 0; eAci < WMM_AC_INDEX_NUM; eAci++) {
+		prAcParam = &prIeWmmParam->arAcParam[eAci];
+
+		/* ACI */
+		prAcParam->ucAciAifsn = aucACI[eAci];
+		/* ACM */
+		if (prBssInfo->arACQueParmsForBcast[eAci].ucIsACMSet)
+			prAcParam->ucAciAifsn |= WMM_ACIAIFSN_ACM;
+		/* AIFSN */
+		prAcParam->ucAciAifsn |=
+			(prBssInfo->arACQueParmsForBcast[eAci].u2Aifsn &
+			WMM_ACIAIFSN_AIFSN);
+
+		/* ECW Min */
+		prAcParam->ucEcw = (prBssInfo->aucCWminLog2ForBcast[eAci] &
+			WMM_ECW_WMIN_MASK);
+		/* ECW Max */
+		prAcParam->ucEcw |=
+			((prBssInfo->aucCWmaxLog2ForBcast[eAci] <<
+			WMM_ECW_WMAX_OFFSET) & WMM_ECW_WMAX_MASK);
+
+		/* Txop limit */
+		WLAN_SET_FIELD_16(&prAcParam->u2TxopLimit,
+			prBssInfo->arACQueParmsForBcast[eAci].u2TxopLimit);
+
+	}
+
+	/* Increment the total IE length
+	 * for the Element ID and Length fields.
+	 */
+	prMsduInfo->u2FrameLength += IE_SIZE(prIeWmmParam);
+
+}
+
+#if CFG_SUPPORT_TDLS
+/*----------------------------------------------------------------------------*/
+/*!
+ * @brief Generate the WMM Param IE
+ *
+ * \param[in] prAdapter  Adapter pointer
+ * @param prMsduInfo The TX MMPDU
+ *
+ * @return (none)
+ */
+/*----------------------------------------------------------------------------*/
+uint32_t mqmGenerateWmmParamIEByParam(struct ADAPTER *prAdapter,
+	struct BSS_INFO *prBssInfo, uint8_t *pOutBuf)
+{
+	struct IE_WMM_PARAM *prIeWmmParam;
+
+	uint8_t aucWfaOui[] = VENDOR_OUI_WFA;
+
+	uint8_t aucACI[] = {
+		WMM_ACI_AC_BE,
+		WMM_ACI_AC_BK,
+		WMM_ACI_AC_VI,
+		WMM_ACI_AC_VO
+	};
+
+	struct AC_QUE_PARMS *prACQueParms;
+	/* BE, BK, VO, VI */
+	uint8_t auCWminLog2ForBcast[WMM_AC_INDEX_NUM] = {4, 4, 3, 2};
+	uint8_t auCWmaxLog2ForBcast[WMM_AC_INDEX_NUM] = {10, 10, 4, 3};
+	uint8_t auAifsForBcast[WMM_AC_INDEX_NUM] = {3, 7, 2, 2};
+	/* If the AP is OFDM */
+	uint8_t auTxopForBcast[WMM_AC_INDEX_NUM] = {0, 0, 94, 47};
+
+	enum ENUM_WMM_ACI eAci;
+	struct WMM_AC_PARAM *prAcParam;
+
+	DEBUGFUNC("mqmGenerateWmmParamIE");
+	DBGLOG(QM, LOUD, "\n");
+
+	ASSERT(pOutBuf);
+
+	/* In case QoS is not turned off, exit directly */
+	if (IS_FEATURE_DISABLED(prAdapter->rWifiVar.ucQoS))
+		return WLAN_STATUS_SUCCESS;
+
+	if (!prBssInfo->fgIsQBSS)
+		return WLAN_STATUS_SUCCESS;
+
+	if (IS_FEATURE_ENABLED(
+		prAdapter->rWifiVar.fgTdlsBufferSTASleep)) {
+		prACQueParms = prBssInfo->arACQueParmsForBcast;
+
+		for (eAci = 0; eAci < WMM_AC_INDEX_NUM; eAci++) {
+			prACQueParms[eAci].ucIsACMSet = FALSE;
+			prACQueParms[eAci].u2Aifsn = auAifsForBcast[eAci];
+			prACQueParms[eAci].u2CWmin =
+				BIT(auCWminLog2ForBcast[eAci]) - 1;
+			prACQueParms[eAci].u2CWmax =
+				BIT(auCWmaxLog2ForBcast[eAci]) - 1;
+			prACQueParms[eAci].u2TxopLimit = auTxopForBcast[eAci];
+
+			/* used to send WMM IE */
+			prBssInfo->aucCWminLog2ForBcast[eAci] =
+				auCWminLog2ForBcast[eAci];
+			prBssInfo->aucCWmaxLog2ForBcast[eAci] =
+				auCWmaxLog2ForBcast[eAci];
+		}
+	}
+
+	prIeWmmParam = (struct IE_WMM_PARAM *) pOutBuf;
+
+	prIeWmmParam->ucId = ELEM_ID_WMM;
+	prIeWmmParam->ucLength = ELEM_MAX_LEN_WMM_PARAM;
+
+	/* WMM-2.2.1 WMM Information Element Field Values */
+	prIeWmmParam->aucOui[0] = aucWfaOui[0];
+	prIeWmmParam->aucOui[1] = aucWfaOui[1];
+	prIeWmmParam->aucOui[2] = aucWfaOui[2];
+	prIeWmmParam->ucOuiType = VENDOR_OUI_TYPE_WMM;
+	prIeWmmParam->ucOuiSubtype = VENDOR_OUI_SUBTYPE_WMM_PARAM;
+
+	prIeWmmParam->ucVersion = VERSION_WMM;
+	/* STAUT Buffer STA, also sleeps (optional)
+	 * The STAUT sends a TDLS Setup/Response/Confirm Frame,
+	 * with all four AC flags set to 1 in QoS Info Field
+	 * to STA 2, via the AP,
+	 */
+	if (IS_FEATURE_ENABLED(
+		    prAdapter->rWifiVar.fgTdlsBufferSTASleep))
+		prIeWmmParam->ucQosInfo = (0x0F &
+			WMM_QOS_INFO_PARAM_SET_CNT);
+	else
+		prIeWmmParam->ucQosInfo = (prBssInfo->ucWmmParamSetCount &
+			WMM_QOS_INFO_PARAM_SET_CNT);
+
+	/* UAPSD initial queue configurations (delivery and trigger enabled) */
+	if (IS_FEATURE_ENABLED(prAdapter->rWifiVar.ucUapsd))
+		prIeWmmParam->ucQosInfo |= WMM_QOS_INFO_UAPSD;
+
+	/* EDCA parameter */
+
+	for (eAci = 0; eAci < WMM_AC_INDEX_NUM; eAci++) {
+		prAcParam = &prIeWmmParam->arAcParam[eAci];
+		/* ACI */
+		prAcParam->ucAciAifsn = aucACI[eAci];
+		/* ACM */
+		if (prBssInfo->arACQueParmsForBcast[eAci].ucIsACMSet)
+			prAcParam->ucAciAifsn |= WMM_ACIAIFSN_ACM;
+		/* AIFSN */
+		prAcParam->ucAciAifsn |=
+			(prBssInfo->arACQueParmsForBcast[eAci].u2Aifsn &
+			WMM_ACIAIFSN_AIFSN);
+
+		/* ECW Min */
+		prAcParam->ucEcw = (prBssInfo->aucCWminLog2ForBcast[eAci] &
+			WMM_ECW_WMIN_MASK);
+		/* ECW Max */
+		prAcParam->ucEcw |=
+			((prBssInfo->aucCWmaxLog2ForBcast[eAci] <<
+			WMM_ECW_WMAX_OFFSET) & WMM_ECW_WMAX_MASK);
+
+		/* Txop limit */
+		WLAN_SET_FIELD_16(&prAcParam->u2TxopLimit,
+			prBssInfo->arACQueParmsForBcast[eAci].u2TxopLimit);
+
+	}
+
+	/* Increment the total IE length
+	 * for the Element ID and Length fields.
+	 */
+	return IE_SIZE(prIeWmmParam);
+
+}
+
+#endif
+
+u_int8_t isProbeResponse(IN struct MSDU_INFO *prMgmtTxMsdu)
+{
+	struct WLAN_MAC_HEADER *prWlanHdr =
+		(struct WLAN_MAC_HEADER *) NULL;
+
+	prWlanHdr =
+		(struct WLAN_MAC_HEADER *) ((unsigned long)
+		prMgmtTxMsdu->prPacket + MAC_TX_RESERVED_FIELD);
+
+	return (prWlanHdr->u2FrameCtrl & MASK_FRAME_TYPE) ==
+		MAC_FRAME_PROBE_RSP ? TRUE : FALSE;
+}
+
+
+enum ENUM_FRAME_ACTION qmGetFrameAction(IN struct ADAPTER *prAdapter,
+	IN uint8_t ucBssIndex,
+	IN uint8_t ucStaRecIdx, IN struct MSDU_INFO *prMsduInfo,
+	IN enum ENUM_FRAME_TYPE_IN_CMD_Q eFrameType,
+	IN uint16_t u2FrameLength)
+{
+	enum ENUM_FRAME_ACTION eFrameAction = FRAME_ACTION_TX_PKT;
+	struct BSS_INFO *prBssInfo;
+	struct STA_RECORD *prStaRec;
+	uint8_t ucTC = nicTxGetFrameResourceType(eFrameType, prMsduInfo);
+	uint16_t u2FreeResource = nicTxGetResource(prAdapter, ucTC);
+	uint8_t ucReqResource;
+	struct WIFI_VAR *prWifiVar = &prAdapter->rWifiVar;
+
+	DEBUGFUNC("qmGetFrameAction");
+
+	prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, ucBssIndex);
+	prStaRec = cnmGetStaRecByIndexWithoutInUseCheck(prAdapter,
+			ucStaRecIdx);
+
+	do {
+		/* 4 <1> Tx, if FORCE_TX is set */
+		if (prMsduInfo) {
+			if (prMsduInfo->ucControlFlag &
+				MSDU_CONTROL_FLAG_FORCE_TX) {
+				eFrameAction = FRAME_ACTION_TX_PKT;
+				break;
+			}
+		}
+#if CFG_SUPPORT_NAN
+		if (prMsduInfo->ucTxToNafQueFlag == TRUE) {
+			eFrameAction = FRAME_ACTION_TX_PKT;
+			break;
+		}
+#endif
+
+		/* 4 <2> Drop, if BSS is inactive */
+		if (!IS_BSS_ACTIVE(prBssInfo)) {
+			DBGLOG(QM, TRACE,
+				"Drop packets (BSS[%u] is INACTIVE)\n",
+				prBssInfo->ucBssIndex);
+			eFrameAction = FRAME_ACTION_DROP_PKT;
+			break;
+		}
+
+		/* 4 <3> Queue, if BSS is absent, drop probe response */
+		if (prBssInfo->fgIsNetAbsent) {
+			if (prMsduInfo && isProbeResponse(prMsduInfo)) {
+				DBGLOG(TX, TRACE,
+					"Drop probe response (BSS[%u] Absent)\n",
+					prBssInfo->ucBssIndex);
+
+				eFrameAction = FRAME_ACTION_DROP_PKT;
+			} else {
+				DBGLOG(TX, TRACE,
+					"Queue packets (BSS[%u] Absent)\n",
+					prBssInfo->ucBssIndex);
+				eFrameAction = FRAME_ACTION_QUEUE_PKT;
+			}
+			break;
+		}
+
+		/* 4 <4> Check based on StaRec */
+		if (prStaRec) {
+			/* 4 <4.1> Drop, if StaRec is not in use */
+			if (!prStaRec->fgIsInUse) {
+				DBGLOG(QM, TRACE,
+					"Drop packets (Sta[%u] not in USE)\n",
+					prStaRec->ucIndex);
+				eFrameAction = FRAME_ACTION_DROP_PKT;
+				break;
+			}
+			/* 4 <4.2> Sta in PS */
+			if (prStaRec->fgIsInPS) {
+				ucReqResource = nicTxGetPageCount(prAdapter,
+					u2FrameLength, FALSE) +
+					prWifiVar->ucCmdRsvResource +
+					QM_MGMT_QUEUED_THRESHOLD;
+
+				/* 4 <4.2.1> Tx, if resource is enough */
+				if (u2FreeResource > ucReqResource) {
+					eFrameAction = FRAME_ACTION_TX_PKT;
+					break;
+				}
+				/* 4 <4.2.2> Queue, if resource is not enough */
+				else {
+					DBGLOG(QM, INFO,
+						"Queue packets (Sta[%u] in PS)\n",
+						prStaRec->ucIndex);
+					eFrameAction = FRAME_ACTION_QUEUE_PKT;
+					break;
+				}
+			}
+		}
+	} while (FALSE);
+
+	/* <5> Resource CHECK! */
+	/* <5.1> Reserve resource for CMD & 1X */
+	if (eFrameType == FRAME_TYPE_MMPDU) {
+		ucReqResource = nicTxGetPageCount(prAdapter, u2FrameLength,
+			FALSE) + prWifiVar->ucCmdRsvResource;
+
+		if (u2FreeResource < ucReqResource) {
+			eFrameAction = FRAME_ACTION_QUEUE_PKT;
+			DBGLOG(QM, INFO,
+				"Queue MGMT (MSDU[0x%p] Req/Rsv/Free[%u/%u/%u])\n",
+				prMsduInfo,
+				nicTxGetPageCount(prAdapter,
+					u2FrameLength, FALSE),
+				prWifiVar->ucCmdRsvResource, u2FreeResource);
+		}
+
+		/* <6> Timeout check! */
+#if CFG_ENABLE_PKT_LIFETIME_PROFILE
+		if ((eFrameAction == FRAME_ACTION_QUEUE_PKT) && prMsduInfo) {
+			OS_SYSTIME rCurrentTime, rEnqTime;
+
+			GET_CURRENT_SYSTIME(&rCurrentTime);
+			rEnqTime = prMsduInfo->rPktProfile.rEnqueueTimestamp;
+
+			if (CHECK_FOR_TIMEOUT(rCurrentTime, rEnqTime,
+				MSEC_TO_SYSTIME(
+					prWifiVar->u4MgmtQueueDelayTimeout))) {
+				eFrameAction = FRAME_ACTION_DROP_PKT;
+				log_dbg(QM, INFO, "Drop MGMT (MSDU[0x%p] timeout[%ums])\n",
+					prMsduInfo,
+					prWifiVar->u4MgmtQueueDelayTimeout);
+			}
+		}
+#endif
+	}
+
+	return eFrameAction;
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Handle BSS change operation Event from the FW
+ *
+ * \param[in] prAdapter Adapter pointer
+ * \param[in] prEvent The event packet from the FW
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void qmHandleEventBssAbsencePresence(IN struct ADAPTER *prAdapter,
+	IN struct WIFI_EVENT *prEvent)
+{
+	struct EVENT_BSS_ABSENCE_PRESENCE *prEventBssStatus;
+	struct BSS_INFO *prBssInfo;
+	u_int8_t fgIsNetAbsentOld;
+	struct GLUE_INFO *glue = prAdapter->prGlueInfo;
+	struct GL_HIF_INFO *hif = &glue->rHifInfo;
+	char *pos = NULL, *end = NULL;
+	char buf[512];
+	int i;
+
+	prEventBssStatus = (struct EVENT_BSS_ABSENCE_PRESENCE *) (
+		prEvent->aucBuffer);
+	prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter,
+		prEventBssStatus->ucBssIndex);
+	fgIsNetAbsentOld = prBssInfo->fgIsNetAbsent;
+	prBssInfo->fgIsNetAbsent = prEventBssStatus->ucIsAbsent;
+	prBssInfo->ucBssFreeQuota = prEventBssStatus->ucBssFreeQuota;
+
+	memset(buf, 0, sizeof(buf));
+	pos = buf;
+	end = pos + sizeof(buf);
+	for (i = 0; i < NUM_OF_TX_RING; ++i) {
+		pos += kalSnprintf(pos, end - pos, "[%u]",
+			hif->TxRing[i].u4UsedCnt);
+	}
+
+	DBGLOG(QM, INFO, "NAF:B=%d,A=%d,F=%d used=%d %s\n",
+		prEventBssStatus->ucBssIndex, prBssInfo->fgIsNetAbsent,
+		prBssInfo->ucBssFreeQuota, hif->rTokenInfo.u4UsedCnt, buf);
+
+	if (!prBssInfo->fgIsNetAbsent) {
+		/* ToDo:: QM_DBG_CNT_INC */
+		QM_DBG_CNT_INC(&(prAdapter->rQM), QM_DBG_CNT_27);
+	} else {
+		/* ToDo:: QM_DBG_CNT_INC */
+		QM_DBG_CNT_INC(&(prAdapter->rQM), QM_DBG_CNT_28);
+	}
+	/* From Absent to Present */
+	if ((fgIsNetAbsentOld) && (!prBssInfo->fgIsNetAbsent)) {
+		if (HAL_IS_TX_DIRECT(prAdapter))
+			nicTxDirectStartCheckQTimer(prAdapter);
+		else {
+#if QM_ADAPTIVE_TC_RESOURCE_CTRL
+			prAdapter->rQM.fgForceReassign = TRUE;
+#endif
+			kalSetEvent(prAdapter->prGlueInfo);
+			kalSetTxEvent2Hif(prAdapter->prGlueInfo);
+		}
+	}
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Handle STA change PS mode Event from the FW
+ *
+ * \param[in] prAdapter Adapter pointer
+ * \param[in] prEvent The event packet from the FW
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void qmHandleEventStaChangePsMode(IN struct ADAPTER *prAdapter,
+	IN struct WIFI_EVENT *prEvent)
+{
+	struct EVENT_STA_CHANGE_PS_MODE *prEventStaChangePsMode;
+	struct STA_RECORD *prStaRec;
+	u_int8_t fgIsInPSOld;
+
+	/* DbgPrint("QM:Event -RxBa\n"); */
+
+	prEventStaChangePsMode = (struct EVENT_STA_CHANGE_PS_MODE *)
+		(prEvent->aucBuffer);
+	prStaRec = QM_GET_STA_REC_PTR_FROM_INDEX(prAdapter,
+		prEventStaChangePsMode->ucStaRecIdx);
+	/* ASSERT(prStaRec); */
+
+	if (prStaRec) {
+
+		fgIsInPSOld = prStaRec->fgIsInPS;
+		prStaRec->fgIsInPS = prEventStaChangePsMode->ucIsInPs;
+
+		qmUpdateFreeQuota(prAdapter,
+			prStaRec,
+			prEventStaChangePsMode->ucUpdateMode,
+			prEventStaChangePsMode->ucFreeQuota);
+
+		DBGLOG(QM, INFO, "PS=%d,%d\n",
+			prEventStaChangePsMode->ucStaRecIdx,
+			prStaRec->fgIsInPS);
+
+		/* From PS to Awake */
+		if ((fgIsInPSOld) && (!prStaRec->fgIsInPS)) {
+			if (HAL_IS_TX_DIRECT(prAdapter))
+				nicTxDirectStartCheckQTimer(prAdapter);
+			else {
+#if QM_ADAPTIVE_TC_RESOURCE_CTRL
+				prAdapter->rQM.fgForceReassign = TRUE;
+#endif
+				kalSetEvent(prAdapter->prGlueInfo);
+			}
+		}
+	}
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Update STA free quota Event from FW
+ *
+ * \param[in] prAdapter Adapter pointer
+ * \param[in] prEvent The event packet from the FW
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void qmHandleEventStaUpdateFreeQuota(IN struct ADAPTER *prAdapter,
+	IN struct WIFI_EVENT *prEvent)
+{
+	struct EVENT_STA_UPDATE_FREE_QUOTA
+		*prEventStaUpdateFreeQuota;
+	struct STA_RECORD *prStaRec;
+
+	prEventStaUpdateFreeQuota = (struct
+		EVENT_STA_UPDATE_FREE_QUOTA *) (prEvent->aucBuffer);
+	prStaRec = QM_GET_STA_REC_PTR_FROM_INDEX(prAdapter,
+			prEventStaUpdateFreeQuota->ucStaRecIdx);
+	/* 2013/08/30
+	 * Station Record possible been freed.
+	 */
+	/* ASSERT(prStaRec); */
+
+	if (prStaRec) {
+		if (prStaRec->fgIsInPS) {
+			qmUpdateFreeQuota(prAdapter,
+				prStaRec,
+				prEventStaUpdateFreeQuota->ucUpdateMode,
+				prEventStaUpdateFreeQuota->ucFreeQuota);
+
+			if (HAL_IS_TX_DIRECT(prAdapter))
+				nicTxDirectStartCheckQTimer(prAdapter);
+			else
+				kalSetEvent(prAdapter->prGlueInfo);
+		}
+		DBGLOG(QM, TRACE, "UFQ=%d,%d,%d\n",
+			prEventStaUpdateFreeQuota->ucStaRecIdx,
+			prEventStaUpdateFreeQuota->ucUpdateMode,
+			prEventStaUpdateFreeQuota->ucFreeQuota);
+
+	}
+
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Update STA free quota
+ *
+ * \param[in] prStaRec the STA
+ * \param[in] ucUpdateMode the method to update free quota
+ * \param[in] ucFreeQuota  the value for update
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void
+qmUpdateFreeQuota(IN struct ADAPTER *prAdapter,
+	IN struct STA_RECORD *prStaRec, IN uint8_t ucUpdateMode,
+	IN uint8_t ucFreeQuota)
+{
+
+	uint8_t ucFreeQuotaForNonDelivery;
+	uint8_t ucFreeQuotaForDelivery;
+
+	ASSERT(prStaRec);
+	DBGLOG(QM, LOUD,
+		"qmUpdateFreeQuota orig ucFreeQuota=%d Mode %u New %u\n",
+		prStaRec->ucFreeQuota, ucUpdateMode, ucFreeQuota);
+
+	if (!prStaRec->fgIsInPS)
+		return;
+
+	switch (ucUpdateMode) {
+	case FREE_QUOTA_UPDATE_MODE_INIT:
+	case FREE_QUOTA_UPDATE_MODE_OVERWRITE:
+		prStaRec->ucFreeQuota = ucFreeQuota;
+		break;
+	case FREE_QUOTA_UPDATE_MODE_INCREASE:
+		prStaRec->ucFreeQuota += ucFreeQuota;
+		break;
+	case FREE_QUOTA_UPDATE_MODE_DECREASE:
+		prStaRec->ucFreeQuota -= ucFreeQuota;
+		break;
+	default:
+		ASSERT(0);
+	}
+
+	DBGLOG(QM, LOUD, "qmUpdateFreeQuota new ucFreeQuota=%d)\n",
+		prStaRec->ucFreeQuota);
+
+	ucFreeQuota = prStaRec->ucFreeQuota;
+
+	ucFreeQuotaForNonDelivery = 0;
+	ucFreeQuotaForDelivery = 0;
+
+	if (ucFreeQuota > 0) {
+		if (prStaRec->fgIsQoS && prStaRec->fgIsUapsdSupported
+		    /* && prAdapter->rWifiVar.fgSupportQoS */
+		    /* && prAdapter->rWifiVar.fgSupportUAPSD */) {
+			/* XXX We should assign quota to
+			 * aucFreeQuotaPerQueue[NUM_OF_PER_STA_TX_QUEUES]
+			 */
+
+			if (prStaRec->ucFreeQuotaForNonDelivery > 0
+			    && prStaRec->ucFreeQuotaForDelivery > 0) {
+				ucFreeQuotaForNonDelivery = ucFreeQuota >> 1;
+				ucFreeQuotaForDelivery = ucFreeQuota -
+					ucFreeQuotaForNonDelivery;
+			} else if (prStaRec->ucFreeQuotaForNonDelivery == 0
+				   && prStaRec->ucFreeQuotaForDelivery == 0) {
+				ucFreeQuotaForNonDelivery = ucFreeQuota >> 1;
+				ucFreeQuotaForDelivery = ucFreeQuota -
+					ucFreeQuotaForNonDelivery;
+			} else if (prStaRec->ucFreeQuotaForNonDelivery > 0) {
+				/* NonDelivery is not busy */
+				if (ucFreeQuota >= 3) {
+					ucFreeQuotaForNonDelivery = 2;
+					ucFreeQuotaForDelivery = ucFreeQuota -
+						ucFreeQuotaForNonDelivery;
+				} else {
+					ucFreeQuotaForDelivery = ucFreeQuota;
+					ucFreeQuotaForNonDelivery = 0;
+				}
+			} else if (prStaRec->ucFreeQuotaForDelivery > 0) {
+				/* Delivery is not busy */
+				if (ucFreeQuota >= 3) {
+					ucFreeQuotaForDelivery = 2;
+					ucFreeQuotaForNonDelivery =
+						ucFreeQuota -
+						ucFreeQuotaForDelivery;
+				} else {
+					ucFreeQuotaForNonDelivery = ucFreeQuota;
+					ucFreeQuotaForDelivery = 0;
+				}
+			}
+
+		} else {
+			/* !prStaRec->fgIsUapsdSupported */
+			ucFreeQuotaForNonDelivery = ucFreeQuota;
+			ucFreeQuotaForDelivery = 0;
+		}
+	}
+	/* ucFreeQuota > 0 */
+	prStaRec->ucFreeQuotaForDelivery = ucFreeQuotaForDelivery;
+	prStaRec->ucFreeQuotaForNonDelivery =
+		ucFreeQuotaForNonDelivery;
+
+	DBGLOG(QM, LOUD,
+		"new QuotaForDelivery = %d  QuotaForNonDelivery = %d\n",
+		prStaRec->ucFreeQuotaForDelivery,
+		prStaRec->ucFreeQuotaForNonDelivery);
+
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Return the reorder queued RX packets
+ *
+ * \param[in] (none)
+ *
+ * \return The number of queued RX packets
+ */
+/*----------------------------------------------------------------------------*/
+uint32_t qmGetRxReorderQueuedBufferCount(IN struct ADAPTER *prAdapter)
+{
+	uint32_t i, u4Total;
+	struct QUE_MGT *prQM = &prAdapter->rQM;
+
+	u4Total = 0;
+	/* XXX The summation may impact the performance */
+	for (i = 0; i < CFG_NUM_OF_RX_BA_AGREEMENTS; i++) {
+		u4Total += prQM->arRxBaTable[i].rReOrderQue.u4NumElem;
+#if DBG && 0
+		if (QUEUE_IS_EMPTY(&(prQM->arRxBaTable[i].rReOrderQue)))
+			ASSERT(prQM->arRxBaTable[i].rReOrderQue == 0);
+#endif
+	}
+	ASSERT(u4Total <= (CFG_NUM_OF_QM_RX_PKT_NUM * 2));
+	return u4Total;
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief Dump current queue status
+ *
+ * \param[in] (none)
+ *
+ * \return (none)
+ */
+/*----------------------------------------------------------------------------*/
+uint32_t qmDumpQueueStatus(IN struct ADAPTER *prAdapter,
+	IN uint8_t *pucBuf, IN uint32_t u4Max)
+{
+	struct TX_CTRL *prTxCtrl;
+	struct QUE_MGT *prQM;
+	struct GLUE_INFO *prGlueInfo;
+	uint32_t i, u4TotalBufferCount, u4TotalPageCount;
+	uint32_t u4CurBufferCount, u4CurPageCount;
+	uint32_t u4Len = 0;
+
+	DEBUGFUNC(("%s", __func__));
+
+	ASSERT(prAdapter);
+
+	prTxCtrl = &prAdapter->rTxCtrl;
+	prQM = &prAdapter->rQM;
+	prGlueInfo = prAdapter->prGlueInfo;
+	u4TotalBufferCount = 0;
+	u4TotalPageCount = 0;
+	u4CurBufferCount = 0;
+	u4CurPageCount = 0;
+
+	LOGBUF(pucBuf, u4Max, u4Len, "\n");
+	LOGBUF(pucBuf, u4Max, u4Len,
+		"------<Dump QUEUE Status>------\n");
+
+	for (i = TC0_INDEX; i < TC_NUM; i++) {
+		LOGBUF(pucBuf, u4Max, u4Len,
+			"TC%u ResCount: Max[%02u/%03u] Free[%02u/%03u] PreUsed[%03u]\n",
+			i, prTxCtrl->rTc.au4MaxNumOfBuffer[i],
+			prTxCtrl->rTc.au4MaxNumOfPage[i],
+			prTxCtrl->rTc.au4FreeBufferCount[i],
+			prTxCtrl->rTc.au4FreePageCount[i],
+			prTxCtrl->rTc.au4PreUsedPageCount[i]);
+
+		u4TotalBufferCount += prTxCtrl->rTc.au4MaxNumOfBuffer[i];
+		u4TotalPageCount += prTxCtrl->rTc.au4MaxNumOfPage[i];
+		u4CurBufferCount += prTxCtrl->rTc.au4FreeBufferCount[i];
+		u4CurPageCount += prTxCtrl->rTc.au4FreePageCount[i];
+	}
+
+	LOGBUF(pucBuf, u4Max, u4Len,
+		"ToT ResCount: Max[%02u/%03u] Free[%02u/%03u]\n",
+		u4TotalBufferCount, u4TotalPageCount, u4CurBufferCount,
+		u4CurPageCount);
+
+	u4TotalBufferCount = 0;
+	u4TotalPageCount = 0;
+	u4CurBufferCount = 0;
+	u4CurPageCount = 0;
+	LOGBUF(pucBuf, u4Max, u4Len,
+		"------<Dump PLE QUEUE Status>------\n");
+
+	for (i = TC0_INDEX; i < TC_NUM; i++) {
+		LOGBUF(pucBuf, u4Max, u4Len,
+			"TC%u ResCount: Max[%02u/%03u] Free[%02u/%03u] PreUsed[%03u]\n",
+			i, prTxCtrl->rTc.au4MaxNumOfBuffer_PLE[i],
+			prTxCtrl->rTc.au4MaxNumOfPage_PLE[i],
+			prTxCtrl->rTc.au4FreeBufferCount_PLE[i],
+			prTxCtrl->rTc.au4FreePageCount_PLE[i],
+			prTxCtrl->rTc.au4PreUsedPageCount[i]);
+
+		u4TotalBufferCount += prTxCtrl->rTc.au4MaxNumOfBuffer_PLE[i];
+		u4TotalPageCount += prTxCtrl->rTc.au4MaxNumOfPage_PLE[i];
+		u4CurBufferCount += prTxCtrl->rTc.au4FreeBufferCount_PLE[i];
+		u4CurPageCount += prTxCtrl->rTc.au4FreePageCount_PLE[i];
+	}
+
+	LOGBUF(pucBuf, u4Max, u4Len,
+		"ToT ResCount: Max[%02u/%03u] Free[%02u/%03u]\n",
+		u4TotalBufferCount, u4TotalPageCount, u4CurBufferCount,
+		u4CurPageCount);
+
+	LOGBUF(pucBuf, u4Max, u4Len,
+		"---------------------------------\n");
+
+#if QM_ADAPTIVE_TC_RESOURCE_CTRL
+	for (i = TC0_INDEX; i < TC_NUM; i++) {
+		LOGBUF(pucBuf, u4Max, u4Len,
+			"TC%u AvgQLen[%04u] minRsv[%02u] CurTcRes[%02u] GrtdTcRes[%02u]\n",
+			i, QM_GET_TX_QUEUE_LEN(prAdapter, i),
+			prQM->au4MinReservedTcResource[i],
+			prQM->au4CurrentTcResource[i],
+			prQM->au4GuaranteedTcResource[i]);
+	}
+
+	LOGBUF(pucBuf, u4Max, u4Len,
+		"Resource Residual[%u] ExtraRsv[%u]\n",
+		prQM->u4ResidualTcResource,
+		prQM->u4ExtraReservedTcResource);
+	LOGBUF(pucBuf, u4Max, u4Len,
+		"QueLenMovingAvg[%u] Time2AdjResource[%u] Time2UpdateQLen[%u]\n",
+		prQM->u4QueLenMovingAverage, prQM->u4TimeToAdjustTcResource,
+		prQM->u4TimeToUpdateQueLen);
+#endif
+
+	DBGLOG(SW4, INFO, "---------------------------------\n");
+
+#if QM_FORWARDING_FAIRNESS
+	for (i = 0; i < NUM_OF_PER_STA_TX_QUEUES; i++) {
+		LOGBUF(pucBuf, u4Max, u4Len,
+			"TC%u HeadSta[%u] ResourceUsedCount[%u]\n",
+			i, prQM->au4HeadStaRecIndex[i],
+			prQM->au4ResourceUsedCount[i]);
+	}
+#endif
+
+	LOGBUF(pucBuf, u4Max, u4Len,
+		"BMC or unknown TxQueue Len[%u]\n",
+		prQM->arTxQueue[0].u4NumElem);
+	LOGBUF(pucBuf, u4Max, u4Len,
+		"Pending QLen Normal[%u] Sec[%u] Cmd[%u]\n",
+		GLUE_GET_REF_CNT(prGlueInfo->i4TxPendingFrameNum),
+		GLUE_GET_REF_CNT(prGlueInfo->i4TxPendingSecurityFrameNum),
+		GLUE_GET_REF_CNT(prGlueInfo->i4TxPendingCmdNum));
+
+#if defined(LINUX)
+	for (i = 0; i < prAdapter->ucHwBssIdNum; i++) {
+		LOGBUF(pucBuf, u4Max, u4Len,
+			"Pending BSS[%u] QLen[%u:%u:%u:%u]\n", i,
+			prGlueInfo->ai4TxPendingFrameNumPerQueue[i][0],
+			prGlueInfo->ai4TxPendingFrameNumPerQueue[i][1],
+			prGlueInfo->ai4TxPendingFrameNumPerQueue[i][2],
+			prGlueInfo->ai4TxPendingFrameNumPerQueue[i][3]);
+	}
+#endif
+	LOGBUF(pucBuf, u4Max, u4Len, "Pending FWD CNT[%d]\n",
+		prTxCtrl->i4PendingFwdFrameCount);
+	LOGBUF(pucBuf, u4Max, u4Len, "Pending MGMT CNT[%d]\n",
+		prTxCtrl->i4TxMgmtPendingNum);
+
+	LOGBUF(pucBuf, u4Max, u4Len,
+		"---------------------------------\n");
+
+	LOGBUF(pucBuf, u4Max, u4Len, "Total RFB[%u]\n",
+		CFG_RX_MAX_PKT_NUM);
+	LOGBUF(pucBuf, u4Max, u4Len, "rFreeSwRfbList[%u]\n",
+		prAdapter->rRxCtrl.rFreeSwRfbList.u4NumElem);
+	LOGBUF(pucBuf, u4Max, u4Len, "rReceivedRfbList[%u]\n",
+		prAdapter->rRxCtrl.rReceivedRfbList.u4NumElem);
+	LOGBUF(pucBuf, u4Max, u4Len, "rIndicatedRfbList[%u]\n",
+		prAdapter->rRxCtrl.rIndicatedRfbList.u4NumElem);
+	LOGBUF(pucBuf, u4Max, u4Len, "ucNumIndPacket[%u]\n",
+		prAdapter->rRxCtrl.ucNumIndPacket);
+	LOGBUF(pucBuf, u4Max, u4Len, "ucNumRetainedPacket[%u]\n",
+		prAdapter->rRxCtrl.ucNumRetainedPacket);
+
+	LOGBUF(pucBuf, u4Max, u4Len,
+		"---------------------------------\n");
+	LOGBUF(pucBuf, u4Max, u4Len,
+		"CMD: Free[%u/%u] PQ[%u] CQ[%u] TCQ[%u] TCDQ[%u]\n",
+		prAdapter->rFreeCmdList.u4NumElem,
+		CFG_TX_MAX_CMD_PKT_NUM,
+		prAdapter->rPendingCmdQueue.u4NumElem,
+		prGlueInfo->rCmdQueue.u4NumElem,
+		prAdapter->rTxCmdQueue.u4NumElem,
+		prAdapter->rTxCmdDoneQueue.u4NumElem);
+	LOGBUF(pucBuf, u4Max, u4Len,
+		"MSDU: Free[%u/%u] Pending[%u] Done[%u]\n",
+		prAdapter->rTxCtrl.rFreeMsduInfoList.u4NumElem,
+		CFG_TX_MAX_PKT_NUM,
+		prAdapter->rTxCtrl.rTxMgmtTxingQueue.u4NumElem,
+		prAdapter->rTxDataDoneQueue.u4NumElem);
+
+	LOGBUF(pucBuf, u4Max, u4Len,
+		"---------------------------------\n");
+	if (prGlueInfo->rCmdQueue.u4NumElem > 0)
+		cmdBufDumpCmdQueue(&prGlueInfo->rCmdQueue,
+				"waiting Tx CMD queue");
+
+	return u4Len;
+}
+
+#if CFG_M0VE_BA_TO_DRIVER
+/*----------------------------------------------------------------------------*/
+/*!
+ * @brief Send DELBA Action frame
+ *
+ * @param fgIsInitiator DELBA_ROLE_INITIATOR or DELBA_ROLE_RECIPIENT
+ * @param prStaRec Pointer to the STA_REC of the receiving peer
+ * @param u4Tid TID of the BA entry
+ * @param u4ReasonCode The reason code carried in the Action frame
+ *
+ * @return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void
+mqmSendDelBaFrame(IN struct ADAPTER *prAdapter,
+	IN u_int8_t fgIsInitiator, IN struct STA_RECORD *prStaRec,
+	IN uint32_t u4Tid, IN uint32_t u4ReasonCode)
+{
+
+	struct MSDU_INFO *prTxMsduInfo;
+	struct ACTION_DELBA_FRAME *prDelBaFrame;
+	struct BSS_INFO *prBssInfo;
+
+	DBGLOG(QM, WARN, "[Puff]: Enter mqmSendDelBaFrame()\n");
+
+	ASSERT(prStaRec);
+
+	/* 3 <1> Block the message in case of invalid STA */
+	if (!prStaRec->fgIsInUse) {
+		DBGLOG(QM, WARN,
+			"[Puff][%s]: (Warning) sta_rec is not inuse\n",
+			__func__);
+		return;
+	}
+	/* Check HT-capabale STA */
+	if (!(prStaRec->ucDesiredPhyTypeSet & PHY_TYPE_BIT_HT)) {
+		DBGLOG(QM, WARN,
+			"[Puff][%s]: (Warning) sta is NOT HT-capable(0x%08X)\n",
+			__func__,
+			prStaRec->ucDesiredPhyTypeSet);
+		return;
+	}
+	/* 4 <2> Construct the DELBA frame */
+	prTxMsduInfo = (struct MSDU_INFO *) cnmMgtPktAlloc(
+		prAdapter, ACTION_DELBA_FRAME_LEN);
+
+	if (!prTxMsduInfo) {
+		log_dbg(QM, WARN, "[Puff][%s]: (Warning) DELBA for TID=%ld was not sent (MSDU_INFO alloc failure)\n",
+			__func__, u4Tid);
+		return;
+	}
+
+	prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter,
+		prStaRec->ucBssIndex);
+
+	/* Fill the Action frame */
+	prDelBaFrame = (struct ACTION_DELBA_FRAME *)
+		((uint32_t) (prTxMsduInfo->prPacket) +
+		MAC_TX_RESERVED_FIELD);
+	prDelBaFrame->u2FrameCtrl = MAC_FRAME_ACTION;
+#if CFG_SUPPORT_802_11W
+	if (rsnCheckBipKeyInstalled(prAdapter, prStaRec)) {
+		DBGLOG(QM, WARN,
+			"[Puff][%s]: (Warning) DELBA is 80211w enabled\n",
+			__func__);
+		prDelBaFrame->u2FrameCtrl |= MASK_FC_PROTECTED_FRAME;
+	}
+#endif
+
+	prDelBaFrame->u2DurationID = 0;
+	prDelBaFrame->ucCategory = CATEGORY_BLOCK_ACK_ACTION;
+	prDelBaFrame->ucAction = ACTION_DELBA;
+
+	prDelBaFrame->u2DelBaParameterSet = 0;
+	prDelBaFrame->u2DelBaParameterSet |= ((fgIsInitiator ?
+		ACTION_DELBA_INITIATOR_MASK : 0));
+	prDelBaFrame->u2DelBaParameterSet |= ((u4Tid <<
+		ACTION_DELBA_TID_OFFSET) & ACTION_DELBA_TID_MASK);
+	prDelBaFrame->u2ReasonCode = u4ReasonCode;
+
+	COPY_MAC_ADDR(prDelBaFrame->aucDestAddr,
+		prStaRec->aucMacAddr);
+	COPY_MAC_ADDR(prDelBaFrame->aucSrcAddr,
+		prBssInfo->aucOwnMacAddr);
+	COPY_MAC_ADDR(prDelBaFrame->aucBSSID, prBssInfo->aucBSSID);
+
+	/* 4 <3> Configure the MSDU_INFO and forward it to TXM */
+	TX_SET_MMPDU(prAdapter,
+		prTxMsduInfo,
+		prStaRec->ucBssIndex,
+		(prStaRec != NULL) ? (prStaRec->ucIndex) :
+		(STA_REC_INDEX_NOT_FOUND),
+		WLAN_MAC_HEADER_LEN, ACTION_DELBA_FRAME_LEN, NULL,
+		MSDU_RATE_MODE_AUTO);
+
+	/* TID and fgIsInitiator are needed
+	 * when processing TX Done of the DELBA frame
+	 */
+	prTxMsduInfo->ucTID = (uint8_t) u4Tid;
+	prTxMsduInfo->ucControlFlag = (fgIsInitiator ? 1 : 0);
+
+	nicTxEnqueueMsdu(prAdapter, prTxMsduInfo);
+
+	DBGLOG(QM, WARN,
+		"[Puff][%s]: Send DELBA for TID=%ld Initiator=%d\n",
+		__func__, u4Tid, fgIsInitiator);
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * @brief Callback function for the TX Done event for an ADDBA_RSP
+ *
+ * @param prMsduInfo The TX packet
+ * @param rWlanStatus WLAN_STATUS_SUCCESS if TX is successful
+ *
+ * @return WLAN_STATUS_BUFFER_RETAINED is returned if the buffer shall not be
+ *         freed by TXM
+ */
+/*----------------------------------------------------------------------------*/
+uint32_t
+mqmCallbackAddBaRspSent(IN struct ADAPTER *prAdapter,
+	IN struct MSDU_INFO *prMsduInfo,
+	IN enum ENUM_TX_RESULT_CODE rTxDoneStatus)
+{
+	struct RX_BA_ENTRY *prRxBaEntry;
+	struct STA_RECORD *prStaRec;
+	struct QUE_MGT *prQM;
+
+	uint32_t u4Tid = 0;
+
+	/* ASSERT(prMsduInfo); */
+	prStaRec = cnmGetStaRecByIndex(prAdapter,
+		prMsduInfo->ucStaRecIndex);
+	ASSERT(prStaRec);
+
+	prQM = &prAdapter->rQM;
+
+	DBGLOG(QM, WARN,
+	       "[Puff]: Enter mqmCallbackAddBaRspSent()\n");
+
+	/* 4 <0> Check STA_REC status */
+	/* Check STA_REC is inuse */
+	if (!prStaRec->fgIsInUse) {
+		DBGLOG(QM, WARN, "[Puff][%s]: (Warning) sta_rec is not inuse\n",
+			__func__);
+		return WLAN_STATUS_SUCCESS;
+	}
+	/* Check HT-capabale STA */
+	if (!(prStaRec->ucDesiredPhyTypeSet & PHY_TYPE_BIT_HT)) {
+		DBGLOG(QM, WARN,
+			"[Puff][%s]: (Warning) sta is NOT HT-capable(0x%08X)\n",
+			__func__,
+			prStaRec->ucDesiredPhyTypeSet);
+		/* To free the received ADDBA_REQ directly */
+		return WLAN_STATUS_SUCCESS;
+	}
+	/* 4 <1> Find the corresponding BA entry */
+	/* TID is stored in MSDU_INFO when composing the ADDBA_RSP frame */
+	u4Tid = prMsduInfo->ucTID;
+	prRxBaEntry = &prQM->arRxBaTable[u4Tid];
+
+	/* Note: Due to some reason, for example, receiving a DELBA,
+	 * the BA entry may not be in state NEGO
+	 */
+	/* 4 <2> INVALID state */
+	if (!prRxBaEntry) {
+		log_dbg(QM, WARN, "[Puff][%s]: (RX_BA) ADDBA_RSP ---> peer (STA=%d TID=%d)(TX successful)(invalid BA)\n",
+			__func__, prStaRec->ucIndex, u4Tid);
+	}
+	/* 4 <3> NEGO, ACTIVE, or DELETING state */
+	else {
+		switch (rTxDoneStatus) {
+		/* 4 <Case 1> TX Success */
+		case TX_RESULT_SUCCESS:
+
+			DBGLOG(QM, WARN,
+				"[Puff][%s]: (RX_BA) ADDBA_RSP ---> peer (STA=%d TID=%d)(TX successful)\n",
+				__func__, prStaRec->ucIndex, u4Tid);
+
+			/* 4 <Case 1.1> NEGO or ACTIVE state */
+			if (prRxBaEntry->ucStatus != BA_ENTRY_STATUS_DELETING)
+				mqmRxModifyBaEntryStatus(prAdapter, prRxBaEntry,
+					BA_ENTRY_STATUS_ACTIVE);
+			break;
+
+		/* 4 <Case 2> TX Failure */
+		default:
+
+			log_dbg(QM, WARN, "[Puff][%s]: (RX_BA) ADDBA_RSP ---> peer (STA=%d TID=%ld Entry_Status=%d)(TX failed)\n",
+				__func__, prStaRec->ucIndex,
+				u4Tid, prRxBaEntry->ucStatus);
+
+			/* 4 <Case 2.1> NEGO or ACTIVE state */
+			/* Notify the host to delete the agreement */
+			if (prRxBaEntry->ucStatus != BA_ENTRY_STATUS_DELETING) {
+				mqmRxModifyBaEntryStatus(prAdapter, prRxBaEntry,
+					BA_ENTRY_STATUS_DELETING);
+
+				/* Send DELBA to the peer to ensure
+				 * the BA state is synchronized
+				 */
+				mqmSendDelBaFrame(prAdapter,
+					DELBA_ROLE_RECIPIENT,
+					prStaRec, u4Tid,
+					STATUS_CODE_UNSPECIFIED_FAILURE);
+			}
+			break;
+		}
+
+	}
+
+	return WLAN_STATUS_SUCCESS;	/* TXM shall release the packet */
+
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * @brief Check if there is any idle RX BA
+ *
+ * @param u4Param (not used)
+ *
+ * @return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void mqmTimeoutCheckIdleRxBa(IN struct ADAPTER *prAdapter,
+	IN unsigned long ulParamPtr)
+{
+	int8_t i;
+	struct RX_BA_ENTRY *prRxBa;
+	uint32_t u4IdleCountThreshold = 0;
+	struct STA_RECORD *prStaRec;
+	struct QUE_MGT *prQM;
+
+	DBGLOG(QM, WARN,
+		"[Puff]: Enter mqmTimeoutIdleRxBaDetection()\n");
+
+	prQM = &prAdapter->rQM;
+
+	/* 4 <1> Restart the timer */
+	cnmTimerStopTimer(prAdapter,
+		&prAdapter->rMqmIdleRxBaDetectionTimer);
+	cnmTimerStartTimer(prAdapter,
+		&prAdapter->rMqmIdleRxBaDetectionTimer,
+		MQM_IDLE_RX_BA_CHECK_INTERVAL);
+
+	/* 4 <2> Increment the idle count for each idle BA */
+	for (i = 0; i < CFG_NUM_OF_RX_BA_AGREEMENTS; i++) {
+
+		prRxBa = &prQM->arRxBaTable[i];
+
+		if (prRxBa->ucStatus == BA_ENTRY_STATUS_ACTIVE) {
+
+			prStaRec = cnmGetStaRecByIndex(prAdapter,
+				prRxBa->ucStaRecIdx);
+
+			if (!prStaRec->fgIsInUse) {
+				DBGLOG(QM, WARN,
+					"[Puff][%s]: (Warning) sta_rec is not inuse\n",
+					__func__);
+				ASSERT(0);
+			}
+			/* Check HT-capabale STA */
+			if (!(prStaRec->ucDesiredPhyTypeSet &
+				PHY_TYPE_BIT_HT)) {
+				DBGLOG(QM, WARN,
+					"[Puff][%s]: (Warning) sta is NOT HT-capable(0x%08X)\n",
+					__func__,
+					prStaRec->ucDesiredPhyTypeSet);
+				ASSERT(0);
+			}
+			/* 4 <2.1>  Idle detected, increment idle count
+			 * and see if a DELBA should be sent
+			 */
+			if (prRxBa->u2SnapShotSN ==
+			    prStaRec->au2CachedSeqCtrl[prRxBa->ucTid]) {
+
+				prRxBa->ucIdleCount++;
+
+				ASSERT(prRxBa->ucTid < 8);
+				switch (aucTid2ACI[prRxBa->ucTid]) {
+				case 0:	/* BK */
+					u4IdleCountThreshold =
+						MQM_DEL_IDLE_RXBA_THRESHOLD_BK;
+					break;
+				case 1:	/* BE */
+					u4IdleCountThreshold =
+						MQM_DEL_IDLE_RXBA_THRESHOLD_BE;
+					break;
+				case 2:	/* VI */
+					u4IdleCountThreshold =
+						MQM_DEL_IDLE_RXBA_THRESHOLD_VI;
+					break;
+				case 3:	/* VO */
+					u4IdleCountThreshold =
+						MQM_DEL_IDLE_RXBA_THRESHOLD_VO;
+					break;
+				}
+
+				if (prRxBa->ucIdleCount >=
+					u4IdleCountThreshold) {
+					mqmRxModifyBaEntryStatus(prAdapter,
+						prRxBa,
+						BA_ENTRY_STATUS_INVALID);
+					mqmSendDelBaFrame(prAdapter,
+						DELBA_ROLE_RECIPIENT, prStaRec,
+						(uint32_t) prRxBa->ucTid,
+						REASON_CODE_PEER_TIME_OUT);
+					qmDelRxBaEntry(prAdapter,
+						prStaRec->ucIndex,
+						prRxBa->ucTid, TRUE);
+				}
+			}
+			/* 4 <2.2> Activity detected */
+			else {
+				prRxBa->u2SnapShotSN =
+					prStaRec->au2CachedSeqCtrl[
+					prRxBa->ucTid];
+				prRxBa->ucIdleCount = 0;
+				continue;	/* check the next BA entry */
+			}
+		}
+	}
+
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * @brief Do RX BA entry state transition
+ *
+ * @param prRxBaEntry The BA entry pointer
+ * @param eStatus The state to transition to
+ *
+ * @return (none)
+ */
+/*----------------------------------------------------------------------------*/
+void
+mqmRxModifyBaEntryStatus(IN struct ADAPTER *prAdapter,
+	IN struct RX_BA_ENTRY *prRxBaEntry,
+	IN enum ENUM_BA_ENTRY_STATUS eStatus)
+{
+	struct STA_RECORD *prStaRec;
+	struct QUE_MGT *prQM;
+
+	u_int8_t fgResetScoreBoard = FALSE;
+
+	ASSERT(prRxBaEntry);
+
+	prStaRec = cnmGetStaRecByIndex(prAdapter,
+				       prRxBaEntry->ucStaRecIdx);
+	ASSERT(prStaRec);
+	prQM = &prAdapter->rQM;
+
+	if (prRxBaEntry->ucStatus == (uint8_t) eStatus) {
+		DBGLOG(QM, WARN, "[Puff][%s]: eStatus are identical...\n",
+			__func__, prRxBaEntry->ucStatus);
+		return;
+	}
+	/* 4 <1> State transition from state X */
+	switch (prRxBaEntry->ucStatus) {
+
+	/* 4 <1.1> From (X = INVALID) to (ACTIVE or NEGO or DELETING) */
+	case BA_ENTRY_STATUS_INVALID:
+
+		/* Associate the BA entry with the STA_REC
+		 * when leaving INVALID state
+		 */
+		kalMemCopy(&prQM->arRxBaTable[prRxBaEntry->ucTid],
+			   prRxBaEntry, sizeof(struct RX_BA_ENTRY));
+
+		/* Increment the RX BA counter */
+		prQM->ucRxBaCount++;
+		ASSERT(prQM->ucRxBaCount <= CFG_NUM_OF_RX_BA_AGREEMENTS);
+
+		/* Since AMPDU may be received during INVALID state */
+		fgResetScoreBoard = TRUE;
+
+		/* Reset Idle Count since this BA entry is being activated now.
+		 *  Note: If there is no ACTIVE entry,
+		 *  the idle detection timer will not be started.
+		 */
+		prRxBaEntry->ucIdleCount = 0;
+		break;
+
+	/* 4 <1.2> Other cases */
+	default:
+		break;
+	}
+
+	/* 4 <2> State trasition to state Y */
+	switch (eStatus) {
+
+	/* 4 <2.1> From  (NEGO, ACTIVE, DELETING) to (Y=INVALID) */
+	case BA_ENTRY_STATUS_INVALID:
+
+		/* Disassociate the BA entry with the STA_REC */
+		kalMemZero(&prQM->arRxBaTable[prRxBaEntry->ucTid],
+			sizeof(struct RX_BA_ENTRY));
+
+		/* Decrement the RX BA counter */
+		prQM->ucRxBaCount--;
+		ASSERT(prQM->ucRxBaCount < CFG_NUM_OF_RX_BA_AGREEMENTS);
+
+		/* (TBC) */
+		fgResetScoreBoard = TRUE;
+
+		/* If there is not any BA agreement,
+		 * stop doing idle detection
+		 */
+		if (prQM->ucRxBaCount == 0) {
+			if (MQM_CHECK_FLAG(prAdapter->u4FlagBitmap,
+				MQM_FLAG_IDLE_RX_BA_TIMER_STARTED)) {
+				cnmTimerStopTimer(prAdapter,
+					&prAdapter->rMqmIdleRxBaDetectionTimer);
+				MQM_CLEAR_FLAG(prAdapter->u4FlagBitmap,
+					MQM_FLAG_IDLE_RX_BA_TIMER_STARTED);
+			}
+		}
+
+		break;
+
+	/* 4 <2.2> From  (any) to (Y=ACTIVE) */
+	case BA_ENTRY_STATUS_ACTIVE:
+
+		/* If there is at least one BA going into ACTIVE,
+		 * start idle detection
+		 */
+		if (!MQM_CHECK_FLAG(prAdapter->u4FlagBitmap,
+			MQM_FLAG_IDLE_RX_BA_TIMER_STARTED)) {
+			cnmTimerInitTimer(prAdapter,
+				&prAdapter->rMqmIdleRxBaDetectionTimer,
+				(PFN_MGMT_TIMEOUT_FUNC) mqmTimeoutCheckIdleRxBa,
+				(unsigned long) NULL);
+			/* No parameter */
+
+			cnmTimerStopTimer(prAdapter,
+				&prAdapter->rMqmIdleRxBaDetectionTimer);
+
+#if MQM_IDLE_RX_BA_DETECTION
+			cnmTimerStartTimer(prAdapter,
+				&prAdapter->rMqmIdleRxBaDetectionTimer,
+				MQM_IDLE_RX_BA_CHECK_INTERVAL);
+			MQM_SET_FLAG(prAdapter->u4FlagBitmap,
+				MQM_FLAG_IDLE_RX_BA_TIMER_STARTED);
+#endif
+		}
+
+		break;
+
+	case BA_ENTRY_STATUS_NEGO:
+	default:
+		break;
+	}
+
+	if (fgResetScoreBoard) {
+		struct CMD_RESET_BA_SCOREBOARD *prCmdBody;
+
+		prCmdBody = (struct CMD_RESET_BA_SCOREBOARD *)
+			cnmMemAlloc(prAdapter, RAM_TYPE_BUF,
+			sizeof(struct CMD_RESET_BA_SCOREBOARD));
+		ASSERT(prCmdBody);
+
+		prCmdBody->ucflag = MAC_ADDR_TID_MATCH;
+		prCmdBody->ucTID = prRxBaEntry->ucTid;
+		kalMemCopy(prCmdBody->aucMacAddr, prStaRec->aucMacAddr,
+			PARAM_MAC_ADDR_LEN);
+
+		wlanoidResetBAScoreboard(prAdapter, prCmdBody,
+			sizeof(struct CMD_RESET_BA_SCOREBOARD));
+
+		cnmMemFree(prAdapter, prCmdBody);
+	}
+
+	DBGLOG(QM, WARN,
+		"[Puff]QM: (RX_BA) [STA=%d TID=%d] status from %d to %d\n",
+		prRxBaEntry->ucStaRecIdx, prRxBaEntry->ucTid,
+		prRxBaEntry->ucStatus, eStatus);
+
+	prRxBaEntry->ucStatus = (uint8_t) eStatus;
+
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief
+ *
+ * \param[in]
+ *
+ * \return none
+ */
+/*----------------------------------------------------------------------------*/
+void mqmHandleAddBaReq(IN struct ADAPTER *prAdapter,
+	IN struct SW_RFB *prSwRfb)
+{
+	struct STA_RECORD *prStaRec;
+	struct BSS_INFO *prBssInfo;
+	struct ACTION_ADDBA_REQ_FRAME *prAddBaReq;
+	struct ACTION_ADDBA_REQ_BODY rAddBaReqBody;
+	struct ACTION_ADDBA_RSP_FRAME *prAddBaRsp;
+	struct ACTION_ADDBA_RSP_BODY rAddBaRspBody;
+	struct RX_BA_ENTRY *prRxBaEntry;
+	struct MSDU_INFO *prTxMsduInfo;
+	struct QUE_MGT *prQM;
+
+	/* Reject or accept the ADDBA_REQ */
+	u_int8_t fgIsReqAccepted = TRUE;
+	/* Indicator: Whether a new RX BA entry will be added */
+	u_int8_t fgIsNewEntryAdded = FALSE;
+
+	uint32_t u4Tid;
+	uint32_t u4StaRecIdx;
+	uint16_t u2WinStart;
+	uint16_t u2WinSize;
+	uint32_t u4BuffSize;
+
+#if CFG_SUPPORT_BCM
+	uint32_t u4BuffSizeBT;
+#endif
+
+	ASSERT(prSwRfb);
+
+	prStaRec = prSwRfb->prStaRec;
+	prQM = &prAdapter->rQM;
+
+	do {
+
+		/* 4 <0> Check if this is an active HT-capable STA */
+		/* Check STA_REC is inuse */
+		if (!prStaRec->fgIsInUse) {
+			log_dbg(QM, WARN, "[Puff][%s]: (Warning) sta_rec is not inuse\n",
+				__func__);
+			break;
+		}
+		/* Check HT-capabale STA */
+		if (!(prStaRec->ucDesiredPhyTypeSet & PHY_TYPE_BIT_HT)) {
+			DBGLOG(QM, WARN,
+				"[Puff][%s]: (Warning) sta is NOT HT-capable(0x%08X)\n",
+				__func__,
+				prStaRec->ucDesiredPhyTypeSet);
+			break;	/* To free the received ADDBA_REQ directly */
+		}
+		/* 4 <1> Check user configurations and HW capabilities */
+		/* Check configurations (QoS support, AMPDU RX support) */
+		if ((!prAdapter->rWifiVar.fgSupportQoS) ||
+		    (!prAdapter->rWifiVar.fgSupportAmpduRx) ||
+		    (!prStaRec->fgRxAmpduEn)) {
+			DBGLOG(QM, WARN,
+				"[Puff][%s]: (Warning) BA ACK Policy not supported fgSupportQoS(%d)",
+				__func__, prAdapter->rWifiVar.fgSupportQoS);
+			DBGLOG(QM, WARN,
+				"fgSupportAmpduRx(%d), fgRxAmpduEn(%d)\n",
+				prAdapter->rWifiVar.fgSupportAmpduRx,
+				prStaRec->fgRxAmpduEn);
+			/* Will send an ADDBA_RSP with DECLINED */
+			fgIsReqAccepted = FALSE;
+		}
+		/* Check capability */
+		prAddBaReq = ((struct ACTION_ADDBA_REQ_FRAME *) (
+			prSwRfb->pvHeader));
+		kalMemCopy((uint8_t *) (&rAddBaReqBody),
+			(uint8_t *) (&(prAddBaReq->aucBAParameterSet[0])),
+			6);
+		if ((((rAddBaReqBody.u2BAParameterSet) &
+		      BA_PARAM_SET_ACK_POLICY_MASK) >>
+		     BA_PARAM_SET_ACK_POLICY_MASK_OFFSET)
+		    != BA_PARAM_SET_ACK_POLICY_IMMEDIATE_BA) {
+		  /* Only Immediate_BA is supported */
+			DBGLOG(QM, WARN,
+				"[Puff][%s]: (Warning) BA ACK Policy not supported (0x%08X)\n",
+				__func__, rAddBaReqBody.u2BAParameterSet);
+			/* Will send an ADDBA_RSP with DECLINED */
+			fgIsReqAccepted = FALSE;
+		}
+
+		/* 4 <2> Determine the RX BA entry (existing or to be added) */
+		/* Note: BA entry index = (TID, STA_REC index) */
+		u4Tid = (((rAddBaReqBody.u2BAParameterSet) &
+			  BA_PARAM_SET_TID_MASK) >>
+			  BA_PARAM_SET_TID_MASK_OFFSET);
+		u4StaRecIdx = prStaRec->ucIndex;
+		DBGLOG(QM, WARN,
+			"[Puff][%s]: BA entry index = [TID(%d), STA_REC index(%d)]\n",
+			__func__, u4Tid, u4StaRecIdx);
+
+		u2WinStart = ((rAddBaReqBody.u2BAStartSeqCtrl) >>
+			OFFSET_BAR_SSC_SN);
+		u2WinSize = (((rAddBaReqBody.u2BAParameterSet) &
+			BA_PARAM_SET_BUFFER_SIZE_MASK) >>
+			BA_PARAM_SET_BUFFER_SIZE_MASK_OFFSET);
+		DBGLOG(QM, WARN,
+			"[Puff][%s]: BA entry info = [WinStart(%d), WinSize(%d)]\n",
+			__func__, u2WinStart, u2WinSize);
+
+		if (fgIsReqAccepted) {
+
+			prRxBaEntry = &prQM->arRxBaTable[u4Tid];
+
+			if (!prRxBaEntry) {
+
+				/* 4 <Case 2.1> INVALID state && BA entry
+				 *   available --> Add a new entry and accept
+				 */
+				if (prQM->ucRxBaCount <
+					CFG_NUM_OF_RX_BA_AGREEMENTS) {
+
+					fgIsNewEntryAdded =
+						qmAddRxBaEntry(prAdapter,
+						(uint8_t) u4StaRecIdx,
+						(uint8_t) u4Tid, u2WinStart,
+						u2WinSize);
+
+					if (!fgIsNewEntryAdded) {
+						DBGLOG(QM, ERROR,
+							"[Puff][%s]: (Error) Free RX BA entry alloc failure\n");
+						fgIsReqAccepted = FALSE;
+					} else {
+						log_dbg(QM, WARN, "[Puff][%s]: Create a new BA Entry\n");
+					}
+				}
+				/* 4 <Case 2.2> INVALID state && BA entry
+				 *   unavailable --> Reject the ADDBA_REQ
+				 */
+				else {
+					log_dbg(QM, WARN, "[Puff][%s]: (Warning) Free RX BA entry unavailable(req: %d)\n",
+						__func__, prQM->ucRxBaCount);
+					/* Will send ADDBA_RSP with DECLINED */
+					fgIsReqAccepted = FALSE;
+				}
+			} else {
+
+				/* 4 <Case 2.3> NEGO or DELETING  state -->
+				 * Ignore the ADDBA_REQ
+				 * For NEGO: do nothing. Wait for TX Done of
+				 * ADDBA_RSP
+				 * For DELETING: do nothing. Wait for TX Done
+				 * of DELBA
+				 */
+				if (prRxBaEntry->ucStatus !=
+					BA_ENTRY_STATUS_ACTIVE) {
+					/* Ignore the ADDBA_REQ since
+					 * the current state is NEGO
+					 */
+					log_dbg(QM, WARN, "[Puff][%s]:(Warning)ADDBA_REQ for TID=%ld is received, status:%d)\n",
+						__func__, u4Tid,
+						prRxBaEntry->ucStatus);
+					break;
+				}
+			}
+		}
+		/* 4 <3> Construct the ADDBA_RSP frame */
+		prTxMsduInfo = (struct MSDU_INFO *) cnmMgtPktAlloc(
+				       prAdapter, ACTION_ADDBA_RSP_FRAME_LEN);
+		prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter,
+						  prStaRec->ucBssIndex);
+
+		if (!prTxMsduInfo) {
+
+			/* The peer may send an ADDBA_REQ message later.
+			 *  Do nothing to the BA entry. No DELBA will be
+			 *  sent (because cnmMgtPktAlloc() may fail again).
+			 *  No BA deletion event will be sent to the host
+			 *  (because cnmMgtPktAlloc() may fail again).
+			 */
+			DBGLOG(QM, WARN,
+				"[Puff][%s]: (Warning) ADDBA_RSP alloc failure\n",
+				__func__);
+
+			if (fgIsNewEntryAdded) {
+				/* If a new entry has been created due
+				 * to this ADDBA_REQ, delete it
+				 */
+				ASSERT(prRxBaEntry);
+				mqmRxModifyBaEntryStatus(prAdapter,
+					prRxBaEntry, BA_ENTRY_STATUS_INVALID);
+			}
+
+			break;	/* Exit directly to free the ADDBA_REQ */
+		}
+
+		/* Fill the ADDBA_RSP message */
+		prAddBaRsp = (struct ACTION_ADDBA_RSP_FRAME *)
+			((uint32_t) (prTxMsduInfo->prPacket) +
+				MAC_TX_RESERVED_FIELD);
+		prAddBaRsp->u2FrameCtrl = MAC_FRAME_ACTION;
+
+#if CFG_SUPPORT_802_11W
+		if (rsnCheckBipKeyInstalled(prAdapter, prStaRec)) {
+			DBGLOG(QM, WARN,
+				"[Puff][%s]: (Warning) ADDBA_RSP is 80211w enabled\n",
+				__func__);
+			prAddBaReq->u2FrameCtrl |= MASK_FC_PROTECTED_FRAME;
+		}
+#endif
+		prAddBaRsp->u2DurationID = 0;
+		prAddBaRsp->ucCategory = CATEGORY_BLOCK_ACK_ACTION;
+		prAddBaRsp->ucAction = ACTION_ADDBA_RSP;
+		prAddBaRsp->ucDialogToken = prAddBaReq->ucDialogToken;
+
+		log_dbg(QM, WARN, "[Puff][%s]: (Warning) ADDBA_RSP DurationID(%d) Category(%d) Action(%d) DialogToken(%d)\n",
+			__func__, prAddBaRsp->u2DurationID,
+			prAddBaRsp->ucCategory, prAddBaRsp->ucAction,
+			prAddBaRsp->ucDialogToken);
+
+		if (fgIsReqAccepted)
+			rAddBaRspBody.u2StatusCode = STATUS_CODE_SUCCESSFUL;
+		else
+			rAddBaRspBody.u2StatusCode = STATUS_CODE_REQ_DECLINED;
+
+		/* WinSize = min(WinSize in ADDBA_REQ, CFG_RX_BA_MAX_WINSIZE) */
+		u4BuffSize = (((rAddBaReqBody.u2BAParameterSet) &
+			BA_PARAM_SET_BUFFER_SIZE_MASK) >>
+			BA_PARAM_SET_BUFFER_SIZE_MASK_OFFSET);
+
+		/*If ADDBA req WinSize<=0 => use default WinSize(16) */
+		if ((u4BuffSize > CFG_RX_BA_MAX_WINSIZE)
+		    || (u4BuffSize <= 0))
+			u4BuffSize = CFG_RX_BA_MAX_WINSIZE;
+#if CFG_SUPPORT_BCM
+		/* TODO: Call BT coexistence function to limit the winsize */
+		u4BuffSizeBT = bcmRequestBaWinSize();
+		DBGLOG(QM, WARN,
+			"[Puff][%s]: (Warning) bcmRequestBaWinSize(%d)\n",
+			__func__, u4BuffSizeBT);
+
+		if (u4BuffSize > u4BuffSizeBT)
+			u4BuffSize = u4BuffSizeBT;
+#endif /* CFG_SUPPORT_BCM */
+
+		rAddBaRspBody.u2BAParameterSet = (BA_POLICY_IMMEDIATE |
+			(u4Tid << BA_PARAM_SET_TID_MASK_OFFSET) |
+			(u4BuffSize << BA_PARAM_SET_BUFFER_SIZE_MASK_OFFSET));
+
+		/* TODO: Determine the BA timeout value
+		 * according to the default preference
+		 */
+		rAddBaRspBody.u2BATimeoutValue =
+			rAddBaReqBody.u2BATimeoutValue;
+
+		DBGLOG(QM, WARN,
+			"[Puff][%s]: (Warning) ADDBA_RSP u4BuffSize(%d) StatusCode(%d)",
+			__func__, u4BuffSize, rAddBaRspBody.u2StatusCode);
+		DBGLOG(QM, WARN,
+			"BAParameterSet(0x%08X) BATimeoutValue(%d)\n",
+			rAddBaRspBody.u2BAParameterSet,
+			rAddBaRspBody.u2BATimeoutValue);
+		kalMemCopy((uint8_t *) (&(prAddBaRsp->aucStatusCode[0])),
+			(uint8_t *) (&rAddBaRspBody), 6);
+
+		COPY_MAC_ADDR(prAddBaRsp->aucDestAddr,
+			prStaRec->aucMacAddr);
+		COPY_MAC_ADDR(prAddBaRsp->aucSrcAddr,
+			prBssInfo->aucOwnMacAddr);
+		COPY_MAC_ADDR(prAddBaRsp->aucBSSID, prAddBaReq->aucBSSID);
+
+		/* 4 <4> Forward the ADDBA_RSP to TXM */
+		TX_SET_MMPDU(prAdapter,
+			prTxMsduInfo,
+			prStaRec->ucBssIndex,
+			(prStaRec != NULL) ? (prStaRec->ucIndex) :
+			(STA_REC_INDEX_NOT_FOUND),
+			WLAN_MAC_HEADER_LEN,
+			ACTION_ADDBA_RSP_FRAME_LEN,
+			mqmCallbackAddBaRspSent,
+			MSDU_RATE_MODE_AUTO);
+
+		/* Note: prTxMsduInfo->ucTID is not used for transmitting the
+		 * ADDBA_RSP. However, when processing TX Done of this
+		 * ADDBA_RSP, the TID value is needed, so store the TID value
+		 * in advance to prevent parsing the ADDBA_RSP frame
+		 */
+		prTxMsduInfo->ucTID = (uint8_t) u4Tid;
+
+		nicTxEnqueueMsdu(prAdapter, prTxMsduInfo);
+
+		DBGLOG(QM, WARN,
+			"[Puff][%s]: (RX_BA) ADDBA_RSP ---> peer (STA=%d TID=%ld)\n",
+			__func__,
+			prStaRec->ucIndex, u4Tid);
+
+#if 0
+		/* 4 <5> Notify the host to start buffer reordering */
+		/* Only when a new BA entry is indeed
+		 * added will the host be notified
+		 */
+		if (fgIsNewEntryAdded) {
+			ASSERT(fgIsReqAccepted);
+
+			prSwRfbEventToHost = (struct SW_RFB *) cnmMgtPktAlloc(
+				EVENT_RX_ADDBA_PACKET_LEN);
+
+			if (!prSwRfbEventToHost) {
+
+				/* Note: DELBA will not be sent since
+				 * cnmMgtPktAlloc() may fail again. However,
+				 * it does not matter because upon receipt of
+				 * AMPDUs without a RX BA agreement,
+				 * MQM will send DELBA frames
+				 */
+
+				DBGLOG(MQM, WARN,
+					"MQM: (Warning) EVENT packet alloc failed\n");
+
+				/* Ensure that host and FW are synchronized */
+				mqmRxModifyBaEntryStatus(prRxBaEntry,
+					BA_ENTRY_STATUS_INVALID);
+
+				break;	/* Free the received ADDBA_REQ */
+			}
+			prEventRxAddBa = (struct EVENT_RX_ADDBA *)
+					 prSwRfbEventToHost->pucBuffer;
+			prEventRxAddBa->ucStaRecIdx = (uint8_t) u4StaRecIdx;
+			prEventRxAddBa->u2Length = EVENT_RX_ADDBA_PACKET_LEN;
+			prEventRxAddBa->ucEID = EVENT_ID_RX_ADDBA;
+			/* Unsolicited event packet */
+			prEventRxAddBa->ucSeqNum = 0;
+			prEventRxAddBa->u2BAParameterSet =
+				rAddBaRspBody.u2BAParameterSet;
+			prEventRxAddBa->u2BAStartSeqCtrl =
+				rAddBaReqBody.u2BAStartSeqCtrl;
+			prEventRxAddBa->u2BATimeoutValue =
+				rAddBaReqBody.u2BATimeoutValue;
+			prEventRxAddBa->ucDialogToken =
+				prAddBaReq->ucDialogToken;
+
+			log_dbg(MQM, INFO, "MQM: (RX_BA) Event ADDBA ---> driver (STA=%ld TID=%ld WinStart=%d)\n",
+				u4StaRecIdx, u4Tid,
+				(prEventRxAddBa->u2BAStartSeqCtrl >> 4));
+
+			/* Configure the SW_RFB for the Event packet */
+			RXM_SET_EVENT_PACKET(
+				/* struct SW_RFB **/ (struct SW_RFB *)
+				prSwRfbEventToHost,
+				/* HIF RX Packet pointer */
+				(uint8_t *) prEventRxAddBa,
+				/* HIF RX port number */ HIF_RX0_INDEX
+			);
+
+			rxmSendEventToHost(prSwRfbEventToHost);
+
+
+		}
+#endif
+
+	} while (FALSE);
+
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief
+ *
+ * \param[in]
+ *
+ * \return none
+ */
+/*----------------------------------------------------------------------------*/
+void mqmHandleAddBaRsp(IN struct SW_RFB *prSwRfb)
+{
+
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief
+ *
+ * \param[in]
+ *
+ * \return none
+ */
+/*----------------------------------------------------------------------------*/
+void mqmHandleDelBa(IN struct SW_RFB *prSwRfb)
+{
+
+}
+
+/*----------------------------------------------------------------------------*/
+/*!
+ * \brief
+ *
+ * \param[in]
+ *
+ * \return none
+ */
+/*----------------------------------------------------------------------------*/
+void mqmHandleBaActionFrame(IN struct ADAPTER *prAdapter,
+	IN struct SW_RFB *prSwRfb)
+{
+	struct WLAN_ACTION_FRAME *prRxFrame;
+
+	ASSERT(prAdapter);
+	ASSERT(prSwRfb);
+
+	prRxFrame = (struct WLAN_ACTION_FRAME *) prSwRfb->pvHeader;
+	DBGLOG(RLM, WARN, "[Puff][%s] Action(%d)\n", __func__,
+		prRxFrame->ucAction);
+
+	switch (prRxFrame->ucAction) {
+
+	case ACTION_ADDBA_REQ:
+		DBGLOG(RLM, WARN,
+			"[Puff][%s] (RX_BA) ADDBA_REQ <--- peer\n", __func__);
+		mqmHandleAddBaReq(prAdapter, prSwRfb);
+		break;
+
+	case ACTION_ADDBA_RSP:
+		DBGLOG(RLM, WARN,
+			"[Puff][%s] (RX_BA) ADDBA_RSP <--- peer\n", __func__);
+		mqmHandleAddBaRsp(prSwRfb);
+		break;
+
+	case ACTION_DELBA:
+		DBGLOG(RLM, WARN, "[Puff][%s] (RX_BA) DELBA <--- peer\n",
+			__func__);
+		mqmHandleDelBa(prSwRfb);
+		break;
+
+	default:
+		DBGLOG(RLM, WARN, "[Puff][%s] Unknown BA Action Frame\n",
+			__func__);
+		break;
+	}
+
+}
+
+#endif
+
+#if ARP_MONITER_ENABLE
+void qmDetectArpNoResponse(struct ADAPTER *prAdapter,
+	struct MSDU_INFO *prMsduInfo)
+{
+	struct STA_RECORD *prStaRec;
+	struct sk_buff *prSkb = NULL;
+	uint8_t *pucData = NULL;
+	uint16_t u2EtherType = 0;
+	int arpOpCode = 0;
+	struct BSS_INFO *prAisBssInfo = NULL;
+	struct WIFI_VAR *prWifiVar = NULL;
+	uint32_t uArpMonitorNumber;
+	uint32_t uArpMonitorRxPktNum;
+	struct net_device *prNetDev = NULL;
+	struct GLUE_INFO *prGlueInfo = NULL;
+
+	if (!prAdapter ||
+		!prAdapter->prGlueInfo ||
+		!prAdapter->prGlueInfo->prDevHandler) {
+		DBGLOG(QM, WARN, "Param is invalid\n");
+		return;
+	}
+	prGlueInfo = prAdapter->prGlueInfo;
+	prNetDev = prGlueInfo->prDevHandler;
+	prWifiVar = &prAdapter->rWifiVar;
+	uArpMonitorNumber = prWifiVar->uArpMonitorNumber;
+	uArpMonitorRxPktNum = prWifiVar->uArpMonitorRxPktNum;
+
+	if (uArpMonitorNumber == 0)
+		return;
+
+	/* We need to disable arp monitor in CTIA mode */
+	if (prAdapter->fgDisBcnLostDetection == TRUE)
+		return;
+
+	prStaRec = QM_GET_STA_REC_PTR_FROM_INDEX(
+		prAdapter, prMsduInfo->ucStaRecIndex);
+	if (!prStaRec || !IS_STA_IN_AIS(prStaRec))
+		return;
+
+	prAisBssInfo = aisGetAisBssInfo(prAdapter,
+		prStaRec->ucBssIndex);
+
+	if (prMsduInfo->eSrc != TX_PACKET_OS)
+		return;
+
+	prSkb = (struct sk_buff *)prMsduInfo->prPacket;
+
+	if (!prSkb || (prSkb->len <= ETHER_HEADER_LEN))
+		return;
+
+	pucData = prSkb->data;
+	if (!pucData)
+		return;
+	u2EtherType = (pucData[ETH_TYPE_LEN_OFFSET] << 8) |
+		(pucData[ETH_TYPE_LEN_OFFSET + 1]);
+
+	if (u2EtherType != ETH_P_ARP)
+		return;
+
+	/* If ARP req is neither to apIp nor to gatewayIp, ignore detection */
+	if (kalMemCmp(apIp, &pucData[ETH_TYPE_LEN_OFFSET + 26],
+		sizeof(apIp)) &&
+		kalMemCmp(gatewayIp, &pucData[ETH_TYPE_LEN_OFFSET + 26],
+		sizeof(gatewayIp)))
+		return;
+
+	arpOpCode = (pucData[ETH_TYPE_LEN_OFFSET + 8] << 8) |
+		(pucData[ETH_TYPE_LEN_OFFSET + 8 + 1]);
+
+	if (arpOpCode == ARP_PRO_REQ) {
+		arpMoniter++;
+		/* Record counts of RX Packets when Tx 1st ARP Req */
+		if (!last_rx_packets) {
+			last_rx_packets = prNetDev->stats.rx_packets;
+			latest_rx_packets = 0;
+		}
+		/* Record counts of RX Packets when TX ARP Req recently */
+		latest_rx_packets = prNetDev->stats.rx_packets;
+		if (arpMoniter > uArpMonitorNumber) {
+			if ((latest_rx_packets - last_rx_packets) <=
+				uArpMonitorRxPktNum) {
+				DBGLOG(INIT, WARN, "IOT issue, arp no resp!\n");
+				if (prAisBssInfo)
+					prAisBssInfo->u2DeauthReason =
+				BEACON_TIMEOUT_DUE_2_APR_NO_RESPONSE;
+				prAdapter->cArpNoResponseIdx =
+				prStaRec->ucBssIndex;
+			} else
+				DBGLOG(INIT, WARN, "ARP, still have %d pkts\n",
+					latest_rx_packets - last_rx_packets);
+			arpMoniter = 0;
+			last_rx_packets = 0;
+			latest_rx_packets = 0;
+			kalMemZero(apIp, sizeof(apIp));
+		}
+	}
+}
+
+void qmHandleRxArpPackets(struct ADAPTER *prAdapter,
+	struct SW_RFB *prSwRfb)
+{
+	uint8_t *pucData = NULL;
+	uint16_t u2EtherType = 0;
+	int arpOpCode = 0;
+	struct BSS_INFO *prAisBssInfo = NULL;
+
+	prAisBssInfo = aisGetAisBssInfo(prAdapter,
+		secGetBssIdxByRfb(prAdapter, prSwRfb));
+
+	if (prSwRfb->u2PacketLen <= ETHER_HEADER_LEN)
+		return;
+
+	pucData = (uint8_t *)prSwRfb->pvHeader;
+	if (!pucData)
+		return;
+	u2EtherType = (pucData[ETH_TYPE_LEN_OFFSET] << 8) |
+		(pucData[ETH_TYPE_LEN_OFFSET + 1]);
+
+	if (u2EtherType != ETH_P_ARP)
+		return;
+
+	arpOpCode = (pucData[ETH_TYPE_LEN_OFFSET + 8] << 8) |
+		(pucData[ETH_TYPE_LEN_OFFSET + 8 + 1]);
+	if (arpOpCode == ARP_PRO_RSP) {
+		arpMoniter = 0;
+		if (prAisBssInfo &&
+			prAisBssInfo->prStaRecOfAP) {
+			if (EQUAL_MAC_ADDR(
+				&(pucData[ETH_TYPE_LEN_OFFSET + 10]),
+				/* source hardware address */
+				prAisBssInfo->
+				prStaRecOfAP->aucMacAddr)) {
+				kalMemCopy(apIp,
+					&(pucData[ETH_TYPE_LEN_OFFSET + 16]),
+					sizeof(apIp));
+				DBGLOG(INIT, TRACE,
+					"get arp response from AP %d.%d.%d.%d\n",
+					apIp[0], apIp[1], apIp[2], apIp[3]);
+			}
+		}
+	}
+}
+
+void qmHandleRxDhcpPackets(struct ADAPTER *prAdapter,
+	struct SW_RFB *prSwRfb)
+{
+	uint8_t *pucData = NULL;
+	uint8_t *pucEthBody = NULL;
+	uint8_t *pucUdpBody = NULL;
+	uint32_t ipHLen = 0;
+	uint32_t udpLen = 0;
+	uint32_t i = 0;
+	struct BOOTP_PROTOCOL *prBootp = NULL;
+	uint32_t u4DhcpMagicCode = 0;
+	uint8_t dhcpTypeGot = 0;
+	uint8_t dhcpGatewayGot = 0;
+
+	/* check if eth header and ip header is safe to read */
+	if (prSwRfb->u2PacketLen <= ETHER_HEADER_LEN + IP_HEADER_LEN)
+		return;
+
+	pucData = (uint8_t *)prSwRfb->pvHeader;
+	if (!pucData)
+		return;
+	if (((pucData[ETH_TYPE_LEN_OFFSET] << 8) |
+		pucData[ETH_TYPE_LEN_OFFSET + 1]) != ETH_P_IPV4)
+		return;
+
+	/* check ip version and ip proto */
+	pucEthBody = &pucData[ETHER_HEADER_LEN];
+	if (((pucEthBody[0] & IPVH_VERSION_MASK) >>
+		IPVH_VERSION_OFFSET) != IPVERSION)
+		return;
+	if (pucEthBody[9] != IP_PRO_UDP)
+		return;
+
+	/* check ip header len and if udp header safe to read */
+	ipHLen = (pucEthBody[0] & 0x0F) * 4;
+	if (unlikely(prSwRfb->u2PacketLen <
+		ETHER_HEADER_LEN + ipHLen + UDP_HDR_LEN))
+		return;
+
+	/* check udp port is dhcp */
+	pucUdpBody = &pucEthBody[ipHLen];
+	if ((pucUdpBody[0] << 8 | pucUdpBody[1]) != UDP_PORT_DHCPS ||
+		(pucUdpBody[2] << 8 | pucUdpBody[3]) != UDP_PORT_DHCPC)
+		return;
+
+	udpLen = pucUdpBody[4] << 8 | pucUdpBody[5];
+	/* check if udp payload safe to read */
+	if (unlikely(prSwRfb->u2PacketLen <
+		ETHER_HEADER_LEN + ipHLen + udpLen))
+		return;
+
+	prBootp = (struct BOOTP_PROTOCOL *) &pucUdpBody[8];
+
+	WLAN_GET_FIELD_BE32(&prBootp->aucOptions[0],
+		&u4DhcpMagicCode);
+	if (u4DhcpMagicCode != DHCP_MAGIC_NUMBER) {
+		DBGLOG(INIT, WARN,
+			"dhcp wrong magic number, magic code: %d\n",
+			u4DhcpMagicCode);
+		return;
+	}
+
+	/* 1. 248 is from udp header to the beginning of dhcp option
+	 * 2. not sure the dhcp option always usd 255 as a end mark?
+	 *    if so, while condition should be removed?
+	 */
+	while (i < udpLen - 248) {
+		/* bcz of the strange struct BOOTP_PROTOCOL *,
+		 * the dhcp magic code was count in dhcp options
+		 * so need to [i + 4] to skip it
+		 */
+		switch (prBootp->aucOptions[i + 4]) {
+		case 3:
+			/* both dhcp ack and offer will update it */
+			if (prBootp->aucOptions[i + 6] ||
+				prBootp->aucOptions[i + 7] ||
+				prBootp->aucOptions[i + 8] ||
+				prBootp->aucOptions[i + 9]) {
+				gatewayIp[0] = prBootp->aucOptions[i + 6];
+				gatewayIp[1] = prBootp->aucOptions[i + 7];
+				gatewayIp[2] = prBootp->aucOptions[i + 8];
+				gatewayIp[3] = prBootp->aucOptions[i + 9];
+
+				DBGLOG(INIT, TRACE, "Gateway ip: " IPV4STR "\n",
+					IPV4TOSTR(&gatewayIp[0]));
+			};
+			dhcpGatewayGot = 1;
+			break;
+		case 53:
+			if (prBootp->aucOptions[i + 6] != 0x02
+			    && prBootp->aucOptions[i + 6] != 0x05) {
+				DBGLOG(INIT, WARN,
+					"wrong dhcp message type, type: %d\n",
+				  prBootp->aucOptions[i + 6]);
+				if (dhcpGatewayGot)
+					kalMemZero(gatewayIp,
+						sizeof(gatewayIp));
+				return;
+			} else if (prBootp->aucOptions[i + 6] == 0x05) {
+				uint8_t ucBssIndex =
+					secGetBssIdxByRfb(
+					prAdapter, prSwRfb);
+				/* Check if join timer is ticking, then release
+				 * channel privilege and stop join timer.
+				 */
+				qmReleaseCHAtFinishedDhcp(prAdapter,
+					ucBssIndex);
+			}
+			dhcpTypeGot = 1;
+			break;
+		case 255:
+			return;
+
+		default:
+			break;
+		}
+		if (dhcpGatewayGot && dhcpTypeGot)
+			return;
+
+		i += prBootp->aucOptions[i + 5] + 2;
+	}
+	DBGLOG(INIT, WARN,
+	       "can't find the dhcp option 255?, need to check the net log\n");
+}
+
+void qmResetArpDetect(void)
+{
+	arpMoniter = 0;
+	last_rx_packets = 0;
+	latest_rx_packets = 0;
+	kalMemZero(apIp, sizeof(apIp));
+	kalMemZero(gatewayIp, sizeof(gatewayIp));
+}
+#endif
+
+#if QM_ADAPTIVE_TC_RESOURCE_CTRL
+void qmResetTcControlResource(IN struct ADAPTER *prAdapter)
+{
+	uint32_t u4Idx;
+	uint32_t u4TotalMinReservedTcResource = 0;
+	uint32_t u4TotalTcResource = 0;
+	uint32_t u4TotalGurantedTcResource = 0;
+	struct QUE_MGT *prQM = &prAdapter->rQM;
+
+	/* Initialize TC resource control variables */
+	for (u4Idx = 0; u4Idx < TC_NUM; u4Idx++)
+		prQM->au4AverageQueLen[u4Idx] = 0;
+
+	ASSERT(prQM->u4TimeToAdjustTcResource
+	       && prQM->u4TimeToUpdateQueLen);
+
+	for (u4Idx = 0; u4Idx < TC_NUM; u4Idx++) {
+		prQM->au4CurrentTcResource[u4Idx] =
+			prAdapter->rTxCtrl.rTc.au4MaxNumOfBuffer[u4Idx];
+
+		if (u4Idx != TC4_INDEX) {
+			u4TotalTcResource += prQM->au4CurrentTcResource[u4Idx];
+			u4TotalGurantedTcResource +=
+				prQM->au4GuaranteedTcResource[u4Idx];
+			u4TotalMinReservedTcResource +=
+				prQM->au4MinReservedTcResource[u4Idx];
+		}
+	}
+
+	/* Sanity Check */
+	if (u4TotalMinReservedTcResource > u4TotalTcResource)
+		kalMemZero(prQM->au4MinReservedTcResource,
+			   sizeof(prQM->au4MinReservedTcResource));
+
+	if (u4TotalGurantedTcResource > u4TotalTcResource)
+		kalMemZero(prQM->au4GuaranteedTcResource,
+			   sizeof(prQM->au4GuaranteedTcResource));
+
+	u4TotalGurantedTcResource = 0;
+
+	/* Initialize Residual TC resource */
+	for (u4Idx = 0; u4Idx < TC_NUM; u4Idx++) {
+		if (prQM->au4GuaranteedTcResource[u4Idx] <
+		    prQM->au4MinReservedTcResource[u4Idx])
+			prQM->au4GuaranteedTcResource[u4Idx] =
+				prQM->au4MinReservedTcResource[u4Idx];
+
+		if (u4Idx != TC4_INDEX)
+			u4TotalGurantedTcResource +=
+				prQM->au4GuaranteedTcResource[u4Idx];
+	}
+
+	prQM->u4ResidualTcResource = u4TotalTcResource -
+		u4TotalGurantedTcResource;
+
+}
+#endif
+
+/* To change PN number to UINT64 */
+u_int8_t qmRxPNtoU64(uint8_t *pucPN, uint8_t uPNNum,
+	uint64_t *pu64Rets)
+{
+	uint8_t ucCount = 0;
+	uint64_t u64Data = 0;
+
+	if (!pu64Rets) {
+		DBGLOG(QM, ERROR, "Please input valid pu8Rets\n");
+		return FALSE;
+	}
+
+	if (uPNNum > CCMPTSCPNNUM) {
+		DBGLOG(QM, ERROR, "Please input valid uPNNum:%d\n", uPNNum);
+		return FALSE;
+	}
+
+	*pu64Rets = 0;
+	for (; ucCount < uPNNum; ucCount++) {
+		u64Data = ((uint64_t) pucPN[ucCount]) << (8 * ucCount);
+		*pu64Rets +=  u64Data;
+	}
+	return TRUE;
+}
+
+#ifdef CFG_SUPPORT_REPLAY_DETECTION
+/* To check PN/TSC between RxStatus and local record.
+ * return TRUE if PNS is not bigger than PNT
+ */
+u_int8_t qmRxDetectReplay(uint8_t *pucPNS, uint8_t *pucPNT)
+{
+	uint64_t u8RxNum = 0;
+	uint64_t u8LocalRec = 0;
+
+	if (!pucPNS || !pucPNT) {
+		DBGLOG(QM, ERROR, "Please input valid PNS:%p and PNT:%p\n",
+			pucPNS, pucPNT);
+		return TRUE;
+	}
+
+	if (!qmRxPNtoU64(pucPNS, CCMPTSCPNNUM, &u8RxNum)
+	    || !qmRxPNtoU64(pucPNT, CCMPTSCPNNUM, &u8LocalRec)) {
+		DBGLOG(QM, ERROR, "PN2U64 failed\n");
+		return TRUE;
+	}
+	/* PN overflow ? */
+	return !(u8RxNum > u8LocalRec);
+}
+
+/* TO filter broadcast and multicast data packet replay issue. */
+u_int8_t qmHandleRxReplay(struct ADAPTER *prAdapter,
+			  struct SW_RFB *prSwRfb)
+{
+	uint8_t *pucPN = NULL;
+	uint8_t ucKeyID = 0;				/* 0~4 */
+	/* CIPHER_SUITE_NONE~CIPHER_SUITE_GCMP */
+	uint8_t ucSecMode = CIPHER_SUITE_NONE;
+	struct GLUE_INFO *prGlueInfo = NULL;
+	struct GL_WPA_INFO *prWpaInfo = NULL;
+	struct GL_DETECT_REPLAY_INFO *prDetRplyInfo = NULL;
+
+	if (!prAdapter)
+		return TRUE;
+	if (prSwRfb->u2PacketLen <= ETHER_HEADER_LEN)
+		return TRUE;
+
+	if (!(prSwRfb->ucGroupVLD & BIT(RX_GROUP_VLD_1))) {
+		DBGLOG_LIMITED(QM, TRACE, "Group 1 invalid\n");
+		return FALSE;
+	}
+
+	/* BMC only need check CCMP and TKIP Cipher suite */
+	ucSecMode = prSwRfb->ucSecMode;
+
+	prGlueInfo = prAdapter->prGlueInfo;
+
+	prWpaInfo = aisGetWpaInfo(prAdapter,
+		secGetBssIdxByRfb(prAdapter, prSwRfb));
+
+	DBGLOG_LIMITED(QM, TRACE, "ucSecMode = [%u], ChiperGroup = [%u]\n",
+			ucSecMode, prWpaInfo->u4CipherGroup);
+
+	if (ucSecMode != CIPHER_SUITE_CCMP
+	    && ucSecMode != CIPHER_SUITE_TKIP) {
+		DBGLOG_LIMITED(QM, TRACE,
+			"SecMode: %d and CipherGroup: %d, no need check replay\n",
+			ucSecMode, prWpaInfo->u4CipherGroup);
+		return FALSE;
+	}
+
+	if (prWpaInfo->u4CipherGroup != IW_AUTH_CIPHER_TKIP &&
+		prWpaInfo->u4CipherGroup != IW_AUTH_CIPHER_CCMP) {
+		DBGLOG(QM, ERROR,
+			"RX status Chipher mode doens't match AP's setting\n");
+		return FALSE;
+	}
+
+	ucKeyID = prSwRfb->ucKeyID;
+	if (ucKeyID >= MAX_KEY_NUM) {
+		DBGLOG(QM, ERROR, "KeyID: %d error\n", ucKeyID);
+		return TRUE;
+	}
+
+	prDetRplyInfo = aisGetDetRplyInfo(prAdapter,
+		secGetBssIdxByRfb(prAdapter, prSwRfb));
+	/* TODO : Need check fw rekey while fw rekey event. */
+	if (ucKeyID != prDetRplyInfo->ucCurKeyId) {
+		DBGLOG(QM, TRACE,
+			"use last keyID while detect replay information.(0x%x->0x%x)\n",
+			prDetRplyInfo->ucCurKeyId, ucKeyID);
+		ucKeyID = prDetRplyInfo->ucCurKeyId;
+	}
+
+	if (prDetRplyInfo->arReplayPNInfo[ucKeyID].fgFirstPkt) {
+		prDetRplyInfo->arReplayPNInfo[ucKeyID].fgFirstPkt = FALSE;
+		HAL_RX_STATUS_GET_PN(prSwRfb->prRxStatusGroup1,
+			prDetRplyInfo->arReplayPNInfo[ucKeyID].auPN);
+		DBGLOG(QM, INFO,
+			"First check packet. Key ID:0x%x\n", ucKeyID);
+		return FALSE;
+	}
+
+	pucPN = prSwRfb->prRxStatusGroup1->aucPN;
+	DBGLOG_LIMITED(QM, TRACE,
+		"BC packet 0x%x:0x%x:0x%x:0x%x:0x%x:0x%x--0x%x:0x%x:0x%x:0x%x:0x%x:0x%x\n",
+		pucPN[0], pucPN[1], pucPN[2], pucPN[3], pucPN[4], pucPN[5],
+		prDetRplyInfo->arReplayPNInfo[ucKeyID].auPN[0],
+		prDetRplyInfo->arReplayPNInfo[ucKeyID].auPN[1],
+		prDetRplyInfo->arReplayPNInfo[ucKeyID].auPN[2],
+		prDetRplyInfo->arReplayPNInfo[ucKeyID].auPN[3],
+		prDetRplyInfo->arReplayPNInfo[ucKeyID].auPN[4],
+		prDetRplyInfo->arReplayPNInfo[ucKeyID].auPN[5]);
+	if (qmRxDetectReplay(pucPN,
+			prDetRplyInfo->arReplayPNInfo[ucKeyID].auPN)) {
+		DBGLOG_LIMITED(QM, WARN, "Drop BC replay packet!\n");
+		return TRUE;
+	}
+
+	HAL_RX_STATUS_GET_PN(prSwRfb->prRxStatusGroup1,
+		prDetRplyInfo->arReplayPNInfo[ucKeyID].auPN);
+	return FALSE;
+}
+#endif
+
+u_int8_t
+qmIsIPLayerPacket(uint8_t *pucPkt)
+{
+	uint16_t u2EtherType =
+		(pucPkt[ETH_TYPE_LEN_OFFSET] << 8)
+			| (pucPkt[ETH_TYPE_LEN_OFFSET + 1]);
+
+	if (u2EtherType == ETH_P_IPV4 || u2EtherType == ETH_P_IPV6) {
+		uint8_t *pucEthBody = &pucPkt[ETH_HLEN];
+		uint8_t ucIpProto =
+			(u2EtherType == ETH_P_IPV4 ?
+				pucEthBody[IP_PROTO_HLEN] :
+				pucEthBody[IPV6_HDR_PROTOCOL_OFFSET]);
+
+		if (ucIpProto == IP_PRO_UDP || ucIpProto == IP_PRO_TCP)
+			return TRUE;
+	}
+
+	return FALSE;
+}
+
+u_int8_t
+qmIsNoDropPacket(IN struct ADAPTER *prAdapter, IN struct SW_RFB *prSwRfb)
+{
+	uint8_t *pucData = (uint8_t *) prSwRfb->pvHeader;
+	uint8_t ucBssIndex
+		= secGetBssIdxByWlanIdx(prAdapter, prSwRfb->ucWlanIdx);
+	u_int8_t fgCheckDrop = FALSE;
+	struct BSS_INFO *prBssInfo = NULL;
+
+	if (ucBssIndex <= MAX_BSSID_NUM)
+		prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, ucBssIndex);
+
+#if CFG_SUPPORT_LOWLATENCY_MODE
+	if (prAdapter->fgEnLowLatencyMode)
+		fgCheckDrop = TRUE;
+#endif
+
+#if CFG_SUPPORT_OSHARE
+	if (!fgCheckDrop &&
+		(prAdapter->fgEnOshareMode) &&
+		prBssInfo &&
+		prBssInfo->eNetworkType == NETWORK_TYPE_P2P)
+		fgCheckDrop = TRUE;
+#endif
+
+#if CFG_MTK_MDDP_SUPPORT
+	if (!fgCheckDrop && mddpIsSupportMddpWh() &&
+	    prAdapter->fgMddpActivated &&
+	    prBssInfo && prBssInfo->eNetworkType == NETWORK_TYPE_P2P) {
+		struct WIFI_VAR *prWifiVar = NULL;
+		struct P2P_CONNECTION_SETTINGS *prP2PConnSettings = NULL;
+
+		prWifiVar = &prAdapter->rWifiVar;
+		if (prWifiVar && prBssInfo->u4PrivateData < BSS_P2P_NUM) {
+			prP2PConnSettings = prWifiVar->prP2PConnSettings[
+				prBssInfo->u4PrivateData];
+			fgCheckDrop = prP2PConnSettings &&
+				p2pFuncIsAPMode(prP2PConnSettings);
+		}
+	}
+#endif
+
+	if (fgCheckDrop && qmIsIPLayerPacket(pucData))
+		return TRUE;
+
+	/* For some special packet, like DNS, DHCP,
+	 * do not drop evan fall behind.
+	 */
+	if (qmIsIndependentPkt(prSwRfb))
+		return TRUE;
+
+	return FALSE;
+}
+
+void qmMoveStaTxQueue(struct STA_RECORD *prSrcStaRec,
+		      struct STA_RECORD *prDstStaRec)
+{
+	uint8_t ucQueArrayIdx;
+	struct QUE *prSrcQue = NULL;
+	struct QUE *prDstQue = NULL;
+	struct MSDU_INFO *prMsduInfo = NULL;
+	uint8_t ucDstStaIndex = 0;
+
+	ASSERT(prSrcStaRec);
+	ASSERT(prDstStaRec);
+
+	prSrcQue = &prSrcStaRec->arTxQueue[0];
+	prDstQue = &prDstStaRec->arTxQueue[0];
+	ucDstStaIndex = prDstStaRec->ucIndex;
+
+	DBGLOG(QM, INFO, "Pending MSDUs for TC 0~3, %u %u %u %u\n",
+	       prSrcQue[TC0_INDEX].u4NumElem, prSrcQue[TC1_INDEX].u4NumElem,
+	       prSrcQue[TC2_INDEX].u4NumElem, prSrcQue[TC3_INDEX].u4NumElem);
+	/* Concatenate all MSDU_INFOs in TX queues of this STA_REC */
+	for (ucQueArrayIdx = 0; ucQueArrayIdx < TC4_INDEX; ucQueArrayIdx++) {
+		prMsduInfo = (struct MSDU_INFO *)QUEUE_GET_HEAD(
+			&prSrcQue[ucQueArrayIdx]);
+		while (prMsduInfo) {
+			prMsduInfo->ucStaRecIndex = ucDstStaIndex;
+			prMsduInfo = (struct MSDU_INFO *)QUEUE_GET_NEXT_ENTRY(
+				&prMsduInfo->rQueEntry);
+		}
+		QUEUE_CONCATENATE_QUEUES((&prDstQue[ucQueArrayIdx]),
+					 (&prSrcQue[ucQueArrayIdx]));
+	}
+}
+
+void qmHandleDelTspec(struct ADAPTER *prAdapter, struct STA_RECORD *prStaRec,
+		      enum ENUM_ACI eAci)
+{
+	uint8_t aucNextUP[ACI_NUM] = {1 /* BEtoBK */, 1 /*na */, 0 /*VItoBE */,
+				      4 /*VOtoVI */};
+	enum ENUM_ACI aeNextAci[ACI_NUM] = {ACI_BK, ACI_BK, ACI_BE, ACI_VI};
+	uint8_t ucActivedTspec = 0;
+	uint8_t ucNewUp = 0;
+	struct QUE *prSrcQue = NULL;
+	struct QUE *prDstQue = NULL;
+	struct MSDU_INFO *prMsduInfo = NULL;
+	struct AC_QUE_PARMS *prAcQueParam = NULL;
+	uint8_t ucTc = 0;
+	struct BSS_INFO *prAisBssInfo = NULL;
+
+	if (!prStaRec || eAci == ACI_NUM || eAci == ACI_BK || !prAdapter) {
+		DBGLOG(QM, ERROR, "prSta NULL %d, eAci %d, prAdapter NULL %d\n",
+		       !prStaRec, eAci, !prAdapter);
+		return;
+	}
+	prAisBssInfo = aisGetAisBssInfo(prAdapter,
+		prStaRec->ucBssIndex);
+	if (!prAisBssInfo) {
+		DBGLOG(QM, ERROR, "prAisBssInfo NULL\n");
+		return;
+	}
+
+	prSrcQue = &prStaRec->arTxQueue[aucWmmAC2TcResourceSet1[eAci]];
+	prAcQueParam = &(prAisBssInfo->arACQueParms[0]);
+	ucActivedTspec = wmmHasActiveTspec(
+		aisGetWMMInfo(prAdapter, prAisBssInfo->ucBssIndex));
+
+	while (prAcQueParam[eAci].ucIsACMSet &&
+			!(ucActivedTspec & BIT(eAci)) && eAci != ACI_BK) {
+		eAci = aeNextAci[eAci];
+		ucNewUp = aucNextUP[eAci];
+	}
+	DBGLOG(QM, INFO, "new ACI %d, ACM %d, HasTs %d\n", eAci,
+	       prAcQueParam[eAci].ucIsACMSet, !!(ucActivedTspec & BIT(eAci)));
+	ucTc = aucWmmAC2TcResourceSet1[eAci];
+	prDstQue = &prStaRec->arTxQueue[ucTc];
+	prMsduInfo = (struct MSDU_INFO *)QUEUE_GET_HEAD(prSrcQue);
+	while (prMsduInfo) {
+		prMsduInfo->ucUserPriority = ucNewUp;
+		prMsduInfo->ucTC = ucTc;
+		prMsduInfo = (struct MSDU_INFO *)QUEUE_GET_NEXT_ENTRY(
+			&prMsduInfo->rQueEntry);
+	}
+	QUEUE_CONCATENATE_QUEUES(prDstQue, prSrcQue);
+#if QM_ADAPTIVE_TC_RESOURCE_CTRL
+	qmUpdateAverageTxQueLen(prAdapter);
+	qmReassignTcResource(prAdapter);
+#endif
+	nicTxAdjustTcq(prAdapter);
+	kalSetEvent(prAdapter->prGlueInfo);
+}
+
+void qmReleaseCHAtFinishedDhcp(struct ADAPTER *prAdapter,
+			uint8_t ucBssIndex)
+{
+	struct BSS_INFO *prBssInfo;
+	struct AIS_FSM_INFO *prAisFsmInfo = (struct AIS_FSM_INFO *) NULL;
+
+	if (prAdapter == NULL)
+		return;
+
+	prBssInfo = GET_BSS_INFO_BY_INDEX(prAdapter, ucBssIndex);
+	if (prBssInfo == NULL)
+		return;
+
+	if (IS_BSS_AIS(prBssInfo)) { /* STA */
+		prAisFsmInfo = aisGetAisFsmInfo(prAdapter, ucBssIndex);
+
+		if (!timerPendingTimer(&prAisFsmInfo->rJoinTimeoutTimer)) {
+			DBGLOG(QM, ERROR, "No channel occupation\n");
+		} else {
+			DBGLOG(QM, INFO, "Dhcp done, stop join timer.\n");
+			cnmTimerStopTimer(prAdapter,
+				&prAisFsmInfo->rJoinTimeoutTimer);
+			aisFsmRunEventJoinTimeout(prAdapter, ucBssIndex);
+		}
+	} else if (IS_BSS_P2P(prBssInfo)) { /* GC */
+		DBGLOG(QM, INFO, "Dhcp done, stop GC join timer\n");
+		p2pRoleFsmNotifyDhcpDone(prAdapter, ucBssIndex);
+	}
+}
+
+void qmHandleRxReorderWinShift(IN struct ADAPTER *prAdapter,
+	IN uint8_t ucStaRecIdx, uint8_t ucTid, uint32_t u4SSN,
+	OUT struct QUE *prReturnedQue)
+{
+	struct STA_RECORD *prStaRec;
+	struct RX_BA_ENTRY *prReorderQueParm;
+	uint32_t u4WinStart;
+	uint32_t u4WinEnd;
+
+	/* Check whether the STA_REC is activated */
+	prStaRec = cnmGetStaRecByIndex(prAdapter, ucStaRecIdx);
+	if (prStaRec == NULL) {
+		/* ASSERT(prStaRec); */
+		return;
+	}
+
+	/* Check whether the BA agreement exists */
+	prReorderQueParm = prStaRec->aprRxReorderParamRefTbl[ucTid];
+	if (!prReorderQueParm) {
+		/* TODO: (Tehuang) Handle the Host-FW sync issue. */
+		DBGLOG(QM, WARN,
+			"QM: (Warning) BAR for a NULL ReorderQueParm\n");
+		/* ASSERT(0); */
+		return;
+	}
+
+	RX_DIRECT_REORDER_LOCK(prAdapter, 0);
+
+	u4WinStart = (uint32_t) (prReorderQueParm->u2WinStart);
+	u4WinEnd = (uint32_t) (prReorderQueParm->u2WinEnd);
+
+	if (qmCompareSnIsLessThan(u4WinStart, u4SSN)) {
+#if CFG_SUPPORT_RX_OOR_BAR
+		prReorderQueParm->u2BarSSN = u4SSN;
+		DBGLOG(RX, INFO,
+			"BAR: update WinStart from %u to %u, LastRcvdSN=%u",
+			prReorderQueParm->u2WinStart,
+			prReorderQueParm->u2BarSSN,
+			prReorderQueParm->u2LastRcvdSN);
+		SET_BAR_SSN_VALID(prReorderQueParm->u2BarSSN);
+#endif /* CFG_SUPPORT_RX_OOR_BAR */
+
+		prReorderQueParm->u2WinStart = (uint16_t) u4SSN;
+		prReorderQueParm->u2WinEnd =
+			((prReorderQueParm->u2WinStart) +
+			(prReorderQueParm->u2WinSize) - 1) % MAX_SEQ_NO_COUNT;
+
+#if CFG_SUPPORT_RX_AMSDU
+		/* RX reorder for one MSDU in AMSDU issue */
+		prReorderQueParm->u8LastAmsduSubIdx = RX_PAYLOAD_FORMAT_MSDU;
+#endif
+
+		DBGLOG(RX, TEMP,
+			"QM:(BAR U)[%d](%u){%hu,%hu}\n",
+			ucTid, u4SSN,
+			prReorderQueParm->u2WinStart,
+			prReorderQueParm->u2WinEnd);
+		qmPopOutDueToFallAhead(prAdapter, prReorderQueParm,
+			prReturnedQue);
+	} else {
+		DBGLOG(RX, TEMP, "QM:(BAR I)(%d)(%u){%u,%u}\n",
+			ucTid, u4SSN, u4WinStart, u4WinEnd);
+	}
+
+	RX_DIRECT_REORDER_UNLOCK(prAdapter, 0);
+}
+
+void qmCheckRxEAPOLM3(IN struct ADAPTER *prAdapter,
+			IN struct SW_RFB *prSwRfb, uint8_t ucBssIndex)
+{
+	uint8_t *pPkt = NULL;
+	struct sk_buff *skb = NULL;
+	uint16_t u2EtherType;
+	uint8_t *pucEthBody;
+	struct GL_WPA_INFO *prWpaInfo;
+
+	if (prSwRfb->u2PacketLen <= ETHER_HEADER_LEN)
+		return;
+
+	pPkt = prSwRfb->pvHeader;
+	if (!pPkt)
+		return;
+
+	skb = (struct sk_buff *)(prSwRfb->pvPacket);
+	if (!skb)
+		return;
+
+	/* get ethernet protocol */
+	u2EtherType = (pPkt[ETH_TYPE_LEN_OFFSET] << 8)
+			| (pPkt[ETH_TYPE_LEN_OFFSET + 1]);
+	pucEthBody = &pPkt[ETH_HLEN];
+
+	prWpaInfo = aisGetWpaInfo(prAdapter, ucBssIndex);
+	prAdapter->fgIsPostponeTxEAPOLM3 = FALSE;
+
+	if (u2EtherType == ETH_P_1X) {
+		uint8_t *pucEapol = pucEthBody;
+		uint8_t ucEapolType = pucEapol[1];
+		uint16_t u2KeyInfo = 0;
+		uint8_t m;
+
+		if (ucEapolType == ETH_EAPOL_KEY) {
+			WLAN_GET_FIELD_BE16(&pucEapol[5], &u2KeyInfo);
+			m = ((u2KeyInfo & 0x1100) == 0x0000 ||
+				(u2KeyInfo & 0x0008) == 0x0000) ? 1 : 3;
+
+			if (prAdapter->rWifiVar.u4SwTestMode ==
+					ENUM_SW_TEST_MODE_SIGMA_HS20_R2 &&
+					m == 3 &&
+					!prSwRfb->prStaRec->fgIsTxKeyReady) {
+				prAdapter->fgIsPostponeTxEAPOLM3 = TRUE;
+				DBGLOG(QM, INFO,
+					"[Passpoint] Postpone sending EAPOL M4 until PTK installed!");
+			}
+		}
+	}
+}
diff --git a/vendor/mediatek/kernel_modules/connectivity/wlan/./core/gen3/os/linux/include/gl_qa_agent.h b/vendor/mediatek/kernel_modules/connectivity/wlan/./core/gen3/os/linux/include/gl_qa_agent.h
new file mode 100644
index 0000000..9ed57b2
--- /dev/null
+++ b/vendor/mediatek/kernel_modules/connectivity/wlan/./core/gen3/os/linux/include/gl_qa_agent.h
@@ -0,0 +1,228 @@
+/*
+* Copyright (C) 2016 MediaTek Inc.
+*
+* This program is free software: you can redistribute it and/or modify it under the terms of the
+* GNU General Public License version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License along with this program.
+* If not, see <http://www.gnu.org/licenses/>.
+*/
+/*! \file   gl_qa_agent.h
+ * \brief  This file includes private ioctl support.
+ */
+
+#ifndef _GL_QA_AGENT_H
+#define _GL_QA_AGENT_H
+#if CFG_SUPPORT_QA_TOOL
+/*******************************************************************************
+*                         C O M P I L E R   F L A G S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                    E X T E R N A L   R E F E R E N C E S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                              C O N S T A N T S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                                 M A C R O S
+********************************************************************************
+*/
+
+/*******************************************************************************
+*                  F U N C T I O N   D E C L A R A T I O N S
+********************************************************************************
+*/
+
+#define HQA_CMD_MAGIC_NO 0x18142880
+
+#if CFG_SUPPORT_TX_BF
+#define HQA_BF_STR_SIZE 512
+#endif
+
+#define HQA_RX_STATISTIC_NUM 66
+#define MAX_EEPROM_BUFFER_SIZE	1200
+
+#if 0
+typedef struct _PARAM_RX_STAT_T {
+	UINT_32 MacFCSErr;	/* Y            0x820F_D014 */
+	UINT_32 MacMdrdy;	/* Y            0x820F_D030 */
+	UINT_32 FCSErr_CCK;	/* Y            0x8207_021C     [15:00] */
+	UINT_32 FCSErr_OFDM;	/* Y            0x8207_021C     [31:16] */
+	UINT_32 CCK_PD;		/* Y            0x8207_020C     [15:00] */
+	UINT_32 OFDM_PD;	/* Y            0x8207_020C     [15:00] */
+	UINT_32 CCK_SIG_Err;	/* Y            0x8207_0210     [31:16] */
+	UINT_32 CCK_SFD_Err;	/* Y            0x8207_0210     [15:00] */
+	UINT_32 OFDM_SIG_Err;	/* Y            0x8207_0214     [31:16] */
+	UINT_32 OFDM_TAG_Err;	/* Y            0x8207_0214     [15:00] */
+	UINT_32 WB_RSSSI0;	/* Y            0x8207_21A8     [23:16] */
+	UINT_32 IB_RSSSI0;	/* Y            0x8207_21A8     [31:24] */
+	UINT_32 WB_RSSSI1;	/* Y            0x8207_21A8     [07:00] */
+	UINT_32 IB_RSSSI1;	/* Y            0x8207_21A8     [15:08] */
+	UINT_32 PhyMdrdyCCK;	/* Y            0x8207_0220     [15:00] */
+	UINT_32 PhyMdrdyOFDM;	/* Y            0x8207_0220     [31:16] */
+	UINT_32 DriverRxCount;	/* Y            FW Counter Band0 */
+	UINT_32 RCPI0;		/* Y            RXV4            [07:00] */
+	UINT_32 RCPI1;		/* Y            RXV4            [15:08] */
+	UINT_32 FreqOffsetFromRX;	/* Y            RXV5            MISC1[24:00]    OFDM:[11:00]    CCK:[10:00] */
+	UINT_32 RSSI0;		/* N */
+	UINT_32 RSSI1;		/* N */
+	UINT_32 rx_fifo_full;	/* N */
+	UINT_32 RxLenMismatch;	/* N */
+	UINT_32 MacFCSErr_band1;	/* Y            0x820F_D214 */
+	UINT_32 MacMdrdy_band1;	/* Y            0x820F_D230 */
+	/* Y            RXV3            [23:16] (must set 0x8207066C[1:0] = 0x0 ~ 0x3) */
+	UINT_32 FAGC_IB_RSSSI[4];
+	/* Y            RXV3            [31:24] (must set 0x8207066C[1:0] = 0x0 ~ 0x3) */
+	UINT_32 FAGC_WB_RSSSI[4];
+	/* Y            0x8207_21A8     [31:24] [15:08] 0x8207_29A8     [31:24] [15:08] */
+	UINT_32 Inst_IB_RSSSI[4];
+	/* Y            0x8207_21A8     [23:16] [07:00] 0x8207_29A8     [23:16] [07:00] */
+	UINT_32 Inst_WB_RSSSI[4];
+	UINT_32 ACIHitLow;	/* Y            0x8207_21B0     [18] */
+	UINT_32 ACIHitHigh;	/* Y            0x8207_29B0     [18] */
+	UINT_32 DriverRxCount1;	/* Y            FW Counter Band1 */
+	UINT_32 RCPI2;		/* Y            RXV4            [23:16] */
+	UINT_32 RCPI3;		/* Y            RXV4            [31:24] */
+	UINT_32 RSSI2;		/* N */
+	UINT_32 RSSI3;		/* N */
+	UINT_32 SNR0;		/* Y            RXV5            (MISC1 >> 19) - 16 */
+	UINT_32 SNR1;		/* N */
+	UINT_32 SNR2;		/* N */
+	UINT_32 SNR3;		/* N */
+	UINT_32 rx_fifo_full_band1;	/* N */
+	UINT_32 RxLenMismatch_band1;	/* N */
+	UINT_32 CCK_PD_band1;	/* Y            0x8207_040C     [15:00] */
+	UINT_32 OFDM_PD_band1;	/* Y            0x8207_040C     [31:16] */
+	UINT_32 CCK_SIG_Err_band1;	/* Y            0x8207_0410     [31:16] */
+	UINT_32 CCK_SFD_Err_band1;	/* Y            0x8207_0410     [15:00] */
+	UINT_32 OFDM_SIG_Err_band1;	/* Y            0x8207_0414     [31:16] */
+	UINT_32 OFDM_TAG_Err_band1;	/* Y            0x8207_0414     [15:00] */
+	UINT_32 PhyMdrdyCCK_band1;	/* Y            0x8207_0420     [15:00] */
+	UINT_32 PhyMdrdyOFDM_band1;	/* Y            0x8207_0420     [31:16] */
+	UINT_32 CCK_FCS_Err_band1;	/* Y            0x8207_041C     [15:00] */
+	UINT_32 OFDM_FCS_Err_band1;	/* Y            0x8207_041C     [31:16] */
+	UINT_32 MuPktCount;	/* Y            MT_ATEUpdateRxStatistic RXV1_2ND_CYCLE->GroupId */
+} PARAM_RX_STAT_T, *P_PARAM_RX_STAT_T;
+#else
+typedef struct _PARAM_RX_STAT_T {
+	UINT_32 MAC_FCS_Err;	/* b0 */
+	UINT_32 MAC_Mdrdy;	/* b0 */
+	UINT_32 FCSErr_CCK;
+	UINT_32 FCSErr_OFDM;
+	UINT_32 CCK_PD;
+	UINT_32 OFDM_PD;
+	UINT_32 CCK_SIG_Err;
+	UINT_32 CCK_SFD_Err;
+	UINT_32 OFDM_SIG_Err;
+	UINT_32 OFDM_TAG_Err;
+	UINT_32 WB_RSSI0;
+	UINT_32 IB_RSSI0;
+	UINT_32 WB_RSSI1;
+	UINT_32 IB_RSSI1;
+	UINT_32 PhyMdrdyCCK;
+	UINT_32 PhyMdrdyOFDM;
+	UINT_32 DriverRxCount;
+	UINT_32 RCPI0;
+	UINT_32 RCPI1;
+	UINT_32 FreqOffsetFromRX;
+	UINT_32 RSSI0;
+	UINT_32 RSSI1;		/* insert new member here */
+	UINT_32 OutOfResource;	/* MT7615 begin here */
+	UINT_32 LengthMismatchCount_B0;
+	UINT_32 MAC_FCS_Err1;	/* b1 */
+	UINT_32 MAC_Mdrdy1;	/* b1 */
+	UINT_32 FAGCRssiIBR0;
+	UINT_32 FAGCRssiIBR1;
+	UINT_32 FAGCRssiIBR2;
+	UINT_32 FAGCRssiIBR3;
+	UINT_32 FAGCRssiWBR0;
+	UINT_32 FAGCRssiWBR1;
+	UINT_32 FAGCRssiWBR2;
+	UINT_32 FAGCRssiWBR3;
+
+	UINT_32 InstRssiIBR0;
+	UINT_32 InstRssiIBR1;
+	UINT_32 InstRssiIBR2;
+	UINT_32 InstRssiIBR3;
+	UINT_32 InstRssiWBR0;
+	UINT_32 InstRssiWBR1;
+	UINT_32 InstRssiWBR2;
+	UINT_32 InstRssiWBR3;
+	UINT_32 ACIHitLower;
+	UINT_32 ACIHitUpper;
+	UINT_32 DriverRxCount1;
+	UINT_32 RCPI2;
+	UINT_32 RCPI3;
+	UINT_32 RSSI2;
+	UINT_32 RSSI3;
+	UINT_32 SNR0;
+	UINT_32 SNR1;
+	UINT_32 SNR2;
+	UINT_32 SNR3;
+	UINT_32 OutOfResource1;
+	UINT_32 LengthMismatchCount_B1;
+	UINT_32 CCK_PD_Band1;
+	UINT_32 OFDM_PD_Band1;
+	UINT_32 CCK_SIG_Err_Band1;
+	UINT_32 CCK_SFD_Err_Band1;
+	UINT_32 OFDM_SIG_Err_Band1;
+	UINT_32 OFDM_TAG_Err_Band1;
+	UINT_32 PHY_CCK_MDRDY_Band1;
+	UINT_32 PHY_OFDM_MDRDY_Band1;
+	UINT_32 CCK_FCS_Err_Band1;
+	UINT_32 OFDM_FCS_Err_Band1;
+	UINT_32 MRURxCount;
+	UINT_32 SIGMCS;
+	UINT_32 SINR;
+	UINT_32 RXVRSSI;
+	UINT_32 Reserved[184];
+	UINT_32 PHY_Mdrdy;
+	UINT_32 Noise_Floor;
+	UINT_32 AllLengthMismatchCount_B0;
+	UINT_32 AllLengthMismatchCount_B1;
+	UINT_32 AllMacMdrdy0;
+	UINT_32 AllMacMdrdy1;
+	UINT_32 AllFCSErr0;
+	UINT_32 AllFCSErr1;
+	UINT_32 RXOK0;
+	UINT_32 RXOK1;
+	UINT_32 PER0;
+	UINT_32 PER1;
+} PARAM_RX_STAT_T, *P_PARAM_RX_STAT_T;
+extern PARAM_RX_STAT_T g_HqaRxStat;
+#endif
+
+typedef struct _HQA_CMD_FRAME {
+	UINT_32 MagicNo;
+	UINT_16 Type;
+	UINT_16 Id;
+	UINT_16 Length;
+	UINT_16 Sequence;
+	UCHAR Data[2048];
+} __packed HQA_CMD_FRAME;
+
+typedef INT_32(*HQA_CMD_HANDLER) (struct net_device *prNetDev,
+				  IN union iwreq_data *prIwReqData, HQA_CMD_FRAME *HqaCmdFrame);
+
+typedef struct _HQA_CMD_TABLE {
+	HQA_CMD_HANDLER *CmdSet;
+	UINT_32 CmdSetSize;
+	UINT_32 CmdOffset;
+} HQA_CMD_TABLE;
+
+int HQA_CMDHandler(struct net_device *prNetDev, IN union iwreq_data *prIwReqData, HQA_CMD_FRAME *HqaCmdFrame);
+
+int priv_qa_agent(IN struct net_device *prNetDev,
+		  IN struct iw_request_info *prIwReqInfo, IN union iwreq_data *prIwReqData, IN char *pcExtra);
+#endif /*CFG_SUPPORT_QA_TOOL */
+#endif /* _GL_QA_AGENT_H */
diff --git a/vendor/mediatek/kernel_modules/connectivity/common/connectivity_build_in_adapter.c b/vendor/mediatek/kernel_modules/connectivity/common/connectivity_build_in_adapter.c
new file mode 100644
index 0000000..77a1061
--- /dev/null
+++ b/vendor/mediatek/kernel_modules/connectivity/common/connectivity_build_in_adapter.c
@@ -0,0 +1,439 @@
+/*
+ * Copyright (C) 2016 MediaTek Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
+ */
+
+#ifdef DFT_TAG
+#undef DFT_TAG
+#endif
+#define DFT_TAG "[CONNADP]"
+#include "connectivity_build_in_adapter.h"
+
+#include <kernel/sched/sched.h>
+
+/*device tree mode*/
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/irqreturn.h>
+#include <linux/of_address.h>
+#endif
+
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/of_reserved_mem.h>
+
+#include <linux/interrupt.h>
+#ifdef CONFIG_PINCTRL_MTK_PARIS
+#include <pinctrl-mtk-common-v2_debug.h>
+#else
+#include <linux/gpio.h>
+#endif
+
+#ifdef CONFIG_MTK_MT6306_GPIO_SUPPORT
+#include <mtk_6306_gpio.h>
+#endif
+
+#ifdef CONNADP_HAS_CLOCK_BUF_CTRL
+#ifndef CONFIG_FPGA_EARLY_PORTING
+#include <mtk_clkbuf_ctl.h>
+#endif
+#endif
+
+/* PMIC */
+#if defined(CONFIG_MTK_PMIC_CHIP_MT6359)
+#include <mtk_pmic_api_buck.h>
+#endif
+#if defined(CONFIG_MTK_PMIC_CHIP_MT6359P)
+#include <pmic_api_buck.h>
+#endif
+#include <upmu_common.h>
+
+/* MMC */
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <sdio_ops.h>
+
+#include "mtk_spm_resource_req.h"
+
+#ifdef CONFIG_ARCH_MT6570
+#define CPU_BOOST y
+#endif
+#ifdef CONFIG_ARCH_MT6755
+#define CPU_BOOST y
+#endif
+#ifdef CONFIG_MACH_MT6757
+#define CPU_BOOST y
+#endif
+#ifdef CONFIG_MACH_MT6763
+#define CPU_BOOST y
+#endif
+
+#ifdef CPU_BOOST
+#include "mtk_ppm_api.h"
+#endif
+
+#ifndef TASK_STATE_TO_CHAR_STR
+#define TASK_STATE_TO_CHAR_STR "RSDTtXZxKWPNn"
+#endif
+
+
+
+phys_addr_t gConEmiPhyBase;
+EXPORT_SYMBOL(gConEmiPhyBase);
+unsigned long long gConEmiSize;
+EXPORT_SYMBOL(gConEmiSize);
+
+phys_addr_t gGpsRsvMemPhyBase;
+EXPORT_SYMBOL(gGpsRsvMemPhyBase);
+unsigned long long gGpsRsvMemSize;
+EXPORT_SYMBOL(gGpsRsvMemSize);
+/*Reserved memory by device tree!*/
+
+int reserve_memory_consys_fn(struct reserved_mem *rmem)
+{
+	pr_info(DFT_TAG "[W]%s: name: %s,base: 0x%llx,size: 0x%llx\n",
+		__func__, rmem->name, (unsigned long long)rmem->base,
+		(unsigned long long)rmem->size);
+	gConEmiPhyBase = rmem->base;
+	gConEmiSize = rmem->size;
+	return 0;
+}
+
+RESERVEDMEM_OF_DECLARE(reserve_memory_test, "mediatek,consys-reserve-memory",
+			reserve_memory_consys_fn);
+
+int reserve_memory_gps_fn(struct reserved_mem *rmem)
+{
+	pr_info(DFT_TAG "[W]%s: name: %s,base: 0x%llx,size: 0x%llx\n",
+		__func__, rmem->name, (unsigned long long)rmem->base,
+		(unsigned long long)rmem->size);
+	gGpsRsvMemPhyBase = rmem->base;
+	gGpsRsvMemSize = rmem->size;
+	return 0;
+}
+RESERVEDMEM_OF_DECLARE(reserve_memory_gps, "mediatek,gps-reserve-memory",
+			reserve_memory_gps_fn);
+
+void connectivity_export_show_stack(struct task_struct *tsk, unsigned long *sp)
+{
+	show_stack(tsk, sp);
+}
+EXPORT_SYMBOL(connectivity_export_show_stack);
+
+void connectivity_export_tracing_record_cmdline(struct task_struct *tsk)
+{
+	tracing_record_cmdline(tsk);
+}
+EXPORT_SYMBOL(connectivity_export_tracing_record_cmdline);
+
+void connectivity_export_conap_scp_init(unsigned int chip_info, phys_addr_t emi_phy_addr)
+{
+}
+EXPORT_SYMBOL(connectivity_export_conap_scp_init);
+
+
+void connectivity_export_conap_scp_deinit(void)
+{
+}
+EXPORT_SYMBOL(connectivity_export_conap_scp_deinit);
+
+
+#ifdef CPU_BOOST
+bool connectivity_export_spm_resource_req(unsigned int user,
+					  unsigned int req_mask)
+{
+	return spm_resource_req(user, req_mask);
+}
+EXPORT_SYMBOL(connectivity_export_spm_resource_req);
+
+void connectivity_export_mt_ppm_sysboost_freq(enum ppm_sysboost_user user,
+					      unsigned int freq)
+{
+	mt_ppm_sysboost_freq(user, freq);
+}
+EXPORT_SYMBOL(connectivity_export_mt_ppm_sysboost_freq);
+
+void connectivity_export_mt_ppm_sysboost_core(enum ppm_sysboost_user user,
+					      unsigned int core_num)
+{
+	mt_ppm_sysboost_core(user, core_num);
+}
+EXPORT_SYMBOL(connectivity_export_mt_ppm_sysboost_core);
+
+void connectivity_export_mt_ppm_sysboost_set_core_limit(
+				enum ppm_sysboost_user user,
+				unsigned int cluster,
+				int min_core, int max_core)
+{
+	mt_ppm_sysboost_set_core_limit(user, cluster, min_core, max_core);
+}
+EXPORT_SYMBOL(connectivity_export_mt_ppm_sysboost_set_core_limit);
+
+void connectivity_export_mt_ppm_sysboost_set_freq_limit(
+				enum ppm_sysboost_user user,
+				unsigned int cluster,
+				int min_freq, int max_freq)
+{
+	mt_ppm_sysboost_set_freq_limit(user, cluster, min_freq, max_freq);
+}
+EXPORT_SYMBOL(connectivity_export_mt_ppm_sysboost_set_freq_limit);
+#endif
+
+/*******************************************************************************
+ * Clock Buffer Control
+ ******************************************************************************/
+#ifdef CONNADP_HAS_CLOCK_BUF_CTRL
+void connectivity_export_clk_buf_ctrl(enum clk_buf_id id, bool onoff)
+{
+#if defined(CONFIG_MTK_BASE_POWER)
+	clk_buf_ctrl(id, onoff);
+#else
+	pr_info("[%s] not support now", __func__);
+#endif
+}
+EXPORT_SYMBOL(connectivity_export_clk_buf_ctrl);
+
+void connectivity_export_clk_buf_show_status_info(void)
+{
+#if defined(CONFIG_MACH_MT6768) || \
+	defined(CONFIG_MACH_MT6785) || \
+	defined(CONFIG_MACH_MT6771) || \
+	defined(CONFIG_MACH_MT6739) || \
+	defined(CONFIG_MACH_MT6785) || \
+	defined(CONFIG_MACH_MT6873) || \
+	defined(CONFIG_MACH_MT6885) || \
+	defined(CONFIG_MACH_MT6893) || \
+	defined(CONFIG_MACH_MT6877)
+#if defined(CONFIG_MTK_BASE_POWER)
+	clk_buf_show_status_info();
+#else
+	pr_info("[%s] not support now", __func__);
+#endif
+#endif
+}
+EXPORT_SYMBOL(connectivity_export_clk_buf_show_status_info);
+
+int connectivity_export_clk_buf_get_xo_en_sta(/*enum xo_id id*/ int id)
+{
+#if defined(CONFIG_MACH_MT6768) || \
+	defined(CONFIG_MACH_MT6785) || \
+	defined(CONFIG_MACH_MT6771) || \
+	defined(CONFIG_MACH_MT6739)
+	return clk_buf_get_xo_en_sta(id);
+#else
+	return KERNEL_CLK_BUF_CHIP_NOT_SUPPORT;
+#endif
+}
+EXPORT_SYMBOL(connectivity_export_clk_buf_get_xo_en_sta);
+#endif
+
+/*******************************************************************************
+ * MT6306 I2C-based GPIO Expander
+ ******************************************************************************/
+#ifdef CONFIG_MTK_MT6306_GPIO_SUPPORT
+void connectivity_export_mt6306_set_gpio_out(unsigned long pin,
+					unsigned long output)
+{
+	mt6306_set_gpio_out(MT6306_GPIO_01, MT6306_GPIO_OUT_LOW);
+}
+EXPORT_SYMBOL(connectivity_export_mt6306_set_gpio_out);
+
+void connectivity_export_mt6306_set_gpio_dir(unsigned long pin,
+					unsigned long dir)
+{
+	mt6306_set_gpio_dir(MT6306_GPIO_01, MT6306_GPIO_DIR_OUT);
+}
+EXPORT_SYMBOL(connectivity_export_mt6306_set_gpio_dir);
+#endif
+
+/*******************************************************************************
+ * PMIC
+ ******************************************************************************/
+void connectivity_export_pmic_config_interface(unsigned int RegNum,
+		unsigned int val, unsigned int MASK, unsigned int SHIFT)
+{
+	pmic_config_interface(RegNum, val, MASK, SHIFT);
+}
+EXPORT_SYMBOL(connectivity_export_pmic_config_interface);
+
+void connectivity_export_pmic_read_interface(unsigned int RegNum,
+		unsigned int *val, unsigned int MASK, unsigned int SHIFT)
+{
+	pmic_read_interface(RegNum, val, MASK, SHIFT);
+}
+EXPORT_SYMBOL(connectivity_export_pmic_read_interface);
+
+void connectivity_export_pmic_set_register_value(int flagname, unsigned int val)
+{
+#ifdef CONNADP_HAS_UPMU_VCN_CTRL
+	upmu_set_reg_value(flagname, val);
+#else
+	pmic_set_register_value(flagname, val);
+#endif
+}
+EXPORT_SYMBOL(connectivity_export_pmic_set_register_value);
+
+unsigned short connectivity_export_pmic_get_register_value(int flagname)
+{
+#ifdef CONNADP_HAS_UPMU_VCN_CTRL
+	return upmu_get_reg_value(flagname);
+#else
+	return pmic_get_register_value(flagname);
+#endif
+}
+EXPORT_SYMBOL(connectivity_export_pmic_get_register_value);
+
+void connectivity_export_upmu_set_reg_value(unsigned int reg,
+		unsigned int reg_val)
+{
+	upmu_set_reg_value(reg, reg_val);
+}
+EXPORT_SYMBOL(connectivity_export_upmu_set_reg_value);
+
+#if defined(CONFIG_MTK_PMIC_CHIP_MT6359) || \
+	defined(CONFIG_MTK_PMIC_CHIP_MT6359P)
+int connectivity_export_pmic_ldo_vcn13_lp(int user,
+		int op_mode, unsigned char op_en, unsigned char op_cfg)
+{
+	return pmic_ldo_vcn13_lp(user, op_mode, op_en, op_cfg);
+}
+EXPORT_SYMBOL(connectivity_export_pmic_ldo_vcn13_lp);
+
+int connectivity_export_pmic_ldo_vcn18_lp(int user,
+		int op_mode, unsigned char op_en, unsigned char op_cfg)
+{
+	return pmic_ldo_vcn18_lp(user, op_mode, op_en, op_cfg);
+}
+EXPORT_SYMBOL(connectivity_export_pmic_ldo_vcn18_lp);
+
+void connectivity_export_pmic_ldo_vfe28_lp(unsigned int user,
+		int op_mode, unsigned char op_en, unsigned char op_cfg)
+{
+	pmic_ldo_vfe28_lp(user, op_mode, op_en, op_cfg);
+}
+EXPORT_SYMBOL(connectivity_export_pmic_ldo_vfe28_lp);
+
+int connectivity_export_pmic_ldo_vcn33_1_lp(int user,
+		int op_mode, unsigned char op_en, unsigned char op_cfg)
+{
+	return pmic_ldo_vcn33_1_lp(user, op_mode, op_en, op_cfg);
+}
+EXPORT_SYMBOL(connectivity_export_pmic_ldo_vcn33_1_lp);
+
+int connectivity_export_pmic_ldo_vcn33_2_lp(int user,
+		int op_mode, unsigned char op_en, unsigned char op_cfg)
+{
+	return pmic_ldo_vcn33_2_lp(user, op_mode, op_en, op_cfg);
+}
+EXPORT_SYMBOL(connectivity_export_pmic_ldo_vcn33_2_lp);
+#endif
+/*******************************************************************************
+ * MMC
+ ******************************************************************************/
+int connectivity_export_mmc_io_rw_direct(struct mmc_card *card,
+				int write, unsigned int fn,
+				unsigned int addr, u8 in, u8 *out)
+{
+#if defined(CONFIG_MACH_MT6877)
+	pr_info("[%s] not support now", __func__);
+	return 0;
+#else
+	return mmc_io_rw_direct(card, write, fn, addr, in, out);
+#endif
+}
+EXPORT_SYMBOL(connectivity_export_mmc_io_rw_direct);
+
+/******************************************************************************
+ * GPIO dump information
+ ******************************************************************************/
+#ifndef CONFIG_MTK_GPIO
+void __weak gpio_dump_regs_range(int start, int end)
+{
+	pr_info(DFT_TAG "[W]%s: is not define!\n", __func__);
+}
+#endif
+#ifndef CONFIG_MTK_GPIO
+void connectivity_export_dump_gpio_info(int start, int end)
+{
+	gpio_dump_regs_range(start, end);
+}
+EXPORT_SYMBOL(connectivity_export_dump_gpio_info);
+#endif
+
+void connectivity_export_dump_thread_state(const char *name)
+{
+	static const char stat_nam[] = TASK_STATE_TO_CHAR_STR;
+	struct task_struct *p;
+	int cpu;
+	struct rq *rq;
+	struct task_struct *curr;
+	struct thread_info *ti;
+
+	if (name == NULL || strlen(name) > 255) {
+		pr_info("invalid name:%p or thread name too long\n", name);
+		return;
+	}
+
+	pr_info("start to show debug info of %s\n", name);
+
+	rcu_read_lock();
+	for_each_process(p) {
+		unsigned long state;
+
+		if (strncmp(p->comm, name, strlen(name)) != 0)
+			continue;
+		state = p->state;
+		cpu = task_cpu(p);
+		rq = cpu_rq(cpu);
+		curr = rq->curr;
+		ti = task_thread_info(curr);
+		if (state)
+			state = __ffs(state) + 1;
+		pr_info("%d:%-15.15s %c", p->pid, p->comm,
+			state < sizeof(stat_nam) - 1 ? stat_nam[state] : '?');
+		pr_info("cpu=%d on_cpu=%d ", cpu, p->on_cpu);
+		show_stack(p, NULL);
+		pr_info("CPU%d curr=%d:%-15.15s preempt_count=0x%x", cpu,
+			curr->pid, curr->comm, ti->preempt_count);
+
+		if (state == TASK_RUNNING && curr != p)
+			show_stack(curr, NULL);
+
+		break;
+	}
+	rcu_read_unlock();
+}
+EXPORT_SYMBOL(connectivity_export_dump_thread_state);
+
+int connectivity_export_gpio_get_tristate_input(unsigned int pin)
+{
+#ifdef CONFIG_PINCTRL_MTK_PARIS
+	return gpio_get_tristate_input(pin);
+#else
+	return gpio_get_value(pin);
+#endif
+}
+EXPORT_SYMBOL(connectivity_export_gpio_get_tristate_input);
+
+#ifdef CONNADP_HAS_UPMU_VCN_CTRL
+void conn_upmu_set_vcn35_on_ctrl_bt(unsigned int val)
+{
+	upmu_set_vcn35_on_ctrl_bt(val);
+}
+EXPORT_SYMBOL(conn_upmu_set_vcn35_on_ctrl_bt);
+
+void conn_upmu_set_vcn35_on_ctrl_wifi(unsigned int val)
+{
+	upmu_set_vcn35_on_ctrl_wifi(val);
+}
+EXPORT_SYMBOL(conn_upmu_set_vcn35_on_ctrl_wifi);
+#endif
diff --git a/vendor/mediatek/kernel_modules/connectivity/common/connectivity_build_in_adapter.h b/vendor/mediatek/kernel_modules/connectivity/common/connectivity_build_in_adapter.h
new file mode 100644
index 0000000..f0a1648
--- /dev/null
+++ b/vendor/mediatek/kernel_modules/connectivity/common/connectivity_build_in_adapter.h
@@ -0,0 +1,289 @@
+/*
+ * Copyright (C) 2016 MediaTek Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
+ */
+
+#ifndef CONNECTIVITY_BUILD_IN_ADAPTER_H
+#define CONNECTIVITY_BUILD_IN_ADAPTER_H
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched/clock.h>
+
+/*******************************************************************************
+ * Clock Buffer Control
+ *
+ * The Connsys adaptation layer must provide Clock Buffer Control support
+ * should it be available from the platform.
+ * Therefore CONNADP_HAS_CLOCK_BUF_CTRL is defined based on platform chip, and
+ * is used to decide if adaptation has support on Clock Buffer Control.
+ *
+ * Each WMT platform file must still define its own CONSYS_CLOCK_BUF_CTRL to
+ * decide if it is a co-clock'd platform.
+ * It is possible that the Clock Buffer Control is available on the platform,
+ * but is not used by Connsys.
+ *
+ * For Kernel-4,4, definition of CONNADP_HAS_CLOCK_BUF_CTRL must align with:
+ *	drivers/misc/mediatek/base/power/include/mtk_clkbuf_ctl.h
+ *
+ * Platform that wishes to use Clock Buffer Control, please be sure to #include
+ * the header file above.
+ ******************************************************************************/
+#if defined(CONFIG_MACH_MT6735) || \
+	defined(CONFIG_MACH_MT6735M) || \
+	defined(CONFIG_MACH_MT6753) || \
+	defined(CONFIG_MACH_MT6739) || \
+	defined(CONFIG_MACH_MT6755) || \
+	defined(CONFIG_MACH_MT6757) || \
+	defined(CONFIG_MACH_MT6758) || \
+	defined(CONFIG_MACH_MT6759) || \
+	defined(CONFIG_MACH_MT6763) || \
+	defined(CONFIG_MACH_MT6775) || \
+	defined(CONFIG_MACH_MT6797) || \
+	defined(CONFIG_MACH_MT6799) || \
+	defined(CONFIG_MACH_MT6580) || \
+	defined(CONFIG_MACH_MT6765) || \
+	defined(CONFIG_MACH_MT6761) || \
+	defined(CONFIG_MACH_MT3967) || \
+	defined(CONFIG_MACH_MT6771) || \
+	defined(CONFIG_MACH_MT6768) || \
+	defined(CONFIG_MACH_MT6785) || \
+	defined(CONFIG_MACH_KIBOPLUS) || \
+	defined(CONFIG_MACH_MT6885) || \
+	defined(CONFIG_MACH_MT6853) || \
+	defined(CONFIG_MACH_MT6873) || \
+	defined(CONFIG_MACH_ELBRUS) || \
+	defined(CONFIG_MACH_MT6893) || \
+	defined(CONFIG_MACH_MT6877)
+#define CONNADP_HAS_CLOCK_BUF_CTRL
+#define KERNEL_CLK_BUF_CHIP_NOT_SUPPORT -7788
+#define KERNEL_clk_buf_ctrl connectivity_export_clk_buf_ctrl
+#define KERNEL_clk_buf_show_status_info \
+		connectivity_export_clk_buf_show_status_info
+#define KERNEL_clk_buf_get_xo_en_sta \
+		connectivity_export_clk_buf_get_xo_en_sta
+enum clk_buf_id;
+void connectivity_export_clk_buf_ctrl(enum clk_buf_id id, bool onoff);
+void connectivity_export_clk_buf_show_status_info(void);
+int connectivity_export_clk_buf_get_xo_en_sta(/*enum xo_id id*/ int id);
+#endif
+
+/*******************************************************************************
+ * PMIC
+ * Caller please be sure to #include:
+ *	drivers/misc/mediatek/pmic/include/mt6359/mtk_pmic_api_buck.h
+ *	drivers/misc/mediatek/include/mt-plat/upmu_common.h
+ ******************************************************************************/
+#define KERNEL_pmic_config_interface \
+	connectivity_export_pmic_config_interface
+#define KERNEL_pmic_read_interface \
+	connectivity_export_pmic_read_interface
+#define KERNEL_pmic_set_register_value \
+	connectivity_export_pmic_set_register_value
+#define KERNEL_pmic_get_register_value \
+	connectivity_export_pmic_get_register_value
+#define KERNEL_upmu_set_reg_value \
+	connectivity_export_upmu_set_reg_value
+#if defined(CONFIG_MTK_PMIC_CHIP_MT6359) || \
+	defined(CONFIG_MTK_PMIC_CHIP_MT6359P)
+#define KERNEL_pmic_ldo_vcn13_lp \
+	connectivity_export_pmic_ldo_vcn13_lp
+#define KERNEL_pmic_ldo_vcn18_lp \
+	connectivity_export_pmic_ldo_vcn18_lp
+#define KERNEL_pmic_ldo_vfe28_lp \
+	connectivity_export_pmic_ldo_vfe28_lp
+#define KERNEL_pmic_ldo_vcn33_1_lp \
+	connectivity_export_pmic_ldo_vcn33_1_lp
+#define KERNEL_pmic_ldo_vcn33_2_lp \
+	connectivity_export_pmic_ldo_vcn33_2_lp
+#endif
+void connectivity_export_pmic_config_interface(unsigned int RegNum,
+						unsigned int val,
+						unsigned int MASK,
+						unsigned int SHIFT);
+void connectivity_export_pmic_read_interface(unsigned int RegNum,
+						unsigned int *val,
+						unsigned int MASK,
+						unsigned int SHIFT);
+void connectivity_export_pmic_set_register_value(int flagname,
+						unsigned int val);
+unsigned short connectivity_export_pmic_get_register_value(int flagname);
+void connectivity_export_upmu_set_reg_value(unsigned int reg,
+						unsigned int reg_val);
+#if defined(CONFIG_MTK_PMIC_CHIP_MT6359) || \
+	defined(CONFIG_MTK_PMIC_CHIP_MT6359P)
+int connectivity_export_pmic_ldo_vcn13_lp(int user,
+		int op_mode, unsigned char op_en, unsigned char op_cfg);
+int connectivity_export_pmic_ldo_vcn18_lp(int user,
+		int op_mode, unsigned char op_en, unsigned char op_cfg);
+void connectivity_export_pmic_ldo_vfe28_lp(unsigned int user,
+		int op_mode, unsigned char op_en, unsigned char op_cfg);
+int connectivity_export_pmic_ldo_vcn33_1_lp(int user,
+		int op_mode, unsigned char op_en, unsigned char op_cfg);
+int connectivity_export_pmic_ldo_vcn33_2_lp(int user,
+		int op_mode, unsigned char op_en, unsigned char op_cfg);
+#endif
+
+/*******************************************************************************
+ * MMC
+ * Caller please be sure to #include:
+ *	<linux/mmc/host.h>
+ *	<linux/mmc/card.h>
+ *	drivers/mmc/core/sdio_ops.h
+ ******************************************************************************/
+#define KERNEL_mmc_io_rw_direct connectivity_export_mmc_io_rw_direct
+struct mmc_card;
+int connectivity_export_mmc_io_rw_direct(struct mmc_card *card, int write,
+						unsigned int fn,
+						unsigned int addr,
+						u8 in, u8 *out);
+
+/*******************************************************************************
+ * MT6306 I2C-based GPIO Expander
+ ******************************************************************************/
+#ifdef CONFIG_MTK_MT6306_GPIO_SUPPORT
+#define KERNEL_mt6306_set_gpio_out connectivity_export_mt6306_set_gpio_out
+#define KERNEL_mt6306_set_gpio_dir connectivity_export_mt6306_set_gpio_dir
+void connectivity_export_mt6306_set_gpio_out(unsigned long pin,
+						unsigned long output);
+void connectivity_export_mt6306_set_gpio_dir(unsigned long pin,
+						unsigned long dir);
+#endif
+
+
+#ifdef CONFIG_ARCH_MT6570
+#define CPU_BOOST y
+#endif
+#ifdef CONFIG_ARCH_MT6755
+#define CPU_BOOST y
+#endif
+#ifdef CONFIG_MACH_MT6757
+#define CPU_BOOST y
+#endif
+#ifdef CONFIG_MACH_MT6758
+#define CPU_BOOST y
+#endif
+#ifdef CONFIG_MACH_MT6763
+#define CPU_BOOST y
+#endif
+#ifdef CONFIG_MACH_MT6799
+#define CPU_BOOST y
+#endif
+#ifdef CONFIG_MACH_MT6739
+#define CPU_BOOST y
+#endif
+#ifdef CPU_BOOST
+#include "mtk_ppm_api.h"
+#include "mtk_spm_resource_req.h"
+#endif
+
+#define KERNEL_show_stack connectivity_export_show_stack
+#define KERNEL_tracing_record_cmdline connectivity_export_tracing_record_cmdline
+#define KERNEL_dump_thread_state connectivity_export_dump_thread_state
+
+#ifdef CPU_BOOST
+#define KERNEL_mt_ppm_sysboost_freq connectivity_export_mt_ppm_sysboost_freq
+#define KERNEL_mt_ppm_sysboost_core connectivity_export_mt_ppm_sysboost_core
+#define KERNEL_mt_ppm_sysboost_set_core_limit \
+		connectivity_export_mt_ppm_sysboost_set_core_limit
+#define KERNEL_mt_ppm_sysboost_set_freq_limit \
+		connectivity_export_mt_ppm_sysboost_set_freq_limit
+#define KERNEL_spm_resource_req  connectivity_export_spm_resource_req
+#else
+#define KERNEL_mt_ppm_sysboost_freq
+#define KERNEL_mt_ppm_sysboost_core
+#define KERNEL_mt_ppm_sysboost_set_core_limit
+#define KERNEL_mt_ppm_sysboost_set_freq_limit
+#define KERNEL_spm_resource_req
+#endif
+extern void tracing_record_cmdline(struct task_struct *tsk);
+extern void show_stack(struct task_struct *tsk, unsigned long *sp);
+#ifdef CPU_BOOST
+extern void mt_ppm_sysboost_freq(enum ppm_sysboost_user user,
+				 unsigned int freq);
+extern void mt_ppm_sysboost_core(enum ppm_sysboost_user user,
+				 unsigned int core_num);
+extern void mt_ppm_sysboost_set_core_limit(enum ppm_sysboost_user user,
+					   unsigned int cluster,
+					   int min_core, int max_core);
+extern void mt_ppm_sysboost_set_freq_limit(enum ppm_sysboost_user user,
+					   unsigned int cluster,
+					   int min_freq, int max_freq);
+extern bool spm_resource_req(unsigned int user, unsigned int req_mask);
+#endif
+
+void connectivity_export_show_stack(struct task_struct *tsk, unsigned long *sp);
+void connectivity_export_dump_thread_state(const char *name);
+void connectivity_export_tracing_record_cmdline(struct task_struct *tsk);
+
+void connectivity_export_conap_scp_init(unsigned int chip_info, phys_addr_t emi_phy_addr);
+void connectivity_export_conap_scp_deinit(void);
+
+#ifdef CPU_BOOST
+void connectivity_export_mt_ppm_sysboost_freq(enum ppm_sysboost_user user,
+					      unsigned int freq);
+void connectivity_export_mt_ppm_sysboost_core(enum ppm_sysboost_user user,
+					      unsigned int core_num);
+void connectivity_export_mt_ppm_sysboost_set_core_limit(
+				enum ppm_sysboost_user user,
+				unsigned int cluster,
+				int min_core, int max_core);
+void connectivity_export_mt_ppm_sysboost_set_freq_limit(
+				enum ppm_sysboost_user user,
+				unsigned int cluster,
+				int min_freq, int max_freq);
+bool connectivity_export_spm_resource_req(unsigned int user,
+				unsigned int req_mask);
+#endif
+
+/*********************************************
+ * copy from
+ * kernel-3.18/include/linux/ftrace_event.h
+ * kernel-4.4/include/linux/trace_events.h
+ *
+ * event_trace_printk()
+ *********************************************/
+#ifndef CONFIG_MACH_MT6739
+#define KERNEL_event_trace_printk(ip, fmt, args...)               \
+do {                                                              \
+	__trace_printk_check_format(fmt, ##args);                 \
+	KERNEL_tracing_record_cmdline(current);                   \
+	if (__builtin_constant_p(fmt)) {                          \
+		static const char *trace_printk_fmt               \
+		__attribute__((section("__trace_printk_fmt"))) =  \
+		__builtin_constant_p(fmt) ? fmt : NULL;           \
+		__trace_bprintk(ip, trace_printk_fmt, ##args);    \
+	} else                                                    \
+		__trace_printk(ip, fmt, ##args);                  \
+} while (0)
+#endif
+/******************************************************************************
+ * GPIO dump information
+ ******************************************************************************/
+#ifndef CONFIG_MTK_GPIO
+#define KERNEL_gpio_dump_regs_range connectivity_export_dump_gpio_info
+extern void gpio_dump_regs_range(int start, int end);
+void connectivity_export_dump_gpio_info(int start, int end);
+#endif
+
+int connectivity_export_gpio_get_tristate_input(unsigned int pin);
+
+#if defined(CONFIG_MACH_MT8167)
+#define CONNADP_HAS_UPMU_VCN_CTRL
+#define KERNEL_upmu_set_vcn35_on_ctrl_bt conn_upmu_set_vcn35_on_ctrl_bt
+#define KERNEL_upmu_set_vcn35_on_ctrl_wifi conn_upmu_set_vcn35_on_ctrl_wifi
+void conn_upmu_set_vcn35_on_ctrl_bt(unsigned int val);
+void conn_upmu_set_vcn35_on_ctrl_wifi(unsigned int val);
+#endif
+
+#endif /* CONNECTIVITY_BUILD_IN_ADAPTER_H */
diff --git a/vendor/mediatek/kernel_modules/connectivity/common/wmt_build_in_adapter.c b/vendor/mediatek/kernel_modules/connectivity/common/wmt_build_in_adapter.c
new file mode 100644
index 0000000..7d1b6d1
--- /dev/null
+++ b/vendor/mediatek/kernel_modules/connectivity/common/wmt_build_in_adapter.c
@@ -0,0 +1,452 @@
+/*
+ * Copyright (C) 2016 MediaTek Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
+ */
+/*#define pr_fmt(fmt) KBUILD_MODNAME ": %s: " fmt, __func__*/
+#include <linux/kernel.h>
+
+#include "wmt_build_in_adapter.h"
+#include <linux/string.h>
+#include <linux/printk.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/ctype.h>
+#include <linux/cdev.h>
+
+/*device tree mode*/
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/irqreturn.h>
+#include <linux/of_address.h>
+#endif
+
+#include <linux/interrupt.h>
+#include <linux/ratelimit.h>
+
+#define CONNADP_LOG_LOUD    4
+#define CONNADP_LOG_DBG     3
+#define CONNADP_LOG_INFO    2
+#define CONNADP_LOG_WARN    1
+#define CONNADP_LOG_ERR     0
+
+#if defined(CONFIG_MACH_MT6873)
+#include <clk-mt6873-pg.h>
+#define DUMP_CLOCK_FAIL_CALLBACK 1
+#endif
+
+/*******************************************************************************
+ * Connsys adaptation layer logging utility
+ ******************************************************************************/
+static unsigned int gConnAdpDbgLvl = CONNADP_LOG_INFO;
+
+#define CONNADP_LOUD_FUNC(fmt, arg...) \
+do { \
+	if (gConnAdpDbgLvl >= CONNADP_LOG_LOUD) \
+		pr_info("[L]%s:"  fmt, __func__, ##arg); \
+} while (0)
+#define CONNADP_DBG_FUNC(fmt, arg...) \
+do { \
+	if (gConnAdpDbgLvl >= CONNADP_LOG_DBG) \
+		pr_info("[D]%s:"  fmt, __func__, ##arg); \
+} while (0)
+#define CONNADP_INFO_FUNC(fmt, arg...)  \
+do { \
+	if (gConnAdpDbgLvl >= CONNADP_LOG_INFO) \
+		pr_info("[I]%s:"  fmt, __func__, ##arg); \
+} while (0)
+#define CONNADP_WARN_FUNC(fmt, arg...) \
+do { \
+	if (gConnAdpDbgLvl >= CONNADP_LOG_WARN) \
+		pr_info("[W]%s:"  fmt, __func__, ##arg); \
+} while (0)
+#define CONNADP_ERR_FUNC(fmt, arg...) \
+do { \
+	if (gConnAdpDbgLvl >= CONNADP_LOG_ERR) \
+		pr_info("[E]%s(%d):"  fmt, __func__, __LINE__, ##arg); \
+} while (0)
+
+/* device node related macro */
+#define CONN_DBG_DEV_NUM 1
+#define CONN_DBG_DRVIER_NAME "conn_dbg_drv"
+#define CONN_DBG_DEVICE_NAME "conn_dbg_dev"
+#define CONN_DBG_DEV_MAJOR 156
+
+/* device node related */
+static int gConnDbgMajor = CONN_DBG_DEV_MAJOR;
+static struct class *pConnDbgClass;
+static struct device *pConnDbgDev;
+static struct cdev gConnDbgdev;
+
+/*******************************************************************************
+ * Bridging from platform -> wmt_drv.ko
+ ******************************************************************************/
+static struct wmt_platform_bridge bridge;
+
+ssize_t conn_dbg_dev_write(struct file *filp, const char __user *buffer,
+				size_t count, loff_t *f_pos)
+{
+	if (bridge.debug_write_cb)
+		return bridge.debug_write_cb(filp, buffer, count, f_pos);
+
+	return 0;
+}
+
+ssize_t conn_dbg_dev_read(struct file *filp, char __user *buffer,
+				size_t count, loff_t *f_pos)
+{
+	if (bridge.debug_read_cb)
+		return bridge.debug_read_cb(filp, buffer, count, f_pos);
+
+	return 0;
+}
+
+
+
+
+const struct file_operations gConnDbgDevFops = {
+	.write = conn_dbg_dev_write,
+	.read = conn_dbg_dev_read,
+};
+
+static int conn_dbg_dev_init(void)
+{
+	dev_t dev_id = MKDEV(gConnDbgMajor, 0);
+	int ret = 0;
+
+	ret = register_chrdev_region(dev_id, CONN_DBG_DEV_NUM, CONN_DBG_DRVIER_NAME);
+	if (ret) {
+		pr_info("%s fail to register chrdev.(%d)\n", __func__, ret);
+		return -1;
+	}
+
+	cdev_init(&gConnDbgdev, &gConnDbgDevFops);
+	gConnDbgdev.owner = THIS_MODULE;
+
+	ret = cdev_add(&gConnDbgdev, dev_id, CONN_DBG_DEV_NUM);
+	if (ret) {
+		pr_info("cdev_add() fails (%d)\n", ret);
+		goto err1;
+	}
+
+	pConnDbgClass = class_create(THIS_MODULE, CONN_DBG_DEVICE_NAME);
+	if (IS_ERR(pConnDbgClass)) {
+		pr_info("class create fail, error code(%ld)\n", PTR_ERR(pConnDbgClass));
+		goto err2;
+	}
+
+	pConnDbgDev = device_create(pConnDbgClass, NULL, dev_id, NULL, CONN_DBG_DEVICE_NAME);
+	if (IS_ERR(pConnDbgDev)) {
+		pr_info("device create fail, error code(%ld)\n", PTR_ERR(pConnDbgDev));
+		goto err3;
+	}
+
+	return 0;
+err3:
+
+	pr_info("[%s] err3", __func__);
+	if (pConnDbgClass) {
+		class_destroy(pConnDbgClass);
+		pConnDbgClass = NULL;
+	}
+err2:
+	pr_info("[%s] err2", __func__);
+	cdev_del(&gConnDbgdev);
+
+err1:
+	pr_info("[%s] err1", __func__);
+	unregister_chrdev_region(dev_id, CONN_DBG_DEV_NUM);
+
+	return -1;
+}
+
+static int conn_dbg_dev_deinit(void)
+{
+	dev_t dev_id = MKDEV(gConnDbgMajor, 0);
+
+	if (pConnDbgDev) {
+		device_destroy(pConnDbgClass, dev_id);
+		pConnDbgDev = NULL;
+	}
+
+	if (pConnDbgClass) {
+		class_destroy(pConnDbgClass);
+		pConnDbgClass = NULL;
+	}
+
+	cdev_del(&gConnDbgdev);
+	unregister_chrdev_region(dev_id, CONN_DBG_DEV_NUM);
+
+	return 0;
+}
+
+#ifdef DUMP_CLOCK_FAIL_CALLBACK
+static void wmt_clock_debug_dump(enum subsys_id sys)
+{
+	if (sys == SYS_CONN)
+		mtk_wcn_cmb_stub_clock_fail_dump();
+}
+
+static struct pg_callbacks wmt_clk_subsys_handle = {
+	.debug_dump = wmt_clock_debug_dump
+};
+#endif
+
+void wmt_export_platform_bridge_register(struct wmt_platform_bridge *cb)
+{
+	if (unlikely(!cb))
+		return;
+	bridge.thermal_query_cb = cb->thermal_query_cb;
+	bridge.trigger_assert_cb = cb->trigger_assert_cb;
+	bridge.clock_fail_dump_cb = cb->clock_fail_dump_cb;
+	bridge.conninfra_reg_readable_cb = cb->conninfra_reg_readable_cb;
+	bridge.conninfra_reg_is_bus_hang_cb = cb->conninfra_reg_is_bus_hang_cb;
+	bridge.conninfra_reg_is_bus_hang_no_lock_cb = cb->conninfra_reg_is_bus_hang_no_lock_cb;
+#ifdef DUMP_CLOCK_FAIL_CALLBACK
+	register_pg_callback(&wmt_clk_subsys_handle);
+#endif
+
+	if (cb->debug_write_cb != NULL && cb->debug_read_cb != NULL) {
+		bridge.debug_write_cb = cb->debug_write_cb;
+		bridge.debug_read_cb = cb->debug_read_cb;
+		conn_dbg_dev_init();
+	}
+
+	CONNADP_INFO_FUNC("\n");
+}
+EXPORT_SYMBOL(wmt_export_platform_bridge_register);
+
+void wmt_export_platform_bridge_unregister(void)
+{
+	if (bridge.debug_write_cb && bridge.debug_read_cb)
+		conn_dbg_dev_deinit();
+	memset(&bridge, 0, sizeof(struct wmt_platform_bridge));
+	CONNADP_INFO_FUNC("\n");
+}
+EXPORT_SYMBOL(wmt_export_platform_bridge_unregister);
+
+int mtk_wcn_cmb_stub_query_ctrl(void)
+{
+	CONNADP_DBG_FUNC("\n");
+	if (unlikely(!bridge.thermal_query_cb)) {
+		CONNADP_WARN_FUNC("Thermal query not registered\n");
+		return -1;
+	} else
+		return bridge.thermal_query_cb();
+}
+
+int mtk_wcn_cmb_stub_trigger_assert(void)
+{
+	CONNADP_DBG_FUNC("\n");
+	/* dump backtrace for checking assert reason */
+	dump_stack();
+	if (unlikely(!bridge.trigger_assert_cb)) {
+		CONNADP_WARN_FUNC("Trigger assert not registered\n");
+		return -1;
+	} else
+		return bridge.trigger_assert_cb();
+}
+
+void mtk_wcn_cmb_stub_clock_fail_dump(void)
+{
+	CONNADP_DBG_FUNC("\n");
+	if (unlikely(!bridge.clock_fail_dump_cb))
+		CONNADP_WARN_FUNC("Clock fail dump not registered\n");
+	else
+		bridge.clock_fail_dump_cb();
+}
+
+int mtk_wcn_conninfra_reg_readable(void)
+{
+	static DEFINE_RATELIMIT_STATE(_rs, 5*HZ, 1);
+
+	if (unlikely(!bridge.conninfra_reg_readable_cb)) {
+		if (__ratelimit(&_rs))
+			CONNADP_WARN_FUNC("reg_readable not registered\n");
+		return -1;
+	} else
+		return bridge.conninfra_reg_readable_cb();
+}
+
+int mtk_wcn_conninfra_is_bus_hang(void)
+{
+	static DEFINE_RATELIMIT_STATE(_rs, 5*HZ, 1);
+
+	if (unlikely(!bridge.conninfra_reg_is_bus_hang_cb)) {
+		if (__ratelimit(&_rs))
+			CONNADP_WARN_FUNC("is_bus_hang not registered\n");
+		return -1;
+	} else
+		return bridge.conninfra_reg_is_bus_hang_cb();
+}
+
+int mtk_wcn_conninfra_conn_bus_dump(void)
+{
+	static DEFINE_RATELIMIT_STATE(_rs, 5*HZ, 1);
+	int ret = 0;
+
+	if (unlikely(!bridge.conninfra_reg_is_bus_hang_no_lock_cb)) {
+		if (__ratelimit(&_rs))
+			CONNADP_WARN_FUNC("is_bus_hang_no_lock not registered\n");
+		ret = -1;
+	} else {
+		ret = bridge.conninfra_reg_is_bus_hang_no_lock_cb();
+	}
+
+	return ret;
+}
+
+/*******************************************************************************
+ * SDIO integration with platform MMC driver
+ ******************************************************************************/
+static void mtk_wcn_cmb_sdio_request_eirq(msdc_sdio_irq_handler_t irq_handler,
+					  void *data);
+static void mtk_wcn_cmb_sdio_enable_eirq(void);
+static void mtk_wcn_cmb_sdio_disable_eirq(void);
+static void mtk_wcn_cmb_sdio_register_pm(pm_callback_t pm_cb, void *data);
+
+struct sdio_ops mt_sdio_ops[4] = {
+	{NULL, NULL, NULL, NULL},
+	{NULL, NULL, NULL, NULL},
+	{mtk_wcn_cmb_sdio_request_eirq, mtk_wcn_cmb_sdio_enable_eirq,
+		mtk_wcn_cmb_sdio_disable_eirq, mtk_wcn_cmb_sdio_register_pm},
+	{mtk_wcn_cmb_sdio_request_eirq, mtk_wcn_cmb_sdio_enable_eirq,
+		mtk_wcn_cmb_sdio_disable_eirq, mtk_wcn_cmb_sdio_register_pm}
+};
+
+static atomic_t sdio_claim_irq_enable_flag;
+static atomic_t irq_enable_flag;
+
+static msdc_sdio_irq_handler_t mtk_wcn_cmb_sdio_eirq_handler;
+static void *mtk_wcn_cmb_sdio_eirq_data;
+
+unsigned int wifi_irq = 0xffffffff;
+EXPORT_SYMBOL(wifi_irq);
+
+pm_callback_t mtk_wcn_cmb_sdio_pm_cb;
+EXPORT_SYMBOL(mtk_wcn_cmb_sdio_pm_cb);
+
+void *mtk_wcn_cmb_sdio_pm_data;
+EXPORT_SYMBOL(mtk_wcn_cmb_sdio_pm_data);
+
+static int _mtk_wcn_sdio_irq_flag_set(int flag)
+{
+	if (flag != 0)
+		atomic_set(&sdio_claim_irq_enable_flag, 1);
+	else
+		atomic_set(&sdio_claim_irq_enable_flag, 0);
+
+	CONNADP_DBG_FUNC("sdio_claim_irq_enable_flag:%d\n",
+			atomic_read(&sdio_claim_irq_enable_flag));
+
+	return atomic_read(&sdio_claim_irq_enable_flag);
+}
+
+int wmt_export_mtk_wcn_sdio_irq_flag_set(int flag)
+{
+	return _mtk_wcn_sdio_irq_flag_set(flag);
+}
+EXPORT_SYMBOL(wmt_export_mtk_wcn_sdio_irq_flag_set);
+
+static irqreturn_t mtk_wcn_cmb_sdio_eirq_handler_stub(int irq, void *data)
+{
+	if ((mtk_wcn_cmb_sdio_eirq_handler != NULL) &&
+	    (atomic_read(&sdio_claim_irq_enable_flag) != 0))
+		mtk_wcn_cmb_sdio_eirq_handler(mtk_wcn_cmb_sdio_eirq_data);
+	return IRQ_HANDLED;
+}
+
+void mtk_wcn_cmb_sdio_request_eirq_by_wmt(void)
+{
+#ifdef CONFIG_OF
+	int ret = -EINVAL;
+	struct device_node *node;
+
+	CONNADP_INFO_FUNC("enter\n");
+	_mtk_wcn_sdio_irq_flag_set(0);
+	atomic_set(&irq_enable_flag, 1);
+
+	node = (struct device_node *)of_find_compatible_node(NULL, NULL,
+					"mediatek,connectivity-combo");
+	if (node) {
+		wifi_irq = irq_of_parse_and_map(node, 0);/* get wifi eint num */
+		ret = request_irq(wifi_irq, mtk_wcn_cmb_sdio_eirq_handler_stub,
+				IRQF_TRIGGER_LOW, "WIFI-eint", NULL);
+		CONNADP_DBG_FUNC("WIFI EINT irq %d !!\n", wifi_irq);
+
+		if (ret)
+			CONNADP_WARN_FUNC("WIFI EINT LINE NOT AVAILABLE!!\n");
+		else
+			mtk_wcn_cmb_sdio_disable_eirq();/*state:power off*/
+	} else
+		CONNADP_WARN_FUNC("can't find connectivity compatible node\n");
+
+	CONNADP_INFO_FUNC("exit\n");
+	return;
+#endif
+}
+EXPORT_SYMBOL(mtk_wcn_cmb_sdio_request_eirq_by_wmt);
+
+static void mtk_wcn_cmb_sdio_request_eirq(msdc_sdio_irq_handler_t irq_handler,
+					  void *data)
+{
+#ifdef CONFIG_OF
+	CONNADP_INFO_FUNC("enter\n");
+	mtk_wcn_cmb_sdio_eirq_data = data;
+	mtk_wcn_cmb_sdio_eirq_handler = irq_handler;
+
+	CONNADP_INFO_FUNC("exit\n");
+#else
+	CONNADP_ERR_FUNC("not implemented\n");
+#endif
+}
+
+static void mtk_wcn_cmb_sdio_register_pm(pm_callback_t pm_cb, void *data)
+{
+	CONNADP_DBG_FUNC("cmb_sdio_register_pm (0x%p, 0x%p)\n", pm_cb, data);
+	/* register pm change callback */
+	mtk_wcn_cmb_sdio_pm_cb = pm_cb;
+	mtk_wcn_cmb_sdio_pm_data = data;
+}
+
+static void mtk_wcn_cmb_sdio_enable_eirq(void)
+{
+	if (atomic_read(&irq_enable_flag))
+		CONNADP_DBG_FUNC("wifi eint has been enabled\n");
+	else {
+		atomic_set(&irq_enable_flag, 1);
+		if (wifi_irq != 0xffffffff) {
+			enable_irq(wifi_irq);
+			CONNADP_DBG_FUNC(" enable WIFI EINT %d!\n", wifi_irq);
+		}
+	}
+}
+
+static void mtk_wcn_cmb_sdio_disable_eirq(void)
+{
+	if (!atomic_read(&irq_enable_flag))
+		CONNADP_DBG_FUNC("wifi eint has been disabled!\n");
+	else {
+		if (wifi_irq != 0xffffffff) {
+			disable_irq_nosync(wifi_irq);
+			CONNADP_DBG_FUNC("disable WIFI EINT %d!\n", wifi_irq);
+		}
+		atomic_set(&irq_enable_flag, 0);
+	}
+}
+
+void wmt_export_mtk_wcn_cmb_sdio_disable_eirq(void)
+{
+	mtk_wcn_cmb_sdio_disable_eirq();
+}
+EXPORT_SYMBOL(wmt_export_mtk_wcn_cmb_sdio_disable_eirq);
diff --git a/vendor/mediatek/kernel_modules/connectivity/common/wmt_build_in_adapter.h b/vendor/mediatek/kernel_modules/connectivity/common/wmt_build_in_adapter.h
new file mode 100644
index 0000000..c78ba2a
--- /dev/null
+++ b/vendor/mediatek/kernel_modules/connectivity/common/wmt_build_in_adapter.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2016 MediaTek Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See http://www.gnu.org/licenses/gpl-2.0.html for more details.
+ */
+
+#ifndef WMT_BUILD_IN_ADAPTER_H
+#define WMT_BUILD_IN_ADAPTER_H
+
+#include <mtk_wcn_cmb_stub.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+
+#define KERNEL_mtk_wcn_cmb_sdio_request_eirq \
+		mtk_wcn_cmb_sdio_request_eirq_by_wmt
+void mtk_wcn_cmb_sdio_request_eirq_by_wmt(void);
+
+/*******************************************************************************
+ * Bridging from platform -> wmt_drv.ko
+ ******************************************************************************/
+typedef int (*wmt_bridge_thermal_query_cb)(void);
+typedef int (*wmt_bridge_trigger_assert_cb)(void);
+typedef void (*wmt_bridge_connsys_clock_fail_dump_cb)(void);
+
+typedef int (*wmt_bridge_conninfra_reg_readable)(void);
+typedef int (*wmt_bridge_conninfra_reg_is_bus_hang)(void);
+typedef int (*wmt_bridge_conninfra_reg_is_bus_hang_no_lock)(void);
+
+typedef ssize_t (*wmt_bridge_debug_write_cb)(struct file *, const char __user *, size_t, loff_t *);
+typedef ssize_t (*wmt_bridge_debug_read_cb)(struct file *, char __user *, size_t, loff_t *);
+
+struct wmt_platform_bridge {
+	wmt_bridge_thermal_query_cb thermal_query_cb;
+	wmt_bridge_trigger_assert_cb trigger_assert_cb;
+	wmt_bridge_connsys_clock_fail_dump_cb clock_fail_dump_cb;
+	wmt_bridge_debug_write_cb debug_write_cb;
+	wmt_bridge_debug_read_cb debug_read_cb;
+
+	/* for CONNAC 2 */
+	wmt_bridge_conninfra_reg_readable conninfra_reg_readable_cb;
+	wmt_bridge_conninfra_reg_is_bus_hang conninfra_reg_is_bus_hang_cb;
+	wmt_bridge_conninfra_reg_is_bus_hang_no_lock conninfra_reg_is_bus_hang_no_lock_cb;
+};
+
+void wmt_export_platform_bridge_register(struct wmt_platform_bridge *cb);
+void wmt_export_platform_bridge_unregister(void);
+
+
+/*******************************************************************************
+ * SDIO integration with platform MMC driver
+ ******************************************************************************/
+extern unsigned int wifi_irq;
+extern pm_callback_t mtk_wcn_cmb_sdio_pm_cb;
+extern void *mtk_wcn_cmb_sdio_pm_data;
+
+void wmt_export_mtk_wcn_cmb_sdio_disable_eirq(void);
+int wmt_export_mtk_wcn_sdio_irq_flag_set(int flag);
+
+#endif /* WMT_BUILD_IN_ADAPTER_H */
diff --git a/vendor/mediatek/kernel_modules/connectivity/bt/mt66xx/wmt/btmtk_dbg_tp_evt.h b/vendor/mediatek/kernel_modules/connectivity/bt/mt66xx/wmt/btmtk_dbg_tp_evt.h
new file mode 100644
index 0000000..437c3bc
--- /dev/null
+++ b/vendor/mediatek/kernel_modules/connectivity/bt/mt66xx/wmt/btmtk_dbg_tp_evt.h
@@ -0,0 +1,79 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM connsys_trace_event
+
+#if !defined(_TRACE_BTMTK_DBG_EVENTS_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_BTMTK_DBG_EVENTS_H
+
+#include <linux/tracepoint.h>
+
+#define __GET_ENTRY_16_BYTES_LEN_BUFFER(__entry_data, __entry_data_len, data, data_len)	\
+	do {																				\
+		unsigned int data_sz = (data_len <= 16) ? (data_len) : (16);					\
+		char buf_str[32] = {""};														\
+		int i = 0;																		\
+		if (data_sz > 0 && data != NULL) {												\
+			if (snprintf(__entry_data, __entry_data_len, "%s", "") < 0)					\
+				pr_info("snprintf error in btmtk_dbg_tp_evt.h");											\
+			for (i = 0; i < data_sz; i++) {												\
+				if (snprintf(buf_str, sizeof(buf_str), "%02x", data[i]) > 0)			\
+					strncat(__entry_data, buf_str, strlen(buf_str));					\
+			}																			\
+		} else {																		\
+			if (snprintf(__entry_data, __entry_data_len, "%s", "null") < 0)				\
+				pr_info("snprintf error in btmtk_dbg_tp_evt.h");											\
+		}																				\
+	} while (0)
+
+#define __GET_ENTRY_STRING(__entry_data, __entry_data_len, data)					\
+	do {																			\
+		if (strlen(data) == 0 || data == NULL){										\
+			if (snprintf(__entry_data, __entry_data_len, "%s", "null") < 0)			\
+				pr_info("snprintf error in btmtk_dbg_tp_evt.h");										\
+		} else {																	\
+			if (snprintf(__entry_data, __entry_data_len, "%s", data) < 0)			\
+				pr_info("snprintf error in btmtk_dbg_tp_evt.h");										\
+		}																			\
+	} while (0)
+
+TRACE_EVENT(bt_evt,
+
+	TP_PROTO(unsigned int pkt_action,
+		unsigned int parameter,
+		unsigned int data_len,
+		char *data),
+
+	TP_ARGS(pkt_action, parameter, data_len, data),
+
+	TP_STRUCT__entry(
+		__field(unsigned int, pkt_action)
+		__field(unsigned int, parameter)
+		__field(unsigned int, data_len)
+		__dynamic_array(char, data, 256)
+	),
+
+	TP_fast_assign(
+		__entry->pkt_action = pkt_action;
+		__entry->parameter = parameter;
+		__entry->data_len = data_len;
+		__GET_ENTRY_16_BYTES_LEN_BUFFER(__get_str(data), __get_dynamic_array_len(data), data, data_len);
+	),
+
+	TP_printk("%d,%d,%d,%s",
+		__entry->pkt_action, __entry->parameter, __entry->data_len, __get_str(data))
+);
+
+#endif /* _TRACE_BTMTK_DBG_EVENTS_H */
+
+/* This part must be outside protection */
+#undef TRACE_INCLUDE_PATH
+#define TRACE_INCLUDE_PATH ./
+#undef TRACE_INCLUDE_FILE
+#define TRACE_INCLUDE_FILE btmtk_dbg_tp_evt
+#include <trace/define_trace.h>
+
+
diff --git a/vendor/mediatek/kernel_modules/connectivity/bt/mt66xx/wmt/btmtk_dbg_tp_evt_if.h b/vendor/mediatek/kernel_modules/connectivity/bt/mt66xx/wmt/btmtk_dbg_tp_evt_if.h
new file mode 100644
index 0000000..6215c10
--- /dev/null
+++ b/vendor/mediatek/kernel_modules/connectivity/bt/mt66xx/wmt/btmtk_dbg_tp_evt_if.h
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+ 
+#ifndef _BTMTK_DBG_EVENTS_IF_H_
+#define _BTMTK_DBG_EVENTS_IF_H_
+
+#define TP_ACT_PWR_ON 0
+#define TP_ACT_PWR_OFF 1
+#define TP_ACT_POLL 2
+#define TP_ACT_WR_IN 3
+#define TP_ACT_WR_OUT 4
+#define TP_ACT_RD_IN 5
+#define TP_ACT_RD_CB 6
+#define TP_ACT_RD_OUT 7
+#define TP_ACT_FWOWN_IN 8
+#define TP_ACT_FWOWN_OUT 9
+#define TP_ACT_DRVOWN_IN 10
+#define TP_ACT_DRVOWN_OUT 11
+#define TP_ACT_DPI_ENTER 12
+#define TP_ACT_DPI_EXIT 13
+#define TP_ACT_RST 14
+
+#define TP_PAR_PASS 1
+#define TP_PAR_FAIL 2
+#define TP_PAR_RST_START 3
+#define TP_PAR_RST_DUMP 4
+#define TP_PAR_RST_OFF 5
+
+void bt_dbg_tp_evt(unsigned int pkt_action,
+		unsigned int parameter,
+		unsigned int data_len,
+		char *data);
+
+
+#endif
diff --git a/../vendor/mediatek/kernel_modules/connectivity/gps/Android.mk b/../vendor/mediatek/kernel_modules/connectivity/gps/Android.mk
new file mode 100644
index 0000000..2f5a20b
--- /dev/null
+++ b/vendor/mediatek/kernel_modules/connectivity/gps/Android.mk
@@ -0,0 +1,59 @@
+ifeq ($(GPS_CHIP_ID), common)
+LOCAL_PATH_INCLUDE := $(call my-dir)
+
+include $(LOCAL_PATH_INCLUDE)/gps_stp/Android.mk
+
+ifneq ($(wildcard $(LOCAL_PATH_INCLUDE)/data_link/plat/v010),)
+GPS_PLATFORM := v010
+include $(LOCAL_PATH_INCLUDE)/data_link/Android.mk
+endif
+
+ifneq ($(wildcard $(LOCAL_PATH_INCLUDE)/data_link/plat/v030),)
+GPS_PLATFORM := v030
+include $(LOCAL_PATH_INCLUDE)/data_link/Android.mk
+endif
+
+ifneq ($(wildcard $(LOCAL_PATH_INCLUDE)/data_link/plat/v050),)
+GPS_PLATFORM := v050
+include $(LOCAL_PATH_INCLUDE)/data_link/Android.mk
+endif
+
+ifneq ($(wildcard $(LOCAL_PATH_INCLUDE)/gps_scp),)
+include $(LOCAL_PATH_INCLUDE)/gps_scp/Android.mk
+endif
+
+ifneq ($(wildcard $(LOCAL_PATH_INCLUDE)/gps_pwr),)
+include $(LOCAL_PATH_INCLUDE)/gps_pwr/Android.mk
+endif
+
+$(warning GPS_CHIP_ID = common)
+else
+
+$(warning GPS_CHIP_ID != common)
+LOCAL_PATH := $(call my-dir)
+
+ifeq ($(MTK_GPS_SUPPORT), yes)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := gps_drv.ko
+LOCAL_PROPRIETARY_MODULE := true
+LOCAL_MODULE_OWNER := mtk
+LOCAL_INIT_RC := init.gps_drv.rc
+
+ifneq (,$(filter mt6877 mt6879 mt6885 mt6893 mt6983,$(TARGET_BOARD_PLATFORM)))
+#Only set dependency to conninfra.ko when CONSYS_CHIP in list.
+ifneq (,$(filter CONSYS_6877 CONSYS_6879 CONSYS_6885 CONSYS_6893 CONSYS_6983,$(MTK_COMBO_CHIP)))
+LOCAL_REQUIRED_MODULES := conninfra.ko
+else
+$(warning TARGET_BOARD_PLATFORM=$(TARGET_BOARD_PLATFORM), MTK_COMBO_CHIP=$(MTK_COMBO_CHIP))
+$(warning gps_drv.ko does not claim the requirement for conninfra.ko)
+endif
+else
+LOCAL_REQUIRED_MODULES := wmt_drv.ko
+endif
+
+include $(MTK_KERNEL_MODULE)
+
+endif
+
+endif
diff --git a/../vendor/mediatek/kernel_modules/connectivity/gps/Makefile b/../vendor/mediatek/kernel_modules/connectivity/gps/Makefile
new file mode 100644
index 0000000..18d0a61
--- /dev/null
+++ b/vendor/mediatek/kernel_modules/connectivity/gps/Makefile
@@ -0,0 +1,281 @@
+# drivers/barcelona/gps/Makefile
+#
+# Makefile for the Barcelona GPS driver.
+#
+# Copyright (C) 2004,2005 TomTom BV <http://www.tomtom.com/>
+# Author: Dimitry Andric <dimitry.andric@tomtom.com>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2 as
+# published by the Free Software Foundation.
+
+###############################################################################
+ifeq ($(GPS_CHIP_ID), common)
+
+$(warning GPS_CHIP_ID = common)
+else
+$(warning GPS_CHIP_ID != common)
+# Necessary Check
+MTK_PLATFORM := $(subst ",,$(CONFIG_MTK_PLATFORM))
+ifeq ($(CONFIG_MTK_GPS_SUPPORT), y)
+
+ifneq ($(KERNEL_OUT),)
+    ccflags-y += -imacros $(KERNEL_OUT)/include/generated/autoconf.h
+endif
+
+ifndef TOP
+    TOP := $(srctree)/..
+endif
+ifeq ($(TARGET_BUILD_VARIANT),$(filter $(TARGET_BUILD_VARIANT),userdebug user))
+    ldflags-y += -s
+endif
+
+# Force build fail on modpost warning
+KBUILD_MODPOST_FAIL_ON_WARNINGS := y
+###############################################################################
+
+# only WMT align this design flow, but gps use this also.
+#ccflags-y += -D MTK_WCN_REMOVE_KERNEL_MODULE
+
+ifeq ($(CONFIG_ARM64), y)
+    ccflags-y += -D CONFIG_MTK_WCN_ARM64
+endif
+
+ifeq ($(CONFIG_MTK_CONN_LTE_IDC_SUPPORT),y)
+    ccflags-y += -D WMT_IDC_SUPPORT=1
+else
+    ccflags-y += -D WMT_IDC_SUPPORT=0
+endif
+ccflags-y += -D MTK_WCN_WMT_STP_EXP_SYMBOL_ABSTRACT
+
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/include
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/include/mt-plat
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/include/mt-plat/$(MTK_PLATFORM)/include
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/include/mt-plat/$(MTK_PLATFORM)/include/mach
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/freqhopping
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/freqhopping/$(MTK_PLATFORM)
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/emi/submodule
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/emi/$(MTK_PLATFORM)
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/connectivity/common
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/mach/$(MTK_PLATFORM)/include/mach
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/base/power/$(MTK_PLATFORM)
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/base/power/include
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/base/power/include/clkbuf_v1
+ccflags-y += -I$(srctree)/drivers/misc/mediatek/base/power/include/clkbuf_v1/$(MTK_PLATFORM)
+ccflags-y += -I$(srctree)/drivers/devfreq
+###############################################################################
+
+MODULE_NAME := gps_drv
+obj-m += $(MODULE_NAME).o
+
+GPS_DRV_CONTROL_LNA := n
+GPS_DL_SUPPORT := n
+GPS_DL_HAS_MOCK := n
+GPS_DL_HAS_CONNINFRA_DRV := n
+GPS_SRC_FOLDER := $(srctree)/drivers/misc/mediatek/connectivity/gps
+
+ifeq ($(CONFIG_ARCH_MTK_PROJECT),"k6833v1_64_swrgo")
+ccflags-y += -DCONFIG_GPSL5_SUPPORT
+ccflags-y += -DCONFIG_GPS_CTRL_LNA_SUPPORT
+GPS_DRV_CONTROL_LNA := y
+endif
+
+ifeq ($(CONFIG_MACH_MT6833),y)
+ccflags-y += -DCONFIG_GPSL5_SUPPORT
+ccflags-y += -DCONFIG_GPS_CTRL_LNA_SUPPORT
+GPS_DRV_CONTROL_LNA := y
+endif
+ifeq ($(CONFIG_MACH_MT6781),y)
+ccflags-y += -DCONFIG_GPSL5_SUPPORT
+ccflags-y += -DCONFIG_GPS_CTRL_LNA_SUPPORT
+GPS_DRV_CONTROL_LNA := y
+endif
+ifeq ($(CONFIG_MACH_MT6877),y)
+GPS_DL_SUPPORT := y
+GPS_DL_PLATFORM := v030
+endif
+ifeq ($(CONFIG_MACH_MT6879),y)
+GPS_DL_SUPPORT := y
+GPS_DL_PLATFORM := v050
+endif
+ifeq ($(CONFIG_MACH_MT6885),y)
+GPS_DL_SUPPORT := y
+GPS_DL_PLATFORM := v010
+endif
+ifeq ($(CONFIG_MTK_COMBO_CHIP_CONSYS_6893),y)
+GPS_DL_SUPPORT := y
+GPS_DL_PLATFORM := v010
+endif
+ifeq ($(CONFIG_MACH_MT6983),y)
+GPS_DL_SUPPORT := y
+GPS_DL_PLATFORM := v050
+endif
+
+ifeq ($(CONFIG_MTK_COMBO_CHIP_CONSYS_6877),y)
+GPS_DL_HAS_CONNINFRA_DRV := y
+endif
+ifeq ($(CONFIG_MTK_COMBO_CHIP_CONSYS_6879),y)
+GPS_DL_HAS_CONNINFRA_DRV := y
+endif
+ifeq ($(CONFIG_MTK_COMBO_CHIP_CONSYS_6885),y)
+GPS_DL_HAS_CONNINFRA_DRV := y
+endif
+ifeq ($(CONFIG_MTK_COMBO_CHIP_CONSYS_6893),y)
+GPS_DL_HAS_CONNINFRA_DRV := y
+endif
+ifeq ($(CONFIG_MTK_COMBO_CHIP_CONSYS_6983),y)
+GPS_DL_HAS_CONNINFRA_DRV := y
+endif
+
+ifeq ($(GPS_DL_SUPPORT),y) # New GPS driver with L1+L5 support
+ccflags-y += -I$(GPS_SRC_FOLDER)/data_link/plat/$(GPS_DL_PLATFORM)
+ccflags-y += -I$(GPS_SRC_FOLDER)/data_link/plat/$(GPS_DL_PLATFORM)/inc
+ccflags-y += -I$(GPS_SRC_FOLDER)/data_link/plat/$(GPS_DL_PLATFORM)/hw/inc
+ifeq ($(GPS_DL_HAS_CONNINFRA_DRV),y)
+CONNINFRA_SRC_FOLDER := $(srctree)/drivers/misc/mediatek/connectivity/conninfra
+ccflags-y += -I$(CONNINFRA_SRC_FOLDER)/include
+ccflags-y += -I$(CONNINFRA_SRC_FOLDER)/debug_utility/metlog
+ccflags-y += -DGPS_DL_HAS_CONNINFRA_DRV=1
+endif
+
+ccflags-y += -I$(GPS_SRC_FOLDER)/data_link/inc
+ccflags-y += -I$(GPS_SRC_FOLDER)/data_link/linux/inc
+ccflags-y += -I$(GPS_SRC_FOLDER)/data_link/link/inc
+ccflags-y += -I$(GPS_SRC_FOLDER)/data_link/lib/inc
+ccflags-y += -I$(GPS_SRC_FOLDER)/data_link/hal/inc
+ccflags-y += -I$(GPS_SRC_FOLDER)/data_link/hw/inc
+ccflags-y += -I$(GPS_SRC_FOLDER)/data_link_mock/mock/inc
+
+$(MODULE_NAME)-objs += data_link/gps_dl_module.o
+$(MODULE_NAME)-objs += data_link/gps_dl_context.o
+
+$(MODULE_NAME)-objs += data_link/lib/gps_dl_dma_buf.o
+$(MODULE_NAME)-objs += data_link/lib/gps_dl_lib_misc.o
+$(MODULE_NAME)-objs += data_link/lib/gps_dl_hist_rec.o
+$(MODULE_NAME)-objs += data_link/lib/gps_dl_hist_rec2.o
+$(MODULE_NAME)-objs += data_link/lib/gps_dl_time_tick.o
+$(MODULE_NAME)-objs += data_link/lib/gps_dl_name_list.o
+
+$(MODULE_NAME)-objs += data_link/hw/gps_dl_hw_conn_infra.o
+$(MODULE_NAME)-objs += data_link/hw/gps_dl_hw_semaphore.o
+$(MODULE_NAME)-objs += data_link/hw/gps_dl_hw_bgf.o
+$(MODULE_NAME)-objs += data_link/hw/gps_dl_hw_gps.o
+$(MODULE_NAME)-objs += data_link/hw/gps_dl_hw_power_ctrl.o
+$(MODULE_NAME)-objs += data_link/hw/gps_dl_hw_usrt_apb.o
+$(MODULE_NAME)-objs += data_link/hw/gps_dl_hw_util.o
+
+$(MODULE_NAME)-objs += data_link/hal/gps_dl_hal.o
+$(MODULE_NAME)-objs += data_link/hal/gps_dl_hal_util.o
+$(MODULE_NAME)-objs += data_link/hal/gps_dsp_fsm.o
+$(MODULE_NAME)-objs += data_link/hal/gps_dl_power_ctrl.o
+$(MODULE_NAME)-objs += data_link/hal/gps_dl_isr.o
+$(MODULE_NAME)-objs += data_link/hal/gps_dl_dma.o
+$(MODULE_NAME)-objs += data_link/hal/gps_dl_mcub.o
+$(MODULE_NAME)-objs += data_link/hal/gps_dl_zbus.o
+$(MODULE_NAME)-objs += data_link/hal/gps_dl_conn_infra.o
+$(MODULE_NAME)-objs += data_link/hal/gps_dl_hal_met2_0.o
+
+$(MODULE_NAME)-objs += data_link/link/gps_dl_link_event_proc.o
+$(MODULE_NAME)-objs += data_link/link/gps_dl_link_hal_ctrl.o
+$(MODULE_NAME)-objs += data_link/link/gps_dl_link_irq_ctrl.o
+$(MODULE_NAME)-objs += data_link/link/gps_dl_link_state.o
+$(MODULE_NAME)-objs += data_link/link/gps_dl_link_sync.o
+$(MODULE_NAME)-objs += data_link/link/gps_dl_link_util.o
+$(MODULE_NAME)-objs += data_link/link/gps_dl_subsys_reset.o
+$(MODULE_NAME)-objs += data_link/gps_each_link.o
+
+$(MODULE_NAME)-objs += data_link/linux/gps_data_link_devices.o
+$(MODULE_NAME)-objs += data_link/linux/gps_each_device.o
+$(MODULE_NAME)-objs += data_link/linux/gps_dl_linux.o
+$(MODULE_NAME)-objs += data_link/linux/gps_dl_linux_plat_drv.o
+$(MODULE_NAME)-objs += data_link/linux/gps_dl_linux_reserved_mem.o
+$(MODULE_NAME)-objs += data_link/linux/gps_dl_emi.o
+$(MODULE_NAME)-objs += data_link/linux/gps_dl_ctrld.o
+$(MODULE_NAME)-objs += data_link/linux/gps_dl_procfs.o
+$(MODULE_NAME)-objs += data_link/linux/gps_dl_osal.o
+
+$(MODULE_NAME)-objs += data_link/plat/$(GPS_DL_PLATFORM)/gps_dl_hw_dep_bgf.o
+$(MODULE_NAME)-objs += data_link/plat/$(GPS_DL_PLATFORM)/gps_dl_hw_dep_gps.o
+$(MODULE_NAME)-objs += data_link/plat/$(GPS_DL_PLATFORM)/gps_dl_hw_dep_debug.o
+$(MODULE_NAME)-objs += data_link/plat/$(GPS_DL_PLATFORM)/gps_dl_hw_dep_met2_0.o
+
+ifeq ($(GPS_DL_HAS_MOCK),y)
+$(MODULE_NAME)-objs += data_link_mock/mock/gps_mock_mvcd.o
+$(MODULE_NAME)-objs += data_link_mock/mock/gps_mock_hal.o
+ccflags-y += -DGPS_DL_HAS_MOCK=1
+endif
+
+else #Legacy drivers
+WMT_SRC_FOLDER := $(srctree)/drivers/misc/mediatek/connectivity/common
+
+ifeq ($(CONFIG_MTK_COMBO_CHIP),)
+ifneq ($(filter "y",$(CONFIG_MTK_COMBO_CHIP_MT6620) $(CONFIG_MTK_COMBO_CHIP_MT6628) $(CONFIG_MTK_COMBO_CHIP_MT6630) $(CONFIG_MTK_COMBO_CHIP_MT6632) $(CONFIG_MTK_COMBO_CHIP_MT7668) $(CONFIG_MTK_COMBO_CHIP_MT6785)),)
+        ccflags-y += -DSOC_CO_CLOCK_FLAG=0
+        ccflags-y += -DWMT_CREATE_NODE_DYNAMIC=0
+        ccflags-y += -DREMOVE_MK_NODE=1
+$(warning is combo_chip judge by CONFIG_MTK_COMBO_CHIP_*)
+else
+        ccflags-y += -DSOC_CO_CLOCK_FLAG=1
+        ccflags-y += -DWMT_CREATE_NODE_DYNAMIC=1
+        ccflags-y += -DREMOVE_MK_NODE=0
+$(warning is connsys_chip judge by CONFIG_MTK_COMBO_CHIP_*)
+ccflags-y += -I$(WMT_SRC_FOLDER)/common_main/$(MTK_PLATFORM)/include
+
+endif
+else
+ifneq ($(filter "CONSYS_%",$(CONFIG_MTK_COMBO_CHIP)),)
+        ccflags-y += -DSOC_CO_CLOCK_FLAG=1
+        ccflags-y += -DWMT_CREATE_NODE_DYNAMIC=1
+        ccflags-y += -DREMOVE_MK_NODE=0
+$(warning is connsys_chip judge by CONFIG_MTK_COMBO_CHIP)
+ccflags-y += -I$(WMT_SRC_FOLDER)/common_main/$(MTK_PLATFORM)/include
+
+else
+        ccflags-y += -DSOC_CO_CLOCK_FLAG=0
+        ccflags-y += -DWMT_CREATE_NODE_DYNAMIC=0
+        ccflags-y += -DREMOVE_MK_NODE=1
+$(warning is combo_chip judge by CONFIG_MTK_COMBO_CHIP)
+endif
+endif
+
+ccflags-y += -I$(WMT_SRC_FOLDER)/common_main/include
+ccflags-y += -I$(WMT_SRC_FOLDER)/common_main/linux/include
+ccflags-y += -I$(WMT_SRC_FOLDER)/common_main/core/include
+ccflags-y += -I$(WMT_SRC_FOLDER)/common_main/platform/include
+ifneq ($(CONFIG_MTK_CONNSYS_DEDICATED_LOG_PATH),)
+ccflags-y += -I$(WMT_SRC_FOLDER)/debug_utility
+endif
+ifeq ($(GPS_DRV_CONTROL_LNA),y)
+ccflags-y += -I$(GPS_SRC_FOLDER)/gps_stp/lna_ctrl/inc
+ccflags-y += -I$(GPS_SRC_FOLDER)/gps_stp/
+endif
+
+ifeq ($(CONFIG_MTK_CONN_MT3337_CHIP_SUPPORT),y)
+        $(MODULE_NAME)-objs += gps_stp/gps_mt3337.o
+else
+        $(MODULE_NAME)-objs += gps_stp/stp_chrdev_gps.o
+ifeq ($(CONFIG_ARCH_MTK_PROJECT),"k6833v1_64_swrgo")
+        $(MODULE_NAME)-objs += gps_stp/stp_chrdev_gps2.o
+endif
+ifeq ($(CONFIG_MACH_MT6833),y)
+        $(MODULE_NAME)-objs += gps_stp/stp_chrdev_gps2.o
+endif
+ifeq ($(CONFIG_MACH_MT6781),y)
+        $(MODULE_NAME)-objs += gps_stp/stp_chrdev_gps2.o
+endif
+ifeq ($(GPS_DRV_CONTROL_LNA),y)
+        $(MODULE_NAME)-objs += gps_stp/lna_ctrl/src/gps_lna_drv.o
+endif
+endif
+ifneq ($(CONFIG_MTK_GPS_EMI),)
+$(MODULE_NAME)-objs += gps_stp/gps_emi.o
+endif
+ifneq ($(CONFIG_MTK_CONNSYS_DEDICATED_LOG_PATH),)
+$(MODULE_NAME)-objs += gps_stp/fw_log_gps.o
+endif
+
+endif
+
+endif #ifeq ($(CONFIG_MTK_GPS_SUPPORT), y)
+endif
+# EOF
diff --git a/../vendor/mediatek/kernel_modules/connectivity/gps/README b/../vendor/mediatek/kernel_modules/connectivity/gps/README
new file mode 100755
index 0000000..9046e3a
--- /dev/null
+++ b/vendor/mediatek/kernel_modules/connectivity/gps/README
@@ -0,0 +1,2 @@
+GPS driver - kernel modules move out of kernel tree
+
diff --git a/../vendor/mediatek/kernel_modules/connectivity/gps/init.gps_drv.rc b/../vendor/mediatek/kernel_modules/connectivity/gps/init.gps_drv.rc
new file mode 100644
index 0000000..e516011
--- /dev/null
+++ b/vendor/mediatek/kernel_modules/connectivity/gps/init.gps_drv.rc
@@ -0,0 +1,4 @@
+
+# load gps_drv
+on property:vendor.connsys.driver.ready=yes
+  insmod /vendor/lib/modules/${ro.vendor.gps.chrdev}.ko
diff --git a/kernel-4.14/Makefile b/./Makefile
index f8ca2a2..89106ae 100644
--- a/Makefile
+++ b/Makefile
@@ -191,12 +191,12 @@ ifeq ($(KBUILD_SRC),)
         # building in the source tree
         srctree := .
 else
-        ifeq ($(KBUILD_SRC)/,$(dir $(CURDIR)))
-                # building in a subdirectory of the source tree
-                srctree := ..
-        else
+        #ifeq ($(KBUILD_SRC)/,$(dir $(CURDIR)))
+        #        # building in a subdirectory of the source tree
+        #        srctree := ..
+        #else
                 srctree := $(KBUILD_SRC)
-        endif
+        #endif
 endif
 
 export KBUILD_CHECKSRC KBUILD_EXTMOD KBUILD_SRC
diff --git a/./drivers/gpu/drm/mediatek/mtk_disp_aal.c b/./drivers/gpu/drm/mediatek/mtk_disp_aal.c
index 96d50da..a5e4dcb 100644
--- a/./drivers/gpu/drm/mediatek/mtk_disp_aal.c
+++ b/./drivers/gpu/drm/mediatek/mtk_disp_aal.c
@@ -1290,7 +1290,7 @@ static int disp_aal_write_dre_to_reg(struct mtk_ddp_comp *comp,
 #if defined(CONFIG_MACH_MT6885) || defined(CONFIG_MACH_MT6873) \
 	|| defined(CONFIG_MACH_MT6893) || defined(CONFIG_MACH_MT6853) \
 	|| defined(CONFIG_MACH_MT6833) || defined(CONFIG_MACH_MT6877) \
-	|| defined(CONFIG_MACH_MT6781)
+	|| defined(CONFIG_MACH_MT6781) || defined(CONFIG_MACH_MT6785)
 	cmdq_pkt_write(handle, comp->cmdq_base,
 		comp->regs_pa + DISP_AAL_DRE_FLT_FORCE(0),
 	    DRE_REG_2(gain[0], 0, gain[1], 14), ~0);
@@ -1328,10 +1328,10 @@ static int disp_aal_write_dre_to_reg(struct mtk_ddp_comp *comp,
 	cmdq_pkt_write(handle, comp->cmdq_base,
 		comp->regs_pa + DISP_AAL_DRE_FLT_FORCE(11),
 	    DRE_REG_2(gain[27], 0, gain[28], 9), ~0);
+#endif /* CONFIG_MTK_DRE30_SUPPORT */
 
 	return 0;
 }
-#endif /* CONFIG_MTK_DRE30_SUPPORT */
 #if defined(CONFIG_MTK_DRE30_SUPPORT) || !defined(NOT_SUPPORT_CABC_HW)
 static int disp_aal_write_cabc_to_reg(struct mtk_ddp_comp *comp,
 	struct cmdq_pkt *handle, const struct DISP_AAL_PARAM *param)
diff --git a/./drivers/gpu/drm/mediatek/mtk_disp_ccorr.c b/./drivers/gpu/drm/mediatek/mtk_disp_ccorr.c
index cc1be26..abaef2e 100644
--- a/./drivers/gpu/drm/mediatek/mtk_disp_ccorr.c
+++ b/./drivers/gpu/drm/mediatek/mtk_disp_ccorr.c
@@ -262,7 +262,7 @@ static int disp_ccorr_write_coef_reg(struct mtk_ddp_comp *comp,
 #if defined(CONFIG_MACH_MT6885) || defined(CONFIG_MACH_MT6873) \
 	|| defined(CONFIG_MACH_MT6893) || defined(CONFIG_MACH_MT6853) \
 	|| defined(CONFIG_MACH_MT6833) || defined(CONFIG_MACH_MT6877) \
-	|| defined(CONFIG_MACH_MT6781)
+	|| defined(CONFIG_MACH_MT6781) || defined(CONFIG_MACH_MT6785)
 	// For 6885 need to left shift one bit
 	for (i = 0; i < 3; i++)
 		for (j = 0; j < 3; j++)
diff --git a/./drivers/gpu/drm/mediatek/mtk_disp_color.c b/./drivers/gpu/drm/mediatek/mtk_disp_color.c
index 374bd2f..de03a3e 100644
--- a/./drivers/gpu/drm/mediatek/mtk_disp_color.c
+++ b/./drivers/gpu/drm/mediatek/mtk_disp_color.c
@@ -3083,7 +3083,7 @@ int mtk_drm_ioctl_read_reg(struct drm_device *dev, void *data,
 #if defined(CONFIG_MACH_MT6885) || defined(CONFIG_MACH_MT6873) \
 	|| defined(CONFIG_MACH_MT6893) || defined(CONFIG_MACH_MT6853) \
 	|| defined(CONFIG_MACH_MT6833) || defined(CONFIG_MACH_MT6877) \
-	|| defined(CONFIG_MACH_MT6781)
+	|| defined(CONFIG_MACH_MT6781) || defined(CONFIG_MACH_MT6785)
 	// For 6885 CCORR COEF, real values need to right shift one bit
 	if (pa >= ccorr_comp->regs_pa + CCORR_REG(0) &&
 		pa <= ccorr_comp->regs_pa + CCORR_REG(4))
@@ -3126,7 +3126,7 @@ int mtk_drm_ioctl_write_reg(struct drm_device *dev, void *data,
 #if defined(CONFIG_MACH_MT6885) || defined(CONFIG_MACH_MT6873) \
 	|| defined(CONFIG_MACH_MT6893) || defined(CONFIG_MACH_MT6853) \
 	|| defined(CONFIG_MACH_MT6833) || defined(CONFIG_MACH_MT6877) \
-	|| defined(CONFIG_MACH_MT6781)
+	|| defined(CONFIG_MACH_MT6781) || defined(CONFIG_MACH_MT6785)
 	// For 6885 CCORR COEF, real values need to left shift one bit
 	if (pa >= ccorr_comp->regs_pa + CCORR_REG(0) &&
 		pa <= ccorr_comp->regs_pa + CCORR_REG(4))
diff --git a/./drivers/gpu/drm/mediatek/mtk_disp_rdma.c b/./drivers/gpu/drm/mediatek/mtk_disp_rdma.c
index 94c5737..9564b99 100644
--- a/./drivers/gpu/drm/mediatek/mtk_disp_rdma.c
+++ b/./drivers/gpu/drm/mediatek/mtk_disp_rdma.c
@@ -99,7 +99,7 @@
 #define DISP_REG_RDMA_SHADOW_UPDATE 0x00b8
 #endif
 #if defined(CONFIG_MACH_MT6873) || defined(CONFIG_MACH_MT6853) \
-	|| defined(CONFIG_MACH_MT6877) || defined(CONFIG_MACH_MT6781)
+	|| defined(CONFIG_MACH_MT6877) || defined(CONFIG_MACH_MT6781) || defined(CONFIG_MACH_MT6785)
 #define DISP_REG_RDMA_SHADOW_UPDATE 0x00bc
 #define RDMA_BYPASS_SHADOW BIT(1)
 #define RDMA_READ_WORK_REG BIT(2)
@@ -499,7 +499,7 @@ void mtk_rdma_cal_golden_setting(struct mtk_ddp_comp *comp,
 #endif
 #if defined(CONFIG_MACH_MT6873) || defined(CONFIG_MACH_MT6853) \
 	|| defined(CONFIG_MACH_MT6833) || defined(CONFIG_MACH_MT6877) \
-	|| defined(CONFIG_MACH_MT6781)
+	|| defined(CONFIG_MACH_MT6781) || defined(CONFIG_MACH_MT6785)
 	unsigned int pre_ultra_low_us = 250, pre_ultra_high_us = 260;
 	unsigned int ultra_low_us = 230, ultra_high_us = 250;
 	unsigned int urgent_low_us = 110, urgent_high_us = 120;
diff --git a/./drivers/gpu/drm/mediatek/mtk_disp_wdma.c b/./drivers/gpu/drm/mediatek/mtk_disp_wdma.c
index a4657fd..68eb322 100644
--- a/./drivers/gpu/drm/mediatek/mtk_disp_wdma.c
+++ b/./drivers/gpu/drm/mediatek/mtk_disp_wdma.c
@@ -384,7 +384,7 @@ static void mtk_wdma_calc_golden_setting(struct golden_setting_context *gsc,
 	unsigned int fifo_size = 578;
 	unsigned int fifo_size_uv = 29;
 #endif
-#if defined(CONFIG_MACH_MT6781)
+#if defined(CONFIG_MACH_MT6781) || defined(CONFIG_MACH_MT6785)
 	unsigned int fifo_size = 410;
 	unsigned int fifo_size_uv = 200;
 #endif
diff --git a/./drivers/gpu/drm/mediatek/mtk_drm_ddp.c b/./drivers/gpu/drm/mediatek/mtk_drm_ddp.c
index ddc3f0d..42241b7 100644
--- a/./drivers/gpu/drm/mediatek/mtk_drm_ddp.c
+++ b/./drivers/gpu/drm/mediatek/mtk_drm_ddp.c
@@ -5672,7 +5672,7 @@ void mtk_ddp_remove_comp_from_path(void __iomem *config_regs,
 	}
 #endif
 
-#if defined(CONFIG_MACH_MT6781)
+#if defined(CONFIG_MACH_MT6781) || defined(CONFIG_MACH_MT6785)
 	value = mtk_ddp_mout_en_MT6781(reg_data, cur, next, &addr);
 	if (value >= 0) {
 		reg = readl_relaxed(config_regs + addr) & ~(unsigned int)value;
@@ -5772,7 +5772,7 @@ void mtk_ddp_remove_comp_from_path_with_cmdq(struct mtk_drm_crtc *mtk_crtc,
 			       mtk_crtc->config_regs_pa + addr, ~value, value);
 #endif
 
-#if defined(CONFIG_MACH_MT6781)
+#if defined(CONFIG_MACH_MT6781) || defined(CONFIG_MACH_MT6785)
 	value = mtk_ddp_mout_en_MT6781(mtk_crtc->mmsys_reg_data,
 				cur, next, &addr);
 	if (value >= 0)
diff --git a/./drivers/gpu/drm/mediatek/mtk_dsi.c b/./drivers/gpu/drm/mediatek/mtk_dsi.c
index 6668571..ca5d187 100644
--- a/./drivers/gpu/drm/mediatek/mtk_dsi.c
+++ b/./drivers/gpu/drm/mediatek/mtk_dsi.c
@@ -1304,7 +1304,7 @@ static void mtk_dsi_ps_control_vact(struct mtk_dsi *dsi)
 #if !defined(CONFIG_MACH_MT6885) && !defined(CONFIG_MACH_MT6873) \
 	&& !defined(CONFIG_MACH_MT6893) && !defined(CONFIG_MACH_MT6853) \
 	&& !defined(CONFIG_MACH_MT6833) && !defined(CONFIG_MACH_MT6877) \
-	&& !defined(CONFIG_MACH_MT6781)
+	&& !defined(CONFIG_MACH_MT6781) && !defined(CONFIG_MACH_MT6785)
 	val = vm->hactive * dsi_buf_bpp;
 	writel(val, dsi->regs + DSI_HSTX_CKL_WC);
 #endif
diff --git a/./drivers/gpu/drm/mediatek/mtk_hdmi.c b/./drivers/gpu/drm/mediatek/mtk_hdmi.c
index a80e9be..2278830 100644
--- a/./drivers/gpu/drm/mediatek/mtk_hdmi.c
+++ b/./drivers/gpu/drm/mediatek/mtk_hdmi.c
@@ -35,6 +35,7 @@
 #include "mtk_cec.h"
 #include "mtk_hdmi.h"
 #include "mtk_hdmi_regs.h"
+#include "mtk_log.h"
 
 #define NCTS_BYTES	7
 
@@ -974,7 +975,7 @@ static int mtk_hdmi_setup_avi_infoframe(struct mtk_hdmi *hdmi,
 	u8 buffer[17];
 	ssize_t err;
 
-	err = drm_hdmi_avi_infoframe_from_display_mode(&frame, mode);
+	err = drm_hdmi_avi_infoframe_from_display_mode(&frame, mode, false);
 	if (err < 0) {
 		dev_err(hdmi->dev,
 			"Failed to get AVI infoframe from mode: %zd\n", err);
diff --git a/./drivers/input/touchscreen/mediatek/hxchipset_p11/himax_common.c b/./drivers/input/touchscreen/mediatek/hxchipset_p11/himax_common.c
index 9d126e8..15be180 100644
--- a/./drivers/input/touchscreen/mediatek/hxchipset_p11/himax_common.c
+++ b/./drivers/input/touchscreen/mediatek/hxchipset_p11/himax_common.c
@@ -2975,7 +2975,8 @@ static void himax_fb_register(struct work_struct *work)
 	I("%s in1\n", __func__);
 	ts->fb_notif.notifier_call = fb_notifier_callback;
 	ret = fb_register_client(&ts->fb_notif);
-#elif defined(HX_CONFIG_DRM)
+#endif
+#if defined(HX_CONFIG_DRM)
 #if defined(__HIMAX_MOD__)
 	I("%s in2\n", __func__);
 	hx_msm_drm_register_client =
@@ -3391,7 +3392,8 @@ void himax_chip_common_deinit(void)
 		E("Error occurred while unregistering fb_notifier.\n");
 	cancel_delayed_work_sync(&ts->work_att);
 	destroy_workqueue(ts->himax_att_wq);
-#elif defined(HX_CONFIG_DRM)
+#endif
+#if defined(HX_CONFIG_DRM)
 #if defined(__HIMAX_MOD__)
 	hx_msm_drm_unregister_client =
 		(void *)kallsyms_lookup_name("msm_drm_unregister_client");
diff --git a/./drivers/input/touchscreen/mediatek/hxchipset_p11/himax_common.h b/./drivers/input/touchscreen/mediatek/hxchipset_p11/himax_common.h
index cc06118..6b02aaa 100644
--- a/./drivers/input/touchscreen/mediatek/hxchipset_p11/himax_common.h
+++ b/./drivers/input/touchscreen/mediatek/hxchipset_p11/himax_common.h
@@ -95,12 +95,13 @@
 #undef HX_CONFIG_FB
 
 /* Enable it if driver go into suspend/resume twice */
-/*#undef HX_CONFIG_DRM*/
+#undef HX_CONFIG_DRM
 
 #if defined(HX_CONFIG_FB)
 #include <linux/notifier.h>
 #include <linux/fb.h>
-#elif defined(HX_CONFIG_DRM)
+#endif
+#if defined(HX_CONFIG_DRM)
 #include <drm/drm_panel.h>
 #endif
 
@@ -165,7 +166,8 @@
 #if defined(HX_CONFIG_FB)
 int fb_notifier_callback(struct notifier_block *self,
 		unsigned long event, void *data);
-#elif defined(HX_CONFIG_DRM)
+#endif
+#if defined(HX_CONFIG_DRM)
 int drm_notifier_callback(struct notifier_block *self,
 			unsigned long event, void *data);
 #endif
diff --git a/./drivers/misc/mediatek/cmdq/mailbox/mt6785/cmdq-platform.c b/./drivers/misc/mediatek/cmdq/mailbox/mt6785/cmdq-platform.c
new file mode 100644
index 0000000..640e94b
--- /dev/null
+++ b/./drivers/misc/mediatek/cmdq/mailbox/mt6785/cmdq-platform.c
@@ -0,0 +1,95 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019 MediaTek Inc.
+ */
+
+#include <dt-bindings/gce/mt6785-gce.h>
+#include "../cmdq-util.h"
+
+const char *cmdq_thread_module_dispatch(phys_addr_t gce_pa, s32 thread)
+{
+	switch (thread) {
+	case 0 ... 6:
+	case 8 ... 9:
+		return "DISP";
+	case 7:
+		return "VDEC";
+	case 10:
+	case 19 ... 22:
+		return "MDP";
+	case 11:
+	case 13 ... 14:
+	case 16 ... 18:
+		return "ISP";
+	case 12:
+		return "VENC";
+	case 15:
+		return "CMDQ";
+	case 23:
+		return "VFMT";
+	default:
+		return "CMDQ";
+	}
+}
+
+const char *cmdq_event_module_dispatch(phys_addr_t gce_pa, const u16 event,
+	s32 thread)
+{
+	switch (event) {
+	case CMDQ_EVENT_LINE_COUNT_THRESHOLD_INTERRUPT ... CMDQ_EVENT_GCE_CNT_OP_THRESHOLD:
+		return "VDEC";
+	case CMDQ_EVENT_VDEC_MINI_MDP_EVENT_0 ... CMDQ_EVENT_VDEC_MINI_MDP_EVENT_15:
+		return "VFMT";
+	case CMDQ_EVENT_ISP_FRAME_DONE_A ... CMDQ_EVENT_CQ_VR_SNAP_B_INT:
+		return "CAM";
+	case CMDQ_EVENT_VENC_CMDQ_FRAME_DONE ... CMDQ_EVENT_VENC_CMDQ_VPS_DONE:
+		return "VENC";
+	case CMDQ_EVENT_FDVT_DONE ... CMDQ_EVENT_DVP_DONE_ASYNC_SHOT:
+		return "IPE";
+	case CMDQ_EVENT_GCE_IMG2_EVENT0 ... CMDQ_EVENT_GCE_IMG1_EVENT23:
+		return "IMG";
+	case CMDQ_EVENT_MDP_RDMA0_SOF ... CMDQ_EVENT_MDP_RDMA0_SW_RST_DONE_ENG_EVENT:
+		return "MDP";
+	case CMDQ_EVENT_DISP_OVL0_SOF ... CMDQ_EVENT_BUF_UNDERRUN_ENG_EVENT_7:
+		return "DISP";
+	default:
+		return cmdq_thread_module_dispatch(gce_pa, thread);
+	}
+}
+EXPORT_SYMBOL(cmdq_event_module_dispatch);
+
+u32 cmdq_util_hw_id(u32 pa)
+{
+	return 0;
+}
+
+u32 cmdq_test_get_subsys_list(u32 **regs_out)
+{
+	static u32 regs[] = {
+		0x14000100,	/* mmsys MMSYS_CG_CON0 */
+		0x112300a0,	/* msdc0 SW_DBG_SEL: LSB 16-bit only */
+		0x1121004c,	/* To-do: audio AFE_I2S_CON3_OFFSET */
+		0x110020bc,	/* uart0:LSB 1-bit only */
+	};
+
+	*regs_out = regs;
+	return ARRAY_SIZE(regs);
+}
+
+const char *cmdq_util_hw_name(void *chan)
+{
+	return "GCE";
+}
+
+bool cmdq_thread_ddr_user_check(const s32 thread)
+{
+	switch (thread) {
+	case 0 ... 6:
+	case 8 ... 9:
+	case 15:
+		return false;
+	default:
+		return true;
+	}
+}
+EXPORT_SYMBOL(cmdq_thread_ddr_user_check);
diff --git a/./drivers/misc/mediatek/connectivity/Makefile b/./drivers/misc/mediatek/connectivity/Makefile
index 67dbf26..3fc1b7a 100644
--- a/./drivers/misc/mediatek/connectivity/Makefile
+++ b/./drivers/misc/mediatek/connectivity/Makefile
@@ -47,7 +47,7 @@ endif
     # Do build-in for Makefile checking
     # export CONFIG_WLAN_DRV_BUILD_IN=y
 
-    ifeq ($(CONFIG_WLAN_DRV_BUILD_IN),y)
+    #ifeq ($(CONFIG_WLAN_DRV_BUILD_IN),y)
         $(info $$CONFIG_MTK_COMBO_CHIP is [${CONFIG_MTK_COMBO_CHIP}])
         MTK_PLATFORM_ID := $(patsubst CONSYS_%,%,$(subst ",,$(CONFIG_MTK_COMBO_CHIP)))
         $(info MTK_PLATFORM_ID is [${MTK_PLATFORM_ID}])
@@ -128,68 +128,102 @@ endif
         endif
 
         # Do build-in for xxx.c checking
-        subdir-ccflags-y += -D MTK_WCN_REMOVE_KERNEL_MODULE
-        subdir-ccflags-y += -D MTK_WCN_BUILT_IN_DRIVER
-        obj-y += wmt_drv/
-        obj-y += wmt_chrdev_wifi/
-        obj-y += wlan_drv_gen4m/
+				#subdir-ccflags-y += -D MTK_WCN_REMOVE_KERNEL_MODULE
+        #subdir-ccflags-y += -D MTK_WCN_BUILT_IN_DRIVER
+        obj-m += wmt_drv/
+        obj-m += wmt_chrdev_wifi/
+        obj-m += wlan_drv_gen4m/
 
         # For BT built-in mode start @{
-        # ifneq (,$(filter $(CONFIG_MTK_COMBO_CHIP), "CONSYS_6885"))
-        #     PATH_TO_BT_DRV       = vendor/mediatek/kernel_modules/connectivity/bt/mt66xx/btif
-        #     export _MTK_BT_CHIP=MTK_CONSYS_MT6885
-        # else ifneq (,$(filter $(CONFIG_MTK_COMBO_CHIP), "CONSYS_6893"))
-        #     PATH_TO_BT_DRV       = vendor/mediatek/kernel_modules/connectivity/bt/mt66xx/btif
-        #     export _MTK_BT_CHIP=MTK_CONSYS_MT6893
-        # else ifneq (,$(filter $(CONFIG_MTK_COMBO_CHIP), "CONSYS_6877"))
-        #     PATH_TO_BT_DRV       = vendor/mediatek/kernel_modules/connectivity/bt/mt66xx/btif
-        #     export _MTK_BT_CHIP=MTK_CONSYS_MT6877
-        # else
-        #     PATH_TO_BT_DRV       = vendor/mediatek/kernel_modules/connectivity/bt/mt66xx/wmt
-        # endif
-        # ABS_PATH_TO_BT_DRV       = $(srctree)/../$(PATH_TO_BT_DRV)
-        # $(shell unlink $(srctree)/$(src)/bt)
-        # $(shell ln -s $(ABS_PATH_TO_BT_DRV)      $(srctree)/$(src)/bt)
-        # obj-y += bt/
+        ifneq (,$(filter $(CONFIG_MTK_COMBO_CHIP), "CONSYS_6885"))
+            PATH_TO_BT_DRV       = vendor/mediatek/kernel_modules/connectivity/bt/mt66xx/btif
+            export _MTK_BT_CHIP=MTK_CONSYS_MT6885
+        else ifneq (,$(filter $(CONFIG_MTK_COMBO_CHIP), "CONSYS_6893"))
+            PATH_TO_BT_DRV       = vendor/mediatek/kernel_modules/connectivity/bt/mt66xx/btif
+            export _MTK_BT_CHIP=MTK_CONSYS_MT6893
+        else ifneq (,$(filter $(CONFIG_MTK_COMBO_CHIP), "CONSYS_6877"))
+            PATH_TO_BT_DRV       = vendor/mediatek/kernel_modules/connectivity/bt/mt66xx/btif
+            export _MTK_BT_CHIP=MTK_CONSYS_MT6877
+        else
+            PATH_TO_BT_DRV       = vendor/mediatek/kernel_modules/connectivity/bt/mt66xx/wmt
+        endif
+				export BT_PLATFORM=connac1x
+        ABS_PATH_TO_BT_DRV       = $(srctree)/../$(PATH_TO_BT_DRV)
+        $(shell unlink $(srctree)/$(src)/bt)
+        $(shell ln -s $(ABS_PATH_TO_BT_DRV)      $(srctree)/$(src)/bt)
+        obj-y += bt/
         # @} For BT built-in mode end
 
 
         # For FM built-in mode start @{
         # for fmradio options
-        # ifneq (,$(filter $(CONFIG_MTK_COMBO_CHIP), "CONSYS_6885" "CONSYS_6893" "CONSYS_6877"))
-        #     export CFG_BUILD_CONNAC2=true
-        # else
-        #     export CFG_BUILD_CONNAC2=false
-        # endif
-        # FM_6631_CHIPS := 6758 6759 6771 6775 6765 6761 3967 6797 6768 6785 8168
-        # FM_6635_CHIPS := 6779 6885 6873 6893 6877
-        # ifneq ($(filter $(FM_6631_CHIPS), $(MTK_PLATFORM_ID)),)
-        #     FM_CHIP := mt6631
-        # else ifneq ($(filter $(FM_6635_CHIPS), $(MTK_PLATFORM_ID)),)
-        #     FM_CHIP := mt6635
-        # endif
-        # export CFG_FM_CHIP_ID=$(MTK_PLATFORM_ID)
-        # export CFG_FM_CHIP=$(FM_CHIP)
-        # PATH_TO_FMRADIO_DRV       = vendor/mediatek/kernel_modules/connectivity/fmradio
-        # ABS_PATH_TO_FMRADIO_DRV  = $(srctree)/../$(PATH_TO_FMRADIO_DRV)
-        # $(shell unlink $(srctree)/$(src)/fmradio)
-        # $(shell ln -s $(ABS_PATH_TO_FMRADIO_DRV)      $(srctree)/$(src)/fmradio)
-        # obj-y += fmradio/
+        ifneq (,$(filter $(CONFIG_MTK_COMBO_CHIP), "CONSYS_6885" "CONSYS_6893" "CONSYS_6877"))
+            export CFG_BUILD_CONNAC2=true
+        else
+            export CFG_BUILD_CONNAC2=false
+        endif
+        FM_6631_CHIPS := 6758 6759 6771 6775 6765 6761 3967 6797 6768 6785 8168
+        FM_6635_CHIPS := 6779 6885 6873 6893 6877
+        ifneq ($(filter $(FM_6631_CHIPS), $(MTK_PLATFORM_ID)),)
+            FM_CHIP := mt6631
+        else ifneq ($(filter $(FM_6635_CHIPS), $(MTK_PLATFORM_ID)),)
+            FM_CHIP := mt6635
+        endif
+				export CFG_FM_PLAT=mt6631
+        export CFG_FM_CHIP_ID=$(MTK_PLATFORM_ID)
+        export CFG_FM_CHIP=$(FM_CHIP)
+        PATH_TO_FMRADIO_DRV       = vendor/mediatek/kernel_modules/connectivity/fmradio
+        ABS_PATH_TO_FMRADIO_DRV  = $(srctree)/../$(PATH_TO_FMRADIO_DRV)
+        $(shell unlink $(srctree)/$(src)/fmradio)
+        $(shell ln -s $(ABS_PATH_TO_FMRADIO_DRV)      $(srctree)/$(src)/fmradio)
+        obj-y += fmradio/
         # @} For FM built-in mode end
 
         # For GPS built-in mode start @{
-        # PATH_TO_GPS_DRV      = vendor/mediatek/kernel_modules/connectivity/gps
-        # ABS_PATH_TO_GPS_DRV      = $(srctree)/../$(PATH_TO_GPS_DRV)
-        # ifeq (,$(wildcard $(ABS_PATH_TO_GPS_DRV)))
-        #     $(error $(ABS_PATH_TO_GPS_DRV) is not existed)
-        # endif
-        # $(warning symbolic link to $(PATH_TO_GPS_DRV))
-        # $(shell unlink $(srctree)/$(src)/gps_drv)
-        # $(shell ln -s $(ABS_PATH_TO_GPS_DRV)      $(srctree)/$(src)/gps_drv)
-        # obj-y += gps_drv/
+        PATH_TO_GPS_DRV      = vendor/mediatek/kernel_modules/connectivity/gps
+        ABS_PATH_TO_GPS_DRV      = $(srctree)/../$(PATH_TO_GPS_DRV)
+        ifeq (,$(wildcard $(ABS_PATH_TO_GPS_DRV)))
+            $(error $(ABS_PATH_TO_GPS_DRV) is not existed)
+        endif
+        $(warning symbolic link to $(PATH_TO_GPS_DRV))
+        $(shell unlink $(srctree)/$(src)/gps_drv)
+        $(shell ln -s $(ABS_PATH_TO_GPS_DRV)      $(srctree)/$(src)/gps_drv)
+        obj-y += gps_drv/
         # @} For GPS built-in mode end
 
-    endif
+				# Connfem build
+        PATH_TO_CONNFEM_DRV      = vendor/mediatek/kernel_modules/connectivity/connfem
+        ABS_PATH_TO_CONNFEM_DRV      = $(srctree)/../$(PATH_TO_CONNFEM_DRV)
+        ifeq (,$(wildcard $(ABS_PATH_TO_CONNFEM_DRV)))
+            $(error $(ABS_PATH_TO_CONNFEM_DRV) is not existed)
+        endif
+        $(warning symbolic link to $(PATH_TO_CONNFEM_DRV))
+        $(shell unlink $(srctree)/$(src)/connfem)
+        $(shell ln -s $(ABS_PATH_TO_CONNFEM_DRV)      $(srctree)/$(src)/connfem)
+        obj-y += connfem/
+				
+				# Conninfra build
+        # PATH_TO_CONNINFRA_DRV      = vendor/mediatek/kernel_modules/connectivity/conninfra
+        # ABS_PATH_TO_CONNINFRA_DRV      = $(srctree)/../$(PATH_TO_CONNINFRA_DRV)
+        # ifeq (,$(wildcard $(ABS_PATH_TO_CONNINFRA_DRV)))
+        #     $(error $(ABS_PATH_TO_CONNINFRA_DRV) is not existed)
+        # endif
+        # $(warning symbolic link to $(PATH_TO_CONNINFRA_DRV))
+        # $(shell unlink $(srctree)/$(src)/conninfra)
+        # $(shell ln -s $(ABS_PATH_TO_CONNINFRA_DRV)      $(srctree)/$(src)/conninfra)
+        # obj-y += conninfra/
+
+				# Common files
+        PATH_TO_COMMON      = vendor/mediatek/kernel_modules/connectivity/common
+        ABS_PATH_TO_COMMON      = $(srctree)/../$(PATH_TO_COMMON)
+        ifeq (,$(wildcard $(ABS_PATH_TO_COMMON)))
+            $(error $(ABS_PATH_TO_COMMON) is not existed)
+        endif
+        $(warning symbolic link to $(PATH_TO_COMMON))
+        $(shell unlink $(srctree)/$(src)/common)
+        $(shell ln -s $(ABS_PATH_TO_COMMON)      $(srctree)/$(src)/common)
+        obj-y += common/
+    #endif
 
 # Otherwise we were called directly from the command line;
 # invoke the kernel build system.
diff --git a/./drivers/misc/mediatek/connectivity/common/connectivity_build_in_adapter.c b/./drivers/misc/mediatek/connectivity/common_orig/connectivity_build_in_adapter.c
similarity index 100%
rename from ./misc/mediatek/connectivity/common/connectivity_build_in_adapter.c
rename to /./drivers/misc/mediatek/connectivity/common_orig/connectivity_build_in_adapter.c
diff --git a/./drivers/misc/mediatek/connectivity/common/connectivity_build_in_adapter.h b/./drivers/misc/mediatek/connectivity/common_orig/connectivity_build_in_adapter.h
similarity index 100%
rename from ./misc/mediatek/connectivity/common/connectivity_build_in_adapter.h
rename to /./drivers/misc/mediatek/connectivity/common_orig/connectivity_build_in_adapter.h
diff --git a/./drivers/misc/mediatek/connectivity/common/wmt_build_in_adapter.c b/./drivers/misc/mediatek/connectivity/common_orig/wmt_build_in_adapter.c
similarity index 100%
rename from ./misc/mediatek/connectivity/common/wmt_build_in_adapter.c
rename to /./drivers/misc/mediatek/connectivity/common_orig/wmt_build_in_adapter.c
diff --git a/./drivers/misc/mediatek/connectivity/common/wmt_build_in_adapter.h b/./drivers/misc/mediatek/connectivity/common_orig/wmt_build_in_adapter.h
similarity index 100%
rename from ./misc/mediatek/connectivity/common/wmt_build_in_adapter.h
rename to /./drivers/misc/mediatek/connectivity/common_orig/wmt_build_in_adapter.h
diff --git a/./drivers/misc/mediatek/eccci/Makefile b/./drivers/misc/mediatek/eccci/Makefile
index 1906509..c94c27b 100644
--- a/./drivers/misc/mediatek/eccci/Makefile
+++ b/./drivers/misc/mediatek/eccci/Makefile
@@ -49,7 +49,7 @@ endif
 obj-y += fsm/
 obj-y += hif/
 obj-y += port/
-obj-y += udc/
+obj-m += udc/
 obj-$(CONFIG_MTK_MIX_DEVICES) +=  mixdev/
 
 ifeq ($(CONFIG_MTK_ECCCI_C2K), y)
diff --git a/./drivers/misc/mediatek/eccci/udc/Makefile b/./drivers/misc/mediatek/eccci/udc_orig/Makefile
similarity index 100%
rename from ./misc/mediatek/eccci/udc/Makefile
rename to /./drivers/misc/mediatek/eccci/udc_orig/Makefile
diff --git a/./drivers/misc/mediatek/eccci/udc/udc.c b/./drivers/misc/mediatek/eccci/udc_orig/udc.c
similarity index 100%
rename from ./misc/mediatek/eccci/udc/udc.c
rename to /./drivers/misc/mediatek/eccci/udc_orig/udc.c
diff --git a/./drivers/misc/mediatek/eccci/udc/udc.h b/./drivers/misc/mediatek/eccci/udc_orig/udc.h
similarity index 100%
rename from ./misc/mediatek/eccci/udc/udc.h
rename to /./drivers/misc/mediatek/eccci/udc_orig/udc.h
diff --git a/./drivers/misc/mediatek/eccci/udc/udc_dictionary.h b/./drivers/misc/mediatek/eccci/udc_orig/udc_dictionary.h
similarity index 100%
rename from ./misc/mediatek/eccci/udc/udc_dictionary.h
rename to /./drivers/misc/mediatek/eccci/udc_orig/udc_dictionary.h
diff --git a/./drivers/misc/mediatek/eccci/udc/udc_lib_inc/udc_zlib.h b/./drivers/misc/mediatek/eccci/udc_orig/udc_lib_inc/udc_zlib.h
similarity index 100%
rename from ./misc/mediatek/eccci/udc/udc_lib_inc/udc_zlib.h
rename to /./drivers/misc/mediatek/eccci/udc_orig/udc_lib_inc/udc_zlib.h
diff --git a/./drivers/misc/mediatek/mdp/mdp_def.h b/./drivers/misc/mediatek/mdp/mdp_def.h
index 3809289..c1dbd7c 100644
--- a/./drivers/misc/mediatek/mdp/mdp_def.h
+++ b/./drivers/misc/mediatek/mdp/mdp_def.h
@@ -22,7 +22,7 @@
 
 #define MDP_DRIVER_DEVICE_NAME         "mtk_mdp"
 
-/* #define MDP_COMMON_ENG_SUPPORT */
+#define MDP_COMMON_ENG_SUPPORT
 #ifdef MDP_COMMON_ENG_SUPPORT
 #include "mdp_engine_common.h"
 #else
#diff --git a/drivers/misc/mediatek/met_drv/Makefile b/kernel-4.14/drivers/misc/mediatek/met_drv/Makefile
#index 8bdc7e8..dd4473d 100644
#--- a/drivers/misc/mediatek/met_drv/Makefile
#+++ b/kernel-4.14/drivers/misc/mediatek/met_drv/Makefile
#@@ -1,3 +1,5 @@
#+obj-y += met_api.o
#+
# MTK_PLATFORM := $(subst ",,$(CONFIG_MTK_PLATFORM))
# MTK_FAMILY_PLATFORM := $(MTK_PLATFORM)
# ifeq ($(CONFIG_MACH_MT6833),y)
#diff --git a/./met_drv/Makefile b/../../../kernel-4.14/drivers/misc/mediatek/./met_drv_orig/Makefile
#index 306a302..7cbda92 100644
#--- a/./drivers/misc/mediatek/met_drv/Makefile
#+++ b/./drivers/misc/mediatek/met_drv/Makefile
#@@ -15,13 +15,29 @@ endif
# CONFIG_KERVER_VERSION := $(VERSION).$(PATCHLEVEL)
# 
# #CONFIG_MTK_MET_BUILT_IN := y
#-ifeq ($(CONFIG_MTK_MET_BUILT_IN),y)
#+#ifeq ($(CONFIG_MTK_MET_BUILT_IN),y)
# ccflags-y += -DMTK_MET_BUILT_IN
# MTK_PLATFORM := $(subst ",,$(CONFIG_MTK_PLATFORM))
# MET_ROOT_DIR := $(srctree)/../vendor/mediatek/kernel_modules/met_drv/$(CONFIG_KERVER_VERSION)
# MET_COMMON_DIR := $(wildcard $(MET_ROOT_DIR)/common)
# MET_PLF_DIR := $(wildcard $(MET_ROOT_DIR)/$(MTK_PLATFORM))
# 
#+ifeq (,$(wildcard $(MET_ROOT_DIR)))
#+    $(error $(MET_ROOT_DIR) is not existed)
#+endif
#+$(warning symbolic link to $(MET_ROOT_DIR))
#+$(shell unlink $(srctree)/$(src)/common)
#+$(shell ln -s $(MET_ROOT_DIR)      $(srctree)/$(src)/common)
#+obj-y += common/
#+
#+# ifeq (,$(wildcard $(MET_COMMON_DIR)))
#+#     $(error $(MET_COMMON_DIR) is not existed)
#+# endif
#+# $(warning symbolic link to $(MET_COMMON_DIR))
#+# $(shell unlink $(srctree)/$(src)/common)
#+# $(shell ln -s $(MET_COMMON_DIR)      $(srctree)/$(src)/common)
#+# obj-y += common/
#+
# ifeq ($(CONFIG_FTRACE),y)
#     ifeq ($(CONFIG_TRACING),y)
#         FTRACE_READY := y
diff --git a/./drivers/misc/mediatek/performance/fpsgo_v3/Makefile b/./drivers/misc/mediatek/performance/fpsgo_v3/Makefile
index 552eb54..ba39ce5 100644
--- a/./drivers/misc/mediatek/performance/fpsgo_v3/Makefile
+++ b/./drivers/misc/mediatek/performance/fpsgo_v3/Makefile
@@ -22,6 +22,8 @@ COM_TOP = $(FPSGO_TOP)/composer
 EARA_JOB_TOP = $(FPSGO_TOP)/eara_job
 VIDEOX_TOP += $(srctree)/drivers/misc/mediatek/video/$(MTK_PLATFORM)/videox
 
+MODULE_NAME := fpsgo
+
 obj-y += fpsgo_main.o
 obj-y += base/
 obj-y += composer/
diff --git a/./drivers/misc/mediatek/performance/fpsgo_v3/fbt/src/xgf.c b/./drivers/misc/mediatek/performance/fpsgo_v3/fbt/src/xgf.c
index f299085..ac2a214 100644
--- a/./drivers/misc/mediatek/performance/fpsgo_v3/fbt/src/xgf.c
+++ b/./drivers/misc/mediatek/performance/fpsgo_v3/fbt/src/xgf.c
@@ -1987,7 +1987,7 @@ static int xgf_enter_est_runtime(int rpid, struct xgf_render *render,
 {
 	int ret;
 
-	WARN_ON(!xgf_est_runtime_fp);
+  //WARN_ON(!xgf_est_runtime_fp);
 
 	if (xgf_est_runtime_fp)
 		ret = xgf_est_runtime_fp(rpid, render, runtime, ts);
diff --git a/./drivers/misc/mediatek/video/Makefile b/./drivers/misc/mediatek/video/Makefile
index 90e6555..b0574e5 100644
--- a/./drivers/misc/mediatek/video/Makefile
+++ b/./drivers/misc/mediatek/video/Makefile
@@ -18,7 +18,9 @@
 ################################################################################
 
 ifneq ($(CONFIG_MTK_LCM), y)
-	obj-y += mtdummy/
+	ifneq ($(CONFIG_DRM_MEDIATEK), y)
+		obj-y += mtdummy/
+	endif
 else
 	######################################
 # separate mt6833 from family mt6853
diff --git a/./drivers/tty/vt/selection.c b/./drivers/tty/vt/selection.c
index 8d7ab88..a038b91 100644
--- a/./drivers/tty/vt/selection.c
+++ b/./drivers/tty/vt/selection.c
@@ -348,17 +348,17 @@ int set_selection(const struct tiocl_selection __user *v, struct tty_struct *tty
 	return ret;
 }
 
-int set_selection(const struct tiocl_selection __user *v,
-	struct tty_struct *tty)
-{
-	int ret;
-
-	console_lock();
-	ret = __set_selection(v, tty);
-	console_unlock();
-
-	return ret;
-}
+// int set_selection(const struct tiocl_selection __user *v,
+// 	struct tty_struct *tty)
+// {
+// 	int ret;
+//
+// 	console_lock();
+// 	ret = __set_selection(v, tty);
+// 	console_unlock();
+//
+// 	return ret;
+// }
 
 /* Insert the contents of the selection buffer into the
  * queue of the tty associated with the current console.
